/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 68 "defines.h"
typedef long flow_t;
#line 69 "defines.h"
typedef long cost_t;
#line 99
struct node;
#line 99 "defines.h"
typedef struct node node_t;
#line 100 "defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 102 "defines.h"
typedef struct arc arc_t;
#line 103 "defines.h"
typedef struct arc *arc_p;
#line 107 "defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 138 "defines.h"
struct network {
   char inputfile[200] ;
   char clustfile[200] ;
   long n ;
   long n_trips ;
   long max_m ;
   long m ;
   long m_org ;
   long m_impl ;
   long max_residual_new_m ;
   long max_new_m ;
   long primal_unbounded ;
   long dual_unbounded ;
   long perturbed ;
   long feasible ;
   long eps ;
   long opt_tol ;
   long feas_tol ;
   long pert_val ;
   long bigM ;
   double optcost ;
   cost_t ignore_impl ;
   node_p nodes ;
   node_p stop_nodes ;
   arc_p arcs ;
   arc_p stop_arcs ;
   arc_p dummy_arcs ;
   arc_p stop_dummy ;
   long iterations ;
   long bound_exchanges ;
   long checksum ;
};
#line 138 "defines.h"
typedef struct network network_t;
#line 30 "pbeampp.h"
extern arc_t *primal_bea_mpp(long  , arc_t * , arc_t * , cost_t * ) ;
#line 30 "pbla.h"
extern node_t *primal_iminus(flow_t * , long * , node_t * , node_t * , node_t ** ) ;
#line 30 "pflowup.h"
extern void primal_update_flow(node_t * , node_t * , node_t * ) ;
#line 30 "treeup.h"
extern void update_tree(long  , long  , flow_t  , flow_t  , node_t * , node_t * ,
                        node_t * , node_t * , node_t * , arc_t * , cost_t  , flow_t  ) ;
#line 31 "mcfutil.h"
extern long refresh_potential(network_t * ) ;
#line 34
extern long primal_feasible(network_t * ) ;
#line 35
extern long dual_feasible(network_t * ) ;
#line 35 "psimplex.h"
long primal_net_simplex(network_t *net ) ;
void primal_net_simplex_cil_lr_1(network_t **__cil_ap_net , long **__cil_ap_checksum ,
                                 long opt , long xchange , node_t *w , arc_t *arcs ,
                                 arc_t *stop_arcs , long m , cost_t red_cost_of_bea ,
                                 long *iterations , long *bound_exchanges ) ;
#line 30 "psimplex.c"
long primal_net_simplex(network_t *net ) 
{ 
  long xchange ;
  node_t *w ;
  cost_t red_cost_of_bea ;
  long *checksum ;
  network_t **__cil_pp_net  = & net;
  long **__cil_pp_checksum  = & checksum;
  network_t **__cil_fp_net  = & net;
  long **__cil_fp_checksum  = & checksum;
  long opt_ssa_1 ;
  arc_t *arcs_ssa_1 ;
  arc_t *stop_arcs_ssa_1 ;
  long m_ssa_1 ;
  long *iterations_ssa_1 ;
  long *bound_exchanges_ssa_1 ;
  long *checksum_ssa_1 ;
  network_t *net_ssa_1 ;
  long *checksum_ssa_2 ;
  long tmp___0_ssa_1 ;
  unsigned char *__cil_tmp39 ;
  arc_p *__cil_tmp40 ;
  unsigned char *__cil_tmp41 ;
  arc_p *__cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  long *__cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  long __cil_tmp48 ;

  {
  {
#line 38
  opt_ssa_1 = 0L;
#line 48
  __cil_tmp39 = (unsigned char *)net + 568;
#line 48
  __cil_tmp40 = (arc_p *)__cil_tmp39;
#line 48
  arcs_ssa_1 = *__cil_tmp40;
#line 49
  __cil_tmp41 = (unsigned char *)net + 576;
#line 49
  __cil_tmp42 = (arc_p *)__cil_tmp41;
#line 49
  stop_arcs_ssa_1 = *__cil_tmp42;
#line 51
  __cil_tmp43 = (unsigned char *)net + 424;
#line 51
  __cil_tmp44 = (long *)__cil_tmp43;
#line 51
  m_ssa_1 = *__cil_tmp44;
#line 54
  __cil_tmp45 = (unsigned char *)net + 600;
#line 54
  iterations_ssa_1 = (long *)__cil_tmp45;
#line 55
  __cil_tmp46 = (unsigned char *)net + 608;
#line 55
  bound_exchanges_ssa_1 = (long *)__cil_tmp46;
#line 56
  __cil_tmp47 = (unsigned char *)net + 616;
#line 56
  checksum_ssa_1 = (long *)__cil_tmp47;
  }
  {
  *__cil_fp_net = net;
  *__cil_fp_checksum = checksum_ssa_1;
#line 59
  primal_net_simplex_cil_lr_1(__cil_pp_net, __cil_pp_checksum, opt_ssa_1, xchange,
                              w, arcs_ssa_1, stop_arcs_ssa_1, m_ssa_1, red_cost_of_bea,
                              iterations_ssa_1, bound_exchanges_ssa_1);
  net_ssa_1 = *__cil_fp_net;
  checksum_ssa_2 = *__cil_fp_checksum;
  }
  {
#line 152
  tmp___0_ssa_1 = refresh_potential(net_ssa_1);
#line 152
  __cil_tmp48 = *checksum_ssa_2;
#line 152
  *checksum_ssa_2 = __cil_tmp48 + tmp___0_ssa_1;
#line 153
  primal_feasible(net_ssa_1);
#line 154
  dual_feasible(net_ssa_1);
  }
#line 156
  return (0L);
}
}
void primal_net_simplex_cil_lr_1(network_t **__cil_ap_net , long **__cil_ap_checksum ,
                                 long opt , long xchange , node_t *w , arc_t *arcs ,
                                 arc_t *stop_arcs , long m , cost_t red_cost_of_bea ,
                                 long *iterations , long *bound_exchanges ) 
{ 
  flow_t delta ;
  cost_t *__cil_pp_red_cost_of_bea  = & red_cost_of_bea;
  flow_t *__cil_pp_delta  = & delta;
  long *__cil_pp_xchange  = & xchange;
  node_t **__cil_pp_w  = & w;
  cost_t *__cil_fp_red_cost_of_bea  = & red_cost_of_bea;
  long *__cil_fp_xchange  = & xchange;
  node_t **__cil_fp_w  = & w;
  flow_t *__cil_fp_delta  = & delta;
  arc_t *bea_ssa_1 ;
  cost_t red_cost_of_bea_ssa_1 ;
  node_t *iplus_ssa_1 ;
  node_t *jplus_ssa_1 ;
  flow_t delta_ssa_1 ;
  node_t *iminus_ssa_1 ;
  long xchange_ssa_1 ;
  node_t *w_ssa_1 ;
  flow_t delta_ssa_2 ;
  node_t *temp_ssa_1 ;
  node_t *jplus_ssa_2 ;
  node_t *iplus_ssa_2 ;
  node_t *jminus_ssa_1 ;
  arc_t *bla_ssa_1 ;
  long new_set_ssa_1 ;
  flow_t new_flow_ssa_1 ;
  long new_orientation_ssa_1 ;
  long tmp_ssa_1 ;
  long opt_ssa_1 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  long __cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  node_p *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  node_p *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;
  node_p *__cil_tmp63 ;
  unsigned char *__cil_tmp64 ;
  node_p *__cil_tmp65 ;
  long __cil_tmp66 ;
  unsigned char *__cil_tmp67 ;
  int *__cil_tmp68 ;
  int __cil_tmp69 ;
  unsigned char *__cil_tmp70 ;
  int *__cil_tmp71 ;
  unsigned char *__cil_tmp72 ;
  int *__cil_tmp73 ;
  unsigned char *__cil_tmp74 ;
  node_p *__cil_tmp75 ;
  unsigned char *__cil_tmp76 ;
  arc_p *__cil_tmp77 ;
  unsigned char *__cil_tmp78 ;
  int *__cil_tmp79 ;
  int __cil_tmp80 ;
  long __cil_tmp81 ;
  unsigned char *__cil_tmp82 ;
  node_p *__cil_tmp83 ;
  node_p __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  network_t *__cil_tmp86 ;
  unsigned char *__cil_tmp87 ;
  unsigned char *__cil_tmp88 ;
  long *__cil_tmp89 ;
  long __cil_tmp90 ;
  unsigned char *__cil_tmp91 ;
  int *__cil_tmp92 ;
  unsigned char *__cil_tmp93 ;
  int *__cil_tmp94 ;
  long __cil_tmp95 ;
  long __cil_tmp96 ;
  long __cil_tmp97 ;
  network_t *__cil_tmp98 ;
  long *__cil_tmp99 ;
  long __cil_tmp100 ;
  long *__cil_tmp101 ;

  {
#line 59
  if (! opt) {
    {
    *__cil_fp_red_cost_of_bea = red_cost_of_bea;
#line 61
    bea_ssa_1 = primal_bea_mpp(m, arcs, stop_arcs, __cil_pp_red_cost_of_bea);
    red_cost_of_bea_ssa_1 = *__cil_fp_red_cost_of_bea;
    }
#line 61
    if (bea_ssa_1) {
      {
#line 63
      __cil_tmp57 = *iterations;
#line 63
      *iterations = __cil_tmp57 + 1L;
      }
      {
#line 71
      __cil_tmp51 = red_cost_of_bea_ssa_1 > 0L;
#line 71
      if (__cil_tmp51) {
        {
#line 73
        __cil_tmp58 = (unsigned char *)bea_ssa_1 + 16;
#line 73
        __cil_tmp59 = (node_p *)__cil_tmp58;
#line 73
        iplus_ssa_1 = *__cil_tmp59;
#line 74
        __cil_tmp60 = (unsigned char *)bea_ssa_1 + 8;
#line 74
        __cil_tmp61 = (node_p *)__cil_tmp60;
#line 74
        jplus_ssa_1 = *__cil_tmp61;
        }
      } else {
        {
#line 78
        __cil_tmp62 = (unsigned char *)bea_ssa_1 + 8;
#line 78
        __cil_tmp63 = (node_p *)__cil_tmp62;
#line 78
        iplus_ssa_1 = *__cil_tmp63;
#line 79
        __cil_tmp64 = (unsigned char *)bea_ssa_1 + 16;
#line 79
        __cil_tmp65 = (node_p *)__cil_tmp64;
#line 79
        jplus_ssa_1 = *__cil_tmp65;
        }
      }
      }
      {
#line 82
      delta_ssa_1 = (flow_t )1;
      *__cil_fp_xchange = xchange;
      *__cil_fp_w = w;
      *__cil_fp_delta = delta_ssa_1;
#line 83
      iminus_ssa_1 = primal_iminus(__cil_pp_delta, __cil_pp_xchange, iplus_ssa_1,
                                   jplus_ssa_1, __cil_pp_w);
      xchange_ssa_1 = *__cil_fp_xchange;
      w_ssa_1 = *__cil_fp_w;
      delta_ssa_2 = *__cil_fp_delta;
      }
#line 86
      if (! iminus_ssa_1) {
        {
#line 88
        __cil_tmp66 = *bound_exchanges;
#line 88
        *bound_exchanges = __cil_tmp66 + 1L;
        }
        {
#line 90
        __cil_tmp67 = (unsigned char *)bea_ssa_1 + 24;
#line 90
        __cil_tmp68 = (int *)__cil_tmp67;
#line 90
        __cil_tmp69 = *__cil_tmp68;
#line 90
        __cil_tmp52 = __cil_tmp69 == 2;
#line 90
        if (__cil_tmp52) {
          {
#line 91
          __cil_tmp70 = (unsigned char *)bea_ssa_1 + 24;
#line 91
          __cil_tmp71 = (int *)__cil_tmp70;
#line 91
          *__cil_tmp71 = 1;
          }
        } else {
          {
#line 93
          __cil_tmp72 = (unsigned char *)bea_ssa_1 + 24;
#line 93
          __cil_tmp73 = (int *)__cil_tmp72;
#line 93
          *__cil_tmp73 = 2;
          }
        }
        }
#line 95
        if (delta_ssa_2) {
          {
#line 96
          primal_update_flow(iplus_ssa_1, jplus_ssa_1, w_ssa_1);
          opt_ssa_1 = opt;
          }
        } else {
          opt_ssa_1 = opt;
        }
      } else {
#line 100
        if (xchange_ssa_1) {
          {
#line 102
          temp_ssa_1 = jplus_ssa_1;
#line 103
          jplus_ssa_2 = iplus_ssa_1;
#line 104
          iplus_ssa_2 = temp_ssa_1;
          }
        } else {
          iplus_ssa_2 = iplus_ssa_1;
          jplus_ssa_2 = jplus_ssa_1;
        }
        {
#line 107
        __cil_tmp74 = (unsigned char *)iminus_ssa_1 + 24;
#line 107
        __cil_tmp75 = (node_p *)__cil_tmp74;
#line 107
        jminus_ssa_1 = *__cil_tmp75;
#line 109
        __cil_tmp76 = (unsigned char *)iminus_ssa_1 + 48;
#line 109
        __cil_tmp77 = (arc_p *)__cil_tmp76;
#line 109
        bla_ssa_1 = *__cil_tmp77;
        }
        {
#line 111
        __cil_tmp78 = (unsigned char *)iminus_ssa_1 + 8;
#line 111
        __cil_tmp79 = (int *)__cil_tmp78;
#line 111
        __cil_tmp80 = *__cil_tmp79;
#line 111
        __cil_tmp81 = (long )__cil_tmp80;
#line 111
        __cil_tmp53 = xchange_ssa_1 != __cil_tmp81;
#line 111
        if (__cil_tmp53) {
          {
#line 112
          new_set_ssa_1 = 1L;
          }
        } else {
          {
#line 114
          new_set_ssa_1 = 2L;
          }
        }
        }
        {
#line 116
        __cil_tmp54 = red_cost_of_bea_ssa_1 > 0L;
#line 116
        if (__cil_tmp54) {
          {
#line 117
          new_flow_ssa_1 = 1L - delta_ssa_2;
          }
        } else {
          {
#line 119
          new_flow_ssa_1 = delta_ssa_2;
          }
        }
        }
        {
#line 121
        __cil_tmp82 = (unsigned char *)bea_ssa_1 + 8;
#line 121
        __cil_tmp83 = (node_p *)__cil_tmp82;
#line 121
        __cil_tmp84 = *__cil_tmp83;
#line 121
        __cil_tmp85 = (unsigned long )__cil_tmp84;
#line 121
        __cil_tmp55 = __cil_tmp85 == (unsigned long )iplus_ssa_2;
#line 121
        if (__cil_tmp55) {
          {
#line 122
          new_orientation_ssa_1 = 1L;
          }
        } else {
          {
#line 124
          new_orientation_ssa_1 = 0L;
          }
        }
        }
        {
#line 126
        __cil_tmp86 = *__cil_ap_net;
#line 126
        __cil_tmp87 = (unsigned char *)__cil_tmp86;
#line 126
        __cil_tmp88 = __cil_tmp87 + 512;
#line 126
        __cil_tmp89 = (long *)__cil_tmp88;
#line 126
        __cil_tmp90 = *__cil_tmp89;
#line 126
        update_tree((long )(! xchange_ssa_1), new_orientation_ssa_1, delta_ssa_2,
                    new_flow_ssa_1, iplus_ssa_2, jplus_ssa_2, iminus_ssa_1, jminus_ssa_1,
                    w_ssa_1, bea_ssa_1, red_cost_of_bea_ssa_1, __cil_tmp90);
#line 131
        __cil_tmp91 = (unsigned char *)bea_ssa_1 + 24;
#line 131
        __cil_tmp92 = (int *)__cil_tmp91;
#line 131
        *__cil_tmp92 = 0;
#line 132
        __cil_tmp93 = (unsigned char *)bla_ssa_1 + 24;
#line 132
        __cil_tmp94 = (int *)__cil_tmp93;
#line 132
        *__cil_tmp94 = (int )new_set_ssa_1;
        }
        {
#line 134
        __cil_tmp95 = *iterations;
#line 134
        __cil_tmp96 = __cil_tmp95 - 1L;
#line 134
        __cil_tmp97 = __cil_tmp96 % 200L;
#line 134
        __cil_tmp56 = ! __cil_tmp97;
#line 134
        if (__cil_tmp56) {
          {
#line 136
          __cil_tmp98 = *__cil_ap_net;
#line 136
          tmp_ssa_1 = refresh_potential(__cil_tmp98);
#line 136
          __cil_tmp99 = *__cil_ap_checksum;
#line 136
          __cil_tmp100 = *__cil_tmp99;
#line 136
          __cil_tmp101 = *__cil_ap_checksum;
#line 136
          *__cil_tmp101 = __cil_tmp100 + tmp_ssa_1;
          opt_ssa_1 = opt;
          }
        } else {
          opt_ssa_1 = opt;
        }
        }
      }
    } else {
      {
#line 148
      opt_ssa_1 = 1L;
      w_ssa_1 = w;
      xchange_ssa_1 = xchange;
      }
    }
    {
    primal_net_simplex_cil_lr_1(__cil_ap_net, __cil_ap_checksum, opt_ssa_1, xchange_ssa_1,
                                w_ssa_1, arcs, stop_arcs, m, red_cost_of_bea_ssa_1,
                                iterations, bound_exchanges);
    }
    return;
  } else {
    return;
  }
}
}
