/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 137 "bzlib.h"
typedef void BZFILE;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 161 "bzip2.c"
typedef char Char;
#line 162 "bzip2.c"
typedef unsigned char Bool;
#line 163 "bzip2.c"
typedef unsigned char UChar;
#line 164 "bzip2.c"
typedef int Int32;
#line 165 "bzip2.c"
typedef unsigned int UInt32;
#line 166 "bzip2.c"
typedef short Int16;
#line 167 "bzip2.c"
typedef unsigned short UInt16;
#line 176 "bzip2.c"
typedef int IntNative;
#line 232 "bzip2.c"
struct __anonstruct_UInt64_56 {
   UChar b[8] ;
};
#line 232 "bzip2.c"
typedef struct __anonstruct_UInt64_56 UInt64;
#line 1694 "bzip2.c"
struct zzzz {
   Char *name ;
   struct zzzz *link ;
};
#line 1694 "bzip2.c"
typedef struct zzzz Cell;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 139 "bzlib.h"
extern BZFILE *BZ2_bzReadOpen(int *bzerror , FILE *f , int verbosity , int small ,
                              void *unused , int nUnused ) ;
#line 148
extern void BZ2_bzReadClose(int *bzerror , BZFILE *b ) ;
#line 153
extern void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) ;
#line 160
extern int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 167
extern BZFILE *BZ2_bzWriteOpen(int *bzerror , FILE *f , int blockSize100k , int verbosity ,
                               int workFactor ) ;
#line 175
extern void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 190
extern void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                               unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                               unsigned int *nbytes_out_hi32 ) ;
#line 233
extern char const   *BZ2_bzlibVersion(void) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 478
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 267
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 183 "bzip2.c"
Int32 verbosity  ;
#line 184 "bzip2.c"
Bool keepInputFiles  ;
#line 184 "bzip2.c"
Bool smallMode  ;
#line 184 "bzip2.c"
Bool deleteOutputOnInterrupt  ;
#line 185 "bzip2.c"
Bool forceOverwrite  ;
#line 185 "bzip2.c"
Bool testFailsExist  ;
#line 185 "bzip2.c"
Bool unzFailsExist  ;
#line 185 "bzip2.c"
Bool noisy  ;
#line 186 "bzip2.c"
Int32 numFileNames  ;
#line 186 "bzip2.c"
Int32 numFilesProcessed  ;
#line 186 "bzip2.c"
Int32 blockSize100k  ;
#line 187 "bzip2.c"
Int32 exitValue  ;
#line 199 "bzip2.c"
Int32 opMode  ;
#line 200 "bzip2.c"
Int32 srcMode  ;
#line 204 "bzip2.c"
Int32 longestFileName  ;
#line 205 "bzip2.c"
Char inName[1034]  ;
#line 206 "bzip2.c"
Char outName[1034]  ;
#line 207 "bzip2.c"
Char tmpName[1034]  ;
#line 208 "bzip2.c"
Char *progName  ;
#line 209 "bzip2.c"
Char progNameReally[1034]  ;
#line 210 "bzip2.c"
FILE *outputHandleJustInCase  ;
#line 211 "bzip2.c"
Int32 workFactor  ;
#line 213
static  __attribute__((__noreturn__)) void panic(Char const   *s ) ;
#line 214
static  __attribute__((__noreturn__)) void ioError(void) ;
#line 215
static  __attribute__((__noreturn__)) void outOfMemory(void) ;
#line 216
static  __attribute__((__noreturn__)) void configError(void) ;
#line 217
static  __attribute__((__noreturn__)) void crcError(void) ;
#line 218
static  __attribute__((__noreturn__)) void cleanUpAndFail(Int32 ec ) ;
#line 219
static  __attribute__((__noreturn__)) void compressedStreamEOF(void) ;
#line 221
static void copyFileName(Char *to , Char *from ) ;
#line 222
static void *myMalloc(Int32 n ) ;
#line 223
static void applySavedFileAttrToOutputFile(IntNative fd ) ;
#line 1033 "bzip2.c"
static struct stat fileMetaInfo  ;
#line 1104 "bzip2.c"
Char const   *zSuffix[4]  = {      ".bz2",      ".bz",      ".tbz2",      ".tbz"};
#line 1106 "bzip2.c"
Char const   *unzSuffix[4]  = {      "",      "",      ".tar",      ".tar"};
void addFlagsFromEnvVar_cil_lr_1_cil_lr_1(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) ;
void addFlagsFromEnvVar_cil_lr_1_cil_lr_2(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) ;
void addFlagsFromEnvVar_cil_lr_1_cil_lr_3(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p , Int32 *__cil_ap_k ,
                                          Int32 j ) ;
void addFlagsFromEnvVar_cil_lr_1(Cell **argList , Int32 i , Char *p ) ;
void snocString_cil_lr_1(Cell **__cil_ap_root , Char **__cil_ap_name , Cell **__cil_ap_tmp___3 ) ;
void pad_cil_lr_1(Char *s , Int32 i ) ;
void uInt64_toAscii_cil_lr_1(char **__cil_ap_outbuf , Int32 *__cil_ap_nBuf , UChar buf[32] ,
                             UInt64 n_copy ) ;
void uInt64_toAscii_cil_lr_2(char *outbuf , Int32 i , UChar buf[32] , Int32 nBuf ) ;
void uInt64_qrm10_cil_lr_1(UInt32 *__cil_ap_rem , UInt64 *n , Int32 i ) ;
int uInt64_isZero_cil_lr_1(Bool *__cil_ap___cil_ret3 , UInt64 *n , Int32 i ) ;
void uInt64_to_double_cil_lr_1(double *__cil_ap_sum , UInt64 *n , Int32 i , double base ) ;
#line 237 "bzip2.c"
static void uInt64_from_UInt32s(UInt64 *n , UInt32 lo32 , UInt32 hi32 ) 
{ 
  UInt32 __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  UChar *__cil_tmp6 ;
  UChar *__cil_tmp7 ;
  UInt32 __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  UChar *__cil_tmp10 ;
  UChar *__cil_tmp11 ;
  UInt32 __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  UChar *__cil_tmp14 ;
  UChar *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  UChar *__cil_tmp17 ;
  UChar *__cil_tmp18 ;
  UInt32 __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  UChar *__cil_tmp21 ;
  UChar *__cil_tmp22 ;
  UInt32 __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  UChar *__cil_tmp25 ;
  UChar *__cil_tmp26 ;
  UInt32 __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  UChar *__cil_tmp29 ;
  UChar *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  UChar *__cil_tmp32 ;
  UChar *__cil_tmp33 ;

  {
  {
#line 240
  __cil_tmp4 = hi32 >> 24;
#line 240
  __cil_tmp5 = __cil_tmp4 & 255U;
#line 240
  __cil_tmp6 = *((UChar (*)[8])n);
#line 240
  __cil_tmp7 = __cil_tmp6 + 7;
#line 240
  *__cil_tmp7 = (UChar )__cil_tmp5;
#line 241
  __cil_tmp8 = hi32 >> 16;
#line 241
  __cil_tmp9 = __cil_tmp8 & 255U;
#line 241
  __cil_tmp10 = *((UChar (*)[8])n);
#line 241
  __cil_tmp11 = __cil_tmp10 + 6;
#line 241
  *__cil_tmp11 = (UChar )__cil_tmp9;
#line 242
  __cil_tmp12 = hi32 >> 8;
#line 242
  __cil_tmp13 = __cil_tmp12 & 255U;
#line 242
  __cil_tmp14 = *((UChar (*)[8])n);
#line 242
  __cil_tmp15 = __cil_tmp14 + 5;
#line 242
  *__cil_tmp15 = (UChar )__cil_tmp13;
#line 243
  __cil_tmp16 = hi32 & 255U;
#line 243
  __cil_tmp17 = *((UChar (*)[8])n);
#line 243
  __cil_tmp18 = __cil_tmp17 + 4;
#line 243
  *__cil_tmp18 = (UChar )__cil_tmp16;
#line 244
  __cil_tmp19 = lo32 >> 24;
#line 244
  __cil_tmp20 = __cil_tmp19 & 255U;
#line 244
  __cil_tmp21 = *((UChar (*)[8])n);
#line 244
  __cil_tmp22 = __cil_tmp21 + 3;
#line 244
  *__cil_tmp22 = (UChar )__cil_tmp20;
#line 245
  __cil_tmp23 = lo32 >> 16;
#line 245
  __cil_tmp24 = __cil_tmp23 & 255U;
#line 245
  __cil_tmp25 = *((UChar (*)[8])n);
#line 245
  __cil_tmp26 = __cil_tmp25 + 2;
#line 245
  *__cil_tmp26 = (UChar )__cil_tmp24;
#line 246
  __cil_tmp27 = lo32 >> 8;
#line 246
  __cil_tmp28 = __cil_tmp27 & 255U;
#line 246
  __cil_tmp29 = *((UChar (*)[8])n);
#line 246
  __cil_tmp30 = __cil_tmp29 + 1;
#line 246
  *__cil_tmp30 = (UChar )__cil_tmp28;
#line 247
  __cil_tmp31 = lo32 & 255U;
#line 247
  __cil_tmp32 = *((UChar (*)[8])n);
#line 247
  __cil_tmp33 = (UChar *)__cil_tmp32;
#line 247
  *__cil_tmp33 = (UChar )__cil_tmp31;
  }
#line 248
  return;
}
}
#line 251 "bzip2.c"
static double uInt64_to_double(UInt64 *n ) 
{ 
  double sum ;
  double *__cil_pp_sum  = & sum;
  double *__cil_fp_sum  = & sum;
  double base_ssa_1 ;
  double sum_ssa_1 ;
  Int32 i_ssa_1 ;
  double sum_ssa_2 ;

  {
  {
#line 255
  base_ssa_1 = 1.0;
#line 256
  sum_ssa_1 = 0.0;
#line 257
  i_ssa_1 = 0;
  }
  {
  *__cil_fp_sum = sum_ssa_1;
#line 257
  uInt64_to_double_cil_lr_1(__cil_pp_sum, n, i_ssa_1, base_ssa_1);
  sum_ssa_2 = *__cil_fp_sum;
  }
#line 261
  return (sum_ssa_2);
}
}
#line 265 "bzip2.c"
static Bool uInt64_isZero(UInt64 *n ) 
{ 
  Bool __cil_ret3 ;
  Bool *__cil_pp___cil_ret3  = & __cil_ret3;
  Bool *__cil_fp___cil_ret3  = & __cil_ret3;
  Int32 i_ssa_1 ;
  int retflag4_ssa_1 ;
  Bool __cil_ret3_ssa_1 ;

  {
  {
#line 269
  i_ssa_1 = 0;
  }
  {
  {
  *__cil_fp___cil_ret3 = __cil_ret3;
#line 269
  retflag4_ssa_1 = uInt64_isZero_cil_lr_1(__cil_pp___cil_ret3, n, i_ssa_1);
  __cil_ret3_ssa_1 = *__cil_fp___cil_ret3;
  }
#line 269
  if (retflag4_ssa_1) {
#line 269
    return (__cil_ret3_ssa_1);
  } else {
#line 271
    return ((Bool )1);
  }
  }
}
}
#line 276 "bzip2.c"
static Int32 uInt64_qrm10(UInt64 *n ) 
{ 
  UInt32 rem ;
  UInt32 *__cil_pp_rem  = & rem;
  UInt32 *__cil_fp_rem  = & rem;
  UInt32 rem_ssa_1 ;
  Int32 i_ssa_1 ;
  UInt32 rem_ssa_2 ;

  {
  {
#line 281
  rem_ssa_1 = (UInt32 )0;
#line 282
  i_ssa_1 = 7;
  }
  {
  *__cil_fp_rem = rem_ssa_1;
#line 282
  uInt64_qrm10_cil_lr_1(__cil_pp_rem, n, i_ssa_1);
  rem_ssa_2 = *__cil_fp_rem;
  }
#line 287
  return ((Int32 )rem_ssa_2);
}
}
#line 294 "bzip2.c"
static void uInt64_toAscii(char *outbuf , UInt64 *n ) 
{ 
  UChar buf[32] ;
  Int32 nBuf ;
  char **__cil_pp_outbuf  = & outbuf;
  Int32 *__cil_pp_nBuf  = & nBuf;
  char **__cil_fp_outbuf  = & outbuf;
  Int32 *__cil_fp_nBuf  = & nBuf;
  Int32 nBuf_ssa_1 ;
  UInt64 n_copy_ssa_1 ;
  char *outbuf_ssa_1 ;
  Int32 nBuf_ssa_2 ;
  Int32 i_ssa_1 ;
  char *__cil_tmp18 ;

  {
  {
#line 299
  nBuf_ssa_1 = 0;
#line 300
  n_copy_ssa_1 = *n;
  }
  {
  *__cil_fp_outbuf = outbuf;
  *__cil_fp_nBuf = nBuf_ssa_1;
#line 301
  uInt64_toAscii_cil_lr_1(__cil_pp_outbuf, __cil_pp_nBuf, buf, n_copy_ssa_1);
  outbuf_ssa_1 = *__cil_fp_outbuf;
  nBuf_ssa_2 = *__cil_fp_nBuf;
  }
  {
#line 306
  __cil_tmp18 = outbuf_ssa_1 + nBuf_ssa_2;
#line 306
  *__cil_tmp18 = (char)0;
#line 307
  i_ssa_1 = 0;
  }
  {
#line 307
  uInt64_toAscii_cil_lr_2(outbuf_ssa_1, i_ssa_1, buf, nBuf_ssa_2);
  }
#line 309
  return;
}
}
#line 317 "bzip2.c"
static Bool myfeof(FILE *f ) 
{ 
  int tmp_ssa_1 ;
  Int32 c_ssa_1 ;
  int __cil_tmp6 ;

  {
  {
#line 320
  tmp_ssa_1 = fgetc(f);
#line 320
  c_ssa_1 = tmp_ssa_1;
  }
  {
#line 321
  __cil_tmp6 = c_ssa_1 == -1;
#line 321
  if (__cil_tmp6) {
#line 321
    return ((Bool )1);
  } else {
    {
#line 322
    ungetc(c_ssa_1, f);
    }
#line 323
    return ((Bool )0);
  }
  }
}
}
#line 328 "bzip2.c"
static void compressStream(FILE *stream , FILE *zStream ) 
{ 
  BZFILE *bzf ;
  UChar ibuf[5000] ;
  Int32 nIbuf ;
  UInt32 nbytes_in_lo32 ;
  UInt32 nbytes_in_hi32 ;
  UInt32 nbytes_out_lo32 ;
  UInt32 nbytes_out_hi32 ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  int tmp ;
  int tmp___0 ;
  Bool tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  Int32 fd ;
  int tmp___5 ;
  int tmp___6 ;
  Char buf_nin[32] ;
  Char buf_nout[32] ;
  UInt64 nbytes_in ;
  UInt64 nbytes_out ;
  double nbytes_in_d ;
  double nbytes_out_d ;

  {
#line 341
  tmp = ferror(stream);
#line 341
  if (tmp) {
#line 341
    goto errhandler_io;
  }
#line 342
  tmp___0 = ferror(zStream);
#line 342
  if (tmp___0) {
#line 342
    goto errhandler_io;
  }
#line 344
  bzf = BZ2_bzWriteOpen(& bzerr, zStream, blockSize100k, verbosity, workFactor);
#line 346
  if (bzerr != 0) {
#line 346
    goto errhandler;
  }
#line 348
  if (verbosity >= 2) {
#line 348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 350
  while (1) {
#line 352
    tmp___1 = myfeof(stream);
#line 352
    if (tmp___1) {
#line 352
      break;
    }
#line 353
    tmp___2 = fread((void */* __restrict  */)(ibuf), sizeof(UChar ), (size_t )5000,
                    (FILE */* __restrict  */)stream);
#line 353
    nIbuf = (Int32 )tmp___2;
#line 354
    tmp___3 = ferror(stream);
#line 354
    if (tmp___3) {
#line 354
      goto errhandler_io;
    }
#line 355
    if (nIbuf > 0) {
#line 355
      BZ2_bzWrite(& bzerr, bzf, (void *)(ibuf), nIbuf);
    }
#line 356
    if (bzerr != 0) {
#line 356
      goto errhandler;
    }
  }
#line 360
  BZ2_bzWriteClose64(& bzerr, bzf, 0, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
#line 363
  if (bzerr != 0) {
#line 363
    goto errhandler;
  }
#line 365
  tmp___4 = ferror(zStream);
#line 365
  if (tmp___4) {
#line 365
    goto errhandler_io;
  }
#line 366
  ret = fflush(zStream);
#line 367
  if (ret == -1) {
#line 367
    goto errhandler_io;
  }
#line 368
  if ((unsigned long )zStream != (unsigned long )stdout) {
#line 369
    tmp___5 = fileno(zStream);
#line 369
    fd = tmp___5;
#line 370
    if (fd < 0) {
#line 370
      goto errhandler_io;
    }
#line 371
    applySavedFileAttrToOutputFile(fd);
#line 372
    ret = fclose(zStream);
#line 373
    outputHandleJustInCase = (FILE *)((void *)0);
#line 374
    if (ret == -1) {
#line 374
      goto errhandler_io;
    }
  }
#line 376
  outputHandleJustInCase = (FILE *)((void *)0);
#line 377
  tmp___6 = ferror(stream);
#line 377
  if (tmp___6) {
#line 377
    goto errhandler_io;
  }
#line 378
  ret = fclose(stream);
#line 379
  if (ret == -1) {
#line 379
    goto errhandler_io;
  }
#line 381
  if (verbosity >= 1) {
#line 382
    if (nbytes_in_lo32 == 0U) {
#line 382
      if (nbytes_in_hi32 == 0U) {
#line 383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" no data compressed.\n");
      } else {
#line 382
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 388
      uInt64_from_UInt32s(& nbytes_in, nbytes_in_lo32, nbytes_in_hi32);
#line 390
      uInt64_from_UInt32s(& nbytes_out, nbytes_out_lo32, nbytes_out_hi32);
#line 392
      nbytes_in_d = uInt64_to_double(& nbytes_in);
#line 393
      nbytes_out_d = uInt64_to_double(& nbytes_out);
#line 394
      uInt64_toAscii(buf_nin, & nbytes_in);
#line 395
      uInt64_toAscii(buf_nout, & nbytes_out);
#line 396
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\n",
              nbytes_in_d / nbytes_out_d, (8.0 * nbytes_out_d) / nbytes_in_d, 100.0 * (1.0 - nbytes_out_d / nbytes_in_d),
              buf_nin, buf_nout);
    }
  }
#line 407
  return;
  errhandler: 
#line 410
  BZ2_bzWriteClose64(& bzerr_dummy, bzf, 1, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
#line 413
  switch (bzerr) {
  case -9: 
#line 415
  configError();
#line 415
  break;
  case -3: 
#line 417
  outOfMemory();
#line 417
  break;
  errhandler_io: 
  case -6: 
#line 420
  ioError();
#line 420
  break;
  default: 
#line 422
  panic("compress:unexpected error");
  }
#line 425
  panic("compress:end");
}
}
#line 432 "bzip2.c"
static Bool uncompressStream(FILE *zStream , FILE *stream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  Int32 fd ;
  int tmp___4 ;
  int tmp___5 ;
  Bool tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 443
  nUnused = 0;
#line 444
  streamNo = 0;
#line 449
  tmp = ferror(stream);
#line 449
  if (tmp) {
#line 449
    goto errhandler_io;
  }
#line 450
  tmp___0 = ferror(zStream);
#line 450
  if (tmp___0) {
#line 450
    goto errhandler_io;
  }
#line 452
  while (1) {
#line 454
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
#line 458
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 458
      goto errhandler;
    } else
#line 458
    if (bzerr != 0) {
#line 458
      goto errhandler;
    }
#line 459
    streamNo ++;
#line 461
    while (bzerr == 0) {
#line 462
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
#line 463
      if (bzerr == -5) {
#line 463
        goto trycat;
      }
#line 464
      if (bzerr == 0) {
#line 464
        goto _L;
      } else
#line 464
      if (bzerr == 4) {
        _L: /* CIL Label */ 
#line 464
        if (nread > 0) {
#line 465
          fwrite((void const   */* __restrict  */)(obuf), sizeof(UChar ), (size_t )nread,
                 (FILE */* __restrict  */)stream);
        }
      }
#line 466
      tmp___1 = ferror(stream);
#line 466
      if (tmp___1) {
#line 466
        goto errhandler_io;
      }
    }
#line 468
    if (bzerr != 4) {
#line 468
      goto errhandler;
    }
#line 470
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
#line 471
    if (bzerr != 0) {
#line 471
      panic("decompress:bzReadGetUnused");
    }
#line 473
    unusedTmp = (UChar *)unusedTmpV;
#line 474
    i = 0;
#line 474
    while (i < nUnused) {
#line 474
      unused[i] = *(unusedTmp + i);
#line 474
      i ++;
    }
#line 476
    BZ2_bzReadClose(& bzerr, bzf);
#line 477
    if (bzerr != 0) {
#line 477
      panic("decompress:bzReadGetUnused");
    }
#line 479
    if (nUnused == 0) {
#line 479
      tmp___2 = myfeof(zStream);
#line 479
      if (tmp___2) {
#line 479
        break;
      }
    }
  }
  closeok: 
#line 483
  tmp___3 = ferror(zStream);
#line 483
  if (tmp___3) {
#line 483
    goto errhandler_io;
  }
#line 484
  if ((unsigned long )stream != (unsigned long )stdout) {
#line 485
    tmp___4 = fileno(stream);
#line 485
    fd = tmp___4;
#line 486
    if (fd < 0) {
#line 486
      goto errhandler_io;
    }
#line 487
    applySavedFileAttrToOutputFile(fd);
  }
#line 489
  ret = fclose(zStream);
#line 490
  if (ret == -1) {
#line 490
    goto errhandler_io;
  }
#line 492
  tmp___5 = ferror(stream);
#line 492
  if (tmp___5) {
#line 492
    goto errhandler_io;
  }
#line 493
  ret = fflush(stream);
#line 494
  if (ret != 0) {
#line 494
    goto errhandler_io;
  }
#line 495
  if ((unsigned long )stream != (unsigned long )stdout) {
#line 496
    ret = fclose(stream);
#line 497
    outputHandleJustInCase = (FILE *)((void *)0);
#line 498
    if (ret == -1) {
#line 498
      goto errhandler_io;
    }
  }
#line 500
  outputHandleJustInCase = (FILE *)((void *)0);
#line 501
  if (verbosity >= 2) {
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    ");
  }
#line 502
  return ((Bool )1);
  trycat: 
#line 505
  if (forceOverwrite) {
#line 506
    rewind(zStream);
#line 507
    while (1) {
#line 508
      tmp___6 = myfeof(zStream);
#line 508
      if (tmp___6) {
#line 508
        break;
      }
#line 509
      tmp___7 = fread((void */* __restrict  */)(obuf), sizeof(UChar ), (size_t )5000,
                      (FILE */* __restrict  */)zStream);
#line 509
      nread = (Int32 )tmp___7;
#line 510
      tmp___8 = ferror(zStream);
#line 510
      if (tmp___8) {
#line 510
        goto errhandler_io;
      }
#line 511
      if (nread > 0) {
#line 511
        fwrite((void const   */* __restrict  */)(obuf), sizeof(UChar ), (size_t )nread,
               (FILE */* __restrict  */)stream);
      }
#line 512
      tmp___9 = ferror(stream);
#line 512
      if (tmp___9) {
#line 512
        goto errhandler_io;
      }
    }
#line 514
    goto closeok;
  }
  errhandler: 
#line 518
  BZ2_bzReadClose(& bzerr_dummy, bzf);
#line 519
  switch (bzerr) {
  case -9: 
#line 521
  configError();
#line 521
  break;
  errhandler_io: 
  case -6: 
#line 524
  ioError();
#line 524
  break;
  case -4: 
#line 526
  crcError();
  case -3: 
#line 528
  outOfMemory();
  case -7: 
#line 530
  compressedStreamEOF();
  case -5: 
#line 532
  if ((unsigned long )zStream != (unsigned long )stdin) {
#line 532
    fclose(zStream);
  }
#line 533
  if ((unsigned long )stream != (unsigned long )stdout) {
#line 533
    fclose(stream);
  }
#line 534
  if (streamNo == 1) {
#line 535
    return ((Bool )0);
  } else {
#line 537
    if (noisy) {
#line 538
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: trailing garbage after EOF ignored\n",
              progName, inName);
    }
#line 541
    return ((Bool )1);
  }
  default: 
#line 544
  panic("decompress:unexpected error");
  }
#line 547
  panic("decompress:end");
#line 548
  return ((Bool )1);
}
}
#line 553 "bzip2.c"
static Bool testStream(FILE *zStream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  int tmp ;
  Bool tmp___0 ;
  int tmp___1 ;

  {
#line 564
  nUnused = 0;
#line 565
  streamNo = 0;
#line 568
  tmp = ferror(zStream);
#line 568
  if (tmp) {
#line 568
    goto errhandler_io;
  }
#line 570
  while (1) {
#line 572
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
#line 576
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 576
      goto errhandler;
    } else
#line 576
    if (bzerr != 0) {
#line 576
      goto errhandler;
    }
#line 577
    streamNo ++;
#line 579
    while (bzerr == 0) {
#line 580
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
#line 581
      if (bzerr == -5) {
#line 581
        goto errhandler;
      }
    }
#line 583
    if (bzerr != 4) {
#line 583
      goto errhandler;
    }
#line 585
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
#line 586
    if (bzerr != 0) {
#line 586
      panic("test:bzReadGetUnused");
    }
#line 588
    unusedTmp = (UChar *)unusedTmpV;
#line 589
    i = 0;
#line 589
    while (i < nUnused) {
#line 589
      unused[i] = *(unusedTmp + i);
#line 589
      i ++;
    }
#line 591
    BZ2_bzReadClose(& bzerr, bzf);
#line 592
    if (bzerr != 0) {
#line 592
      panic("test:bzReadGetUnused");
    }
#line 593
    if (nUnused == 0) {
#line 593
      tmp___0 = myfeof(zStream);
#line 593
      if (tmp___0) {
#line 593
        break;
      }
    }
  }
#line 597
  tmp___1 = ferror(zStream);
#line 597
  if (tmp___1) {
#line 597
    goto errhandler_io;
  }
#line 598
  ret = fclose(zStream);
#line 599
  if (ret == -1) {
#line 599
    goto errhandler_io;
  }
#line 601
  if (verbosity >= 2) {
#line 601
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    ");
  }
#line 602
  return ((Bool )1);
  errhandler: 
#line 605
  BZ2_bzReadClose(& bzerr_dummy, bzf);
#line 606
  if (verbosity == 0) {
#line 607
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
            progName, inName);
  }
#line 608
  switch (bzerr) {
  case -9: 
#line 610
  configError();
#line 610
  break;
  errhandler_io: 
  case -6: 
#line 613
  ioError();
#line 613
  break;
  case -4: 
#line 615
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data integrity (CRC) error in data\n");
#line 617
  return ((Bool )0);
  case -3: 
#line 619
  outOfMemory();
  case -7: 
#line 621
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file ends unexpectedly\n");
#line 623
  return ((Bool )0);
  case -5: 
#line 625
  if ((unsigned long )zStream != (unsigned long )stdin) {
#line 625
    fclose(zStream);
  }
#line 626
  if (streamNo == 1) {
#line 627
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad magic number (file not created by bzip2)\n");
#line 629
    return ((Bool )0);
  } else {
#line 631
    if (noisy) {
#line 632
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trailing garbage after EOF ignored\n");
    }
#line 634
    return ((Bool )1);
  }
  default: 
#line 637
  panic("test:unexpected error");
  }
#line 640
  panic("test:end");
#line 641
  return ((Bool )1);
}
}
#line 650 "bzip2.c"
static void setExit(Int32 v ) 
{ 
  Int32 *__cil_gp_exitValue  = & exitValue;
  int __cil_tmp3 ;
  Int32 __cil_tmp4 ;

  {
  {
#line 653
  __cil_tmp4 = *__cil_gp_exitValue;
#line 653
  __cil_tmp3 = v > __cil_tmp4;
#line 653
  if (__cil_tmp3) {
    {
#line 653
    *__cil_gp_exitValue = v;
    }
  } else {

  }
  }
#line 654
  return;
}
}
#line 658 "bzip2.c"
static void cadvise(void) 
{ 
  Bool *__cil_gp_noisy  = & noisy;
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Bool __cil_tmp3 ;
  struct _IO_FILE *__cil_tmp4 ;

  {
  {
#line 661
  __cil_tmp3 = *__cil_gp_noisy;
#line 661
  if (__cil_tmp3) {
    {
#line 662
    __cil_tmp4 = *__cil_gp_stderr;
#line 662
    fprintf((FILE */* __restrict  */)__cil_tmp4, (char const   */* __restrict  */)"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n");
    }
  } else {

  }
  }
#line 669
  return;
}
}
#line 673 "bzip2.c"
static void showFileNames(void) 
{ 
  Bool *__cil_gp_noisy  = & noisy;
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Bool __cil_tmp3 ;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;
  Char *__cil_tmp6 ;

  {
  {
#line 676
  __cil_tmp3 = *__cil_gp_noisy;
#line 676
  if (__cil_tmp3) {
    {
#line 677
    __cil_tmp4 = *__cil_gp_stderr;
#line 677
    __cil_tmp5 = inName;
#line 677
    __cil_tmp6 = outName;
#line 677
    fprintf((FILE */* __restrict  */)__cil_tmp4, (char const   */* __restrict  */)"\tInput file = %s, output file = %s\n",
            __cil_tmp5, __cil_tmp6);
    }
  } else {

  }
  }
#line 682
  return;
}
}
#line 686
static  __attribute__((__noreturn__)) void cleanUpAndFail(Int32 ec ) ;
#line 686 "bzip2.c"
static void cleanUpAndFail(Int32 ec ) 
{ 
  struct stat statBuf ;
  struct stat *__cil_pp_statBuf  = & statBuf;
  Int32 *__cil_gp_srcMode  = & srcMode;
  Int32 *__cil_gp_opMode  = & opMode;
  Bool *__cil_gp_deleteOutputOnInterrupt  = & deleteOutputOnInterrupt;
  Bool *__cil_gp_noisy  = & noisy;
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  FILE **__cil_gp_outputHandleJustInCase  = & outputHandleJustInCase;
  Int32 *__cil_gp_numFileNames  = & numFileNames;
  Int32 *__cil_gp_numFilesProcessed  = & numFilesProcessed;
  Int32 *__cil_gp_exitValue  = & exitValue;
  IntNative retVal_ssa_1 ;
  IntNative retVal_ssa_2 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  Bool __cil_tmp19 ;
  int __cil_tmp20 ;
  Bool __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  Bool __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  Int32 __cil_tmp27 ;
  Int32 __cil_tmp28 ;
  Char *__cil_tmp29 ;
  struct _IO_FILE *__cil_tmp30 ;
  Char *__cil_tmp31 ;
  Char *__cil_tmp32 ;
  FILE *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  FILE *__cil_tmp35 ;
  Char *__cil_tmp36 ;
  struct _IO_FILE *__cil_tmp37 ;
  Char *__cil_tmp38 ;
  struct _IO_FILE *__cil_tmp39 ;
  Char *__cil_tmp40 ;
  struct _IO_FILE *__cil_tmp41 ;
  Char *__cil_tmp42 ;
  struct _IO_FILE *__cil_tmp43 ;
  Char *__cil_tmp44 ;
  Char *__cil_tmp45 ;
  struct _IO_FILE *__cil_tmp46 ;
  Char *__cil_tmp47 ;
  Int32 __cil_tmp48 ;
  Int32 __cil_tmp49 ;
  Int32 __cil_tmp50 ;
  struct _IO_FILE *__cil_tmp51 ;
  Int32 __cil_tmp52 ;
  Int32 __cil_tmp53 ;
  Char *__cil_tmp54 ;
  Char *__cil_tmp55 ;
  Int32 __cil_tmp56 ;
  Int32 __cil_tmp57 ;
  Int32 __cil_tmp58 ;

  {
  {
#line 692
  __cil_tmp27 = *__cil_gp_srcMode;
#line 692
  __cil_tmp17 = __cil_tmp27 == 3;
#line 692
  if (__cil_tmp17) {
    {
#line 692
    __cil_tmp28 = *__cil_gp_opMode;
#line 692
    __cil_tmp18 = __cil_tmp28 != 3;
#line 692
    if (__cil_tmp18) {
      {
#line 692
      __cil_tmp19 = *__cil_gp_deleteOutputOnInterrupt;
#line 692
      if (__cil_tmp19) {
        {
#line 701
        __cil_tmp29 = inName;
#line 701
        retVal_ssa_1 = stat((char const   */* __restrict  */)__cil_tmp29, (struct stat */* __restrict  */)__cil_pp_statBuf);
        }
        {
#line 702
        __cil_tmp20 = retVal_ssa_1 == 0;
#line 702
        if (__cil_tmp20) {
          {
#line 703
          __cil_tmp21 = *__cil_gp_noisy;
#line 703
          if (__cil_tmp21) {
            {
#line 704
            __cil_tmp30 = *__cil_gp_stderr;
#line 704
            __cil_tmp31 = *__cil_gp_progName;
#line 704
            __cil_tmp32 = outName;
#line 704
            fprintf((FILE */* __restrict  */)__cil_tmp30, (char const   */* __restrict  */)"%s: Deleting output file %s, if it exists.\n",
                    __cil_tmp31, __cil_tmp32);
            }
          } else {

          }
          }
          {
#line 707
          __cil_tmp33 = *__cil_gp_outputHandleJustInCase;
#line 707
          __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 707
          __cil_tmp22 = __cil_tmp34 != (unsigned long )((void *)0);
#line 707
          if (__cil_tmp22) {
            {
#line 708
            __cil_tmp35 = *__cil_gp_outputHandleJustInCase;
#line 708
            fclose(__cil_tmp35);
            }
          } else {

          }
          }
          {
#line 709
          __cil_tmp36 = outName;
#line 709
          retVal_ssa_2 = remove((char const   *)__cil_tmp36);
          }
          {
#line 710
          __cil_tmp23 = retVal_ssa_2 != 0;
#line 710
          if (__cil_tmp23) {
            {
#line 711
            __cil_tmp37 = *__cil_gp_stderr;
#line 711
            __cil_tmp38 = *__cil_gp_progName;
#line 711
            fprintf((FILE */* __restrict  */)__cil_tmp37, (char const   */* __restrict  */)"%s: WARNING: deletion of output file (apparently) failed.\n",
                    __cil_tmp38);
            }
          } else {

          }
          }
        } else {
          {
#line 716
          __cil_tmp39 = *__cil_gp_stderr;
#line 716
          __cil_tmp40 = *__cil_gp_progName;
#line 716
          fprintf((FILE */* __restrict  */)__cil_tmp39, (char const   */* __restrict  */)"%s: WARNING: deletion of output file suppressed\n",
                  __cil_tmp40);
#line 719
          __cil_tmp41 = *__cil_gp_stderr;
#line 719
          __cil_tmp42 = *__cil_gp_progName;
#line 719
          fprintf((FILE */* __restrict  */)__cil_tmp41, (char const   */* __restrict  */)"%s:    since input file no longer exists.  Output file\n",
                  __cil_tmp42);
#line 722
          __cil_tmp43 = *__cil_gp_stderr;
#line 722
          __cil_tmp44 = *__cil_gp_progName;
#line 722
          __cil_tmp45 = outName;
#line 722
          fprintf((FILE */* __restrict  */)__cil_tmp43, (char const   */* __restrict  */)"%s:    `%s\' may be incomplete.\n",
                  __cil_tmp44, __cil_tmp45);
#line 725
          __cil_tmp46 = *__cil_gp_stderr;
#line 725
          __cil_tmp47 = *__cil_gp_progName;
#line 725
          fprintf((FILE */* __restrict  */)__cil_tmp46, (char const   */* __restrict  */)"%s:    I suggest doing an integrity test (bzip2 -tv) of it.\n",
                  __cil_tmp47);
          }
        }
        }
      } else {

      }
      }
    } else {

    }
    }
  } else {

  }
  }
  {
#line 732
  __cil_tmp24 = *__cil_gp_noisy;
#line 732
  if (__cil_tmp24) {
    {
#line 732
    __cil_tmp48 = *__cil_gp_numFileNames;
#line 732
    __cil_tmp25 = __cil_tmp48 > 0;
#line 732
    if (__cil_tmp25) {
      {
#line 732
      __cil_tmp49 = *__cil_gp_numFilesProcessed;
#line 732
      __cil_tmp50 = *__cil_gp_numFileNames;
#line 732
      __cil_tmp26 = __cil_tmp49 < __cil_tmp50;
#line 732
      if (__cil_tmp26) {
        {
#line 733
        __cil_tmp51 = *__cil_gp_stderr;
#line 733
        __cil_tmp52 = *__cil_gp_numFileNames;
#line 733
        __cil_tmp53 = *__cil_gp_numFilesProcessed;
#line 733
        __cil_tmp54 = *__cil_gp_progName;
#line 733
        __cil_tmp55 = *__cil_gp_progName;
#line 733
        __cil_tmp56 = *__cil_gp_numFileNames;
#line 733
        __cil_tmp57 = __cil_tmp52 - __cil_tmp53;
#line 733
        fprintf((FILE */* __restrict  */)__cil_tmp51, (char const   */* __restrict  */)"%s: WARNING: some files have not been processed:\n%s:    %d specified on command line, %d not processed yet.\n\n",
                __cil_tmp54, __cil_tmp55, __cil_tmp56, __cil_tmp57);
        }
      } else {

      }
      }
    } else {

    }
    }
  } else {

  }
  }
  {
#line 739
  setExit(ec);
#line 740
  __cil_tmp58 = *__cil_gp_exitValue;
#line 740
  exit(__cil_tmp58);
  }
}
}
#line 745
static  __attribute__((__noreturn__)) void panic(Char const   *s ) ;
#line 745 "bzip2.c"
static void panic(Char const   *s ) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
  {
#line 748
  __cil_tmp4 = *__cil_gp_stderr;
#line 748
  __cil_tmp5 = *__cil_gp_progName;
#line 748
  fprintf((FILE */* __restrict  */)__cil_tmp4, (char const   */* __restrict  */)"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to me at:\n\tjseward@bzip.org\n",
          __cil_tmp5, s);
#line 754
  showFileNames();
#line 755
  cleanUpAndFail(3);
  }
}
}
#line 760
static  __attribute__((__noreturn__)) void crcError(void) ;
#line 760 "bzip2.c"
static void crcError(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  struct _IO_FILE *__cil_tmp3 ;
  Char *__cil_tmp4 ;

  {
  {
#line 763
  __cil_tmp3 = *__cil_gp_stderr;
#line 763
  __cil_tmp4 = *__cil_gp_progName;
#line 763
  fprintf((FILE */* __restrict  */)__cil_tmp3, (char const   */* __restrict  */)"\n%s: Data integrity error when decompressing.\n",
          __cil_tmp4);
#line 766
  showFileNames();
#line 767
  cadvise();
#line 768
  cleanUpAndFail(2);
  }
}
}
#line 773
static  __attribute__((__noreturn__)) void compressedStreamEOF(void) ;
#line 773 "bzip2.c"
static void compressedStreamEOF(void) 
{ 
  Bool *__cil_gp_noisy  = & noisy;
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  Bool __cil_tmp4 ;
  struct _IO_FILE *__cil_tmp5 ;
  Char *__cil_tmp6 ;
  Char *__cil_tmp7 ;

  {
  {
#line 776
  __cil_tmp4 = *__cil_gp_noisy;
#line 776
  if (__cil_tmp4) {
    {
#line 777
    __cil_tmp5 = *__cil_gp_stderr;
#line 777
    __cil_tmp6 = *__cil_gp_progName;
#line 777
    fprintf((FILE */* __restrict  */)__cil_tmp5, (char const   */* __restrict  */)"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
            __cil_tmp6);
#line 781
    __cil_tmp7 = *__cil_gp_progName;
#line 781
    perror((char const   *)__cil_tmp7);
#line 782
    showFileNames();
#line 783
    cadvise();
    }
  } else {

  }
  }
  {
#line 785
  cleanUpAndFail(2);
  }
}
}
#line 790
static  __attribute__((__noreturn__)) void ioError(void) ;
#line 790 "bzip2.c"
static void ioError(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  struct _IO_FILE *__cil_tmp3 ;
  Char *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
  {
#line 793
  __cil_tmp3 = *__cil_gp_stderr;
#line 793
  __cil_tmp4 = *__cil_gp_progName;
#line 793
  fprintf((FILE */* __restrict  */)__cil_tmp3, (char const   */* __restrict  */)"\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          __cil_tmp4);
#line 797
  __cil_tmp5 = *__cil_gp_progName;
#line 797
  perror((char const   *)__cil_tmp5);
#line 798
  showFileNames();
#line 799
  cleanUpAndFail(1);
  }
}
}
#line 804 "bzip2.c"
static void mySignalCatcher(IntNative n ) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
  {
#line 807
  __cil_tmp4 = *__cil_gp_stderr;
#line 807
  __cil_tmp5 = *__cil_gp_progName;
#line 807
  fprintf((FILE */* __restrict  */)__cil_tmp4, (char const   */* __restrict  */)"\n%s: Control-C or similar caught, quitting.\n",
          __cil_tmp5);
#line 810
  cleanUpAndFail(1);
  }
}
}
#line 815 "bzip2.c"
static void mySIGSEGVorSIGBUScatcher(IntNative n ) 
{ 
  Int32 *__cil_gp_opMode  = & opMode;
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  struct _IO_FILE *__cil_tmp8 ;
  Char *__cil_tmp9 ;
  struct _IO_FILE *__cil_tmp10 ;
  Char *__cil_tmp11 ;
  Int32 __cil_tmp12 ;

  {
  {
#line 818
  __cil_tmp7 = *__cil_gp_opMode;
#line 818
  __cil_tmp5 = __cil_tmp7 == 1;
#line 818
  if (__cil_tmp5) {
    {
#line 819
    __cil_tmp8 = *__cil_gp_stderr;
#line 819
    __cil_tmp9 = *__cil_gp_progName;
#line 819
    fprintf((FILE */* __restrict  */)__cil_tmp8, (char const   */* __restrict  */)"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing.\n\n   Possible causes are (most likely first):\n   (1) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (2) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (3) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (1) and (2).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (1)\n   or (2), feel free to report it to me at: jseward@bzip.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n",
            __cil_tmp9);
    }
  } else {
    {
#line 840
    __cil_tmp10 = *__cil_gp_stderr;
#line 840
    __cil_tmp11 = *__cil_gp_progName;
#line 840
    fprintf((FILE */* __restrict  */)__cil_tmp10, (char const   */* __restrict  */)"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing.\n\n   Possible causes are (most likely first):\n   (1) The compressed data is corrupted, and bzip2\'s usual checks\n       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n   (2) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (3) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (4) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (2) and (3).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (2)\n   or (3), feel free to report it to me at: jseward@bzip.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n",
            __cil_tmp11);
    }
  }
  }
  {
#line 863
  showFileNames();
  }
  {
#line 864
  __cil_tmp12 = *__cil_gp_opMode;
#line 864
  __cil_tmp6 = __cil_tmp12 == 1;
#line 864
  if (__cil_tmp6) {
    {
#line 865
    cleanUpAndFail(3);
    }
  } else {
    {
#line 866
    cadvise();
#line 866
    cleanUpAndFail(2);
    }
  }
  }
}
}
#line 871
static  __attribute__((__noreturn__)) void outOfMemory(void) ;
#line 871 "bzip2.c"
static void outOfMemory(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  struct _IO_FILE *__cil_tmp3 ;
  Char *__cil_tmp4 ;

  {
  {
#line 874
  __cil_tmp3 = *__cil_gp_stderr;
#line 874
  __cil_tmp4 = *__cil_gp_progName;
#line 874
  fprintf((FILE */* __restrict  */)__cil_tmp3, (char const   */* __restrict  */)"\n%s: couldn\'t allocate enough memory\n",
          __cil_tmp4);
#line 877
  showFileNames();
#line 878
  cleanUpAndFail(1);
  }
}
}
#line 883
static  __attribute__((__noreturn__)) void configError(void) ;
#line 883 "bzip2.c"
static void configError(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Int32 *__cil_gp_exitValue  = & exitValue;
  struct _IO_FILE *__cil_tmp3 ;
  Int32 __cil_tmp4 ;

  {
  {
#line 886
  __cil_tmp3 = *__cil_gp_stderr;
#line 886
  fprintf((FILE */* __restrict  */)__cil_tmp3, (char const   */* __restrict  */)"bzip2: I\'m not configured correctly for this platform!\n\tI require Int32, Int16 and Char to have sizes\n\tof 4, 2 and 1 bytes to run properly, and they don\'t.\n\tProbably you can fix this by defining them correctly,\n\tand recompiling.  Bye!\n");
#line 892
  setExit(3);
#line 893
  __cil_tmp4 = *__cil_gp_exitValue;
#line 893
  exit(__cil_tmp4);
  }
}
}
#line 907 "bzip2.c"
static void pad(Char *s ) 
{ 
  Int32 *__cil_gp_longestFileName  = & longestFileName;
  size_t tmp_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp8 ;
  Int32 __cil_tmp9 ;

  {
  {
#line 911
  tmp_ssa_1 = strlen((char const   *)s);
  }
  {
#line 911
  __cil_tmp9 = *__cil_gp_longestFileName;
#line 911
  __cil_tmp8 = (Int32 )tmp_ssa_1 >= __cil_tmp9;
#line 911
  if (__cil_tmp8) {
#line 911
    return;
  } else {
    {
#line 912
    i_ssa_1 = 1;
    }
    {
#line 912
    pad_cil_lr_1(s, i_ssa_1);
    }
#line 914
    return;
  }
  }
}
}
#line 918 "bzip2.c"
static void copyFileName(Char *to , Char *from ) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Int32 *__cil_gp_exitValue  = & exitValue;
  size_t tmp_ssa_1 ;
  int __cil_tmp7 ;
  struct _IO_FILE *__cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Char *__cil_tmp10 ;

  {
  {
#line 921
  tmp_ssa_1 = strlen((char const   *)from);
  }
  {
#line 921
  __cil_tmp7 = tmp_ssa_1 > 1024UL;
#line 921
  if (__cil_tmp7) {
    {
#line 922
    __cil_tmp8 = *__cil_gp_stderr;
#line 922
    fprintf((FILE */* __restrict  */)__cil_tmp8, (char const   */* __restrict  */)"bzip2: file name\n`%s\'\nis suspiciously (more than %d chars) long.\nTry using a reasonable file name instead.  Sorry! :-)\n",
            from, 1024);
#line 929
    setExit(1);
#line 930
    __cil_tmp9 = *__cil_gp_exitValue;
#line 930
    exit(__cil_tmp9);
    }
  } else {

  }
  }
  {
#line 933
  strncpy((char */* __restrict  */)to, (char const   */* __restrict  */)from, (size_t )1024);
#line 934
  __cil_tmp10 = to + 1024;
#line 934
  *__cil_tmp10 = (Char )'\000';
  }
#line 935
  return;
}
}
#line 939 "bzip2.c"
static Bool fileExists(Char *name ) 
{ 
  FILE *tmp___0_ssa_1 ;
  FILE *tmp_ssa_1 ;
  Bool exists_ssa_1 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 942
  tmp___0_ssa_1 = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
#line 942
  tmp_ssa_1 = tmp___0_ssa_1;
#line 943
  __cil_tmp9 = (unsigned long )tmp_ssa_1 != (unsigned long )((void *)0);
#line 943
  exists_ssa_1 = (Bool )__cil_tmp9;
  }
  {
#line 944
  __cil_tmp8 = (unsigned long )tmp_ssa_1 != (unsigned long )((void *)0);
#line 944
  if (__cil_tmp8) {
    {
#line 944
    fclose(tmp_ssa_1);
    }
  } else {

  }
  }
#line 945
  return (exists_ssa_1);
}
}
#line 959 "bzip2.c"
static FILE *fopen_output_safely(Char *name , char const   *mode ) 
{ 
  FILE *fp ;
  IntNative fh_ssa_1 ;
  FILE *fp_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 965
  fh_ssa_1 = open((char const   *)name, 193, 384);
  }
  {
#line 966
  __cil_tmp7 = fh_ssa_1 == -1;
#line 966
  if (__cil_tmp7) {
#line 966
    return ((FILE *)0);
  } else {
    {
#line 967
    fp_ssa_1 = fdopen(fh_ssa_1, mode);
    }
    {
#line 968
    __cil_tmp8 = (unsigned long )fp_ssa_1 == (unsigned long )((void *)0);
#line 968
    if (__cil_tmp8) {
      {
#line 968
      close(fh_ssa_1);
      }
    } else {

    }
    }
#line 969
    return (fp_ssa_1);
  }
  }
#line 969
  return (fp);
}
}
#line 980 "bzip2.c"
static Bool notAStandardFile(Char *name ) 
{ 
  struct stat statBuf ;
  struct stat *__cil_pp_statBuf  = & statBuf;
  IntNative i_ssa_1 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  __mode_t *__cil_tmp9 ;
  __mode_t __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
  {
#line 986
  i_ssa_1 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)__cil_pp_statBuf);
  }
  {
#line 987
  __cil_tmp6 = i_ssa_1 != 0;
#line 987
  if (__cil_tmp6) {
#line 987
    return ((Bool )1);
  } else {
    {
#line 988
    __cil_tmp8 = (unsigned char *)__cil_pp_statBuf + 24;
#line 988
    __cil_tmp9 = (__mode_t *)__cil_tmp8;
#line 988
    __cil_tmp10 = *__cil_tmp9;
#line 988
    __cil_tmp11 = __cil_tmp10 & 61440U;
#line 988
    __cil_tmp7 = __cil_tmp11 == 32768U;
#line 988
    if (__cil_tmp7) {
#line 988
      return ((Bool )0);
    } else {
#line 989
      return ((Bool )1);
    }
    }
  }
  }
}
}
#line 997 "bzip2.c"
static Int32 countHardLinks(Char *name ) 
{ 
  struct stat statBuf ;
  struct stat *__cil_pp_statBuf  = & statBuf;
  IntNative i_ssa_1 ;
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  __nlink_t *__cil_tmp9 ;
  __nlink_t __cil_tmp10 ;
  __nlink_t __cil_tmp11 ;

  {
  {
#line 1003
  i_ssa_1 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)__cil_pp_statBuf);
  }
  {
#line 1004
  __cil_tmp6 = i_ssa_1 != 0;
#line 1004
  if (__cil_tmp6) {
#line 1004
    return (0);
  } else {
    {
#line 1005
    __cil_tmp8 = (unsigned char *)__cil_pp_statBuf + 16;
#line 1005
    __cil_tmp9 = (__nlink_t *)__cil_tmp8;
#line 1005
    __cil_tmp10 = *__cil_tmp9;
#line 1005
    __cil_tmp11 = __cil_tmp10 - 1UL;
#line 1005
    __cil_tmp7 = (Int32 )__cil_tmp11;
#line 1005
    return (__cil_tmp7);
    }
  }
  }
}
}
#line 1037 "bzip2.c"
static void saveInputFileMetaInfo(Char *srcName ) 
{ 
  struct stat *__cil_pp_fileMetaInfo  = & fileMetaInfo;
  IntNative retVal_ssa_1 ;
  int __cil_tmp5 ;

  {
  {
#line 1043
  retVal_ssa_1 = stat((char const   */* __restrict  */)srcName, (struct stat */* __restrict  */)__cil_pp_fileMetaInfo);
  }
  {
#line 1044
  __cil_tmp5 = retVal_ssa_1 != 0;
#line 1044
  if (__cil_tmp5) {
    {
#line 1044
    ioError();
    }
  } else {

  }
  }
#line 1046
  return;
}
}
#line 1049 "bzip2.c"
static void applySavedTimeInfoToOutputFile(Char *dstName ) 
{ 
  struct utimbuf uTimBuf ;
  struct utimbuf *__cil_pp_uTimBuf  = & uTimBuf;
  struct stat *__cil_pp_fileMetaInfo  = & fileMetaInfo;
  IntNative retVal_ssa_1 ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  __time_t *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  __time_t *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  __time_t *__cil_tmp13 ;

  {
  {
#line 1056
  __cil_tmp8 = (unsigned char *)__cil_pp_fileMetaInfo + 72;
#line 1056
  __cil_tmp9 = (__time_t *)__cil_tmp8;
#line 1056
  *((__time_t *)__cil_pp_uTimBuf) = *__cil_tmp9;
#line 1057
  __cil_tmp10 = (unsigned char *)__cil_pp_fileMetaInfo + 88;
#line 1057
  __cil_tmp11 = (__time_t *)__cil_tmp10;
#line 1057
  __cil_tmp12 = (unsigned char *)__cil_pp_uTimBuf + 8;
#line 1057
  __cil_tmp13 = (__time_t *)__cil_tmp12;
#line 1057
  *__cil_tmp13 = *__cil_tmp11;
#line 1059
  retVal_ssa_1 = utime((char const   *)dstName, (struct utimbuf  const  *)__cil_pp_uTimBuf);
  }
  {
#line 1060
  __cil_tmp7 = retVal_ssa_1 != 0;
#line 1060
  if (__cil_tmp7) {
    {
#line 1060
    ioError();
    }
  } else {

  }
  }
#line 1062
  return;
}
}
#line 1064 "bzip2.c"
static void applySavedFileAttrToOutputFile(IntNative fd ) 
{ 
  struct stat *__cil_pp_fileMetaInfo  = & fileMetaInfo;
  IntNative retVal_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  __mode_t *__cil_tmp7 ;
  __mode_t __cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  __uid_t *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  __gid_t *__cil_tmp12 ;
  __uid_t __cil_tmp13 ;
  __gid_t __cil_tmp14 ;

  {
  {
#line 1070
  __cil_tmp6 = (unsigned char *)__cil_pp_fileMetaInfo + 24;
#line 1070
  __cil_tmp7 = (__mode_t *)__cil_tmp6;
#line 1070
  __cil_tmp8 = *__cil_tmp7;
#line 1070
  retVal_ssa_1 = fchmod(fd, __cil_tmp8);
  }
  {
#line 1071
  __cil_tmp5 = retVal_ssa_1 != 0;
#line 1071
  if (__cil_tmp5) {
    {
#line 1071
    ioError();
    }
  } else {

  }
  }
  {
#line 1073
  __cil_tmp9 = (unsigned char *)__cil_pp_fileMetaInfo + 28;
#line 1073
  __cil_tmp10 = (__uid_t *)__cil_tmp9;
#line 1073
  __cil_tmp11 = (unsigned char *)__cil_pp_fileMetaInfo + 32;
#line 1073
  __cil_tmp12 = (__gid_t *)__cil_tmp11;
#line 1073
  __cil_tmp13 = *__cil_tmp10;
#line 1073
  __cil_tmp14 = *__cil_tmp12;
#line 1073
  fchown(fd, __cil_tmp13, __cil_tmp14);
  }
#line 1078
  return;
}
}
#line 1082 "bzip2.c"
static Bool containsDubiousChars(Char *name ) 
{ 


  {
#line 1089
  return ((Bool )0);
}
}
#line 1109 "bzip2.c"
static Bool hasSuffix(Char *s , Char const   *suffix ) 
{ 
  size_t tmp_ssa_1 ;
  Int32 ns_ssa_1 ;
  size_t tmp___0_ssa_1 ;
  Int32 nx_ssa_1 ;
  int tmp___1_ssa_1 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  Char *__cil_tmp15 ;
  Char *__cil_tmp16 ;

  {
  {
#line 1112
  tmp_ssa_1 = strlen((char const   *)s);
#line 1112
  ns_ssa_1 = (Int32 )tmp_ssa_1;
#line 1113
  tmp___0_ssa_1 = strlen(suffix);
#line 1113
  nx_ssa_1 = (Int32 )tmp___0_ssa_1;
  }
  {
#line 1114
  __cil_tmp13 = ns_ssa_1 < nx_ssa_1;
#line 1114
  if (__cil_tmp13) {
#line 1114
    return ((Bool )0);
  } else {
    {
#line 1115
    __cil_tmp15 = s + ns_ssa_1;
#line 1115
    __cil_tmp16 = __cil_tmp15 - nx_ssa_1;
#line 1115
    tmp___1_ssa_1 = strcmp((char const   *)__cil_tmp16, suffix);
    }
    {
#line 1115
    __cil_tmp14 = tmp___1_ssa_1 == 0;
#line 1115
    if (__cil_tmp14) {
#line 1115
      return ((Bool )1);
    } else {
#line 1116
      return ((Bool )0);
    }
    }
  }
  }
}
}
#line 1119 "bzip2.c"
static Bool mapSuffix(Char *name , Char const   *oldSuffix , Char const   *newSuffix ) 
{ 
  Bool tmp_ssa_1 ;
  size_t tmp___0_ssa_1 ;
  size_t tmp___1_ssa_1 ;
  size_t __cil_tmp10 ;
  Char *__cil_tmp11 ;

  {
  {
#line 1124
  tmp_ssa_1 = hasSuffix(name, oldSuffix);
  }
#line 1124
  if (tmp_ssa_1) {
    {
#line 1125
    tmp___0_ssa_1 = strlen((char const   *)name);
#line 1125
    tmp___1_ssa_1 = strlen(oldSuffix);
#line 1125
    __cil_tmp10 = tmp___0_ssa_1 - tmp___1_ssa_1;
#line 1125
    __cil_tmp11 = name + __cil_tmp10;
#line 1125
    *__cil_tmp11 = (Char )0;
#line 1126
    strcat((char */* __restrict  */)name, (char const   */* __restrict  */)newSuffix);
    }
#line 1127
    return ((Bool )1);
  } else {
#line 1124
    return ((Bool )0);
  }
}
}
#line 1132 "bzip2.c"
static void compress(Char *name ) 
{ 
  FILE *inStr ;
  FILE *outStr ;
  Int32 n ;
  Int32 i ;
  struct stat statBuf ;
  Bool tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  IntNative retVal ;
  int tmp___17 ;

  {
#line 1140
  deleteOutputOnInterrupt = (Bool )0;
#line 1142
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1142
    if (srcMode != 1) {
#line 1143
      panic("compress: bad modes\n");
    }
  }
#line 1145
  switch (srcMode) {
  case 1: 
#line 1147
  copyFileName(inName, (Char *)"(stdin)");
#line 1148
  copyFileName(outName, (Char *)"(stdout)");
#line 1149
  break;
  case 3: 
#line 1151
  copyFileName(inName, name);
#line 1152
  copyFileName(outName, name);
#line 1153
  strcat((char */* __restrict  */)(outName), (char const   */* __restrict  */)".bz2");
#line 1154
  break;
  case 2: 
#line 1156
  copyFileName(inName, name);
#line 1157
  copyFileName(outName, (Char *)"(stdout)");
#line 1158
  break;
  }
#line 1161
  if (srcMode != 1) {
#line 1161
    tmp = containsDubiousChars(inName);
#line 1161
    if (tmp) {
#line 1162
      if (noisy) {
#line 1163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: There are no files matching `%s\'.\n",
                progName, inName);
      }
#line 1165
      setExit(1);
#line 1166
      return;
    }
  }
#line 1168
  if (srcMode != 1) {
#line 1168
    tmp___2 = fileExists(inName);
#line 1168
    if (! tmp___2) {
#line 1169
      tmp___0 = __errno_location();
#line 1169
      tmp___1 = strerror(*tmp___0);
#line 1169
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
              progName, inName, tmp___1);
#line 1171
      setExit(1);
#line 1172
      return;
    }
  }
#line 1174
  i = 0;
#line 1174
  while (i < 4) {
#line 1175
    tmp___3 = hasSuffix(inName, zSuffix[i]);
#line 1175
    if (tmp___3) {
#line 1176
      if (noisy) {
#line 1177
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s already has %s suffix.\n",
                progName, inName, zSuffix[i]);
      }
#line 1180
      setExit(1);
#line 1181
      return;
    }
#line 1174
    i ++;
  }
#line 1184
  if (srcMode == 3) {
#line 1184
    goto _L;
  } else
#line 1184
  if (srcMode == 2) {
    _L: /* CIL Label */ 
#line 1185
    stat((char const   */* __restrict  */)(inName), (struct stat */* __restrict  */)(& statBuf));
#line 1186
    if ((statBuf.st_mode & 61440U) == 16384U) {
#line 1187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1190
      setExit(1);
#line 1191
      return;
    }
  }
#line 1194
  if (srcMode == 3) {
#line 1194
    if (! forceOverwrite) {
#line 1194
      tmp___4 = notAStandardFile(inName);
#line 1194
      if (tmp___4) {
#line 1195
        if (noisy) {
#line 1196
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is not a normal file.\n",
                  progName, inName);
        }
#line 1198
        setExit(1);
#line 1199
        return;
      }
    }
  }
#line 1201
  if (srcMode == 3) {
#line 1201
    tmp___5 = fileExists(outName);
#line 1201
    if (tmp___5) {
#line 1202
      if (forceOverwrite) {
#line 1203
        remove((char const   *)(outName));
      } else {
#line 1205
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Output file %s already exists.\n",
                progName, outName);
#line 1207
        setExit(1);
#line 1208
        return;
      }
    }
  }
#line 1211
  if (srcMode == 3) {
#line 1211
    if (! forceOverwrite) {
#line 1211
      n = countHardLinks(inName);
#line 1211
      if (n > 0) {
#line 1213
        if (n > 1) {
#line 1213
          tmp___6 = "s";
        } else {
#line 1213
          tmp___6 = "";
        }
#line 1213
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s has %d other link%s.\n",
                progName, inName, n, tmp___6);
#line 1215
        setExit(1);
#line 1216
        return;
      }
    }
  }
#line 1219
  if (srcMode == 3) {
#line 1222
    saveInputFileMetaInfo(inName);
  }
#line 1225
  switch (srcMode) {
  case 1: 
#line 1228
  inStr = stdin;
#line 1229
  outStr = stdout;
#line 1230
  tmp___7 = fileno(stdout);
#line 1230
  tmp___8 = isatty(tmp___7);
#line 1230
  if (tmp___8) {
#line 1231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t write compressed data to a terminal.\n",
            progName);
#line 1234
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1236
    setExit(1);
#line 1237
    return;
  }
#line 1239
  break;
  case 2: 
#line 1242
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1243
  outStr = stdout;
#line 1244
  tmp___9 = fileno(stdout);
#line 1244
  tmp___10 = isatty(tmp___9);
#line 1244
  if (tmp___10) {
#line 1245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t write compressed data to a terminal.\n",
            progName);
#line 1248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1250
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1250
      fclose(inStr);
    }
#line 1251
    setExit(1);
#line 1252
    return;
  }
#line 1254
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1255
    tmp___11 = __errno_location();
#line 1255
    tmp___12 = strerror(*tmp___11);
#line 1255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___12);
#line 1257
    setExit(1);
#line 1258
    return;
  }
#line 1260
  break;
  case 3: 
#line 1263
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1264
  outStr = fopen_output_safely(outName, "wb");
#line 1265
  if ((unsigned long )outStr == (unsigned long )((void *)0)) {
#line 1266
    tmp___13 = __errno_location();
#line 1266
    tmp___14 = strerror(*tmp___13);
#line 1266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t create output file %s: %s.\n",
            progName, outName, tmp___14);
#line 1268
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1268
      fclose(inStr);
    }
#line 1269
    setExit(1);
#line 1270
    return;
  }
#line 1272
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1273
    tmp___15 = __errno_location();
#line 1273
    tmp___16 = strerror(*tmp___15);
#line 1273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___16);
#line 1275
    if ((unsigned long )outStr != (unsigned long )((void *)0)) {
#line 1275
      fclose(outStr);
    }
#line 1276
    setExit(1);
#line 1277
    return;
  }
#line 1279
  break;
  default: 
#line 1282
  panic("compress: bad srcMode");
#line 1283
  break;
  }
#line 1286
  if (verbosity >= 1) {
#line 1287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: ",
            inName);
#line 1288
    pad(inName);
#line 1289
    fflush(stderr);
  }
#line 1293
  outputHandleJustInCase = outStr;
#line 1294
  deleteOutputOnInterrupt = (Bool )1;
#line 1295
  compressStream(inStr, outStr);
#line 1296
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1299
  if (srcMode == 3) {
#line 1300
    applySavedTimeInfoToOutputFile(outName);
#line 1301
    deleteOutputOnInterrupt = (Bool )0;
#line 1302
    if (! keepInputFiles) {
#line 1303
      tmp___17 = remove((char const   *)(inName));
#line 1303
      retVal = tmp___17;
#line 1304
      if (retVal != 0) {
#line 1304
        ioError();
      }
    }
  }
#line 1308
  deleteOutputOnInterrupt = (Bool )0;
#line 1309
  return;
}
}
#line 1313 "bzip2.c"
static void uncompress(Char *name ) 
{ 
  FILE *inStr ;
  FILE *outStr ;
  Int32 n ;
  Int32 i ;
  Bool magicNumberOK ;
  Bool cantGuess ;
  struct stat statBuf ;
  Bool tmp ;
  Bool tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  IntNative retVal ;
  int tmp___15 ;
  IntNative retVal___0 ;
  int tmp___16 ;

  {
#line 1323
  deleteOutputOnInterrupt = (Bool )0;
#line 1325
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1325
    if (srcMode != 1) {
#line 1326
      panic("uncompress: bad modes\n");
    }
  }
#line 1328
  cantGuess = (Bool )0;
#line 1329
  switch (srcMode) {
  case 1: 
#line 1331
  copyFileName(inName, (Char *)"(stdin)");
#line 1332
  copyFileName(outName, (Char *)"(stdout)");
#line 1333
  break;
  case 3: 
#line 1335
  copyFileName(inName, name);
#line 1336
  copyFileName(outName, name);
#line 1337
  i = 0;
#line 1337
  while (i < 4) {
#line 1338
    tmp = mapSuffix(outName, zSuffix[i], unzSuffix[i]);
#line 1338
    if (tmp) {
#line 1339
      goto zzz;
    }
#line 1337
    i ++;
  }
#line 1340
  cantGuess = (Bool )1;
#line 1341
  strcat((char */* __restrict  */)(outName), (char const   */* __restrict  */)".out");
#line 1342
  break;
  case 2: 
#line 1344
  copyFileName(inName, name);
#line 1345
  copyFileName(outName, (Char *)"(stdout)");
#line 1346
  break;
  }
  zzz: 
#line 1350
  if (srcMode != 1) {
#line 1350
    tmp___0 = containsDubiousChars(inName);
#line 1350
    if (tmp___0) {
#line 1351
      if (noisy) {
#line 1352
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: There are no files matching `%s\'.\n",
                progName, inName);
      }
#line 1354
      setExit(1);
#line 1355
      return;
    }
  }
#line 1357
  if (srcMode != 1) {
#line 1357
    tmp___3 = fileExists(inName);
#line 1357
    if (! tmp___3) {
#line 1358
      tmp___1 = __errno_location();
#line 1358
      tmp___2 = strerror(*tmp___1);
#line 1358
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
              progName, inName, tmp___2);
#line 1360
      setExit(1);
#line 1361
      return;
    }
  }
#line 1363
  if (srcMode == 3) {
#line 1363
    goto _L;
  } else
#line 1363
  if (srcMode == 2) {
    _L: /* CIL Label */ 
#line 1364
    stat((char const   */* __restrict  */)(inName), (struct stat */* __restrict  */)(& statBuf));
#line 1365
    if ((statBuf.st_mode & 61440U) == 16384U) {
#line 1366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1369
      setExit(1);
#line 1370
      return;
    }
  }
#line 1373
  if (srcMode == 3) {
#line 1373
    if (! forceOverwrite) {
#line 1373
      tmp___4 = notAStandardFile(inName);
#line 1373
      if (tmp___4) {
#line 1374
        if (noisy) {
#line 1375
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is not a normal file.\n",
                  progName, inName);
        }
#line 1377
        setExit(1);
#line 1378
        return;
      }
    }
  }
#line 1380
  if (cantGuess) {
#line 1381
    if (noisy) {
#line 1382
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t guess original name for %s -- using %s\n",
              progName, inName, outName);
    }
  }
#line 1387
  if (srcMode == 3) {
#line 1387
    tmp___5 = fileExists(outName);
#line 1387
    if (tmp___5) {
#line 1388
      if (forceOverwrite) {
#line 1389
        remove((char const   *)(outName));
      } else {
#line 1391
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Output file %s already exists.\n",
                progName, outName);
#line 1393
        setExit(1);
#line 1394
        return;
      }
    }
  }
#line 1397
  if (srcMode == 3) {
#line 1397
    if (! forceOverwrite) {
#line 1397
      n = countHardLinks(inName);
#line 1397
      if (n > 0) {
#line 1399
        if (n > 1) {
#line 1399
          tmp___6 = "s";
        } else {
#line 1399
          tmp___6 = "";
        }
#line 1399
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s has %d other link%s.\n",
                progName, inName, n, tmp___6);
#line 1401
        setExit(1);
#line 1402
        return;
      }
    }
  }
#line 1405
  if (srcMode == 3) {
#line 1408
    saveInputFileMetaInfo(inName);
  }
#line 1411
  switch (srcMode) {
  case 1: 
#line 1414
  inStr = stdin;
#line 1415
  outStr = stdout;
#line 1416
  tmp___7 = fileno(stdin);
#line 1416
  tmp___8 = isatty(tmp___7);
#line 1416
  if (tmp___8) {
#line 1417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t read compressed data from a terminal.\n",
            progName);
#line 1420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1422
    setExit(1);
#line 1423
    return;
  }
#line 1425
  break;
  case 2: 
#line 1428
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1429
  outStr = stdout;
#line 1430
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1431
    tmp___9 = __errno_location();
#line 1431
    tmp___10 = strerror(*tmp___9);
#line 1431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s:%s.\n",
            progName, inName, tmp___10);
#line 1433
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1433
      fclose(inStr);
    }
#line 1434
    setExit(1);
#line 1435
    return;
  }
#line 1437
  break;
  case 3: 
#line 1440
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1441
  outStr = fopen_output_safely(outName, "wb");
#line 1442
  if ((unsigned long )outStr == (unsigned long )((void *)0)) {
#line 1443
    tmp___11 = __errno_location();
#line 1443
    tmp___12 = strerror(*tmp___11);
#line 1443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t create output file %s: %s.\n",
            progName, outName, tmp___12);
#line 1445
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1445
      fclose(inStr);
    }
#line 1446
    setExit(1);
#line 1447
    return;
  }
#line 1449
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1450
    tmp___13 = __errno_location();
#line 1450
    tmp___14 = strerror(*tmp___13);
#line 1450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___14);
#line 1452
    if ((unsigned long )outStr != (unsigned long )((void *)0)) {
#line 1452
      fclose(outStr);
    }
#line 1453
    setExit(1);
#line 1454
    return;
  }
#line 1456
  break;
  default: 
#line 1459
  panic("uncompress: bad srcMode");
#line 1460
  break;
  }
#line 1463
  if (verbosity >= 1) {
#line 1464
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: ",
            inName);
#line 1465
    pad(inName);
#line 1466
    fflush(stderr);
  }
#line 1470
  outputHandleJustInCase = outStr;
#line 1471
  deleteOutputOnInterrupt = (Bool )1;
#line 1472
  magicNumberOK = uncompressStream(inStr, outStr);
#line 1473
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1476
  if (magicNumberOK) {
#line 1477
    if (srcMode == 3) {
#line 1478
      applySavedTimeInfoToOutputFile(outName);
#line 1479
      deleteOutputOnInterrupt = (Bool )0;
#line 1480
      if (! keepInputFiles) {
#line 1481
        tmp___15 = remove((char const   *)(inName));
#line 1481
        retVal = tmp___15;
#line 1482
        if (retVal != 0) {
#line 1482
          ioError();
        }
      }
    }
  } else {
#line 1486
    unzFailsExist = (Bool )1;
#line 1487
    deleteOutputOnInterrupt = (Bool )0;
#line 1488
    if (srcMode == 3) {
#line 1489
      tmp___16 = remove((char const   *)(outName));
#line 1489
      retVal___0 = tmp___16;
#line 1490
      if (retVal___0 != 0) {
#line 1490
        ioError();
      }
    }
  }
#line 1493
  deleteOutputOnInterrupt = (Bool )0;
#line 1495
  if (magicNumberOK) {
#line 1496
    if (verbosity >= 1) {
#line 1497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done\n");
    }
  } else {
#line 1499
    setExit(2);
#line 1500
    if (verbosity >= 1) {
#line 1501
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a bzip2 file.\n");
    } else {
#line 1502
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a bzip2 file.\n",
              progName, inName);
    }
  }
#line 1507
  return;
}
}
#line 1511 "bzip2.c"
static void testf(Char *name ) 
{ 
  FILE *inStr ;
  Bool allOK ;
  struct stat statBuf ;
  Bool tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 1518
  deleteOutputOnInterrupt = (Bool )0;
#line 1520
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1520
    if (srcMode != 1) {
#line 1521
      panic("testf: bad modes\n");
    }
  }
#line 1523
  copyFileName(outName, (Char *)"(none)");
#line 1524
  switch (srcMode) {
  case 1: 
#line 1525
  copyFileName(inName, (Char *)"(stdin)");
#line 1525
  break;
  case 3: 
#line 1526
  copyFileName(inName, name);
#line 1526
  break;
  case 2: 
#line 1527
  copyFileName(inName, name);
#line 1527
  break;
  }
#line 1530
  if (srcMode != 1) {
#line 1530
    tmp = containsDubiousChars(inName);
#line 1530
    if (tmp) {
#line 1531
      if (noisy) {
#line 1532
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: There are no files matching `%s\'.\n",
                progName, inName);
      }
#line 1534
      setExit(1);
#line 1535
      return;
    }
  }
#line 1537
  if (srcMode != 1) {
#line 1537
    tmp___2 = fileExists(inName);
#line 1537
    if (! tmp___2) {
#line 1538
      tmp___0 = __errno_location();
#line 1538
      tmp___1 = strerror(*tmp___0);
#line 1538
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input %s: %s.\n",
              progName, inName, tmp___1);
#line 1540
      setExit(1);
#line 1541
      return;
    }
  }
#line 1543
  if (srcMode != 1) {
#line 1544
    stat((char const   */* __restrict  */)(inName), (struct stat */* __restrict  */)(& statBuf));
#line 1545
    if ((statBuf.st_mode & 61440U) == 16384U) {
#line 1546
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1549
      setExit(1);
#line 1550
      return;
    }
  }
#line 1554
  switch (srcMode) {
  case 1: 
#line 1557
  tmp___3 = fileno(stdin);
#line 1557
  tmp___4 = isatty(tmp___3);
#line 1557
  if (tmp___4) {
#line 1558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: I won\'t read compressed data from a terminal.\n",
            progName);
#line 1561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1563
    setExit(1);
#line 1564
    return;
  }
#line 1566
  inStr = stdin;
#line 1567
  break;
  case 3: 
  case 2: 
#line 1570
  inStr = fopen((char const   */* __restrict  */)(inName), (char const   */* __restrict  */)"rb");
#line 1571
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1572
    tmp___5 = __errno_location();
#line 1572
    tmp___6 = strerror(*tmp___5);
#line 1572
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file %s:%s.\n",
            progName, inName, tmp___6);
#line 1574
    setExit(1);
#line 1575
    return;
  }
#line 1577
  break;
  default: 
#line 1580
  panic("testf: bad srcMode");
#line 1581
  break;
  }
#line 1584
  if (verbosity >= 1) {
#line 1585
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: ",
            inName);
#line 1586
    pad(inName);
#line 1587
    fflush(stderr);
  }
#line 1591
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1592
  allOK = testStream(inStr);
#line 1594
  if (allOK) {
#line 1594
    if (verbosity >= 1) {
#line 1594
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ok\n");
    }
  }
#line 1595
  if (! allOK) {
#line 1595
    testFailsExist = (Bool )1;
  }
#line 1596
  return;
}
}
#line 1600 "bzip2.c"
static void license(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  char const   *tmp_ssa_1 ;
  struct _IO_FILE *__cil_tmp4 ;

  {
  {
#line 1603
  tmp_ssa_1 = BZ2_bzlibVersion();
#line 1603
  __cil_tmp4 = *__cil_gp_stderr;
#line 1603
  fprintf((FILE */* __restrict  */)__cil_tmp4, (char const   */* __restrict  */)"bzip2, a block-sorting file compressor.  Version %s.\n   \n   Copyright (C) 1996-2010 by Julian Seward.\n   \n   This program is free software; you can redistribute it and/or modify\n   it under the terms set out in the LICENSE file, which is included\n   in the bzip2-1.0.6 source distribution.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   LICENSE file for more details.\n   \n",
          tmp_ssa_1);
  }
#line 1621
  return;
}
}
#line 1625 "bzip2.c"
static void usage(Char *fullProgName ) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  char const   *tmp_ssa_1 ;
  struct _IO_FILE *__cil_tmp5 ;

  {
  {
#line 1628
  tmp_ssa_1 = BZ2_bzlibVersion();
#line 1628
  __cil_tmp5 = *__cil_gp_stderr;
#line 1628
  fprintf((FILE */* __restrict  */)__cil_tmp5, (char const   */* __restrict  */)"bzip2, a block-sorting file compressor.  Version %s.\n\n   usage: %s [flags and input files in any order]\n\n   -h --help           print this message\n   -d --decompress     force decompression\n   -z --compress       force compression\n   -k --keep           keep (don\'t delete) input files\n   -f --force          overwrite existing output files\n   -t --test           test compressed file integrity\n   -c --stdout         output to standard out\n   -q --quiet          suppress noncritical error messages\n   -v --verbose        be verbose (a 2nd -v gives more)\n   -L --license        display software version & license\n   -V --version        display software version & license\n   -s --small          use less memory (at most 2500k)\n   -1 .. -9            set block size to 100k .. 900k\n   --fast              alias for -1\n   --best              alias for -9\n\n   If invoked as `bzip2\', default action is to compress.\n              as `bunzip2\',  default action is to decompress.\n              as `bzcat\', default action is to decompress to stdout.\n\n   If no file names are given, bzip2 compresses or decompresses\n   from standard input to standard output.  You can combine\n   short flags, so `-v -4\' means the same as -v4 or -4v, &c.\n\n",
          tmp_ssa_1, fullProgName);
  }
#line 1665
  return;
}
}
#line 1669 "bzip2.c"
static void redundant(Char *flag ) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  Char **__cil_gp_progName  = & progName;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
  {
#line 1672
  __cil_tmp4 = *__cil_gp_stderr;
#line 1672
  __cil_tmp5 = *__cil_gp_progName;
#line 1672
  fprintf((FILE */* __restrict  */)__cil_tmp4, (char const   */* __restrict  */)"%s: %s is redundant in versions 0.9.5 and above\n",
          __cil_tmp5, flag);
  }
#line 1676
  return;
}
}
#line 1703 "bzip2.c"
static void *myMalloc(Int32 n ) 
{ 
  void *p_ssa_1 ;
  int __cil_tmp4 ;

  {
  {
#line 1708
  p_ssa_1 = malloc((size_t )n);
  }
  {
#line 1709
  __cil_tmp4 = (unsigned long )p_ssa_1 == (unsigned long )((void *)0);
#line 1709
  if (__cil_tmp4) {
    {
#line 1709
    outOfMemory();
    }
  } else {

  }
  }
#line 1710
  return (p_ssa_1);
}
}
#line 1715 "bzip2.c"
static Cell *mkCell(void) 
{ 
  void *tmp_ssa_1 ;
  Cell *c_ssa_1 ;
  unsigned char *__cil_tmp5 ;
  struct zzzz **__cil_tmp6 ;

  {
  {
#line 1720
  tmp_ssa_1 = myMalloc((Int32 )sizeof(Cell ));
#line 1720
  c_ssa_1 = (Cell *)tmp_ssa_1;
#line 1721
  *((Char **)c_ssa_1) = (Char *)0;
#line 1722
  __cil_tmp5 = (unsigned char *)c_ssa_1 + 8;
#line 1722
  __cil_tmp6 = (struct zzzz **)__cil_tmp5;
#line 1722
  *__cil_tmp6 = (struct zzzz *)0;
  }
#line 1723
  return (c_ssa_1);
}
}
#line 1728 "bzip2.c"
static Cell *snocString(Cell *root , Char *name ) 
{ 
  Cell *tmp___3 ;
  Cell **__cil_pp_root  = & root;
  Char **__cil_pp_name  = & name;
  Cell **__cil_pp_tmp___3  = & tmp___3;
  Cell **__cil_fp_root  = & root;
  Char **__cil_fp_name  = & name;
  Cell **__cil_fp_tmp___3  = & tmp___3;
  Cell *tmp___0_ssa_1 ;
  Cell *tmp_ssa_1 ;
  size_t tmp___1_ssa_1 ;
  void *tmp___2_ssa_1 ;
  Cell *tmp___3_ssa_1 ;
  Cell *root_ssa_1 ;
  Char *name_ssa_1 ;
  Cell *tmp___3_ssa_2 ;
  int __cil_tmp22 ;
  size_t __cil_tmp23 ;
  Char *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  struct zzzz **__cil_tmp26 ;
  struct zzzz *__cil_tmp27 ;

  {
  {
#line 1731
  __cil_tmp22 = (unsigned long )root == (unsigned long )((void *)0);
#line 1731
  if (__cil_tmp22) {
    {
#line 1732
    tmp___0_ssa_1 = mkCell();
#line 1732
    tmp_ssa_1 = tmp___0_ssa_1;
#line 1733
    tmp___1_ssa_1 = strlen((char const   *)name);
#line 1733
    __cil_tmp23 = 5UL + tmp___1_ssa_1;
#line 1733
    tmp___2_ssa_1 = myMalloc((Int32 )__cil_tmp23);
#line 1733
    *((Char **)tmp_ssa_1) = (Char *)tmp___2_ssa_1;
#line 1734
    __cil_tmp24 = *((Char **)tmp_ssa_1);
#line 1734
    strcpy((char */* __restrict  */)__cil_tmp24, (char const   */* __restrict  */)name);
    }
#line 1735
    return (tmp_ssa_1);
  } else {
    {
#line 1737
    tmp___3_ssa_1 = root;
    }
    {
    *__cil_fp_root = root;
    *__cil_fp_name = name;
    *__cil_fp_tmp___3 = tmp___3_ssa_1;
#line 1738
    snocString_cil_lr_1(__cil_pp_root, __cil_pp_name, __cil_pp_tmp___3);
    root_ssa_1 = *__cil_fp_root;
    name_ssa_1 = *__cil_fp_name;
    tmp___3_ssa_2 = *__cil_fp_tmp___3;
    }
    {
#line 1739
    __cil_tmp25 = (unsigned char *)tmp___3_ssa_2 + 8;
#line 1739
    __cil_tmp26 = (struct zzzz **)__cil_tmp25;
#line 1739
    __cil_tmp27 = *__cil_tmp26;
#line 1739
    *((struct zzzz **)((unsigned char *)tmp___3_ssa_2 + 8)) = snocString(__cil_tmp27,
                                                                         name_ssa_1);
    }
#line 1740
    return (root_ssa_1);
  }
  }
}
}
#line 1746 "bzip2.c"
static void addFlagsFromEnvVar(Cell **argList , Char *varName ) 
{ 
  Char *envbase_ssa_1 ;
  Char *p_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp13 ;

  {
  {
#line 1752
  envbase_ssa_1 = getenv((char const   *)varName);
  }
  {
#line 1753
  __cil_tmp13 = (unsigned long )envbase_ssa_1 != (unsigned long )((void *)0);
#line 1753
  if (__cil_tmp13) {
    {
#line 1754
    p_ssa_1 = envbase_ssa_1;
#line 1755
    i_ssa_1 = 0;
    }
    {
#line 1756
    addFlagsFromEnvVar_cil_lr_1(argList, i_ssa_1, p_ssa_1);
    }
  } else {

  }
  }
#line 1770
  return;
}
}
#line 1776 "bzip2.c"
IntNative main(IntNative argc , Char **argv ) 
{ 
  Int32 i ;
  Int32 j ;
  Char *tmp ;
  Cell *argList ;
  Cell *aa ;
  Bool decode ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  Cell *aa2 ;

  {
#line 1785
  if (sizeof(Int32 ) != 4UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(UInt32 ) != 4UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(Int16 ) != 2UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(UInt16 ) != 2UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(Char ) != 1UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(UChar ) != 1UL) {
#line 1788
    configError();
  }
#line 1791
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1792
  smallMode = (Bool )0;
#line 1793
  keepInputFiles = (Bool )0;
#line 1794
  forceOverwrite = (Bool )0;
#line 1795
  noisy = (Bool )1;
#line 1796
  verbosity = 0;
#line 1797
  blockSize100k = 9;
#line 1798
  testFailsExist = (Bool )0;
#line 1799
  unzFailsExist = (Bool )0;
#line 1800
  numFileNames = 0;
#line 1801
  numFilesProcessed = 0;
#line 1802
  workFactor = 30;
#line 1803
  deleteOutputOnInterrupt = (Bool )0;
#line 1804
  exitValue = 0;
#line 1805
  j = 0;
#line 1808
  signal(11, & mySIGSEGVorSIGBUScatcher);
#line 1811
  signal(7, & mySIGSEGVorSIGBUScatcher);
#line 1815
  copyFileName(inName, (Char *)"(none)");
#line 1816
  copyFileName(outName, (Char *)"(none)");
#line 1818
  copyFileName(progNameReally, *(argv + 0));
#line 1819
  progName = & progNameReally[0];
#line 1820
  tmp = & progNameReally[0];
#line 1820
  while ((int )*tmp != 0) {
#line 1821
    if ((int )*tmp == 47) {
#line 1821
      progName = tmp + 1;
    }
#line 1820
    tmp ++;
  }
#line 1827
  argList = (Cell *)((void *)0);
#line 1828
  addFlagsFromEnvVar(& argList, (Char *)"BZIP2");
#line 1829
  addFlagsFromEnvVar(& argList, (Char *)"BZIP");
#line 1830
  i = 1;
#line 1830
  while (i <= argc - 1) {
#line 1831
    argList = snocString(argList, *(argv + i));
#line 1830
    i ++;
  }
#line 1835
  longestFileName = 7;
#line 1836
  numFileNames = 0;
#line 1837
  decode = (Bool )1;
#line 1838
  aa = argList;
#line 1838
  while ((unsigned long )aa != (unsigned long )((void *)0)) {
#line 1839
    tmp___0 = strcmp((char const   *)aa->name, "--");
#line 1839
    if (tmp___0 == 0) {
#line 1839
      decode = (Bool )0;
#line 1839
      goto __Cont;
    }
#line 1840
    if ((int )*(aa->name + 0) == 45) {
#line 1840
      if (decode) {
#line 1840
        goto __Cont;
      }
    }
#line 1841
    numFileNames ++;
#line 1842
    tmp___2 = strlen((char const   *)aa->name);
#line 1842
    if (longestFileName < (Int32 )tmp___2) {
#line 1843
      tmp___1 = strlen((char const   *)aa->name);
#line 1843
      longestFileName = (Int32 )tmp___1;
    }
    __Cont: /* CIL Label */ 
#line 1838
    aa = aa->link;
  }
#line 1848
  if (numFileNames == 0) {
#line 1849
    srcMode = 1;
  } else {
#line 1849
    srcMode = 3;
  }
#line 1854
  opMode = 1;
#line 1856
  tmp___3 = strstr((char const   *)progName, "unzip");
#line 1856
  if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
#line 1858
    opMode = 2;
  } else {
#line 1856
    tmp___4 = strstr((char const   *)progName, "UNZIP");
#line 1856
    if ((unsigned long )tmp___4 != (unsigned long )((char *)0)) {
#line 1858
      opMode = 2;
    }
  }
#line 1860
  tmp___5 = strstr((char const   *)progName, "z2cat");
#line 1860
  if ((unsigned long )tmp___5 != (unsigned long )((char *)0)) {
#line 1860
    goto _L;
  } else {
#line 1860
    tmp___6 = strstr((char const   *)progName, "Z2CAT");
#line 1860
    if ((unsigned long )tmp___6 != (unsigned long )((char *)0)) {
#line 1860
      goto _L;
    } else {
#line 1860
      tmp___7 = strstr((char const   *)progName, "zcat");
#line 1860
      if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
#line 1860
        goto _L;
      } else {
#line 1860
        tmp___8 = strstr((char const   *)progName, "ZCAT");
#line 1860
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
          _L: /* CIL Label */ 
#line 1864
          opMode = 2;
#line 1865
          if (numFileNames == 0) {
#line 1865
            srcMode = 1;
          } else {
#line 1865
            srcMode = 2;
          }
        }
      }
    }
  }
#line 1870
  aa = argList;
#line 1870
  while ((unsigned long )aa != (unsigned long )((void *)0)) {
#line 1871
    tmp___9 = strcmp((char const   *)aa->name, "--");
#line 1871
    if (tmp___9 == 0) {
#line 1871
      break;
    }
#line 1872
    if ((int )*(aa->name + 0) == 45) {
#line 1872
      if ((int )*(aa->name + 1) != 45) {
#line 1873
        j = 1;
#line 1873
        while ((int )*(aa->name + j) != 0) {
#line 1874
          switch ((int )*(aa->name + j)) {
          case 99: 
#line 1875
          srcMode = 2;
#line 1875
          break;
          case 100: 
#line 1876
          opMode = 2;
#line 1876
          break;
          case 122: 
#line 1877
          opMode = 1;
#line 1877
          break;
          case 102: 
#line 1878
          forceOverwrite = (Bool )1;
#line 1878
          break;
          case 116: 
#line 1879
          opMode = 3;
#line 1879
          break;
          case 107: 
#line 1880
          keepInputFiles = (Bool )1;
#line 1880
          break;
          case 115: 
#line 1881
          smallMode = (Bool )1;
#line 1881
          break;
          case 113: 
#line 1882
          noisy = (Bool )0;
#line 1882
          break;
          case 49: 
#line 1883
          blockSize100k = 1;
#line 1883
          break;
          case 50: 
#line 1884
          blockSize100k = 2;
#line 1884
          break;
          case 51: 
#line 1885
          blockSize100k = 3;
#line 1885
          break;
          case 52: 
#line 1886
          blockSize100k = 4;
#line 1886
          break;
          case 53: 
#line 1887
          blockSize100k = 5;
#line 1887
          break;
          case 54: 
#line 1888
          blockSize100k = 6;
#line 1888
          break;
          case 55: 
#line 1889
          blockSize100k = 7;
#line 1889
          break;
          case 56: 
#line 1890
          blockSize100k = 8;
#line 1890
          break;
          case 57: 
#line 1891
          blockSize100k = 9;
#line 1891
          break;
          case 76: 
          case 86: 
#line 1893
          license();
#line 1893
          break;
          case 118: 
#line 1894
          verbosity ++;
#line 1894
          break;
          case 104: 
#line 1895
          usage(progName);
#line 1896
          exit(0);
#line 1897
          break;
          default: 
#line 1898
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Bad flag `%s\'\n",
                  progName, aa->name);
#line 1900
          usage(progName);
#line 1901
          exit(1);
#line 1902
          break;
          }
#line 1873
          j ++;
        }
      }
    }
#line 1870
    aa = aa->link;
  }
#line 1909
  aa = argList;
#line 1909
  while ((unsigned long )aa != (unsigned long )((void *)0)) {
#line 1910
    tmp___10 = strcmp((char const   *)aa->name, "--");
#line 1910
    if (tmp___10 == 0) {
#line 1910
      break;
    }
#line 1911
    tmp___28 = strcmp((char const   *)aa->name, "--stdout");
#line 1911
    if (tmp___28 == 0) {
#line 1911
      srcMode = 2;
    } else {
#line 1912
      tmp___27 = strcmp((char const   *)aa->name, "--decompress");
#line 1912
      if (tmp___27 == 0) {
#line 1912
        opMode = 2;
      } else {
#line 1913
        tmp___26 = strcmp((char const   *)aa->name, "--compress");
#line 1913
        if (tmp___26 == 0) {
#line 1913
          opMode = 1;
        } else {
#line 1914
          tmp___25 = strcmp((char const   *)aa->name, "--force");
#line 1914
          if (tmp___25 == 0) {
#line 1914
            forceOverwrite = (Bool )1;
          } else {
#line 1915
            tmp___24 = strcmp((char const   *)aa->name, "--test");
#line 1915
            if (tmp___24 == 0) {
#line 1915
              opMode = 3;
            } else {
#line 1916
              tmp___23 = strcmp((char const   *)aa->name, "--keep");
#line 1916
              if (tmp___23 == 0) {
#line 1916
                keepInputFiles = (Bool )1;
              } else {
#line 1917
                tmp___22 = strcmp((char const   *)aa->name, "--small");
#line 1917
                if (tmp___22 == 0) {
#line 1917
                  smallMode = (Bool )1;
                } else {
#line 1918
                  tmp___21 = strcmp((char const   *)aa->name, "--quiet");
#line 1918
                  if (tmp___21 == 0) {
#line 1918
                    noisy = (Bool )0;
                  } else {
#line 1919
                    tmp___20 = strcmp((char const   *)aa->name, "--version");
#line 1919
                    if (tmp___20 == 0) {
#line 1919
                      license();
                    } else {
#line 1920
                      tmp___19 = strcmp((char const   *)aa->name, "--license");
#line 1920
                      if (tmp___19 == 0) {
#line 1920
                        license();
                      } else {
#line 1921
                        tmp___18 = strcmp((char const   *)aa->name, "--exponential");
#line 1921
                        if (tmp___18 == 0) {
#line 1921
                          workFactor = 1;
                        } else {
#line 1922
                          tmp___17 = strcmp((char const   *)aa->name, "--repetitive-best");
#line 1922
                          if (tmp___17 == 0) {
#line 1922
                            redundant(aa->name);
                          } else {
#line 1923
                            tmp___16 = strcmp((char const   *)aa->name, "--repetitive-fast");
#line 1923
                            if (tmp___16 == 0) {
#line 1923
                              redundant(aa->name);
                            } else {
#line 1924
                              tmp___15 = strcmp((char const   *)aa->name, "--fast");
#line 1924
                              if (tmp___15 == 0) {
#line 1924
                                blockSize100k = 1;
                              } else {
#line 1925
                                tmp___14 = strcmp((char const   *)aa->name, "--best");
#line 1925
                                if (tmp___14 == 0) {
#line 1925
                                  blockSize100k = 9;
                                } else {
#line 1926
                                  tmp___13 = strcmp((char const   *)aa->name, "--verbose");
#line 1926
                                  if (tmp___13 == 0) {
#line 1926
                                    verbosity ++;
                                  } else {
#line 1927
                                    tmp___12 = strcmp((char const   *)aa->name, "--help");
#line 1927
                                    if (tmp___12 == 0) {
#line 1927
                                      usage(progName);
#line 1927
                                      exit(0);
                                    } else {
#line 1929
                                      tmp___11 = strncmp((char const   *)aa->name,
                                                         "--", (size_t )2);
#line 1929
                                      if (tmp___11 == 0) {
#line 1930
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Bad flag `%s\'\n",
                                                progName, aa->name);
#line 1931
                                        usage(progName);
#line 1932
                                        exit(1);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1909
    aa = aa->link;
  }
#line 1936
  if (verbosity > 4) {
#line 1936
    verbosity = 4;
  }
#line 1937
  if (opMode == 1) {
#line 1937
    if (smallMode) {
#line 1937
      if (blockSize100k > 2) {
#line 1938
        blockSize100k = 2;
      }
    }
  }
#line 1940
  if (opMode == 3) {
#line 1940
    if (srcMode == 2) {
#line 1941
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -c and -t cannot be used together.\n",
              progName);
#line 1943
      exit(1);
    }
  }
#line 1946
  if (srcMode == 2) {
#line 1946
    if (numFileNames == 0) {
#line 1947
      srcMode = 1;
    }
  }
#line 1949
  if (opMode != 1) {
#line 1949
    blockSize100k = 0;
  }
#line 1951
  if (srcMode == 3) {
#line 1952
    signal(2, & mySignalCatcher);
#line 1953
    signal(15, & mySignalCatcher);
#line 1955
    signal(1, & mySignalCatcher);
  }
#line 1959
  if (opMode == 1) {
#line 1960
    if (srcMode == 1) {
#line 1961
      compress((Char *)((void *)0));
    } else {
#line 1963
      decode = (Bool )1;
#line 1964
      aa = argList;
#line 1964
      while ((unsigned long )aa != (unsigned long )((void *)0)) {
#line 1965
        tmp___29 = strcmp((char const   *)aa->name, "--");
#line 1965
        if (tmp___29 == 0) {
#line 1965
          decode = (Bool )0;
#line 1965
          goto __Cont___0;
        }
#line 1966
        if ((int )*(aa->name + 0) == 45) {
#line 1966
          if (decode) {
#line 1966
            goto __Cont___0;
          }
        }
#line 1967
        numFilesProcessed ++;
#line 1968
        compress(aa->name);
        __Cont___0: /* CIL Label */ 
#line 1964
        aa = aa->link;
      }
    }
  } else
#line 1974
  if (opMode == 2) {
#line 1975
    unzFailsExist = (Bool )0;
#line 1976
    if (srcMode == 1) {
#line 1977
      uncompress((Char *)((void *)0));
    } else {
#line 1979
      decode = (Bool )1;
#line 1980
      aa = argList;
#line 1980
      while ((unsigned long )aa != (unsigned long )((void *)0)) {
#line 1981
        tmp___30 = strcmp((char const   *)aa->name, "--");
#line 1981
        if (tmp___30 == 0) {
#line 1981
          decode = (Bool )0;
#line 1981
          goto __Cont___1;
        }
#line 1982
        if ((int )*(aa->name + 0) == 45) {
#line 1982
          if (decode) {
#line 1982
            goto __Cont___1;
          }
        }
#line 1983
        numFilesProcessed ++;
#line 1984
        uncompress(aa->name);
        __Cont___1: /* CIL Label */ 
#line 1980
        aa = aa->link;
      }
    }
#line 1987
    if (unzFailsExist) {
#line 1988
      setExit(2);
#line 1989
      exit(exitValue);
    }
  } else {
#line 1994
    testFailsExist = (Bool )0;
#line 1995
    if (srcMode == 1) {
#line 1996
      testf((Char *)((void *)0));
    } else {
#line 1998
      decode = (Bool )1;
#line 1999
      aa = argList;
#line 1999
      while ((unsigned long )aa != (unsigned long )((void *)0)) {
#line 2000
        tmp___31 = strcmp((char const   *)aa->name, "--");
#line 2000
        if (tmp___31 == 0) {
#line 2000
          decode = (Bool )0;
#line 2000
          goto __Cont___2;
        }
#line 2001
        if ((int )*(aa->name + 0) == 45) {
#line 2001
          if (decode) {
#line 2001
            goto __Cont___2;
          }
        }
#line 2002
        numFilesProcessed ++;
#line 2003
        testf(aa->name);
        __Cont___2: /* CIL Label */ 
#line 1999
        aa = aa->link;
      }
    }
#line 2006
    if (testFailsExist) {
#line 2006
      if (noisy) {
#line 2007
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n");
#line 2012
        setExit(2);
#line 2013
        exit(exitValue);
      }
    }
  }
#line 2020
  aa = argList;
#line 2021
  while ((unsigned long )aa != (unsigned long )((void *)0)) {
#line 2022
    aa2 = aa->link;
#line 2023
    if ((unsigned long )aa->name != (unsigned long )((void *)0)) {
#line 2023
      free((void *)aa->name);
    }
#line 2024
    free((void *)aa);
#line 2025
    aa = aa2;
  }
#line 2028
  return (exitValue);
}
}
void addFlagsFromEnvVar_cil_lr_1_cil_lr_1(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) 
{ 
  unsigned short const   **tmp_ssa_1 ;
  int __cil_tmp6 ;
  Char *__cil_tmp7 ;
  Char *__cil_tmp8 ;
  Char __cil_tmp9 ;
  unsigned short const   *__cil_tmp10 ;
  Int32 __cil_tmp11 ;
  unsigned short const   *__cil_tmp12 ;
  unsigned short __cil_tmp13 ;
  int __cil_tmp14 ;
  Char *__cil_tmp15 ;

  {
  {
#line 1760
  tmp_ssa_1 = __ctype_b_loc();
  }
  {
#line 1760
  __cil_tmp7 = *__cil_ap_p;
#line 1760
  __cil_tmp8 = __cil_tmp7 + 0;
#line 1760
  __cil_tmp9 = *__cil_tmp8;
#line 1760
  __cil_tmp10 = *tmp_ssa_1;
#line 1760
  __cil_tmp11 = (Int32 )__cil_tmp9;
#line 1760
  __cil_tmp12 = __cil_tmp10 + __cil_tmp11;
#line 1760
  __cil_tmp13 = *__cil_tmp12;
#line 1760
  __cil_tmp14 = (int const   )__cil_tmp13;
#line 1760
  __cil_tmp6 = __cil_tmp14 & 8192;
#line 1760
  if (__cil_tmp6) {
    {
#line 1760
    __cil_tmp15 = *__cil_ap_p;
#line 1760
    *__cil_ap_p = __cil_tmp15 + 1;
    }
    {
    addFlagsFromEnvVar_cil_lr_1_cil_lr_1(__cil_ap_argList, __cil_ap_i, __cil_ap_p);
    }
    return;
  } else {
    return;
  }
  }
}
}
void addFlagsFromEnvVar_cil_lr_1_cil_lr_2(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) 
{ 
  unsigned short const   **tmp___0_ssa_1 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  Char *__cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Char *__cil_tmp10 ;
  Char __cil_tmp11 ;
  int __cil_tmp12 ;
  Char *__cil_tmp13 ;
  Int32 __cil_tmp14 ;
  Char *__cil_tmp15 ;
  Char __cil_tmp16 ;
  unsigned short const   *__cil_tmp17 ;
  Int32 __cil_tmp18 ;
  unsigned short const   *__cil_tmp19 ;
  unsigned short __cil_tmp20 ;
  int __cil_tmp21 ;
  Int32 __cil_tmp22 ;

  {
  {
#line 1761
  __cil_tmp8 = *__cil_ap_p;
#line 1761
  __cil_tmp9 = *__cil_ap_i;
#line 1761
  __cil_tmp10 = __cil_tmp8 + __cil_tmp9;
#line 1761
  __cil_tmp11 = *__cil_tmp10;
#line 1761
  __cil_tmp12 = (int )__cil_tmp11;
#line 1761
  __cil_tmp6 = __cil_tmp12 != 0;
#line 1761
  if (__cil_tmp6) {
    {
#line 1761
    tmp___0_ssa_1 = __ctype_b_loc();
    }
    {
#line 1761
    __cil_tmp13 = *__cil_ap_p;
#line 1761
    __cil_tmp14 = *__cil_ap_i;
#line 1761
    __cil_tmp15 = __cil_tmp13 + __cil_tmp14;
#line 1761
    __cil_tmp16 = *__cil_tmp15;
#line 1761
    __cil_tmp17 = *tmp___0_ssa_1;
#line 1761
    __cil_tmp18 = (Int32 )__cil_tmp16;
#line 1761
    __cil_tmp19 = __cil_tmp17 + __cil_tmp18;
#line 1761
    __cil_tmp20 = *__cil_tmp19;
#line 1761
    __cil_tmp21 = (int const   )__cil_tmp20;
#line 1761
    __cil_tmp7 = __cil_tmp21 & 8192;
#line 1761
    if (__cil_tmp7) {
      return;
    } else {
      {
#line 1761
      __cil_tmp22 = *__cil_ap_i;
#line 1761
      *__cil_ap_i = __cil_tmp22 + 1;
      }
      {
      addFlagsFromEnvVar_cil_lr_1_cil_lr_2(__cil_ap_argList, __cil_ap_i, __cil_ap_p);
      }
      return;
    }
    }
  } else {
    return;
  }
  }
}
}
void addFlagsFromEnvVar_cil_lr_1_cil_lr_3(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p , Int32 *__cil_ap_k ,
                                          Int32 j ) 
{ 
  Int32 j_ssa_1 ;
  int __cil_tmp7 ;
  Int32 __cil_tmp8 ;
  Char *__cil_tmp9 ;
  Char *__cil_tmp10 ;
  Char *__cil_tmp11 ;

  {
  {
#line 1764
  __cil_tmp8 = *__cil_ap_k;
#line 1764
  __cil_tmp7 = j < __cil_tmp8;
#line 1764
  if (__cil_tmp7) {
    {
#line 1764
    __cil_tmp9 = *__cil_ap_p;
#line 1764
    __cil_tmp10 = __cil_tmp9 + j;
#line 1764
    __cil_tmp11 = tmpName + j;
#line 1764
    *__cil_tmp11 = *__cil_tmp10;
#line 1764
    j_ssa_1 = j + 1;
    }
    {
    addFlagsFromEnvVar_cil_lr_1_cil_lr_3(__cil_ap_argList, __cil_ap_i, __cil_ap_p,
                                         __cil_ap_k, j_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
}
}
void addFlagsFromEnvVar_cil_lr_1(Cell **argList , Int32 i , Char *p ) 
{ 
  Int32 k ;
  Cell ***__cil_pp_argList  = & argList;
  Int32 *__cil_pp_i  = & i;
  Char **__cil_pp_p  = & p;
  Int32 *__cil_pp_k  = & k;
  Cell ***__cil_fp_argList  = & argList;
  Int32 *__cil_fp_i  = & i;
  Char **__cil_fp_p  = & p;
  Int32 *__cil_fp_k  = & k;
  Char *p_ssa_1 ;
  Int32 i_ssa_1 ;
  Cell **argList_ssa_1 ;
  Int32 i_ssa_2 ;
  Char *p_ssa_2 ;
  Cell **argList_ssa_2 ;
  Int32 i_ssa_3 ;
  Char *p_ssa_3 ;
  Int32 k_ssa_1 ;
  Int32 k_ssa_2 ;
  Int32 j_ssa_1 ;
  Cell **argList_ssa_3 ;
  Int32 i_ssa_4 ;
  Char *p_ssa_4 ;
  Int32 k_ssa_3 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  Char *__cil_tmp34 ;
  Char __cil_tmp35 ;
  int __cil_tmp36 ;
  Char *__cil_tmp37 ;
  Cell *__cil_tmp38 ;
  Char *__cil_tmp39 ;

  {
  {
#line 1757
  __cil_tmp34 = p + i;
#line 1757
  __cil_tmp35 = *__cil_tmp34;
#line 1757
  __cil_tmp36 = (int )__cil_tmp35;
#line 1757
  __cil_tmp31 = __cil_tmp36 == 0;
#line 1757
  if (__cil_tmp31) {
    return;
  } else {
    {
#line 1758
    p_ssa_1 = p + i;
#line 1759
    i_ssa_1 = 0;
    }
    {
    *__cil_fp_argList = argList;
    *__cil_fp_i = i_ssa_1;
    *__cil_fp_p = p_ssa_1;
#line 1760
    addFlagsFromEnvVar_cil_lr_1_cil_lr_1(__cil_pp_argList, __cil_pp_i, __cil_pp_p);
    argList_ssa_1 = *__cil_fp_argList;
    i_ssa_2 = *__cil_fp_i;
    p_ssa_2 = *__cil_fp_p;
    }
    {
    *__cil_fp_argList = argList_ssa_1;
    *__cil_fp_i = i_ssa_2;
    *__cil_fp_p = p_ssa_2;
#line 1761
    addFlagsFromEnvVar_cil_lr_1_cil_lr_2(__cil_pp_argList, __cil_pp_i, __cil_pp_p);
    argList_ssa_2 = *__cil_fp_argList;
    i_ssa_3 = *__cil_fp_i;
    p_ssa_3 = *__cil_fp_p;
    }
    {
#line 1762
    __cil_tmp32 = i_ssa_3 > 0;
#line 1762
    if (__cil_tmp32) {
      {
#line 1763
      k_ssa_1 = i_ssa_3;
      }
      {
#line 1763
      __cil_tmp33 = k_ssa_1 > 1024;
#line 1763
      if (__cil_tmp33) {
        {
#line 1763
        k_ssa_2 = 1024;
        }
      } else {
        k_ssa_2 = k_ssa_1;
      }
      }
      {
#line 1764
      j_ssa_1 = 0;
      }
      {
      *__cil_fp_argList = argList_ssa_2;
      *__cil_fp_i = i_ssa_3;
      *__cil_fp_p = p_ssa_3;
      *__cil_fp_k = k_ssa_2;
#line 1764
      addFlagsFromEnvVar_cil_lr_1_cil_lr_3(__cil_pp_argList, __cil_pp_i, __cil_pp_p,
                                           __cil_pp_k, j_ssa_1);
      argList_ssa_3 = *__cil_fp_argList;
      i_ssa_4 = *__cil_fp_i;
      p_ssa_4 = *__cil_fp_p;
      k_ssa_3 = *__cil_fp_k;
      }
      {
#line 1765
      __cil_tmp37 = tmpName + k_ssa_3;
#line 1765
      *__cil_tmp37 = (Char )0;
#line 1766
      __cil_tmp38 = *argList_ssa_3;
#line 1766
      __cil_tmp39 = tmpName;
#line 1766
      *argList_ssa_3 = snocString(__cil_tmp38, __cil_tmp39);
      }
    } else {
      argList_ssa_3 = argList_ssa_2;
      i_ssa_4 = i_ssa_3;
      p_ssa_4 = p_ssa_3;
    }
    }
    {
    addFlagsFromEnvVar_cil_lr_1(argList_ssa_3, i_ssa_4, p_ssa_4);
    }
    return;
  }
  }
  {
  addFlagsFromEnvVar_cil_lr_1(argList, i, p);
  }
  return;
}
}
void snocString_cil_lr_1(Cell **__cil_ap_root , Char **__cil_ap_name , Cell **__cil_ap_tmp___3 ) 
{ 
  int __cil_tmp4 ;
  Cell *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  struct zzzz **__cil_tmp8 ;
  struct zzzz *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  Cell *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  struct zzzz **__cil_tmp14 ;

  {
  {
#line 1738
  __cil_tmp5 = *__cil_ap_tmp___3;
#line 1738
  __cil_tmp6 = (unsigned char *)__cil_tmp5;
#line 1738
  __cil_tmp7 = __cil_tmp6 + 8;
#line 1738
  __cil_tmp8 = (struct zzzz **)__cil_tmp7;
#line 1738
  __cil_tmp9 = *__cil_tmp8;
#line 1738
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 1738
  __cil_tmp4 = __cil_tmp10 != (unsigned long )((void *)0);
#line 1738
  if (__cil_tmp4) {
    {
#line 1738
    __cil_tmp11 = *__cil_ap_tmp___3;
#line 1738
    __cil_tmp12 = (unsigned char *)__cil_tmp11;
#line 1738
    __cil_tmp13 = __cil_tmp12 + 8;
#line 1738
    __cil_tmp14 = (struct zzzz **)__cil_tmp13;
#line 1738
    *__cil_ap_tmp___3 = *__cil_tmp14;
    }
    {
    snocString_cil_lr_1(__cil_ap_root, __cil_ap_name, __cil_ap_tmp___3);
    }
    return;
  } else {
    return;
  }
  }
}
}
void pad_cil_lr_1(Char *s , Int32 i ) 
{ 
  Int32 *__cil_gp_longestFileName  = & longestFileName;
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  size_t tmp___0_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Int32 __cil_tmp10 ;
  struct _IO_FILE *__cil_tmp11 ;

  {
  {
#line 912
  tmp___0_ssa_1 = strlen((char const   *)s);
  }
  {
#line 912
  __cil_tmp9 = *__cil_gp_longestFileName;
#line 912
  __cil_tmp10 = __cil_tmp9 - (Int32 )tmp___0_ssa_1;
#line 912
  __cil_tmp8 = i <= __cil_tmp10;
#line 912
  if (__cil_tmp8) {
    {
#line 913
    __cil_tmp11 = *__cil_gp_stderr;
#line 913
    fprintf((FILE */* __restrict  */)__cil_tmp11, (char const   */* __restrict  */)" ");
#line 912
    i_ssa_1 = i + 1;
    }
    {
    pad_cil_lr_1(s, i_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
}
}
void uInt64_toAscii_cil_lr_1(char **__cil_ap_outbuf , Int32 *__cil_ap_nBuf , UChar buf[32] ,
                             UInt64 n_copy ) 
{ 
  UInt64 *__cil_pp_n_copy  = & n_copy;
  Int32 q_ssa_1 ;
  Bool tmp_ssa_1 ;
  Int32 __cil_tmp10 ;
  Int32 __cil_tmp11 ;
  UChar *__cil_tmp12 ;
  Int32 __cil_tmp13 ;

  {
  {
#line 302
  q_ssa_1 = uInt64_qrm10(__cil_pp_n_copy);
#line 303
  __cil_tmp10 = q_ssa_1 + 48;
#line 303
  __cil_tmp11 = *__cil_ap_nBuf;
#line 303
  __cil_tmp12 = buf + __cil_tmp11;
#line 303
  *__cil_tmp12 = (UChar )__cil_tmp10;
#line 304
  __cil_tmp13 = *__cil_ap_nBuf;
#line 304
  *__cil_ap_nBuf = __cil_tmp13 + 1;
#line 301
  tmp_ssa_1 = uInt64_isZero(__cil_pp_n_copy);
  }
#line 301
  if (tmp_ssa_1) {
    return;
  } else {
    {
    uInt64_toAscii_cil_lr_1(__cil_ap_outbuf, __cil_ap_nBuf, buf, n_copy);
    }
    return;
  }
}
}
void uInt64_toAscii_cil_lr_2(char *outbuf , Int32 i , UChar buf[32] , Int32 nBuf ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  Int32 __cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar __cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 307
  __cil_tmp6 = i < nBuf;
#line 307
  if (__cil_tmp6) {
    {
#line 308
    __cil_tmp7 = nBuf - i;
#line 308
    __cil_tmp8 = __cil_tmp7 - 1;
#line 308
    __cil_tmp9 = buf + __cil_tmp8;
#line 308
    __cil_tmp10 = *__cil_tmp9;
#line 308
    __cil_tmp11 = outbuf + i;
#line 308
    *__cil_tmp11 = (char )__cil_tmp10;
#line 307
    i_ssa_1 = i + 1;
    }
    {
    uInt64_toAscii_cil_lr_2(outbuf, i_ssa_1, buf, nBuf);
    }
    return;
  } else {
    return;
  }
  }
}
}
void uInt64_qrm10_cil_lr_1(UInt32 *__cil_ap_rem , UInt64 *n , Int32 i ) 
{ 
  UInt32 tmp_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp7 ;
  UInt32 __cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar *__cil_tmp10 ;
  UChar __cil_tmp11 ;
  UInt32 __cil_tmp12 ;
  UInt32 __cil_tmp13 ;
  UInt32 __cil_tmp14 ;
  UChar *__cil_tmp15 ;
  UChar *__cil_tmp16 ;

  {
  {
#line 282
  __cil_tmp7 = i >= 0;
#line 282
  if (__cil_tmp7) {
    {
#line 283
    __cil_tmp8 = *__cil_ap_rem;
#line 283
    __cil_tmp9 = *((UChar (*)[8])n);
#line 283
    __cil_tmp10 = __cil_tmp9 + i;
#line 283
    __cil_tmp11 = *__cil_tmp10;
#line 283
    __cil_tmp12 = __cil_tmp8 * 256U;
#line 283
    __cil_tmp13 = (UInt32 )__cil_tmp11;
#line 283
    tmp_ssa_1 = __cil_tmp12 + __cil_tmp13;
#line 284
    __cil_tmp14 = tmp_ssa_1 / 10U;
#line 284
    __cil_tmp15 = *((UChar (*)[8])n);
#line 284
    __cil_tmp16 = __cil_tmp15 + i;
#line 284
    *__cil_tmp16 = (UChar )__cil_tmp14;
#line 285
    *__cil_ap_rem = tmp_ssa_1 % 10U;
#line 282
    i_ssa_1 = i - 1;
    }
    {
    uInt64_qrm10_cil_lr_1(__cil_ap_rem, n, i_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
}
}
int uInt64_isZero_cil_lr_1(Bool *__cil_ap___cil_ret3 , UInt64 *n , Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int retflag4_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar *__cil_tmp10 ;
  UChar __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 269
  __cil_tmp7 = i < 8;
#line 269
  if (__cil_tmp7) {
    {
#line 270
    __cil_tmp9 = *((UChar (*)[8])n);
#line 270
    __cil_tmp10 = __cil_tmp9 + i;
#line 270
    __cil_tmp11 = *__cil_tmp10;
#line 270
    __cil_tmp12 = (int )__cil_tmp11;
#line 270
    __cil_tmp8 = __cil_tmp12 != 0;
#line 270
    if (__cil_tmp8) {
      {
      {
#line 270
      *__cil_ap___cil_ret3 = (Bool )0;
      }
      return (1);
      }
    } else {
      {
#line 269
      i_ssa_1 = i + 1;
      }
      {
      retflag4_ssa_1 = uInt64_isZero_cil_lr_1(__cil_ap___cil_ret3, n, i_ssa_1);
      }
      return (retflag4_ssa_1);
    }
    }
  } else {
    return (0);
  }
  }
}
}
void uInt64_to_double_cil_lr_1(double *__cil_ap_sum , UInt64 *n , Int32 i , double base ) 
{ 
  double base_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp7 ;
  UChar *__cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;

  {
  {
#line 257
  __cil_tmp7 = i < 8;
#line 257
  if (__cil_tmp7) {
    {
#line 258
    __cil_tmp8 = *((UChar (*)[8])n);
#line 258
    __cil_tmp9 = __cil_tmp8 + i;
#line 258
    __cil_tmp10 = *__cil_tmp9;
#line 258
    __cil_tmp11 = (double )__cil_tmp10;
#line 258
    __cil_tmp12 = *__cil_ap_sum;
#line 258
    __cil_tmp13 = base * __cil_tmp11;
#line 258
    *__cil_ap_sum = __cil_tmp12 + __cil_tmp13;
#line 259
    base_ssa_1 = base * 256.0;
#line 257
    i_ssa_1 = i + 1;
    }
    {
    uInt64_to_double_cil_lr_1(__cil_ap_sum, n, i_ssa_1, base_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
}
}
