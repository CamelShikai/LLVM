/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */
typedef unsigned long size_t;
struct regexp {
   char *startp[10] ;
   char *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
typedef struct regexp regexp;
struct comp {
   char *regparse ;
   int regnpar ;
   char *regcode ;
   char regdummy[3] ;
   long regsize ;
};
struct exec {
   char *reginput ;
   char *regbol ;
   char **regstartp ;
   char **regendp ;
};
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
regexp *regcomp(char const   *exp ) ;
int regexec(regexp *prog , char const   *str ) ;
extern void regerror(char *message ) ;
static char *reg(struct comp *cp , int paren , int *flagp ) ;
static char *regbranch(struct comp *cp , int *flagp ) ;
static char *( __attribute__((__noinline__)) regpiece)(struct comp *cp , int *flagp ) ;
static char *regatom(struct comp *cp , int *flagp ) ;
static char *regnode(struct comp *cp , char op ) ;
static char *regnext(char *p ) ;
static void regc(struct comp *cp , char b ) ;
static void reginsert(struct comp *cp , char op , char *opnd ) ;
static void regtail(struct comp *cp , char *p , char *val ) ;
static void regoptail(struct comp *cp , char *p , char *val ) ;
static int regtry(struct exec *ep , regexp *prog , char *string ) ;
static int regmatch(struct exec *ep , char *prog ) ;
static size_t ( __attribute__((__noinline__)) regrepeat)(struct exec *ep , char *node ) ;
void regtry_cil_lr_1(struct exec **__cil_ap_ep , regexp **__cil_ap_prog , char **__cil_ap_string ,
                     int i , char **stp , char **enp ) ;
int regexec_cil_lr_1(int *__cil_ap___cil_ret10 , regexp *prog , char *s , struct exec ex ) ;
int regexec_cil_lr_2(int *__cil_ap___cil_ret12 , regexp *prog , char *s , struct exec ex ) ;
int regbranch_cil_lr_1(struct comp **__cil_ap_cp , char **__cil_ap_ret , char **__cil_ap_chain ,
                       char **__cil_ap___cil_ret8 , int *flagp , int flags ) ;
void regcomp_cil_lr_1(regexp **__cil_ap_r , char **__cil_ap_longest , size_t *__cil_ap_len ,
                      char *scan ) ;
regexp *regcomp(char const   *exp ) 
{ 
  regexp *r ;
  int flags ;
  struct comp co ;
  char *longest ;
  size_t len ;
  struct comp *__cil_pp_co  = & co;
  int *__cil_pp_flags  = & flags;
  regexp **__cil_pp_r  = & r;
  char **__cil_pp_longest  = & longest;
  size_t *__cil_pp_len  = & len;
  int *__cil_fp_flags  = & flags;
  regexp **__cil_fp_r  = & r;
  char **__cil_fp_longest  = & longest;
  size_t *__cil_fp_len  = & len;
  char *tmp_ssa_1 ;
  int flags_ssa_1 ;
  void *tmp___0_ssa_1 ;
  regexp *r_ssa_1 ;
  char *tmp___1_ssa_1 ;
  int flags_ssa_2 ;
  char *scan_ssa_1 ;
  char *tmp___3_ssa_1 ;
  char *scan_ssa_2 ;
  char *longest_ssa_1 ;
  size_t len_ssa_1 ;
  regexp *r_ssa_2 ;
  char *longest_ssa_2 ;
  size_t len_ssa_2 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  int *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  long *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  char (*__cil_tmp50)[3] ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  char (*__cil_tmp54)[3] ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  unsigned char *__cil_tmp57 ;
  char (*__cil_tmp58)[3] ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  unsigned char *__cil_tmp61 ;
  char (*__cil_tmp62)[3] ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  unsigned char *__cil_tmp65 ;
  char (*__cil_tmp66)[3] ;
  unsigned char *__cil_tmp67 ;
  char **__cil_tmp68 ;
  unsigned char *__cil_tmp69 ;
  long *__cil_tmp70 ;
  long __cil_tmp71 ;
  unsigned char *__cil_tmp72 ;
  long *__cil_tmp73 ;
  long __cil_tmp74 ;
  size_t __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  unsigned char *__cil_tmp77 ;
  int *__cil_tmp78 ;
  unsigned char *__cil_tmp79 ;
  char (*__cil_tmp80)[1] ;
  unsigned char *__cil_tmp81 ;
  char **__cil_tmp82 ;
  unsigned char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  unsigned char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  unsigned char *__cil_tmp87 ;
  char **__cil_tmp88 ;
  unsigned char *__cil_tmp89 ;
  int *__cil_tmp90 ;
  unsigned char *__cil_tmp91 ;
  char (*__cil_tmp92)[1] ;
  char *__cil_tmp93 ;
  char __cil_tmp94 ;
  int __cil_tmp95 ;
  char __cil_tmp96 ;
  int __cil_tmp97 ;
  char *__cil_tmp98 ;
  unsigned char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char __cil_tmp101 ;
  int __cil_tmp102 ;
  unsigned char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  unsigned char *__cil_tmp105 ;
  char **__cil_tmp106 ;
  unsigned char *__cil_tmp107 ;
  int *__cil_tmp108 ;
  {
  {
  __cil_tmp36 = (unsigned long )exp == (unsigned long )((void *)0);
  if (__cil_tmp36) {
    {
    regerror((char *)"NULL argument to regcomp");
    }
    return ((regexp *)0);
  } else {
    {
    *((char **)__cil_pp_co) = (char *)exp;
    __cil_tmp45 = (unsigned char *)__cil_pp_co + 8;
    __cil_tmp46 = (int *)__cil_tmp45;
    *__cil_tmp46 = 1;
    __cil_tmp47 = (unsigned char *)__cil_pp_co + 32;
    __cil_tmp48 = (long *)__cil_tmp47;
    *__cil_tmp48 = 0L;
    __cil_tmp49 = (unsigned char *)__cil_pp_co + 24;
    __cil_tmp50 = (char (*)[3])__cil_tmp49;
    __cil_tmp51 = *__cil_tmp50;
    __cil_tmp52 = (char *)__cil_tmp51;
    *__cil_tmp52 = (char)9;
    __cil_tmp53 = (unsigned char *)__cil_pp_co + 24;
    __cil_tmp54 = (char (*)[3])__cil_tmp53;
    __cil_tmp55 = *__cil_tmp54;
    __cil_tmp56 = __cil_tmp55 + 2;
    *__cil_tmp56 = (char)0;
    __cil_tmp57 = (unsigned char *)__cil_pp_co + 24;
    __cil_tmp58 = (char (*)[3])__cil_tmp57;
    __cil_tmp59 = *__cil_tmp58;
    __cil_tmp60 = __cil_tmp59 + 2;
    __cil_tmp61 = (unsigned char *)__cil_pp_co + 24;
    __cil_tmp62 = (char (*)[3])__cil_tmp61;
    __cil_tmp63 = *__cil_tmp62;
    __cil_tmp64 = __cil_tmp63 + 1;
    *__cil_tmp64 = *__cil_tmp60;
    __cil_tmp65 = (unsigned char *)__cil_pp_co + 24;
    __cil_tmp66 = (char (*)[3])__cil_tmp65;
    __cil_tmp67 = (unsigned char *)__cil_pp_co + 16;
    __cil_tmp68 = (char **)__cil_tmp67;
    *__cil_tmp68 = *__cil_tmp66;
    regc(__cil_pp_co, 156);
    *__cil_fp_flags = flags;
    tmp_ssa_1 = reg(__cil_pp_co, 0, __cil_pp_flags);
    flags_ssa_1 = *__cil_fp_flags;
    }
    {
    __cil_tmp37 = (unsigned long )tmp_ssa_1 == (unsigned long )((void *)0);
    if (__cil_tmp37) {
      return ((regexp *)0);
    } else {
      {
      __cil_tmp69 = (unsigned char *)__cil_pp_co + 32;
      __cil_tmp70 = (long *)__cil_tmp69;
      __cil_tmp71 = *__cil_tmp70;
      __cil_tmp38 = __cil_tmp71 >= 32767L;
      if (__cil_tmp38) {
        {
        regerror((char *)"regexp too big");
        }
        return ((regexp *)0);
      } else {
        {
        __cil_tmp72 = (unsigned char *)__cil_pp_co + 32;
        __cil_tmp73 = (long *)__cil_tmp72;
        __cil_tmp74 = *__cil_tmp73;
        __cil_tmp75 = (size_t )__cil_tmp74;
        __cil_tmp76 = sizeof(regexp ) + __cil_tmp75;
        tmp___0_ssa_1 = malloc(__cil_tmp76);
        r_ssa_1 = (regexp *)tmp___0_ssa_1;
        }
        {
        __cil_tmp39 = (unsigned long )r_ssa_1 == (unsigned long )((void *)0);
        if (__cil_tmp39) {
          {
          regerror((char *)"out of space");
          }
          return ((regexp *)0);
        } else {
          {
          *((char **)__cil_pp_co) = (char *)exp;
          __cil_tmp77 = (unsigned char *)__cil_pp_co + 8;
          __cil_tmp78 = (int *)__cil_tmp77;
          *__cil_tmp78 = 1;
          __cil_tmp79 = (unsigned char *)r_ssa_1 + 180;
          __cil_tmp80 = (char (*)[1])__cil_tmp79;
          __cil_tmp81 = (unsigned char *)__cil_pp_co + 16;
          __cil_tmp82 = (char **)__cil_tmp81;
          *__cil_tmp82 = *__cil_tmp80;
          regc(__cil_pp_co, 156);
          *__cil_fp_flags = flags_ssa_1;
          tmp___1_ssa_1 = reg(__cil_pp_co, 0, __cil_pp_flags);
          flags_ssa_2 = *__cil_fp_flags;
          }
          {
          __cil_tmp40 = (unsigned long )tmp___1_ssa_1 == (unsigned long )((void *)0);
          if (__cil_tmp40) {
            return ((regexp *)0);
          } else {
            {
            __cil_tmp83 = (unsigned char *)r_ssa_1 + 160;
            __cil_tmp84 = (char *)__cil_tmp83;
            *__cil_tmp84 = (char )'\000';
            __cil_tmp85 = (unsigned char *)r_ssa_1 + 161;
            __cil_tmp86 = (char *)__cil_tmp85;
            *__cil_tmp86 = (char)0;
            __cil_tmp87 = (unsigned char *)r_ssa_1 + 168;
            __cil_tmp88 = (char **)__cil_tmp87;
            *__cil_tmp88 = (char *)0;
            __cil_tmp89 = (unsigned char *)r_ssa_1 + 176;
            __cil_tmp90 = (int *)__cil_tmp89;
            *__cil_tmp90 = 0;
            __cil_tmp91 = (unsigned char *)r_ssa_1 + 180;
            __cil_tmp92 = (char (*)[1])__cil_tmp91;
            __cil_tmp93 = *__cil_tmp92;
            scan_ssa_1 = __cil_tmp93 + 1;
            tmp___3_ssa_1 = regnext(scan_ssa_1);
            }
            {
            __cil_tmp94 = *tmp___3_ssa_1;
            __cil_tmp95 = (int )__cil_tmp94;
            __cil_tmp41 = __cil_tmp95 == 0;
            if (__cil_tmp41) {
              {
              scan_ssa_2 = scan_ssa_1 + 3;
              }
              {
              __cil_tmp96 = *scan_ssa_2;
              __cil_tmp97 = (int )__cil_tmp96;
              __cil_tmp42 = __cil_tmp97 == 8;
              if (__cil_tmp42) {
                {
                __cil_tmp98 = scan_ssa_2 + 3;
                __cil_tmp99 = (unsigned char *)r_ssa_1 + 160;
                __cil_tmp100 = (char *)__cil_tmp99;
                *__cil_tmp100 = *__cil_tmp98;
                }
              } else {
                {
                __cil_tmp101 = *scan_ssa_2;
                __cil_tmp102 = (int )__cil_tmp101;
                __cil_tmp43 = __cil_tmp102 == 1;
                if (__cil_tmp43) {
                  {
                  __cil_tmp103 = (unsigned char *)r_ssa_1 + 161;
                  __cil_tmp104 = (char *)__cil_tmp103;
                  *__cil_tmp104 = (char)1;
                  }
                } else {
                }
                }
              }
              }
              {
              __cil_tmp44 = flags_ssa_2 & 4;
              if (__cil_tmp44) {
                {
                longest_ssa_1 = (char *)0;
                len_ssa_1 = (size_t )0;
                }
                {
                *__cil_fp_r = r_ssa_1;
                *__cil_fp_longest = longest_ssa_1;
                *__cil_fp_len = len_ssa_1;
                regcomp_cil_lr_1(__cil_pp_r, __cil_pp_longest, __cil_pp_len, scan_ssa_2);
                r_ssa_2 = *__cil_fp_r;
                longest_ssa_2 = *__cil_fp_longest;
                len_ssa_2 = *__cil_fp_len;
                }
                {
                __cil_tmp105 = (unsigned char *)r_ssa_2 + 168;
                __cil_tmp106 = (char **)__cil_tmp105;
                *__cil_tmp106 = longest_ssa_2;
                __cil_tmp107 = (unsigned char *)r_ssa_2 + 176;
                __cil_tmp108 = (int *)__cil_tmp107;
                *__cil_tmp108 = (int )len_ssa_2;
                }
              } else {
                r_ssa_2 = r_ssa_1;
              }
              }
            } else {
              r_ssa_2 = r_ssa_1;
            }
            }
            return (r_ssa_2);
          }
          }
          return (r);
        }
        }
        return (r);
      }
      }
      return (r);
    }
    }
    return (r);
  }
  }
  return (r);
}
}
static char *reg(struct comp *cp , int paren , int *flagp ) 
{ 
  char *ret ;
  char *br ;
  char *ender ;
  int parno ;
  int flags ;
  int tmp ;
  char *tmp___0 ;
  {
  *flagp = 1;
  if (paren) {
    if (cp->regnpar >= 10) {
      regerror((char *)"too many ()");
      return ((char *)((void *)0));
    }
    parno = cp->regnpar;
    (cp->regnpar) ++;
    ret = regnode(cp, 20 + parno);
  }
  br = regbranch(cp, & flags);
  if ((unsigned long )br == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if (paren) {
    regtail(cp, ret, br);
  } else {
    ret = br;
  }
  *flagp &= ~ (~ flags & 1);
  *flagp |= flags & 4;
  while ((int )*(cp->regparse) == 124) {
    (cp->regparse) ++;
    br = regbranch(cp, & flags);
    if ((unsigned long )br == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    }
    regtail(cp, ret, br);
    *flagp &= ~ (~ flags & 1);
    *flagp |= flags & 4;
  }
  if (paren) {
    tmp = 30 + parno;
  } else {
    tmp = 0;
  }
  ender = regnode(cp, tmp);
  regtail(cp, ret, ender);
  br = ret;
  while ((unsigned long )br != (unsigned long )((void *)0)) {
    regoptail(cp, br, ender);
    br = regnext(br);
  }
  if (paren) {
    tmp___0 = cp->regparse;
    (cp->regparse) ++;
    if ((int )*tmp___0 != 41) {
      regerror((char *)"unterminated ()");
      return ((char *)((void *)0));
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! paren) {
    if ((int )*(cp->regparse) != 0) {
      if ((int )*(cp->regparse) == 41) {
        regerror((char *)"unmatched ()");
        return ((char *)((void *)0));
      } else {
        regerror((char *)"internal error: junk on end");
        return ((char *)((void *)0));
      }
    }
  }
  return (ret);
}
}
static char *regbranch(struct comp *cp , int *flagp ) 
{ 
  char *ret ;
  char *chain ;
  int flags ;
  char *__cil_ret8 ;
  struct comp **__cil_pp_cp  = & cp;
  char **__cil_pp_ret  = & ret;
  char **__cil_pp_chain  = & chain;
  char **__cil_pp___cil_ret8  = & __cil_ret8;
  struct comp **__cil_fp_cp  = & cp;
  char **__cil_fp_ret  = & ret;
  char **__cil_fp_chain  = & chain;
  char **__cil_fp___cil_ret8  = & __cil_ret8;
  char *ret_ssa_1 ;
  char *chain_ssa_1 ;
  int retflag9_ssa_1 ;
  struct comp *cp_ssa_1 ;
  char *ret_ssa_2 ;
  char *chain_ssa_2 ;
  char *__cil_ret8_ssa_1 ;
  int __cil_tmp25 ;
  {
  {
  *flagp = 0;
  ret_ssa_1 = regnode(cp, 6);
  chain_ssa_1 = (char *)0;
  }
  {
  {
  *__cil_fp_cp = cp;
  *__cil_fp_ret = ret_ssa_1;
  *__cil_fp_chain = chain_ssa_1;
  *__cil_fp___cil_ret8 = __cil_ret8;
  retflag9_ssa_1 = regbranch_cil_lr_1(__cil_pp_cp, __cil_pp_ret, __cil_pp_chain, __cil_pp___cil_ret8,
                                      flagp, flags);
  cp_ssa_1 = *__cil_fp_cp;
  ret_ssa_2 = *__cil_fp_ret;
  chain_ssa_2 = *__cil_fp_chain;
  __cil_ret8_ssa_1 = *__cil_fp___cil_ret8;
  }
  if (retflag9_ssa_1) {
    return (__cil_ret8_ssa_1);
  } else {
    {
    __cil_tmp25 = (unsigned long )chain_ssa_2 == (unsigned long )((void *)0);
    if (__cil_tmp25) {
      {
      regnode(cp_ssa_1, 9);
      }
    } else {
    }
    }
    return (ret_ssa_2);
  }
  }
  return (ret);
}
}
static char *( __attribute__((__noinline__)) regpiece)(struct comp *cp , int *flagp ) 
{ 
  char *ret ;
  char op ;
  char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  {
  ret = regatom(cp, & flags);
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  op = *(cp->regparse);
  if (! ((int )op == 42)) {
    if (! ((int )op == 43)) {
      if (! ((int )op == 63)) {
        *flagp = flags;
        return (ret);
      }
    }
  }
  if (! (flags & 1)) {
    if ((int )op != 63) {
      regerror((char *)"*+ operand could be empty");
      return ((char *)((void *)0));
    }
  }
  switch ((int )op) {
  case 42: 
  *flagp = 4;
  break;
  case 43: 
  *flagp = 5;
  break;
  case 63: 
  *flagp = 0;
  break;
  }
  if ((int )op == 42) {
    if (flags & 2) {
      reginsert(cp, 10, ret);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if ((int )op == 42) {
    reginsert(cp, 6, ret);
    tmp = regnode(cp, 7);
    regoptail(cp, ret, tmp);
    regoptail(cp, ret, ret);
    tmp___0 = regnode(cp, 6);
    regtail(cp, ret, tmp___0);
    tmp___1 = regnode(cp, 9);
    regtail(cp, ret, tmp___1);
  } else
  if ((int )op == 43) {
    if (flags & 2) {
      reginsert(cp, 11, ret);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )op == 43) {
    next = regnode(cp, 6);
    regtail(cp, ret, next);
    tmp___2 = regnode(cp, 7);
    regtail(cp, tmp___2, ret);
    tmp___3 = regnode(cp, 6);
    regtail(cp, next, tmp___3);
    tmp___4 = regnode(cp, 9);
    regtail(cp, ret, tmp___4);
  } else
  if ((int )op == 63) {
    reginsert(cp, 6, ret);
    tmp___5 = regnode(cp, 6);
    regtail(cp, ret, tmp___5);
    next = regnode(cp, 9);
    regtail(cp, ret, next);
    regoptail(cp, ret, next);
  }
  (cp->regparse) ++;
  if ((int )*(cp->regparse) == 42) {
    regerror((char *)"nested *?+");
    return ((char *)((void *)0));
  } else
  if ((int )*(cp->regparse) == 43) {
    regerror((char *)"nested *?+");
    return ((char *)((void *)0));
  } else
  if ((int )*(cp->regparse) == 63) {
    regerror((char *)"nested *?+");
    return ((char *)((void *)0));
  }
  return (ret);
}
}
static char *regatom(struct comp *cp , int *flagp ) 
{ 
  char *ret ;
  int flags ;
  char *tmp ;
  int range ;
  int rangeend ;
  int c ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t len ;
  char ender ;
  char *tmp___2 ;
  {
  *flagp = 0;
  tmp = cp->regparse;
  (cp->regparse) ++;
  switch ((int )*tmp) {
  case 94: 
  ret = regnode(cp, 1);
  break;
  case 36: 
  ret = regnode(cp, 2);
  break;
  case 46: 
  ret = regnode(cp, 3);
  *flagp |= 3;
  break;
  case 91: 
  if ((int )*(cp->regparse) == 94) {
    ret = regnode(cp, 5);
    (cp->regparse) ++;
  } else {
    ret = regnode(cp, 4);
  }
  c = (int )*(cp->regparse);
  if (c == 93) {
    regc(cp, c);
    (cp->regparse) ++;
  } else
  if (c == 45) {
    regc(cp, c);
    (cp->regparse) ++;
  }
  while (1) {
    tmp___0 = cp->regparse;
    (cp->regparse) ++;
    c = (int )*tmp___0;
    if (c != 0) {
      if (! (c != 93)) {
        break;
      }
    } else {
      break;
    }
    if (c != 45) {
      regc(cp, c);
    } else {
      c = (int )*(cp->regparse);
      if (c == 93) {
        regc(cp, '-');
      } else
      if (c == 0) {
        regc(cp, '-');
      } else {
        range = (int )((unsigned char )*(cp->regparse - 2));
        rangeend = (int )((unsigned char )c);
        if (range > rangeend) {
          regerror((char *)"invalid [] range");
          return ((char *)((void *)0));
        }
        range ++;
        while (range <= rangeend) {
          regc(cp, range);
          range ++;
        }
        (cp->regparse) ++;
      }
    }
  }
  regc(cp, '\000');
  if (c != 93) {
    regerror((char *)"unmatched []");
    return ((char *)((void *)0));
  }
  *flagp |= 3;
  break;
  case 40: 
  ret = reg(cp, 1, & flags);
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  *flagp |= flags & 5;
  break;
  case 41: 
  case 124: 
  case 0: 
  regerror((char *)"internal error: \\0|) unexpected");
  return ((char *)((void *)0));
  break;
  case 42: 
  case 43: 
  case 63: 
  regerror((char *)"?+* follows nothing");
  return ((char *)((void *)0));
  break;
  case 92: 
  if ((int )*(cp->regparse) == 0) {
    regerror((char *)"trailing \\");
    return ((char *)((void *)0));
  }
  ret = regnode(cp, 8);
  tmp___1 = cp->regparse;
  (cp->regparse) ++;
  regc(cp, (int )*tmp___1);
  regc(cp, '\000');
  *flagp |= 3;
  break;
  default: 
  (cp->regparse) --;
  len = strcspn((char const   *)cp->regparse, "^$.[()|?+*\\");
  if (len == 0UL) {
    regerror((char *)"internal error: strcspn 0");
    return ((char *)((void *)0));
  }
  ender = *(cp->regparse + len);
  if (len > 1UL) {
    if ((int )ender == 42) {
      len --;
    } else
    if ((int )ender == 43) {
      len --;
    } else
    if ((int )ender == 63) {
      len --;
    }
  }
  *flagp |= 1;
  if (len == 1UL) {
    *flagp |= 2;
  }
  ret = regnode(cp, 8);
  while (len > 0UL) {
    tmp___2 = cp->regparse;
    (cp->regparse) ++;
    regc(cp, (int )*tmp___2);
    len --;
  }
  regc(cp, '\000');
  break;
  }
  return (ret);
}
}
static char *regnode(struct comp *cp , char op ) 
{ 
  char *ret_ssa_1 ;
  char *ptr_ssa_1 ;
  char *tmp_ssa_1 ;
  char *ptr_ssa_2 ;
  char *tmp___0_ssa_1 ;
  char *ptr_ssa_3 ;
  char *tmp___1_ssa_1 ;
  char *ptr_ssa_4 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  char **__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  char **__cil_tmp20 ;
  char *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  char (*__cil_tmp23)[3] ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  long *__cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  long *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  char **__cil_tmp34 ;
  {
  {
  __cil_tmp17 = (unsigned char *)cp + 16;
  __cil_tmp18 = (char **)__cil_tmp17;
  ret_ssa_1 = *__cil_tmp18;
  }
  {
  __cil_tmp19 = (unsigned char *)cp + 16;
  __cil_tmp20 = (char **)__cil_tmp19;
  __cil_tmp21 = *__cil_tmp20;
  __cil_tmp22 = (unsigned char *)cp + 24;
  __cil_tmp23 = (char (*)[3])__cil_tmp22;
  __cil_tmp24 = *__cil_tmp23;
  __cil_tmp25 = (unsigned long )__cil_tmp21;
  __cil_tmp26 = (unsigned long )__cil_tmp24;
  __cil_tmp27 = __cil_tmp25 != __cil_tmp26;
  __cil_tmp16 = ! __cil_tmp27;
  if (__cil_tmp16) {
    {
    __cil_tmp28 = (unsigned char *)cp + 32;
    __cil_tmp29 = (long *)__cil_tmp28;
    __cil_tmp30 = *__cil_tmp29;
    __cil_tmp31 = (unsigned char *)cp + 32;
    __cil_tmp32 = (long *)__cil_tmp31;
    *__cil_tmp32 = __cil_tmp30 + 3L;
    }
    return (ret_ssa_1);
  } else {
    {
    ptr_ssa_1 = ret_ssa_1;
    tmp_ssa_1 = ptr_ssa_1;
    ptr_ssa_2 = ptr_ssa_1 + 1;
    *tmp_ssa_1 = op;
    tmp___0_ssa_1 = ptr_ssa_2;
    ptr_ssa_3 = ptr_ssa_2 + 1;
    *tmp___0_ssa_1 = (char )'\000';
    tmp___1_ssa_1 = ptr_ssa_3;
    ptr_ssa_4 = ptr_ssa_3 + 1;
    *tmp___1_ssa_1 = (char )'\000';
    __cil_tmp33 = (unsigned char *)cp + 16;
    __cil_tmp34 = (char **)__cil_tmp33;
    *__cil_tmp34 = ptr_ssa_4;
    }
    return (ret_ssa_1);
  }
  }
}
}
static void regc(struct comp *cp , char b ) 
{ 
  char *tmp_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  char **__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  char (*__cil_tmp10)[3] ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  char **__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  char **__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  char **__cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  long *__cil_tmp22 ;
  long __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  long *__cil_tmp25 ;
  {
  {
  __cil_tmp6 = (unsigned char *)cp + 16;
  __cil_tmp7 = (char **)__cil_tmp6;
  __cil_tmp8 = *__cil_tmp7;
  __cil_tmp9 = (unsigned char *)cp + 24;
  __cil_tmp10 = (char (*)[3])__cil_tmp9;
  __cil_tmp11 = *__cil_tmp10;
  __cil_tmp12 = (unsigned long )__cil_tmp8;
  __cil_tmp13 = (unsigned long )__cil_tmp11;
  __cil_tmp5 = __cil_tmp12 != __cil_tmp13;
  if (__cil_tmp5) {
    {
    __cil_tmp14 = (unsigned char *)cp + 16;
    __cil_tmp15 = (char **)__cil_tmp14;
    tmp_ssa_1 = *__cil_tmp15;
    __cil_tmp16 = (unsigned char *)cp + 16;
    __cil_tmp17 = (char **)__cil_tmp16;
    __cil_tmp18 = *__cil_tmp17;
    __cil_tmp19 = (unsigned char *)cp + 16;
    __cil_tmp20 = (char **)__cil_tmp19;
    *__cil_tmp20 = __cil_tmp18 + 1;
    *tmp_ssa_1 = b;
    }
  } else {
    {
    __cil_tmp21 = (unsigned char *)cp + 32;
    __cil_tmp22 = (long *)__cil_tmp21;
    __cil_tmp23 = *__cil_tmp22;
    __cil_tmp24 = (unsigned char *)cp + 32;
    __cil_tmp25 = (long *)__cil_tmp24;
    *__cil_tmp25 = __cil_tmp23 + 1L;
    }
  }
  }
  return;
}
}
static void reginsert(struct comp *cp , char op , char *opnd ) 
{ 
  char *place_ssa_1 ;
  char *tmp_ssa_1 ;
  char *place_ssa_2 ;
  char *tmp___0_ssa_1 ;
  char *place_ssa_3 ;
  char *tmp___1_ssa_1 ;
  int __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  char **__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  char (*__cil_tmp20)[3] ;
  char *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  long *__cil_tmp26 ;
  long __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  long *__cil_tmp29 ;
  char *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  char **__cil_tmp32 ;
  char *__cil_tmp33 ;
  long __cil_tmp34 ;
  unsigned char *__cil_tmp35 ;
  char **__cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned char *__cil_tmp38 ;
  char **__cil_tmp39 ;
  {
  {
  __cil_tmp16 = (unsigned char *)cp + 16;
  __cil_tmp17 = (char **)__cil_tmp16;
  __cil_tmp18 = *__cil_tmp17;
  __cil_tmp19 = (unsigned char *)cp + 24;
  __cil_tmp20 = (char (*)[3])__cil_tmp19;
  __cil_tmp21 = *__cil_tmp20;
  __cil_tmp22 = (unsigned long )__cil_tmp18;
  __cil_tmp23 = (unsigned long )__cil_tmp21;
  __cil_tmp24 = __cil_tmp22 != __cil_tmp23;
  __cil_tmp15 = ! __cil_tmp24;
  if (__cil_tmp15) {
    {
    __cil_tmp25 = (unsigned char *)cp + 32;
    __cil_tmp26 = (long *)__cil_tmp25;
    __cil_tmp27 = *__cil_tmp26;
    __cil_tmp28 = (unsigned char *)cp + 32;
    __cil_tmp29 = (long *)__cil_tmp28;
    *__cil_tmp29 = __cil_tmp27 + 3L;
    }
    return;
  } else {
    {
    __cil_tmp30 = opnd + 3;
    __cil_tmp31 = (unsigned char *)cp + 16;
    __cil_tmp32 = (char **)__cil_tmp31;
    __cil_tmp33 = *__cil_tmp32;
    __cil_tmp34 = __cil_tmp33 - opnd;
    memmove((void *)__cil_tmp30, (void const   *)opnd, (size_t )__cil_tmp34);
    __cil_tmp35 = (unsigned char *)cp + 16;
    __cil_tmp36 = (char **)__cil_tmp35;
    __cil_tmp37 = *__cil_tmp36;
    __cil_tmp38 = (unsigned char *)cp + 16;
    __cil_tmp39 = (char **)__cil_tmp38;
    *__cil_tmp39 = __cil_tmp37 + 3;
    place_ssa_1 = opnd;
    tmp_ssa_1 = place_ssa_1;
    place_ssa_2 = place_ssa_1 + 1;
    *tmp_ssa_1 = op;
    tmp___0_ssa_1 = place_ssa_2;
    place_ssa_3 = place_ssa_2 + 1;
    *tmp___0_ssa_1 = (char )'\000';
    tmp___1_ssa_1 = place_ssa_3;
    *tmp___1_ssa_1 = (char )'\000';
    }
    return;
  }
  }
}
}
static void regtail(struct comp *cp , char *p , char *val ) 
{ 
  char *scan ;
  char *temp ;
  int offset ;
  {
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
    return;
  }
  scan = p;
  while (1) {
    temp = regnext(scan);
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
      break;
    }
    goto __Cont;
    __Cont: /* CIL Label */ 
    scan = temp;
  }
  if ((int )*scan == 7) {
    offset = (int )(scan - val);
  } else {
    offset = (int )(val - scan);
  }
  *(scan + 1) = (char )((offset >> 8) & 127);
  *(scan + 2) = (char )(offset & 255);
  return;
}
}
static void regoptail(struct comp *cp , char *p , char *val ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  char **__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  char (*__cil_tmp10)[3] ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  char __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  {
  {
  __cil_tmp6 = (unsigned char *)cp + 16;
  __cil_tmp7 = (char **)__cil_tmp6;
  __cil_tmp8 = *__cil_tmp7;
  __cil_tmp9 = (unsigned char *)cp + 24;
  __cil_tmp10 = (char (*)[3])__cil_tmp9;
  __cil_tmp11 = *__cil_tmp10;
  __cil_tmp12 = (unsigned long )__cil_tmp8;
  __cil_tmp13 = (unsigned long )__cil_tmp11;
  __cil_tmp14 = __cil_tmp12 != __cil_tmp13;
  __cil_tmp4 = ! __cil_tmp14;
  if (__cil_tmp4) {
    return;
  } else {
    {
    __cil_tmp15 = *p;
    __cil_tmp16 = (int )__cil_tmp15;
    __cil_tmp5 = __cil_tmp16 != 6;
    if (__cil_tmp5) {
      return;
    } else {
      {
      __cil_tmp17 = p + 3;
      regtail(cp, __cil_tmp17, val);
      }
      return;
    }
    }
  }
  }
}
}
int regexec(regexp *prog , char const   *str ) 
{ 
  struct exec ex ;
  int __cil_ret10 ;
  int __cil_ret12 ;
  struct exec *__cil_pp_ex  = & ex;
  int *__cil_pp___cil_ret10  = & __cil_ret10;
  int *__cil_pp___cil_ret12  = & __cil_ret12;
  int *__cil_fp___cil_ret10  = & __cil_ret10;
  int *__cil_fp___cil_ret12  = & __cil_ret12;
  char *string_ssa_1 ;
  char *tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  char *s_ssa_1 ;
  int retflag11_ssa_1 ;
  int __cil_ret10_ssa_1 ;
  int retflag13_ssa_1 ;
  int __cil_ret12_ssa_1 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  char __cil_tmp32 ;
  int __cil_tmp33 ;
  char __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  char (*__cil_tmp37)[1] ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char __cil_tmp40 ;
  unsigned char __cil_tmp41 ;
  int __cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  char **__cil_tmp44 ;
  char *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  char **__cil_tmp48 ;
  char *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  char **__cil_tmp51 ;
  unsigned char *__cil_tmp52 ;
  char ***__cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  char *(*__cil_tmp55)[10] ;
  unsigned char *__cil_tmp56 ;
  char ***__cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char __cil_tmp62 ;
  int __cil_tmp63 ;
  unsigned char *__cil_tmp64 ;
  char **__cil_tmp65 ;
  unsigned char *__cil_tmp66 ;
  char ***__cil_tmp67 ;
  unsigned char *__cil_tmp68 ;
  char *(*__cil_tmp69)[10] ;
  unsigned char *__cil_tmp70 ;
  char ***__cil_tmp71 ;
  unsigned char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  unsigned char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char __cil_tmp76 ;
  int __cil_tmp77 ;
  {
  {
  string_ssa_1 = (char *)str;
  }
  {
  __cil_tmp27 = (unsigned long )prog == (unsigned long )((void *)0);
  if (__cil_tmp27) {
    {
    regerror((char *)"NULL argument to regexec");
    }
    return (0);
  } else {
    {
    __cil_tmp28 = (unsigned long )string_ssa_1 == (unsigned long )((void *)0);
    if (__cil_tmp28) {
      {
      regerror((char *)"NULL argument to regexec");
      }
      return (0);
    } else {
      {
      __cil_tmp36 = (unsigned char *)prog + 180;
      __cil_tmp37 = (char (*)[1])__cil_tmp36;
      __cil_tmp38 = *__cil_tmp37;
      __cil_tmp39 = (char *)__cil_tmp38;
      __cil_tmp40 = *__cil_tmp39;
      __cil_tmp41 = (unsigned char )__cil_tmp40;
      __cil_tmp42 = (int )__cil_tmp41;
      __cil_tmp29 = __cil_tmp42 != 156;
      if (__cil_tmp29) {
        {
        regerror((char *)"corrupted regexp");
        }
        return (0);
      } else {
        {
        __cil_tmp43 = (unsigned char *)prog + 168;
        __cil_tmp44 = (char **)__cil_tmp43;
        __cil_tmp45 = *__cil_tmp44;
        __cil_tmp46 = (unsigned long )__cil_tmp45;
        __cil_tmp30 = __cil_tmp46 != (unsigned long )((void *)0);
        if (__cil_tmp30) {
          {
          __cil_tmp47 = (unsigned char *)prog + 168;
          __cil_tmp48 = (char **)__cil_tmp47;
          __cil_tmp49 = *__cil_tmp48;
          tmp_ssa_1 = strstr((char const   *)string_ssa_1, (char const   *)__cil_tmp49);
          }
          {
          __cil_tmp31 = (unsigned long )tmp_ssa_1 == (unsigned long )((void *)0);
          if (__cil_tmp31) {
            return (0);
          } else {
            {
            __cil_tmp50 = (unsigned char *)__cil_pp_ex + 8;
            __cil_tmp51 = (char **)__cil_tmp50;
            *__cil_tmp51 = string_ssa_1;
            __cil_tmp52 = (unsigned char *)__cil_pp_ex + 16;
            __cil_tmp53 = (char ***)__cil_tmp52;
            *__cil_tmp53 = *((char *(*)[10])prog);
            __cil_tmp54 = (unsigned char *)prog + 80;
            __cil_tmp55 = (char *(*)[10])__cil_tmp54;
            __cil_tmp56 = (unsigned char *)__cil_pp_ex + 24;
            __cil_tmp57 = (char ***)__cil_tmp56;
            *__cil_tmp57 = *__cil_tmp55;
            }
            {
            __cil_tmp58 = (unsigned char *)prog + 161;
            __cil_tmp59 = (char *)__cil_tmp58;
            __cil_tmp32 = *__cil_tmp59;
            if (__cil_tmp32) {
              {
              tmp___0_ssa_1 = regtry(__cil_pp_ex, prog, string_ssa_1);
              }
              return (tmp___0_ssa_1);
            } else {
              {
              __cil_tmp60 = (unsigned char *)prog + 160;
              __cil_tmp61 = (char *)__cil_tmp60;
              __cil_tmp62 = *__cil_tmp61;
              __cil_tmp63 = (int )__cil_tmp62;
              __cil_tmp33 = __cil_tmp63 != 0;
              if (__cil_tmp33) {
                {
                s_ssa_1 = string_ssa_1;
                }
                {
                {
                *__cil_fp___cil_ret10 = __cil_ret10;
                retflag11_ssa_1 = regexec_cil_lr_1(__cil_pp___cil_ret10, prog, s_ssa_1,
                                                   ex);
                __cil_ret10_ssa_1 = *__cil_fp___cil_ret10;
                }
                if (retflag11_ssa_1) {
                  return (__cil_ret10_ssa_1);
                } else {
                  return (0);
                }
                }
              } else {
                {
                s_ssa_1 = string_ssa_1;
                }
                {
                {
                *__cil_fp___cil_ret12 = __cil_ret12;
                retflag13_ssa_1 = regexec_cil_lr_2(__cil_pp___cil_ret12, prog, s_ssa_1,
                                                   ex);
                __cil_ret12_ssa_1 = *__cil_fp___cil_ret12;
                }
                if (retflag13_ssa_1) {
                  return (__cil_ret12_ssa_1);
                } else {
                  return (1);
                }
                }
              }
              }
            }
            }
          }
          }
        } else {
          {
          __cil_tmp64 = (unsigned char *)__cil_pp_ex + 8;
          __cil_tmp65 = (char **)__cil_tmp64;
          *__cil_tmp65 = string_ssa_1;
          __cil_tmp66 = (unsigned char *)__cil_pp_ex + 16;
          __cil_tmp67 = (char ***)__cil_tmp66;
          *__cil_tmp67 = *((char *(*)[10])prog);
          __cil_tmp68 = (unsigned char *)prog + 80;
          __cil_tmp69 = (char *(*)[10])__cil_tmp68;
          __cil_tmp70 = (unsigned char *)__cil_pp_ex + 24;
          __cil_tmp71 = (char ***)__cil_tmp70;
          *__cil_tmp71 = *__cil_tmp69;
          }
          {
          __cil_tmp72 = (unsigned char *)prog + 161;
          __cil_tmp73 = (char *)__cil_tmp72;
          __cil_tmp34 = *__cil_tmp73;
          if (__cil_tmp34) {
            {
            tmp___0_ssa_1 = regtry(__cil_pp_ex, prog, string_ssa_1);
            }
            return (tmp___0_ssa_1);
          } else {
            {
            __cil_tmp74 = (unsigned char *)prog + 160;
            __cil_tmp75 = (char *)__cil_tmp74;
            __cil_tmp76 = *__cil_tmp75;
            __cil_tmp77 = (int )__cil_tmp76;
            __cil_tmp35 = __cil_tmp77 != 0;
            if (__cil_tmp35) {
              {
              s_ssa_1 = string_ssa_1;
              }
              {
              {
              *__cil_fp___cil_ret10 = __cil_ret10;
              retflag11_ssa_1 = regexec_cil_lr_1(__cil_pp___cil_ret10, prog, s_ssa_1,
                                                 ex);
              __cil_ret10_ssa_1 = *__cil_fp___cil_ret10;
              }
              if (retflag11_ssa_1) {
                return (__cil_ret10_ssa_1);
              } else {
                return (0);
              }
              }
            } else {
              {
              s_ssa_1 = string_ssa_1;
              }
              {
              {
              *__cil_fp___cil_ret12 = __cil_ret12;
              retflag13_ssa_1 = regexec_cil_lr_2(__cil_pp___cil_ret12, prog, s_ssa_1,
                                                 ex);
              __cil_ret12_ssa_1 = *__cil_fp___cil_ret12;
              }
              if (retflag13_ssa_1) {
                return (__cil_ret12_ssa_1);
              } else {
                return (1);
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
}
}
static int regtry(struct exec *ep , regexp *prog , char *string ) 
{ 
  struct exec **__cil_pp_ep  = & ep;
  regexp **__cil_pp_prog  = & prog;
  char **__cil_pp_string  = & string;
  struct exec **__cil_fp_ep  = & ep;
  regexp **__cil_fp_prog  = & prog;
  char **__cil_fp_string  = & string;
  char **stp_ssa_1 ;
  char **enp_ssa_1 ;
  int i_ssa_1 ;
  struct exec *ep_ssa_1 ;
  regexp *prog_ssa_1 ;
  char *string_ssa_1 ;
  int tmp___1_ssa_1 ;
  unsigned char *__cil_tmp23 ;
  char *(*__cil_tmp24)[10] ;
  unsigned char *__cil_tmp25 ;
  char (*__cil_tmp26)[1] ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char **__cil_tmp29 ;
  char **__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  char *(*__cil_tmp32)[10] ;
  char **__cil_tmp33 ;
  char **__cil_tmp34 ;
  {
  {
  *((char **)ep) = string;
  stp_ssa_1 = *((char *(*)[10])prog);
  __cil_tmp23 = (unsigned char *)prog + 80;
  __cil_tmp24 = (char *(*)[10])__cil_tmp23;
  enp_ssa_1 = *__cil_tmp24;
  i_ssa_1 = 10;
  }
  {
  *__cil_fp_ep = ep;
  *__cil_fp_prog = prog;
  *__cil_fp_string = string;
  regtry_cil_lr_1(__cil_pp_ep, __cil_pp_prog, __cil_pp_string, i_ssa_1, stp_ssa_1,
                  enp_ssa_1);
  ep_ssa_1 = *__cil_fp_ep;
  prog_ssa_1 = *__cil_fp_prog;
  string_ssa_1 = *__cil_fp_string;
  }
  {
  __cil_tmp25 = (unsigned char *)prog_ssa_1 + 180;
  __cil_tmp26 = (char (*)[1])__cil_tmp25;
  __cil_tmp27 = *__cil_tmp26;
  __cil_tmp28 = __cil_tmp27 + 1;
  tmp___1_ssa_1 = regmatch(ep_ssa_1, __cil_tmp28);
  }
  if (tmp___1_ssa_1) {
    {
    __cil_tmp29 = *((char *(*)[10])prog_ssa_1);
    __cil_tmp30 = (char **)__cil_tmp29;
    *__cil_tmp30 = string_ssa_1;
    __cil_tmp31 = (unsigned char *)prog_ssa_1 + 80;
    __cil_tmp32 = (char *(*)[10])__cil_tmp31;
    __cil_tmp33 = *__cil_tmp32;
    __cil_tmp34 = (char **)__cil_tmp33;
    *__cil_tmp34 = *((char **)ep_ssa_1);
    }
    return (1);
  } else {
    return (0);
  }
}
}
static int regmatch(struct exec *ep , char *prog ) 
{ 
  char *scan ;
  char *next ;
  size_t len ;
  char *opnd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int no ;
  char *input ;
  int tmp___2 ;
  int no___0 ;
  char *input___0 ;
  int tmp___3 ;
  char *save ;
  int tmp___4 ;
  char nextch ;
  int tmp___5 ;
  size_t no___1 ;
  char *save___0 ;
  size_t min ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  {
  scan = prog;
  while ((unsigned long )scan != (unsigned long )((void *)0)) {
    next = regnext(scan);
    switch ((int )*scan) {
    case 1: 
    if ((unsigned long )ep->reginput != (unsigned long )ep->regbol) {
      return (0);
    }
    break;
    case 2: 
    if ((int )*(ep->reginput) != 0) {
      return (0);
    }
    break;
    case 3: 
    if ((int )*(ep->reginput) == 0) {
      return (0);
    }
    (ep->reginput) ++;
    break;
    case 8: 
    opnd = scan + 3;
    if ((int )*opnd != (int )*(ep->reginput)) {
      return (0);
    }
    len = strlen((char const   *)opnd);
    if (len > 1UL) {
      tmp = strncmp((char const   *)opnd, (char const   *)ep->reginput, len);
      if (tmp != 0) {
        return (0);
      }
    }
    ep->reginput += len;
    break;
    case 4: 
    if ((int )*(ep->reginput) == 0) {
      return (0);
    } else {
      tmp___0 = strchr((char const   *)(scan + 3), (int )*(ep->reginput));
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        return (0);
      }
    }
    (ep->reginput) ++;
    break;
    case 5: 
    if ((int )*(ep->reginput) == 0) {
      return (0);
    } else {
      tmp___1 = strchr((char const   *)(scan + 3), (int )*(ep->reginput));
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        return (0);
      }
    }
    (ep->reginput) ++;
    break;
    case 9: 
    break;
    case 7: 
    break;
    case 29: 
    case 28: 
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 21: 
    no = (int )*scan - 20;
    input = ep->reginput;
    tmp___2 = regmatch(ep, next);
    if (tmp___2) {
      if ((unsigned long )*(ep->regstartp + no) == (unsigned long )((void *)0)) {
        *(ep->regstartp + no) = input;
      }
      return (1);
    } else {
      return (0);
    }
    break;
    case 39: 
    case 38: 
    case 37: 
    case 36: 
    case 35: 
    case 34: 
    case 33: 
    case 32: 
    case 31: 
    no___0 = (int )*scan - 30;
    input___0 = ep->reginput;
    tmp___3 = regmatch(ep, next);
    if (tmp___3) {
      if ((unsigned long )*(ep->regendp + no___0) == (unsigned long )((void *)0)) {
        *(ep->regendp + no___0) = input___0;
      }
      return (1);
    } else {
      return (0);
    }
    break;
    case 6: 
    save = ep->reginput;
    if ((int )*next != 6) {
      next = scan + 3;
    } else {
      while ((int )*scan == 6) {
        tmp___4 = regmatch(ep, scan + 3);
        if (tmp___4) {
          return (1);
        }
        ep->reginput = save;
        scan = regnext(scan);
      }
      return (0);
    }
    break;
    case 11: 
    case 10: 
    if ((int )*next == 8) {
      tmp___5 = (int )*(next + 3);
    } else {
      tmp___5 = '\000';
    }
    nextch = (char )tmp___5;
    save___0 = ep->reginput;
    if ((int )*scan == 10) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    min = (size_t )tmp___6;
    tmp___7 = regrepeat(ep, scan + 3);
    no___1 = tmp___7 + 1UL;
    while (no___1 > min) {
      ep->reginput = (save___0 + no___1) - 1;
      if ((int )nextch == 0) {
        goto _L;
      } else
      if ((int )*(ep->reginput) == (int )nextch) {
        _L: /* CIL Label */ 
        tmp___8 = regmatch(ep, next);
        if (tmp___8) {
          return (1);
        }
      }
      no___1 --;
    }
    return (0);
    break;
    case 0: 
    return (1);
    break;
    default: 
    regerror((char *)"regexp corruption");
    return (0);
    break;
    }
    scan = next;
  }
  regerror((char *)"corrupted pointers");
  return (0);
}
}
static size_t ( __attribute__((__noinline__)) regrepeat)(struct exec *ep , char *node ) 
{ 
  size_t count ;
  char *scan ;
  char ch ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  {
  switch ((int )*node) {
  case 3: 
  tmp = strlen((char const   *)ep->reginput);
  return (tmp);
  break;
  case 8: 
  ch = *(node + 3);
  count = (size_t )0;
  scan = ep->reginput;
  while ((int )*scan == (int )ch) {
    count ++;
    scan ++;
  }
  return (count);
  break;
  case 4: 
  tmp___0 = strspn((char const   *)ep->reginput, (char const   *)(node + 3));
  return (tmp___0);
  break;
  case 5: 
  tmp___1 = strcspn((char const   *)ep->reginput, (char const   *)(node + 3));
  return (tmp___1);
  break;
  default: 
  regerror((char *)"internal error: bad call of regrepeat");
  return ((size_t )0);
  break;
  }
  return (0UL);
}
}
static char *regnext(char *p ) 
{ 
  char *tmp ;
  int offset_ssa_1 ;
  char *tmp_ssa_1 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char __cil_tmp17 ;
  int __cil_tmp18 ;
  {
  {
  __cil_tmp8 = p + 1;
  __cil_tmp9 = *__cil_tmp8;
  __cil_tmp10 = (int )__cil_tmp9;
  __cil_tmp11 = __cil_tmp10 & 127;
  __cil_tmp12 = p + 2;
  __cil_tmp13 = *__cil_tmp12;
  __cil_tmp14 = (int )__cil_tmp13;
  __cil_tmp15 = __cil_tmp11 << 8;
  __cil_tmp16 = __cil_tmp14 & 255;
  offset_ssa_1 = __cil_tmp15 + __cil_tmp16;
  }
  {
  __cil_tmp6 = offset_ssa_1 == 0;
  if (__cil_tmp6) {
    return ((char *)0);
  } else {
    {
    __cil_tmp17 = *p;
    __cil_tmp18 = (int )__cil_tmp17;
    __cil_tmp7 = __cil_tmp18 == 7;
    if (__cil_tmp7) {
      {
      tmp_ssa_1 = p - offset_ssa_1;
      }
    } else {
      {
      tmp_ssa_1 = p + offset_ssa_1;
      }
    }
    }
    return (tmp_ssa_1);
  }
  }
  return (tmp);
}
}
void regtry_cil_lr_1(struct exec **__cil_ap_ep , regexp **__cil_ap_prog , char **__cil_ap_string ,
                     int i , char **stp , char **enp ) 
{ 
  char **tmp_ssa_1 ;
  char **stp_ssa_1 ;
  char **tmp___0_ssa_1 ;
  char **enp_ssa_1 ;
  int i_ssa_1 ;
  int __cil_tmp14 ;
  {
  {
  __cil_tmp14 = i > 0;
  if (__cil_tmp14) {
    {
    tmp_ssa_1 = stp;
    stp_ssa_1 = stp + 1;
    *tmp_ssa_1 = (char *)0;
    tmp___0_ssa_1 = enp;
    enp_ssa_1 = enp + 1;
    *tmp___0_ssa_1 = (char *)0;
    i_ssa_1 = i - 1;
    }
    {
    regtry_cil_lr_1(__cil_ap_ep, __cil_ap_prog, __cil_ap_string, i_ssa_1, stp_ssa_1,
                    enp_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
}
}
int regexec_cil_lr_1(int *__cil_ap___cil_ret10 , regexp *prog , char *s , struct exec ex ) 
{ 
  struct exec *__cil_pp_ex  = & ex;
  int tmp___1_ssa_1 ;
  char *s_ssa_1 ;
  int retflag6_ssa_1 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char __cil_tmp15 ;
  {
  {
  __cil_tmp11 = (unsigned long )s != (unsigned long )((void *)0);
  if (__cil_tmp11) {
    {
    tmp___1_ssa_1 = regtry(__cil_pp_ex, prog, s);
    }
    if (tmp___1_ssa_1) {
      {
      {
      *__cil_ap___cil_ret10 = 1;
      }
      return (1);
      }
    } else {
      {
      __cil_tmp12 = s + 1;
      __cil_tmp13 = (unsigned char *)prog + 160;
      __cil_tmp14 = (char *)__cil_tmp13;
      __cil_tmp15 = *__cil_tmp14;
      s_ssa_1 = strchr((char const   *)__cil_tmp12, (int )__cil_tmp15);
      }
      {
      retflag6_ssa_1 = regexec_cil_lr_1(__cil_ap___cil_ret10, prog, s_ssa_1, ex);
      }
      return (retflag6_ssa_1);
    }
  } else {
    return (0);
  }
  }
}
}
int regexec_cil_lr_2(int *__cil_ap___cil_ret12 , regexp *prog , char *s , struct exec ex ) 
{ 
  struct exec *__cil_pp_ex  = & ex;
  int tmp___2_ssa_1 ;
  char *s_ssa_1 ;
  int retflag6_ssa_1 ;
  int __cil_tmp11 ;
  char __cil_tmp12 ;
  int __cil_tmp13 ;
  {
  {
  tmp___2_ssa_1 = regtry(__cil_pp_ex, prog, s);
  }
  if (tmp___2_ssa_1) {
    return (0);
  } else {
    {
    __cil_tmp12 = *s;
    __cil_tmp13 = (int )__cil_tmp12;
    __cil_tmp11 = __cil_tmp13 == 0;
    if (__cil_tmp11) {
      {
      {
      *__cil_ap___cil_ret12 = 0;
      }
      return (1);
      }
    } else {
      {
      s_ssa_1 = s + 1;
      }
      {
      retflag6_ssa_1 = regexec_cil_lr_2(__cil_ap___cil_ret12, prog, s_ssa_1, ex);
      }
      return (retflag6_ssa_1);
    }
    }
  }
}
}
int regbranch_cil_lr_1(struct comp **__cil_ap_cp , char **__cil_ap_ret , char **__cil_ap_chain ,
                       char **__cil_ap___cil_ret8 , int *flagp , int flags ) 
{ 
  char *latest ;
  int *__cil_pp_flags  = & flags;
  int *__cil_fp_flags  = & flags;
  int c_ssa_1 ;
  char *latest_ssa_1 ;
  int flags_ssa_1 ;
  int retflag9_ssa_1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  struct comp *__cil_tmp21 ;
  char **__cil_tmp22 ;
  char *__cil_tmp23 ;
  char __cil_tmp24 ;
  struct comp *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  struct comp *__cil_tmp32 ;
  char *__cil_tmp33 ;
  {
  {
  __cil_tmp21 = *__cil_ap_cp;
  __cil_tmp22 = (char **)__cil_tmp21;
  __cil_tmp23 = *__cil_tmp22;
  __cil_tmp24 = *__cil_tmp23;
  c_ssa_1 = (int )__cil_tmp24;
  }
  {
  __cil_tmp16 = c_ssa_1 != 0;
  if (__cil_tmp16) {
    {
    __cil_tmp17 = c_ssa_1 != 124;
    if (__cil_tmp17) {
      {
      __cil_tmp18 = c_ssa_1 != 41;
      if (__cil_tmp18) {
        {
        *__cil_fp_flags = flags;
        __cil_tmp25 = *__cil_ap_cp;
        latest_ssa_1 = regpiece(__cil_tmp25, __cil_pp_flags);
        flags_ssa_1 = *__cil_fp_flags;
        }
        {
        __cil_tmp19 = (unsigned long )latest_ssa_1 == (unsigned long )((void *)0);
        if (__cil_tmp19) {
          {
          {
          *__cil_ap___cil_ret8 = (char *)0;
          }
          return (1);
          }
        } else {
          {
          __cil_tmp26 = *flagp;
          __cil_tmp27 = flags_ssa_1 & 1;
          *flagp = __cil_tmp26 | __cil_tmp27;
          }
          {
          __cil_tmp28 = *__cil_ap_chain;
          __cil_tmp29 = (unsigned long )__cil_tmp28;
          __cil_tmp20 = __cil_tmp29 == (unsigned long )((void *)0);
          if (__cil_tmp20) {
            {
            __cil_tmp30 = *flagp;
            __cil_tmp31 = flags_ssa_1 & 4;
            *flagp = __cil_tmp30 | __cil_tmp31;
            }
          } else {
            {
            __cil_tmp32 = *__cil_ap_cp;
            __cil_tmp33 = *__cil_ap_chain;
            regtail(__cil_tmp32, __cil_tmp33, latest_ssa_1);
            }
          }
          }
          {
          *__cil_ap_chain = latest_ssa_1;
          }
          {
          retflag9_ssa_1 = regbranch_cil_lr_1(__cil_ap_cp, __cil_ap_ret, __cil_ap_chain,
                                              __cil_ap___cil_ret8, flagp, flags_ssa_1);
          }
          return (retflag9_ssa_1);
        }
        }
        {
        *__cil_ap_chain = latest;
        }
        {
        retflag9_ssa_1 = regbranch_cil_lr_1(__cil_ap_cp, __cil_ap_ret, __cil_ap_chain,
                                            __cil_ap___cil_ret8, flagp, flags);
        }
        return (retflag9_ssa_1);
      } else {
        return (0);
      }
      }
    } else {
      return (0);
    }
    }
  } else {
    return (0);
  }
  }
  {
  *__cil_ap_chain = latest;
  }
  {
  retflag9_ssa_1 = regbranch_cil_lr_1(__cil_ap_cp, __cil_ap_ret, __cil_ap_chain, __cil_ap___cil_ret8,
                                      flagp, flags);
  }
  return (retflag9_ssa_1);
}
}
void regcomp_cil_lr_1(regexp **__cil_ap_r , char **__cil_ap_longest , size_t *__cil_ap_len ,
                      char *scan ) 
{ 
  size_t tmp___2_ssa_1 ;
  char *scan_ssa_1 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  size_t __cil_tmp14 ;
  char *__cil_tmp15 ;
  {
  {
  __cil_tmp8 = (unsigned long )scan != (unsigned long )((void *)0);
  if (__cil_tmp8) {
    {
    __cil_tmp11 = *scan;
    __cil_tmp12 = (int )__cil_tmp11;
    __cil_tmp9 = __cil_tmp12 == 8;
    if (__cil_tmp9) {
      {
      __cil_tmp13 = scan + 3;
      tmp___2_ssa_1 = strlen((char const   *)__cil_tmp13);
      }
      {
      __cil_tmp14 = *__cil_ap_len;
      __cil_tmp10 = tmp___2_ssa_1 >= __cil_tmp14;
      if (__cil_tmp10) {
        {
        *__cil_ap_longest = scan + 3;
        __cil_tmp15 = scan + 3;
        *__cil_ap_len = strlen((char const   *)__cil_tmp15);
        }
      } else {
      }
      }
    } else {
    }
    }
    {
    scan_ssa_1 = regnext(scan);
    }
    {
    regcomp_cil_lr_1(__cil_ap_r, __cil_ap_longest, __cil_ap_len, scan_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
  {
  scan_ssa_1 = regnext(scan);
  }
  {
  regcomp_cil_lr_1(__cil_ap_r, __cil_ap_longest, __cil_ap_len, scan_ssa_1);
  }
  return;
}
}
