/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 86 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 109 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 216 "/usr/lib/gcc/x86_64-redhat-linux/5.1.1/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 60 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_4 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_4 pthread_mutex_t;
#line 130 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_5 {
   char __size[4] ;
   int __align ;
};
#line 130 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_5 pthread_mutexattr_t;
#line 139 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_7 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 139 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_6 {
   struct __anonstruct___data_7 __data ;
   char __size[48] ;
   long long __align ;
};
#line 139 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_6 pthread_cond_t;
#line 156 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_8 {
   char __size[4] ;
   int __align ;
};
#line 156 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_8 pthread_condattr_t;
#line 33 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 31 "/usr/include/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 525 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_36 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 525 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_35 {
   struct __anonstruct___cancel_jmp_buf_36 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 525 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_35  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 744
struct __jmp_buf_tag;
#line 744
struct __jmp_buf_tag;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 12 "telnet_session.h"
struct __anonstruct_telnet_session_t_52 {
   int in_fd ;
   int in_errno ;
   int in_eof ;
   int in_take ;
   int in_add ;
   char in_buf[2048] ;
   int in_buflen ;
   int in_status ;
   int out_fd ;
   int out_errno ;
   int out_eof ;
   int out_take ;
   int out_add ;
   char out_buf[2048] ;
   int out_buflen ;
};
#line 12 "telnet_session.h"
typedef struct __anonstruct_telnet_session_t_52 telnet_session_t;
#line 49 "af_portability.h"
typedef struct sockaddr_in sockaddr_storage_t;
#line 8 "error.h"
struct __anonstruct_error_t_53 {
   int error_code ;
   char desc[128] ;
};
#line 8 "error.h"
typedef struct __anonstruct_error_t_53 error_t;
#line 24 "watchdog.h"
struct watched {
   pthread_t watched_thread ;
   int in_list ;
   time_t alarm_time ;
   struct watched *older ;
   struct watched *newer ;
   void *watchdog ;
};
#line 24 "watchdog.h"
typedef struct watched watched_t;
#line 43 "watchdog.h"
struct __anonstruct_watchdog_t_54 {
   pthread_mutex_t mutex ;
   int inactivity_timeout ;
   watched_t *oldest ;
   watched_t *newest ;
};
#line 43 "watchdog.h"
typedef struct __anonstruct_watchdog_t_54 watchdog_t;
#line 37 "ftp_session.h"
struct __anonstruct_ftp_session_t_55 {
   int session_active ;
   unsigned long command_number ;
   int data_type ;
   int file_structure ;
   off_t file_offset ;
   unsigned long file_offset_command_number ;
   int epsv_all_set ;
   sockaddr_storage_t client_addr ;
   char client_addr_str[58] ;
   sockaddr_storage_t server_addr ;
   struct sockaddr_in server_ipv4_addr ;
   telnet_session_t *telnet_session ;
   char dir[4097] ;
   int data_channel ;
   sockaddr_storage_t data_port ;
   int server_fd ;
   watched_t *watched ;
};
#line 37 "ftp_session.h"
typedef struct __anonstruct_ftp_session_t_55 ftp_session_t;
#line 15 "ftp_listener.h"
struct __anonstruct_ftp_listener_t_56 {
   int fd ;
   int max_connections ;
   int num_connections ;
   int inactivity_timeout ;
   watchdog_t watchdog ;
   pthread_mutex_t mutex ;
   char dir[4097] ;
   int listener_running ;
   pthread_t listener_thread ;
   int shutdown_request_send_fd ;
   int shutdown_request_recv_fd ;
   pthread_cond_t shutdown_cond ;
};
#line 15 "ftp_listener.h"
typedef struct __anonstruct_ftp_listener_t_56 ftp_listener_t;
#line 64 "ftp_listener.c"
struct connection_info {
   ftp_listener_t *ftp_listener ;
   telnet_session_t telnet_session ;
   ftp_session_t ftp_session ;
   watched_t watched ;
   struct connection_info *next ;
};
#line 64 "ftp_listener.c"
typedef struct connection_info connection_info_t;
#line 106 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 398
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 412
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 235 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 244
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 273
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th ) ;
#line 277
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 512
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 682
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 694
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 735
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 745
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 751
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 970
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 991
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 190 "/usr/include/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 160 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 10 "daemon_assert.h"
extern void daemon_assert_fail(char const   *assertion , char const   *file , int line ,
                               char const   *function ) ;
#line 33 "telnet_session.h"
extern void telnet_session_init(telnet_session_t *t , int in , int out ) ;
#line 37
extern void telnet_session_destroy(telnet_session_t *t ) ;
#line 14 "error.h"
extern void error_init(error_t *err , int error_code , char const   *desc_fmt  , ...) ;
#line 16
extern char const   *error_get_desc(error_t const   *err ) ;
#line 52 "watchdog.h"
extern int watchdog_init(watchdog_t *w , int inactivity_timeout , error_t *err ) ;
#line 53
extern void watchdog_add_watched(watchdog_t *w , watched_t *watched ) ;
#line 55
extern void watchdog_remove_watched(watched_t *watched ) ;
#line 80 "ftp_session.h"
extern int ftp_session_init(ftp_session_t *f , sockaddr_storage_t const   *client_addr ,
                            sockaddr_storage_t const   *server_addr , telnet_session_t *t ,
                            char const   *dir , error_t *err ) ;
#line 86
extern void ftp_session_drop(ftp_session_t *f , char const   *reason ) ;
#line 87
extern void ftp_session_run(ftp_session_t *f , watched_t *watched ) ;
#line 88
extern void ftp_session_destroy(ftp_session_t *f ) ;
#line 55 "ftp_listener.h"
int ftp_listener_init(ftp_listener_t *f , char *address , int port , int max_connections ,
                      int inactivity_timeout , error_t *err ) ;
#line 61
int ftp_listener_start(ftp_listener_t *f , error_t *err ) ;
#line 62
void ftp_listener_stop(ftp_listener_t *f ) ;
#line 74 "ftp_listener.c"
static int invariant(ftp_listener_t const   *f ) ;
#line 75
static void *connection_acceptor(ftp_listener_t *f ) ;
#line 77
static void *connection_handler(connection_info_t *info ) ;
#line 78
static void connection_handler_cleanup(connection_info_t *info ) ;
void ftp_listener_stop_cil_lr_1(ftp_listener_t **__cil_ap_f ) ;
#line 81 "ftp_listener.c"
int ftp_listener_init(ftp_listener_t *f , char *address , int port , int max_connections ,
                      int inactivity_timeout , error_t *err ) 
{ 
  sockaddr_storage_t sock_addr ;
  int fd ;
  int flags ;
  int pipefds[2] ;
  int reuseaddr ;
  char dir[4097] ;
  char buf[101] ;
  char const   *inet_ntop_ret ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int gai_err ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  char const   *tmp___3 ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  unsigned short __v___1 ;
  unsigned short __x___1 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;

  {
#line 97
  if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 97
    daemon_assert_fail("f != ((void *)0)", "ftp_listener.c", 97, "ftp_listener_init");
  }
#line 98
  if (! (port >= 0)) {
#line 98
    daemon_assert_fail("port >= 0", "ftp_listener.c", 98, "ftp_listener_init");
  }
#line 99
  if (! (port < 65536)) {
#line 99
    daemon_assert_fail("port < 65536", "ftp_listener.c", 99, "ftp_listener_init");
  }
#line 100
  if (! (max_connections > 0)) {
#line 100
    daemon_assert_fail("max_connections > 0", "ftp_listener.c", 100, "ftp_listener_init");
  }
#line 101
  if (! ((unsigned long )err != (unsigned long )((void *)0))) {
#line 101
    daemon_assert_fail("err != ((void *)0)", "ftp_listener.c", 101, "ftp_listener_init");
  }
#line 104
  tmp___2 = getcwd(dir, sizeof(dir));
#line 104
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 105
    tmp = __errno_location();
#line 105
    tmp___0 = strerror(*tmp);
#line 105
    tmp___1 = __errno_location();
#line 105
    error_init(err, *tmp___1, "error getting current directory; %s", tmp___0);
#line 107
    return (0);
  }
#line 111
  memset((void *)(& sock_addr), 0, sizeof(sockaddr_storage_t ));
#line 113
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 118
    ((struct sockaddr *)(& sock_addr))->sa_family = (sa_family_t )2;
#line 119
    sock_addr.sin_addr.s_addr = (in_addr_t )0;
  } else {
#line 126
    memset((void *)(& hints), 0, sizeof(hints));
#line 141
    hints.ai_family = 2;
#line 144
    hints.ai_flags = 1;
#line 146
    gai_err = getaddrinfo((char const   */* __restrict  */)address, (char const   */* __restrict  */)((void *)0),
                          (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
#line 147
    if (gai_err != 0) {
#line 148
      tmp___3 = gai_strerror(gai_err);
#line 148
      error_init(err, gai_err, "error parsing server socket address; %s", tmp___3);
#line 150
      return (0);
    }
#line 153
    memcpy((void */* __restrict  */)(& sock_addr), (void const   */* __restrict  */)res->ai_addr,
           (size_t )res->ai_addrlen);
#line 154
    freeaddrinfo(res);
  }
#line 157
  if (port == 0) {
#line 158
    __x = (unsigned short)21;
#line 158
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 158
    sock_addr.sin_port = __v;
  } else {
#line 160
    __x___0 = (unsigned short )port;
#line 160
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 160
    sock_addr.sin_port = __v___0;
  }
#line 164
  inet_ntop_ret = inet_ntop((int )((struct sockaddr *)(& sock_addr))->sa_family, (void const   */* __restrict  */)((void *)(& sock_addr.sin_addr)),
                            (char */* __restrict  */)(buf), (socklen_t )sizeof(buf));
#line 168
  if ((unsigned long )inet_ntop_ret == (unsigned long )((void *)0)) {
#line 169
    tmp___4 = __errno_location();
#line 169
    tmp___5 = strerror(*tmp___4);
#line 169
    tmp___6 = __errno_location();
#line 169
    error_init(err, *tmp___6, "error converting server address to ASCII; %s", tmp___5);
#line 171
    return (0);
  }
#line 176
  __x___1 = sock_addr.sin_port;
#line 176
  __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 176
  syslog(6, "Binding interface \'%s\', port %d, max clients %d\n", buf, (int )__v___1,
         max_connections);
#line 180
  fd = socket(2, 1, 0);
#line 181
  if (fd == -1) {
#line 182
    tmp___7 = __errno_location();
#line 182
    tmp___8 = strerror(*tmp___7);
#line 182
    tmp___9 = __errno_location();
#line 182
    error_init(err, *tmp___9, "error creating socket; %s", tmp___8);
#line 183
    return (0);
  }
#line 186
  reuseaddr = 1;
#line 187
  tmp___13 = setsockopt(fd, 1, 2, (void const   *)((void *)(& reuseaddr)), (socklen_t )sizeof(int ));
#line 187
  if (tmp___13 != 0) {
#line 190
    close(fd);
#line 191
    tmp___10 = __errno_location();
#line 191
    tmp___11 = strerror(*tmp___10);
#line 191
    tmp___12 = __errno_location();
#line 191
    error_init(err, *tmp___12, "error setting socket to reuse address; %s", tmp___11);
#line 193
    return (0);
  }
#line 196
  tmp___17 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& sock_addr)),
                  (socklen_t )sizeof(struct sockaddr_in ));
#line 196
  if (tmp___17 != 0) {
#line 199
    close(fd);
#line 200
    tmp___14 = __errno_location();
#line 200
    tmp___15 = strerror(*tmp___14);
#line 200
    tmp___16 = __errno_location();
#line 200
    error_init(err, *tmp___16, "error binding address; %s", tmp___15);
#line 201
    return (0);
  }
#line 204
  tmp___21 = listen(fd, 128);
#line 204
  if (tmp___21 != 0) {
#line 205
    close(fd);
#line 206
    tmp___18 = __errno_location();
#line 206
    tmp___19 = strerror(*tmp___18);
#line 206
    tmp___20 = __errno_location();
#line 206
    error_init(err, *tmp___20, "error setting socket to listen; %s", tmp___19);
#line 208
    return (0);
  }
#line 212
  flags = fcntl(fd, 3);
#line 213
  if (flags == -1) {
#line 214
    close(fd);
#line 215
    tmp___22 = __errno_location();
#line 215
    tmp___23 = strerror(*tmp___22);
#line 215
    tmp___24 = __errno_location();
#line 215
    error_init(err, *tmp___24, "error getting flags on socket; %s", tmp___23);
#line 217
    return (0);
  }
#line 219
  tmp___28 = fcntl(fd, 4, flags | 2048);
#line 219
  if (tmp___28 != 0) {
#line 220
    close(fd);
#line 221
    tmp___25 = __errno_location();
#line 221
    tmp___26 = strerror(*tmp___25);
#line 221
    tmp___27 = __errno_location();
#line 221
    error_init(err, *tmp___27, "error setting socket to non-blocking; %s", tmp___26);
#line 223
    return (0);
  }
#line 227
  tmp___32 = pipe((int *)(pipefds));
#line 227
  if (tmp___32 != 0) {
#line 228
    close(fd);
#line 229
    tmp___29 = __errno_location();
#line 229
    tmp___30 = strerror(*tmp___29);
#line 229
    tmp___31 = __errno_location();
#line 229
    error_init(err, *tmp___31, "error creating pipe for internal use; %s", tmp___30);
#line 231
    return (0);
  }
#line 236
  f->fd = fd;
#line 237
  f->max_connections = max_connections;
#line 238
  f->num_connections = 0;
#line 239
  f->inactivity_timeout = inactivity_timeout;
#line 240
  pthread_mutex_init(& f->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 242
  tmp___33 = strlen((char const   *)(dir));
#line 242
  if (! (tmp___33 < sizeof(f->dir))) {
#line 242
    daemon_assert_fail("strlen(dir) < sizeof(f->dir)", "ftp_listener.c", 242, "ftp_listener_init");
  }
#line 243
  strcpy((char */* __restrict  */)(f->dir), (char const   */* __restrict  */)(dir));
#line 244
  f->listener_running = 0;
#line 246
  f->shutdown_request_send_fd = pipefds[1];
#line 247
  f->shutdown_request_recv_fd = pipefds[0];
#line 248
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& f->shutdown_cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 250
  tmp___34 = invariant((ftp_listener_t const   *)f);
#line 250
  if (! tmp___34) {
#line 250
    daemon_assert_fail("invariant(f)", "ftp_listener.c", 250, "ftp_listener_init");
  }
#line 251
  return (1);
}
}
#line 255 "ftp_listener.c"
int ftp_listener_start(ftp_listener_t *f , error_t *err ) 
{ 
  pthread_t thread_id ;
  pthread_t *__cil_pp_thread_id  = & thread_id;
  void *(*__cil_pp_connection_acceptor)(ftp_listener_t *f )  = & connection_acceptor;
  pthread_t *__cil_fp_thread_id  = & thread_id;
  int tmp_ssa_1 ;
  int error_code_ssa_1 ;
  pthread_t thread_id_ssa_1 ;
  int ret_val_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int *__cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  pthread_t *__cil_tmp21 ;

  {
  {
#line 261
  tmp_ssa_1 = invariant((ftp_listener_t const   *)f);
  }
#line 261
  if (! tmp_ssa_1) {
    {
#line 261
    daemon_assert_fail("invariant(f)", "ftp_listener.c", 261, "ftp_listener_start");
    }
  }
  {
#line 262
  __cil_tmp16 = (unsigned long )err != (unsigned long )((void *)0);
#line 262
  if (! __cil_tmp16) {
    {
#line 262
    daemon_assert_fail("err != ((void *)0)", "ftp_listener.c", 262, "ftp_listener_start");
    }
  }
  }
  {
  *__cil_fp_thread_id = thread_id;
#line 264
  error_code_ssa_1 = pthread_create((pthread_t */* __restrict  */)__cil_pp_thread_id,
                                    (pthread_attr_t const   */* __restrict  */)0,
                                    (void *(*)(void * ))__cil_pp_connection_acceptor,
                                    (void */* __restrict  */)f);
  thread_id_ssa_1 = *__cil_fp_thread_id;
  }
  {
#line 269
  __cil_tmp17 = error_code_ssa_1 == 0;
#line 269
  if (__cil_tmp17) {
    {
#line 270
    __cil_tmp18 = (unsigned char *)f + 4220;
#line 270
    __cil_tmp19 = (int *)__cil_tmp18;
#line 270
    *__cil_tmp19 = 1;
#line 271
    __cil_tmp20 = (unsigned char *)f + 4224;
#line 271
    __cil_tmp21 = (pthread_t *)__cil_tmp20;
#line 271
    *__cil_tmp21 = thread_id_ssa_1;
#line 272
    ret_val_ssa_1 = 1;
    }
  } else {
    {
#line 274
    error_init(err, error_code_ssa_1, "unable to create thread");
#line 275
    ret_val_ssa_1 = 0;
    }
  }
  }
  {
#line 278
  tmp___0_ssa_1 = invariant((ftp_listener_t const   *)f);
  }
#line 278
  if (! tmp___0_ssa_1) {
    {
#line 278
    daemon_assert_fail("invariant(f)", "ftp_listener.c", 278, "ftp_listener_start");
    }
  }
#line 280
  return (ret_val_ssa_1);
}
}
#line 285 "ftp_listener.c"
static int invariant(ftp_listener_t const   *f ) 
{ 
  size_t tmp_ssa_1 ;
  int dir_len_ssa_1 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  int *__cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  int *__cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  int *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  int *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  char (*__cil_tmp29)[4097] ;
  char *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  int *__cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  int *__cil_tmp35 ;
  int __cil_tmp36 ;

  {
  {
#line 289
  __cil_tmp6 = (unsigned long )f == (unsigned long )((void *)0);
#line 289
  if (__cil_tmp6) {
#line 290
    return (0);
  } else {
    {
#line 292
    __cil_tmp15 = *((int *)f);
#line 292
    __cil_tmp7 = __cil_tmp15 < 0;
#line 292
    if (__cil_tmp7) {
#line 293
      return (0);
    } else {
      {
#line 295
      __cil_tmp16 = (unsigned char *)f + 4;
#line 295
      __cil_tmp17 = (int *)__cil_tmp16;
#line 295
      __cil_tmp18 = *__cil_tmp17;
#line 295
      __cil_tmp8 = __cil_tmp18 <= 0;
#line 295
      if (__cil_tmp8) {
#line 296
        return (0);
      } else {
        {
#line 298
        __cil_tmp19 = (unsigned char *)f + 8;
#line 298
        __cil_tmp20 = (int *)__cil_tmp19;
#line 298
        __cil_tmp21 = *__cil_tmp20;
#line 298
        __cil_tmp9 = __cil_tmp21 < 0;
#line 298
        if (__cil_tmp9) {
#line 299
          return (0);
        } else {
          {
#line 298
          __cil_tmp22 = (unsigned char *)f + 8;
#line 298
          __cil_tmp23 = (int *)__cil_tmp22;
#line 298
          __cil_tmp24 = (unsigned char *)f + 4;
#line 298
          __cil_tmp25 = (int *)__cil_tmp24;
#line 298
          __cil_tmp26 = *__cil_tmp23;
#line 298
          __cil_tmp27 = *__cil_tmp25;
#line 298
          __cil_tmp10 = __cil_tmp26 > __cil_tmp27;
#line 298
          if (__cil_tmp10) {
#line 299
            return (0);
          } else {
            {
#line 301
            __cil_tmp28 = (unsigned char *)f + 120;
#line 301
            __cil_tmp29 = (char (*)[4097])__cil_tmp28;
#line 301
            __cil_tmp30 = *__cil_tmp29;
#line 301
            tmp_ssa_1 = strlen((char const   *)__cil_tmp30);
#line 301
            dir_len_ssa_1 = (int )tmp_ssa_1;
            }
            {
#line 302
            __cil_tmp11 = dir_len_ssa_1 <= 0;
#line 302
            if (__cil_tmp11) {
#line 303
              return (0);
            } else {
              {
#line 302
              __cil_tmp12 = dir_len_ssa_1 > 4096;
#line 302
              if (__cil_tmp12) {
#line 303
                return (0);
              } else {
                {
#line 305
                __cil_tmp31 = (unsigned char *)f + 4232;
#line 305
                __cil_tmp32 = (int *)__cil_tmp31;
#line 305
                __cil_tmp33 = *__cil_tmp32;
#line 305
                __cil_tmp13 = __cil_tmp33 < 0;
#line 305
                if (__cil_tmp13) {
#line 306
                  return (0);
                } else {
                  {
#line 308
                  __cil_tmp34 = (unsigned char *)f + 4236;
#line 308
                  __cil_tmp35 = (int *)__cil_tmp34;
#line 308
                  __cil_tmp36 = *__cil_tmp35;
#line 308
                  __cil_tmp14 = __cil_tmp36 < 0;
#line 308
                  if (__cil_tmp14) {
#line 309
                    return (0);
                  } else {
#line 311
                    return (1);
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
}
}
#line 316 "ftp_listener.c"
static void *connection_acceptor(ftp_listener_t *f ) 
{ 
  error_t err ;
  int num_error ;
  int fd ;
  int tcp_nodelay ;
  sockaddr_storage_t client_addr ;
  sockaddr_storage_t server_addr ;
  unsigned int addr_len ;
  connection_info_t *info ;
  pthread_t thread_id ;
  int error_code ;
  fd_set readfds ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int __d0 ;
  int __d1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
#line 333
  tmp = invariant((ftp_listener_t const   *)f);
#line 333
  if (! tmp) {
#line 333
    daemon_assert_fail("invariant(f)", "ftp_listener.c", 333, "connection_acceptor");
  }
#line 335
  tmp___1 = watchdog_init(& f->watchdog, f->inactivity_timeout, & err);
#line 335
  if (! tmp___1) {
#line 336
    tmp___0 = error_get_desc((error_t const   *)(& err));
#line 336
    syslog(3, "Error initializing watchdog thread; %s", tmp___0);
#line 338
    return ((void *)0);
  }
#line 341
  num_error = 0;
#line 342
  while (1) {
#line 345
    while (1) {
#line 345
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 345
      break;
    }
#line 346
    readfds.__fds_bits[f->fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << f->fd % (8 * (int )sizeof(__fd_mask )));
#line 347
    readfds.__fds_bits[f->shutdown_request_recv_fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << f->shutdown_request_recv_fd % (8 * (int )sizeof(__fd_mask )));
#line 348
    select(1024, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
#line 351
    if ((readfds.__fds_bits[f->shutdown_request_recv_fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << f->shutdown_request_recv_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 352
      close(f->fd);
#line 353
      syslog(6, "listener no longer accepting connections");
#line 354
      pthread_exit((void *)0);
    }
#line 358
    addr_len = (unsigned int )sizeof(sockaddr_storage_t );
#line 359
    fd = accept(f->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& client_addr)),
                (socklen_t */* __restrict  */)(& addr_len));
#line 360
    if (fd >= 0) {
#line 362
      tcp_nodelay = 1;
#line 363
      tmp___4 = setsockopt(fd, 6, 1, (void const   *)((void *)(& tcp_nodelay)), (socklen_t )sizeof(int ));
#line 363
      if (tmp___4 != 0) {
#line 366
        tmp___2 = __errno_location();
#line 366
        tmp___3 = strerror(*tmp___2);
#line 366
        syslog(3, "error in setsockopt(), FTP server dropping connection; %s", tmp___3);
#line 369
        close(fd);
#line 370
        goto __Cont;
      }
#line 373
      addr_len = (unsigned int )sizeof(sockaddr_storage_t );
#line 374
      tmp___7 = getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& server_addr)),
                            (socklen_t */* __restrict  */)(& addr_len));
#line 374
      if (tmp___7 == -1) {
#line 377
        tmp___5 = __errno_location();
#line 377
        tmp___6 = strerror(*tmp___5);
#line 377
        syslog(3, "error in getsockname(), FTP server dropping connection; %s", tmp___6);
#line 380
        close(fd);
#line 381
        goto __Cont;
      }
#line 384
      tmp___8 = malloc(sizeof(connection_info_t ));
#line 384
      info = (connection_info_t *)tmp___8;
#line 385
      if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 386
        syslog(2, "out of memory, FTP server dropping connection");
#line 388
        close(fd);
#line 389
        goto __Cont;
      }
#line 391
      info->ftp_listener = f;
#line 393
      telnet_session_init(& info->telnet_session, fd, fd);
#line 395
      tmp___10 = ftp_session_init(& info->ftp_session, (sockaddr_storage_t const   *)(& client_addr),
                                  (sockaddr_storage_t const   *)(& server_addr), & info->telnet_session,
                                  (char const   *)(f->dir), & err);
#line 395
      if (! tmp___10) {
#line 402
        tmp___9 = error_get_desc((error_t const   *)(& err));
#line 402
        syslog(3, "error initializing FTP session, FTP server exiting; %s", tmp___9);
#line 405
        close(fd);
#line 406
        telnet_session_destroy(& info->telnet_session);
#line 407
        free((void *)info);
#line 408
        goto __Cont;
      }
#line 412
      error_code = pthread_create((pthread_t */* __restrict  */)(& thread_id), (pthread_attr_t const   */* __restrict  */)((void *)0),
                                  (void *(*)(void * ))((void *(*)())(& connection_handler)),
                                  (void */* __restrict  */)info);
#line 417
      if (error_code != 0) {
#line 418
        syslog(3, "error creating new thread; %d", error_code);
#line 419
        close(fd);
#line 420
        telnet_session_destroy(& info->telnet_session);
#line 421
        free((void *)info);
      }
#line 424
      num_error = 0;
    } else {
#line 426
      tmp___15 = __errno_location();
#line 426
      if (*tmp___15 == 103) {
#line 427
        tmp___11 = __errno_location();
#line 427
        tmp___12 = strerror(*tmp___11);
#line 427
        syslog(5, "interruption accepting FTP connection; %s", tmp___12);
      } else {
#line 426
        tmp___16 = __errno_location();
#line 426
        if (*tmp___16 == 104) {
#line 427
          tmp___11 = __errno_location();
#line 427
          tmp___12 = strerror(*tmp___11);
#line 427
          syslog(5, "interruption accepting FTP connection; %s", tmp___12);
        } else {
#line 431
          tmp___13 = __errno_location();
#line 431
          tmp___14 = strerror(*tmp___13);
#line 431
          syslog(4, "error accepting FTP connection; %s", tmp___14);
#line 434
          num_error ++;
        }
      }
#line 436
      if (num_error >= 10) {
#line 437
        syslog(3, "too many consecutive errors, FTP server exiting");
#line 439
        return ((void *)0);
      }
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 447 "ftp_listener.c"
static char *addr2string(sockaddr_storage_t const   *s ) 
{ 
  char *ret_val_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  struct in_addr *__cil_tmp7 ;
  struct in_addr __cil_tmp8 ;

  {
  {
#line 453
  __cil_tmp5 = (unsigned long )s != (unsigned long )((void *)0);
#line 453
  if (! __cil_tmp5) {
    {
#line 453
    daemon_assert_fail("s != ((void *)0)", "ftp_listener.c", 453, "addr2string");
    }
  }
  }
  {
#line 470
  __cil_tmp6 = (unsigned char *)s + 4;
#line 470
  __cil_tmp7 = (struct in_addr *)__cil_tmp6;
#line 470
  __cil_tmp8 = *__cil_tmp7;
#line 470
  ret_val_ssa_1 = inet_ntoa((struct in_addr )__cil_tmp8);
  }
#line 473
  return (ret_val_ssa_1);
}
}
#line 477 "ftp_listener.c"
static void *connection_handler(connection_info_t *info ) 
{ 
  ftp_listener_t *f ;
  int num_connections ;
  char drop_reason[80] ;
  pthread_t tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned short __v ;
  unsigned short __x ;
  char *tmp___2 ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;
  char *tmp___3 ;

  {
#line 484
  f = info->ftp_listener;
#line 487
  tmp = pthread_self();
#line 487
  pthread_detach(tmp);
#line 490
  pthread_setcanceltype(1, (int *)((void *)0));
#line 491
  watchdog_add_watched(& f->watchdog, & info->watched);
#line 494
  while (1) {
#line 494
    __cancel_routine = (void (*)(void * ))((void (*)())(& connection_handler_cleanup));
#line 494
    __cancel_arg = (void *)info;
#line 494
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
#line 494
    __not_first_call = tmp___0;
#line 494
    tmp___1 = __builtin_expect((long )__not_first_call, 0L);
#line 494
    if (tmp___1) {
#line 494
      (*__cancel_routine)(__cancel_arg);
#line 494
      __pthread_unwind_next(& __cancel_buf);
    }
#line 494
    __pthread_register_cancel(& __cancel_buf);
#line 494
    while (1) {
#line 497
      pthread_mutex_lock(& f->mutex);
#line 498
      (f->num_connections) ++;
#line 498
      num_connections = f->num_connections;
#line 501
      __x = info->ftp_session.client_addr.sin_port;
#line 501
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 501
      tmp___2 = addr2string((sockaddr_storage_t const   *)(& info->ftp_session.client_addr));
#line 501
      syslog(6, "%s port %d connection", tmp___2, (int )__v);
#line 502
      pthread_mutex_unlock(& f->mutex);
#line 505
      if (num_connections <= f->max_connections) {
#line 507
        ftp_session_run(& info->ftp_session, & info->watched);
      } else {
#line 512
        sprintf((char */* __restrict  */)(drop_reason), (char const   */* __restrict  */)"Too many users logged in, dropping connection (%d logins maximum)",
                f->max_connections);
#line 515
        ftp_session_drop(& info->ftp_session, (char const   *)(drop_reason));
#line 518
        pthread_mutex_lock(& f->mutex);
#line 522
        __x___0 = info->ftp_session.client_addr.sin_port;
#line 522
        __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 522
        tmp___3 = addr2string((sockaddr_storage_t const   *)(& info->ftp_session.client_addr));
#line 522
        syslog(4, "%s port %d exceeds max users (%d), dropping connection", tmp___3,
               (int )__v___0, num_connections);
#line 524
        pthread_mutex_unlock(& f->mutex);
      }
#line 529
      while (1) {
#line 529
        break;
      }
#line 494
      break;
    }
#line 529
    __pthread_unregister_cancel(& __cancel_buf);
#line 529
    (*__cancel_routine)(__cancel_arg);
#line 494
    break;
  }
#line 532
  return ((void *)0);
}
}
#line 536 "ftp_listener.c"
static void connection_handler_cleanup(connection_info_t *info ) 
{ 
  ftp_listener_t *f ;
  unsigned short __v ;
  unsigned short __x ;
  char *tmp ;

  {
#line 540
  f = info->ftp_listener;
#line 542
  watchdog_remove_watched(& info->watched);
#line 544
  pthread_mutex_lock(& f->mutex);
#line 546
  (f->num_connections) --;
#line 547
  pthread_cond_signal(& f->shutdown_cond);
#line 552
  __x = info->ftp_session.client_addr.sin_port;
#line 552
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 552
  tmp = addr2string((sockaddr_storage_t const   *)(& info->ftp_session.client_addr));
#line 552
  syslog(6, "%s port %d disconnected", tmp, (int )__v);
#line 554
  pthread_mutex_unlock(& f->mutex);
#line 556
  ftp_session_destroy(& info->ftp_session);
#line 557
  telnet_session_destroy(& info->telnet_session);
#line 559
  free((void *)info);
#line 560
  return;
}
}
#line 562 "ftp_listener.c"
void ftp_listener_stop(ftp_listener_t *f ) 
{ 
  ftp_listener_t **__cil_pp_f  = & f;
  ftp_listener_t **__cil_fp_f  = & f;
  int tmp_ssa_1 ;
  ftp_listener_t *f_ssa_1 ;
  unsigned char *__cil_tmp7 ;
  int *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;

  {
  {
#line 564
  tmp_ssa_1 = invariant((ftp_listener_t const   *)f);
  }
#line 564
  if (! tmp_ssa_1) {
    {
#line 564
    daemon_assert_fail("invariant(f)", "ftp_listener.c", 564, "ftp_listener_stop");
    }
  }
  {
#line 567
  __cil_tmp7 = (unsigned char *)f + 4232;
#line 567
  __cil_tmp8 = (int *)__cil_tmp7;
#line 567
  __cil_tmp9 = *__cil_tmp8;
#line 567
  write(__cil_tmp9, (void const   *)"", (size_t )1);
#line 570
  __cil_tmp10 = (unsigned char *)f + 80;
#line 570
  pthread_mutex_lock((pthread_mutex_t *)__cil_tmp10);
  }
  {
  *__cil_fp_f = f;
#line 571
  ftp_listener_stop_cil_lr_1(__cil_pp_f);
  f_ssa_1 = *__cil_fp_f;
  }
  {
#line 574
  __cil_tmp11 = (unsigned char *)f_ssa_1 + 80;
#line 574
  pthread_mutex_unlock((pthread_mutex_t *)__cil_tmp11);
  }
#line 575
  return;
}
}
void ftp_listener_stop_cil_lr_1(ftp_listener_t **__cil_ap_f ) 
{ 
  int __cil_tmp2 ;
  ftp_listener_t *__cil_tmp3 ;
  unsigned char *__cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  int *__cil_tmp6 ;
  int __cil_tmp7 ;
  ftp_listener_t *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  ftp_listener_t *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;

  {
  {
#line 571
  __cil_tmp3 = *__cil_ap_f;
#line 571
  __cil_tmp4 = (unsigned char *)__cil_tmp3;
#line 571
  __cil_tmp5 = __cil_tmp4 + 8;
#line 571
  __cil_tmp6 = (int *)__cil_tmp5;
#line 571
  __cil_tmp7 = *__cil_tmp6;
#line 571
  __cil_tmp2 = __cil_tmp7 > 0;
#line 571
  if (__cil_tmp2) {
    {
#line 572
    __cil_tmp8 = *__cil_ap_f;
#line 572
    __cil_tmp9 = (unsigned char *)__cil_tmp8;
#line 572
    __cil_tmp10 = __cil_tmp9 + 4240;
#line 572
    __cil_tmp11 = *__cil_ap_f;
#line 572
    __cil_tmp12 = (unsigned char *)__cil_tmp11;
#line 572
    __cil_tmp13 = __cil_tmp12 + 80;
#line 572
    pthread_cond_wait((pthread_cond_t */* __restrict  */)__cil_tmp10, (pthread_mutex_t */* __restrict  */)__cil_tmp13);
    }
    {
    ftp_listener_stop_cil_lr_1(__cil_ap_f);
    }
    return;
  } else {
    return;
  }
  }
}
}
