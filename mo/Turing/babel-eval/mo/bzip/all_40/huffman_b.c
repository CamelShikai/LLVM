#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 42 "bzlib_private.h"
#line 43 "bzlib_private.h"
typedef unsigned char UChar;
#line 44 "bzlib_private.h"
typedef int Int32;
#line 58
extern void BZ2_bz__AssertH__fail(int errcode ) ;
#line 281
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) ;
#line 284
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) ;
#line 490
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) ;
#line 492
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3_cil_lr_1(Int32 *__cil_ap_i , Int32 *__cil_ap_j ,
                                                      Int32 *parent , Int32 k ) ;
#line 494
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_1(Int32 *__cil_ap_nHeap , Int32 *__cil_ap_n1 ,
                                                      Int32 *__cil_ap_zz___0 , Int32 *__cil_ap_tmp___1 ,
                                                      Int32 *heap , Int32 *weight ) ;
#line 497
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_2(Int32 *__cil_ap_nHeap , Int32 *__cil_ap_n1 ,
                                                      Int32 *__cil_ap_n2 , Int32 *__cil_ap_zz___1 ,
                                                      Int32 *__cil_ap_tmp___2 , Int32 *heap ,
                                                      Int32 *weight ) ;
#line 501
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_3(Int32 *__cil_ap_nHeap , Int32 *__cil_ap_zz___2 ,
                                                      Int32 *__cil_ap_tmp___5 , Int32 *heap ,
                                                      Int32 *weight ) ;
#line 504
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1_cil_lr_1(Int32 *__cil_ap_i , Int32 *__cil_ap_zz ,
                                                      Int32 *__cil_ap_tmp___0 , Int32 *heap ,
                                                      Int32 *weight ) ;
#line 507
void BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1(Int32 **__cil_ap_perm , Int32 *__cil_ap_pp ,
                                                Int32 *__cil_ap_i , UChar **__cil_ap_length ,
                                                Int32 *__cil_ap_alphaSize , Int32 j ) ;
#line 510
void BZ2_hbAssignCodes_cil_lr_1_cil_lr_1(Int32 **__cil_ap_code , UChar **__cil_ap_length ,
                                         Int32 *__cil_ap_maxLen , Int32 *__cil_ap_alphaSize ,
                                         Int32 *__cil_ap_n , Int32 *__cil_ap_vec ,
                                         Int32 i ) ;
#line 514
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Int32 *__cil_ap_nNodes ,
                                             Int32 *__cil_ap_nHeap , Int32 *heap ,
                                             Int32 *weight , Int32 *parent , Int32 i ) ;
#line 519
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Int32 *__cil_ap_nNodes ,
                                             Int32 *heap , Int32 *weight , Int32 *parent ,
                                             Int32 nHeap ) ;
#line 523
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Bool *__cil_ap_tooLong ,
                                             Int32 *parent , Int32 i ) ;
#line 526
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_4(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Int32 *weight ,
                                             Int32 i ) ;
#line 529
void BZ2_hbCreateDecodeTables_cil_lr_1(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       UChar **__cil_ap_length , Int32 *__cil_ap_minLen ,
                                       Int32 *__cil_ap_maxLen , Int32 *__cil_ap_alphaSize ,
                                       Int32 *perm , Int32 pp , Int32 i ) ;
#line 533
void BZ2_hbCreateDecodeTables_cil_lr_2(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       UChar **__cil_ap_length , Int32 *__cil_ap_minLen ,
                                       Int32 *__cil_ap_maxLen , Int32 *__cil_ap_alphaSize ,
                                       Int32 i ) ;
#line 537
void BZ2_hbCreateDecodeTables_cil_lr_3(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       UChar *length , Int32 alphaSize , Int32 i ) ;
#line 540
void BZ2_hbCreateDecodeTables_cil_lr_4(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       Int32 i ) ;
#line 543
void BZ2_hbCreateDecodeTables_cil_lr_5(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       Int32 i ) ;
#line 546
void BZ2_hbCreateDecodeTables_cil_lr_6(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       Int32 i , Int32 vec ) ;
#line 549
void BZ2_hbCreateDecodeTables_cil_lr_7(Int32 *limit , Int32 *base , Int32 maxLen ,
                                       Int32 i ) ;
#line 551
void BZ2_hbAssignCodes_cil_lr_1(Int32 *code , UChar *length , Int32 maxLen , Int32 alphaSize ,
                                Int32 n , Int32 vec ) ;
#line 553
void BZ2_hbMakeCodeLengths_cil_lr_1(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                    Int32 *__cil_ap_maxLen , Int32 *freq , Int32 i ,
                                    Int32 *weight ) ;
#line 556
void BZ2_hbMakeCodeLengths_cil_lr_2(UChar *len , Int32 alphaSize , Int32 maxLen ,
                                    Int32 *heap , Int32 *weight , Int32 *parent ) ;
   int babel_wrapper_BZ2_hbAssignCodes(Int32 * code, UChar * length, Int32  minLen, Int32  maxLen, Int32  alphaSize)                           // function name insert
      {
        // wrapper for function BZ2_hbAssignCodes        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbAssignCodes"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(code);
arg[1] = Pl_Mk_Integer(length);
arg[2] = Pl_Mk_Integer(minLen);
arg[3] = Pl_Mk_Integer(maxLen);
arg[4] = Pl_Mk_Integer(alphaSize);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables(Int32 ** __cil_pp_limit, Int32 ** __cil_pp_base, UChar ** __cil_pp_length, Int32 * __cil_pp_minLen, Int32 * __cil_pp_maxLen, Int32 * __cil_pp_alphaSize, Int32 ** __cil_fp_limit, Int32 ** __cil_fp_base, UChar ** __cil_fp_length, Int32 * __cil_fp_minLen, Int32 * __cil_fp_maxLen, Int32 * __cil_fp_alphaSize, Int32 * limit, Int32 * base, Int32 * perm, UChar * length, Int32  minLen, Int32  maxLen, Int32  alphaSize)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[20];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_limit);
arg[1] = Pl_Mk_Integer(__cil_pp_base);
arg[2] = Pl_Mk_Integer(__cil_pp_length);
arg[3] = Pl_Mk_Integer(__cil_pp_minLen);
arg[4] = Pl_Mk_Integer(__cil_pp_maxLen);
arg[5] = Pl_Mk_Integer(__cil_pp_alphaSize);
arg[6] = Pl_Mk_Integer(__cil_fp_limit);
arg[7] = Pl_Mk_Integer(__cil_fp_base);
arg[8] = Pl_Mk_Integer(__cil_fp_length);
arg[9] = Pl_Mk_Integer(__cil_fp_minLen);
arg[10] = Pl_Mk_Integer(__cil_fp_maxLen);
arg[11] = Pl_Mk_Integer(__cil_fp_alphaSize);
arg[12] = Pl_Mk_Integer(limit);
arg[13] = Pl_Mk_Integer(base);
arg[14] = Pl_Mk_Integer(perm);
arg[15] = Pl_Mk_Integer(length);
arg[16] = Pl_Mk_Integer(minLen);
arg[17] = Pl_Mk_Integer(maxLen);
arg[18] = Pl_Mk_Integer(alphaSize);

      //routine code, reserve a place for return value
      arg[19] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 20, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[19]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1(Int32 ** __cil_ap_perm, Int32 * __cil_ap_pp, Int32 * __cil_ap_i, UChar ** __cil_ap_length, Int32 * __cil_ap_alphaSize, Int32  j)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_perm);
arg[1] = Pl_Mk_Integer(__cil_ap_pp);
arg[2] = Pl_Mk_Integer(__cil_ap_i);
arg[3] = Pl_Mk_Integer(__cil_ap_length);
arg[4] = Pl_Mk_Integer(__cil_ap_alphaSize);
arg[5] = Pl_Mk_Integer(j);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbAssignCodes_cil_lr_1_cil_lr_1(Int32 ** __cil_ap_code, UChar ** __cil_ap_length, Int32 * __cil_ap_maxLen, Int32 * __cil_ap_alphaSize, Int32 * __cil_ap_n, Int32 * __cil_ap_vec, Int32  i)                           // function name insert
      {
        // wrapper for function BZ2_hbAssignCodes_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbAssignCodes_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_code);
arg[1] = Pl_Mk_Integer(__cil_ap_length);
arg[2] = Pl_Mk_Integer(__cil_ap_maxLen);
arg[3] = Pl_Mk_Integer(__cil_ap_alphaSize);
arg[4] = Pl_Mk_Integer(__cil_ap_n);
arg[5] = Pl_Mk_Integer(__cil_ap_vec);
arg[6] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_1(Int32 ** __cil_pp_perm, Int32 * __cil_pp_pp, Int32 * __cil_pp_i, Int32 ** __cil_fp_perm, Int32 * __cil_fp_pp, Int32 * __cil_fp_i, Int32 ** __cil_ap_limit, Int32 ** __cil_ap_base, UChar ** __cil_ap_length, Int32 * __cil_ap_minLen, Int32 * __cil_ap_maxLen, Int32 * __cil_ap_alphaSize, Int32 * perm, Int32  pp, Int32  i)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[16];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_perm);
arg[1] = Pl_Mk_Integer(__cil_pp_pp);
arg[2] = Pl_Mk_Integer(__cil_pp_i);
arg[3] = Pl_Mk_Integer(__cil_fp_perm);
arg[4] = Pl_Mk_Integer(__cil_fp_pp);
arg[5] = Pl_Mk_Integer(__cil_fp_i);
arg[6] = Pl_Mk_Integer(__cil_ap_limit);
arg[7] = Pl_Mk_Integer(__cil_ap_base);
arg[8] = Pl_Mk_Integer(__cil_ap_length);
arg[9] = Pl_Mk_Integer(__cil_ap_minLen);
arg[10] = Pl_Mk_Integer(__cil_ap_maxLen);
arg[11] = Pl_Mk_Integer(__cil_ap_alphaSize);
arg[12] = Pl_Mk_Integer(perm);
arg[13] = Pl_Mk_Integer(pp);
arg[14] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[15] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 16, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[15]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_2(Int32 ** __cil_ap_limit, Int32 ** __cil_ap_base, UChar ** __cil_ap_length, Int32 * __cil_ap_minLen, Int32 * __cil_ap_maxLen, Int32 * __cil_ap_alphaSize, Int32  i)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_limit);
arg[1] = Pl_Mk_Integer(__cil_ap_base);
arg[2] = Pl_Mk_Integer(__cil_ap_length);
arg[3] = Pl_Mk_Integer(__cil_ap_minLen);
arg[4] = Pl_Mk_Integer(__cil_ap_maxLen);
arg[5] = Pl_Mk_Integer(__cil_ap_alphaSize);
arg[6] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_3(Int32 ** __cil_ap_limit, Int32 ** __cil_ap_base, Int32 * __cil_ap_minLen, Int32 * __cil_ap_maxLen, UChar * length, Int32  alphaSize, Int32  i)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_3        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_3"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_limit);
arg[1] = Pl_Mk_Integer(__cil_ap_base);
arg[2] = Pl_Mk_Integer(__cil_ap_minLen);
arg[3] = Pl_Mk_Integer(__cil_ap_maxLen);
arg[4] = Pl_Mk_Integer(length);
arg[5] = Pl_Mk_Integer(alphaSize);
arg[6] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_4(Int32 ** __cil_ap_limit, Int32 ** __cil_ap_base, Int32 * __cil_ap_minLen, Int32 * __cil_ap_maxLen, Int32  i)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_4        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_4"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_limit);
arg[1] = Pl_Mk_Integer(__cil_ap_base);
arg[2] = Pl_Mk_Integer(__cil_ap_minLen);
arg[3] = Pl_Mk_Integer(__cil_ap_maxLen);
arg[4] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_5(Int32 ** __cil_ap_limit, Int32 ** __cil_ap_base, Int32 * __cil_ap_minLen, Int32 * __cil_ap_maxLen, Int32  i)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_5        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_5"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_limit);
arg[1] = Pl_Mk_Integer(__cil_ap_base);
arg[2] = Pl_Mk_Integer(__cil_ap_minLen);
arg[3] = Pl_Mk_Integer(__cil_ap_maxLen);
arg[4] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_6(Int32 ** __cil_ap_limit, Int32 ** __cil_ap_base, Int32 * __cil_ap_minLen, Int32 * __cil_ap_maxLen, Int32  i, Int32  vec)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_6        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_6"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_limit);
arg[1] = Pl_Mk_Integer(__cil_ap_base);
arg[2] = Pl_Mk_Integer(__cil_ap_minLen);
arg[3] = Pl_Mk_Integer(__cil_ap_maxLen);
arg[4] = Pl_Mk_Integer(i);
arg[5] = Pl_Mk_Integer(vec);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_7(Int32 * limit, Int32 * base, Int32  maxLen, Int32  i)                           // function name insert
      {
        // wrapper for function BZ2_hbCreateDecodeTables_cil_lr_7        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbCreateDecodeTables_cil_lr_7"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(limit);
arg[1] = Pl_Mk_Integer(base);
arg[2] = Pl_Mk_Integer(maxLen);
arg[3] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_BZ2_hbAssignCodes_cil_lr_1(Int32 ** __cil_pp_code, UChar ** __cil_pp_length, Int32 * __cil_pp_maxLen, Int32 * __cil_pp_alphaSize, Int32 * __cil_pp_n, Int32 * __cil_pp_vec, Int32 ** __cil_fp_code, UChar ** __cil_fp_length, Int32 * __cil_fp_maxLen, Int32 * __cil_fp_alphaSize, Int32 * __cil_fp_n, Int32 * __cil_fp_vec, Int32 * code, UChar * length, Int32  maxLen, Int32  alphaSize, Int32  n, Int32  vec)                           // function name insert
      {
        // wrapper for function BZ2_hbAssignCodes_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[19];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("bZ2_hbAssignCodes_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_code);
arg[1] = Pl_Mk_Integer(__cil_pp_length);
arg[2] = Pl_Mk_Integer(__cil_pp_maxLen);
arg[3] = Pl_Mk_Integer(__cil_pp_alphaSize);
arg[4] = Pl_Mk_Integer(__cil_pp_n);
arg[5] = Pl_Mk_Integer(__cil_pp_vec);
arg[6] = Pl_Mk_Integer(__cil_fp_code);
arg[7] = Pl_Mk_Integer(__cil_fp_length);
arg[8] = Pl_Mk_Integer(__cil_fp_maxLen);
arg[9] = Pl_Mk_Integer(__cil_fp_alphaSize);
arg[10] = Pl_Mk_Integer(__cil_fp_n);
arg[11] = Pl_Mk_Integer(__cil_fp_vec);
arg[12] = Pl_Mk_Integer(code);
arg[13] = Pl_Mk_Integer(length);
arg[14] = Pl_Mk_Integer(maxLen);
arg[15] = Pl_Mk_Integer(alphaSize);
arg[16] = Pl_Mk_Integer(n);
arg[17] = Pl_Mk_Integer(vec);

      //routine code, reserve a place for return value
      arg[18] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 19, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[18]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 63 "huffman.c"
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) 
{ 
  Int32 heap[260] ;
  Int32 weight[516] ;
  Int32 parent[516] ;
  UChar **__cil_pp_len ;
  Int32 *__cil_pp_alphaSize ;
  Int32 *__cil_pp_maxLen ;
  UChar **__cil_fp_len ;
  Int32 *__cil_fp_alphaSize ;
  Int32 *__cil_fp_maxLen ;
  Int32 i_ssa_1 ;
  UChar *len_ssa_1 ;
  Int32 alphaSize_ssa_1 ;
  Int32 maxLen_ssa_1 ;

  {
#line 68
  __cil_pp_len = & len;
#line 69
  __cil_pp_alphaSize = & alphaSize;
#line 70
  __cil_pp_maxLen = & maxLen;
#line 71
  __cil_fp_len = & len;
#line 72
  __cil_fp_alphaSize = & alphaSize;
#line 73
  __cil_fp_maxLen = & maxLen;
#line 79
  i_ssa_1 = 0;
#line 82
  *__cil_fp_len = len;
#line 83
  *__cil_fp_alphaSize = alphaSize;
#line 84
  *__cil_fp_maxLen = maxLen;
#line 79
  BZ2_hbMakeCodeLengths_cil_lr_1(__cil_pp_len, __cil_pp_alphaSize, __cil_pp_maxLen,
                                 freq, i_ssa_1, (Int32 *)(weight));
#line 81
  len_ssa_1 = *__cil_fp_len;
#line 82
  alphaSize_ssa_1 = *__cil_fp_alphaSize;
#line 83
  maxLen_ssa_1 = *__cil_fp_maxLen;
#line 82
  BZ2_hbMakeCodeLengths_cil_lr_2(len_ssa_1, alphaSize_ssa_1, maxLen_ssa_1, (Int32 *)(heap),
                                 (Int32 *)(weight), (Int32 *)(parent));
#line 148
  return;
}
}
#line 152 "huffman.c"
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) 
{ 
  Int32 vec_ssa_1 ;
  Int32 n_ssa_1 ;

  {

#line 160
  return babel_wrapper_BZ2_hbAssignCodes(code, length, minLen, maxLen, alphaSize);
#line 160
  vec_ssa_1 = 0;
#line 161
  n_ssa_1 = minLen;
#line 161
  BZ2_hbAssignCodes_cil_lr_1(code, length, maxLen, alphaSize, n_ssa_1, vec_ssa_1);
#line 166
  return;
}
}
#line 170 "huffman.c"
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) 
{ 
  Int32 **__cil_pp_limit ;
  Int32 **__cil_pp_base ;
  UChar **__cil_pp_length ;
  Int32 *__cil_pp_minLen ;
  Int32 *__cil_pp_maxLen ;
  Int32 *__cil_pp_alphaSize ;
  Int32 **__cil_fp_limit ;
  Int32 **__cil_fp_base ;
  UChar **__cil_fp_length ;
  Int32 *__cil_fp_minLen ;
  Int32 *__cil_fp_maxLen ;
  Int32 *__cil_fp_alphaSize ;
  Int32 pp_ssa_1 ;
  Int32 i_ssa_1 ;
  Int32 *limit_ssa_1 ;
  Int32 *base_ssa_1 ;
  UChar *length_ssa_1 ;
  Int32 minLen_ssa_1 ;
  Int32 maxLen_ssa_1 ;
  Int32 alphaSize_ssa_1 ;
  Int32 i_ssa_2 ;
  Int32 *limit_ssa_2 ;
  Int32 *base_ssa_2 ;
  UChar *length_ssa_2 ;
  Int32 minLen_ssa_2 ;
  Int32 maxLen_ssa_2 ;
  Int32 alphaSize_ssa_2 ;
  Int32 i_ssa_3 ;
  Int32 *limit_ssa_3 ;
  Int32 *base_ssa_3 ;
  Int32 minLen_ssa_3 ;
  Int32 maxLen_ssa_3 ;
  Int32 i_ssa_4 ;
  Int32 *limit_ssa_4 ;
  Int32 *base_ssa_4 ;
  Int32 minLen_ssa_4 ;
  Int32 maxLen_ssa_4 ;
  Int32 i_ssa_5 ;
  Int32 *limit_ssa_5 ;
  Int32 *base_ssa_5 ;
  Int32 minLen_ssa_5 ;
  Int32 maxLen_ssa_5 ;
  Int32 vec_ssa_1 ;
  Int32 i_ssa_6 ;
  Int32 *limit_ssa_6 ;
  Int32 *base_ssa_6 ;
  Int32 minLen_ssa_6 ;
  Int32 maxLen_ssa_6 ;
  Int32 i_ssa_7 ;

  {
#line 173
  __cil_fp_alphaSize = & alphaSize;
#line 173
  __cil_fp_maxLen = & maxLen;
#line 173
  __cil_fp_minLen = & minLen;
#line 173
  __cil_fp_length = & length;
#line 173
  __cil_fp_base = & base;
#line 173
  __cil_fp_limit = & limit;
#line 173
  __cil_pp_alphaSize = & alphaSize;
#line 173
  __cil_pp_maxLen = & maxLen;
#line 173
  __cil_pp_minLen = & minLen;
#line 173
  __cil_pp_length = & length;
#line 173
  __cil_pp_base = & base;
#line 173
  __cil_pp_limit = & limit;
#line 173
  return babel_wrapper_BZ2_hbCreateDecodeTables(__cil_pp_limit, __cil_pp_base, __cil_pp_length,
                                                __cil_pp_minLen, __cil_pp_maxLen,
                                                __cil_pp_alphaSize, __cil_fp_limit,
                                                __cil_fp_base, __cil_fp_length, __cil_fp_minLen,
                                                __cil_fp_maxLen, __cil_fp_alphaSize,
                                                limit, base, perm, length, minLen,
                                                maxLen, alphaSize);
#line 173
  __cil_pp_limit = & limit;
#line 174
  __cil_pp_base = & base;
#line 175
  __cil_pp_length = & length;
#line 176
  __cil_pp_minLen = & minLen;
#line 177
  __cil_pp_maxLen = & maxLen;
#line 178
  __cil_pp_alphaSize = & alphaSize;
#line 179
  __cil_fp_limit = & limit;
#line 180
  __cil_fp_base = & base;
#line 181
  __cil_fp_length = & length;
#line 182
  __cil_fp_minLen = & minLen;
#line 183
  __cil_fp_maxLen = & maxLen;
#line 184
  __cil_fp_alphaSize = & alphaSize;
#line 180
  pp_ssa_1 = 0;
#line 181
  i_ssa_1 = minLen;
#line 184
  *__cil_fp_limit = limit;
#line 185
  *__cil_fp_base = base;
#line 186
  *__cil_fp_length = length;
#line 187
  *__cil_fp_minLen = minLen;
#line 188
  *__cil_fp_maxLen = maxLen;
#line 189
  *__cil_fp_alphaSize = alphaSize;
#line 181
  BZ2_hbCreateDecodeTables_cil_lr_1(__cil_pp_limit, __cil_pp_base, __cil_pp_length,
                                    __cil_pp_minLen, __cil_pp_maxLen, __cil_pp_alphaSize,
                                    perm, pp_ssa_1, i_ssa_1);
#line 184
  limit_ssa_1 = *__cil_fp_limit;
#line 185
  base_ssa_1 = *__cil_fp_base;
#line 186
  length_ssa_1 = *__cil_fp_length;
#line 187
  minLen_ssa_1 = *__cil_fp_minLen;
#line 188
  maxLen_ssa_1 = *__cil_fp_maxLen;
#line 189
  alphaSize_ssa_1 = *__cil_fp_alphaSize;
#line 185
  i_ssa_2 = 0;
#line 188
  *__cil_fp_limit = limit_ssa_1;
#line 189
  *__cil_fp_base = base_ssa_1;
#line 190
  *__cil_fp_length = length_ssa_1;
#line 191
  *__cil_fp_minLen = minLen_ssa_1;
#line 192
  *__cil_fp_maxLen = maxLen_ssa_1;
#line 193
  *__cil_fp_alphaSize = alphaSize_ssa_1;
#line 185
  BZ2_hbCreateDecodeTables_cil_lr_2(__cil_pp_limit, __cil_pp_base, __cil_pp_length,
                                    __cil_pp_minLen, __cil_pp_maxLen, __cil_pp_alphaSize,
                                    i_ssa_2);
#line 188
  limit_ssa_2 = *__cil_fp_limit;
#line 189
  base_ssa_2 = *__cil_fp_base;
#line 190
  length_ssa_2 = *__cil_fp_length;
#line 191
  minLen_ssa_2 = *__cil_fp_minLen;
#line 192
  maxLen_ssa_2 = *__cil_fp_maxLen;
#line 193
  alphaSize_ssa_2 = *__cil_fp_alphaSize;
#line 186
  i_ssa_3 = 0;
#line 189
  *__cil_fp_limit = limit_ssa_2;
#line 190
  *__cil_fp_base = base_ssa_2;
#line 191
  *__cil_fp_minLen = minLen_ssa_2;
#line 192
  *__cil_fp_maxLen = maxLen_ssa_2;
#line 186
  BZ2_hbCreateDecodeTables_cil_lr_3(__cil_pp_limit, __cil_pp_base, __cil_pp_minLen,
                                    __cil_pp_maxLen, length_ssa_2, alphaSize_ssa_2,
                                    i_ssa_3);
#line 189
  limit_ssa_3 = *__cil_fp_limit;
#line 190
  base_ssa_3 = *__cil_fp_base;
#line 191
  minLen_ssa_3 = *__cil_fp_minLen;
#line 192
  maxLen_ssa_3 = *__cil_fp_maxLen;
#line 188
  i_ssa_4 = 1;
#line 191
  *__cil_fp_limit = limit_ssa_3;
#line 192
  *__cil_fp_base = base_ssa_3;
#line 193
  *__cil_fp_minLen = minLen_ssa_3;
#line 194
  *__cil_fp_maxLen = maxLen_ssa_3;
#line 188
  BZ2_hbCreateDecodeTables_cil_lr_4(__cil_pp_limit, __cil_pp_base, __cil_pp_minLen,
                                    __cil_pp_maxLen, i_ssa_4);
#line 190
  limit_ssa_4 = *__cil_fp_limit;
#line 191
  base_ssa_4 = *__cil_fp_base;
#line 192
  minLen_ssa_4 = *__cil_fp_minLen;
#line 193
  maxLen_ssa_4 = *__cil_fp_maxLen;
#line 190
  i_ssa_5 = 0;
#line 193
  *__cil_fp_limit = limit_ssa_4;
#line 194
  *__cil_fp_base = base_ssa_4;
#line 195
  *__cil_fp_minLen = minLen_ssa_4;
#line 196
  *__cil_fp_maxLen = maxLen_ssa_4;
#line 190
  BZ2_hbCreateDecodeTables_cil_lr_5(__cil_pp_limit, __cil_pp_base, __cil_pp_minLen,
                                    __cil_pp_maxLen, i_ssa_5);
#line 192
  limit_ssa_5 = *__cil_fp_limit;
#line 193
  base_ssa_5 = *__cil_fp_base;
#line 194
  minLen_ssa_5 = *__cil_fp_minLen;
#line 195
  maxLen_ssa_5 = *__cil_fp_maxLen;
#line 191
  vec_ssa_1 = 0;
#line 193
  i_ssa_6 = minLen_ssa_5;
#line 196
  *__cil_fp_limit = limit_ssa_5;
#line 197
  *__cil_fp_base = base_ssa_5;
#line 198
  *__cil_fp_minLen = minLen_ssa_5;
#line 199
  *__cil_fp_maxLen = maxLen_ssa_5;
#line 193
  BZ2_hbCreateDecodeTables_cil_lr_6(__cil_pp_limit, __cil_pp_base, __cil_pp_minLen,
                                    __cil_pp_maxLen, i_ssa_6, vec_ssa_1);
#line 195
  limit_ssa_6 = *__cil_fp_limit;
#line 196
  base_ssa_6 = *__cil_fp_base;
#line 197
  minLen_ssa_6 = *__cil_fp_minLen;
#line 198
  maxLen_ssa_6 = *__cil_fp_maxLen;
#line 198
  i_ssa_7 = minLen_ssa_6 + 1;
#line 198
  BZ2_hbCreateDecodeTables_cil_lr_7(limit_ssa_6, base_ssa_6, maxLen_ssa_6, i_ssa_7);
#line 200
  return;
}
}
#line 203 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3_cil_lr_1(Int32 *__cil_ap_i , Int32 *__cil_ap_j ,
                                                      Int32 *parent , Int32 k ) 
{ 
  Int32 k_ssa_1 ;
  int __cil_tmp6 ;
  Int32 *__cil_tmp7 ;
  Int32 __cil_tmp8 ;
  Int32 *__cil_tmp9 ;
  Int32 __cil_tmp10 ;

  {
#line 118
  __cil_tmp7 = (Int32 *)(parent + k);
#line 118
  __cil_tmp8 = *__cil_tmp7;
#line 118
  __cil_tmp6 = __cil_tmp8 >= 0;
#line 118
  if (__cil_tmp6 != 0) {
#line 118
    __cil_tmp9 = (Int32 *)(parent + k);
#line 118
    k_ssa_1 = *__cil_tmp9;
#line 118
    __cil_tmp10 = *__cil_ap_j;
#line 118
    *__cil_ap_j = __cil_tmp10 + 1;
#line 121
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3_cil_lr_1(__cil_ap_i, __cil_ap_j, parent,
                                                     k_ssa_1);
#line 124
    return;
  } else {
#line 126
    return;
  }
}
}
#line 131 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_1(Int32 *__cil_ap_nHeap , Int32 *__cil_ap_n1 ,
                                                      Int32 *__cil_ap_zz___0 , Int32 *__cil_ap_tmp___1 ,
                                                      Int32 *heap , Int32 *weight ) 
{ 
  Int32 yy_ssa_1 ;
  Int32 yy_ssa_2 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  Int32 __cil_tmp15 ;
  Int32 __cil_tmp16 ;
  Int32 __cil_tmp17 ;
  Int32 __cil_tmp18 ;
  Int32 *__cil_tmp19 ;
  Int32 __cil_tmp20 ;
  Int32 *__cil_tmp21 ;
  Int32 *__cil_tmp22 ;
  Int32 __cil_tmp23 ;
  Int32 *__cil_tmp24 ;
  Int32 __cil_tmp25 ;
  Int32 __cil_tmp26 ;
  Int32 __cil_tmp27 ;
  Int32 *__cil_tmp28 ;
  Int32 *__cil_tmp29 ;
  Int32 __cil_tmp30 ;
  Int32 *__cil_tmp31 ;
  Int32 __cil_tmp32 ;
  Int32 __cil_tmp33 ;
  Int32 *__cil_tmp34 ;
  Int32 __cil_tmp35 ;
  Int32 *__cil_tmp36 ;

  {
#line 101
  __cil_tmp15 = *__cil_ap_zz___0;
#line 101
  yy_ssa_1 = __cil_tmp15 << 1;
#line 101
  __cil_tmp16 = *__cil_ap_nHeap;
#line 101
  __cil_tmp10 = yy_ssa_1 > __cil_tmp16;
#line 101
  if (__cil_tmp10 != 0) {
#line 102
    return;
  } else {
#line 101
    __cil_tmp17 = *__cil_ap_nHeap;
#line 101
    __cil_tmp11 = yy_ssa_1 < __cil_tmp17;
#line 101
    if (__cil_tmp11 != 0) {
#line 101
      __cil_tmp18 = yy_ssa_1 + 1;
#line 101
      __cil_tmp19 = (Int32 *)(heap + __cil_tmp18);
#line 101
      __cil_tmp20 = *__cil_tmp19;
#line 101
      __cil_tmp21 = (Int32 *)(weight + __cil_tmp20);
#line 101
      __cil_tmp22 = (Int32 *)(heap + yy_ssa_1);
#line 101
      __cil_tmp23 = *__cil_tmp22;
#line 101
      __cil_tmp24 = (Int32 *)(weight + __cil_tmp23);
#line 101
      __cil_tmp25 = *__cil_tmp21;
#line 101
      __cil_tmp26 = *__cil_tmp24;
#line 101
      __cil_tmp12 = __cil_tmp25 < __cil_tmp26;
#line 101
      if (__cil_tmp12 != 0) {
#line 101
        yy_ssa_2 = yy_ssa_1 + 1;
      } else {
#line 104
        yy_ssa_2 = yy_ssa_1;
      }
    } else {
#line 108
      yy_ssa_2 = yy_ssa_1;
    }
#line 101
    __cil_tmp27 = *__cil_ap_tmp___1;
#line 101
    __cil_tmp28 = (Int32 *)(weight + __cil_tmp27);
#line 101
    __cil_tmp29 = (Int32 *)(heap + yy_ssa_2);
#line 101
    __cil_tmp30 = *__cil_tmp29;
#line 101
    __cil_tmp31 = (Int32 *)(weight + __cil_tmp30);
#line 101
    __cil_tmp32 = *__cil_tmp28;
#line 101
    __cil_tmp33 = *__cil_tmp31;
#line 101
    __cil_tmp13 = __cil_tmp32 < __cil_tmp33;
#line 101
    if (__cil_tmp13 != 0) {
#line 102
      return;
    } else {
#line 101
      __cil_tmp34 = (Int32 *)(heap + yy_ssa_2);
#line 101
      __cil_tmp35 = *__cil_ap_zz___0;
#line 101
      __cil_tmp36 = (Int32 *)(heap + __cil_tmp35);
#line 101
      *__cil_tmp36 = *__cil_tmp34;
#line 101
      *__cil_ap_zz___0 = yy_ssa_2;
#line 104
      BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_1(__cil_ap_nHeap, __cil_ap_n1,
                                                       __cil_ap_zz___0, __cil_ap_tmp___1,
                                                       heap, weight);
#line 108
      return;
    }
  }
}
}
#line 116 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_2(Int32 *__cil_ap_nHeap , Int32 *__cil_ap_n1 ,
                                                      Int32 *__cil_ap_n2 , Int32 *__cil_ap_zz___1 ,
                                                      Int32 *__cil_ap_tmp___2 , Int32 *heap ,
                                                      Int32 *weight ) 
{ 
  Int32 yy___0 ;
  Int32 yy___0_ssa_1 ;
  Int32 yy___0_ssa_2 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  Int32 __cil_tmp16 ;
  Int32 __cil_tmp17 ;
  Int32 __cil_tmp18 ;
  Int32 __cil_tmp19 ;
  Int32 *__cil_tmp20 ;
  Int32 __cil_tmp21 ;
  Int32 *__cil_tmp22 ;
  Int32 *__cil_tmp23 ;
  Int32 __cil_tmp24 ;
  Int32 *__cil_tmp25 ;
  Int32 __cil_tmp26 ;
  Int32 __cil_tmp27 ;
  Int32 __cil_tmp28 ;
  Int32 *__cil_tmp29 ;
  Int32 *__cil_tmp30 ;
  Int32 __cil_tmp31 ;
  Int32 *__cil_tmp32 ;
  Int32 __cil_tmp33 ;
  Int32 __cil_tmp34 ;
  Int32 *__cil_tmp35 ;
  Int32 __cil_tmp36 ;
  Int32 *__cil_tmp37 ;
  Int32 __cil_tmp38 ;
  Int32 *__cil_tmp39 ;
  Int32 *__cil_tmp40 ;
  Int32 __cil_tmp41 ;
  Int32 *__cil_tmp42 ;
  Int32 __cil_tmp43 ;
  Int32 __cil_tmp44 ;
  Int32 *__cil_tmp45 ;
  Int32 __cil_tmp46 ;
  Int32 *__cil_tmp47 ;

  {
#line 102
  __cil_tmp16 = *__cil_ap_zz___1;
#line 102
  yy___0_ssa_1 = __cil_tmp16 << 1;
#line 102
  __cil_tmp17 = *__cil_ap_nHeap;
#line 102
  __cil_tmp11 = yy___0_ssa_1 > __cil_tmp17;
#line 102
  if (__cil_tmp11 != 0) {
#line 103
    return;
  } else {
#line 102
    __cil_tmp18 = *__cil_ap_nHeap;
#line 102
    __cil_tmp12 = yy___0_ssa_1 < __cil_tmp18;
#line 102
    if (__cil_tmp12 != 0) {
#line 102
      __cil_tmp19 = yy___0_ssa_1 + 1;
#line 102
      __cil_tmp20 = (Int32 *)(heap + __cil_tmp19);
#line 102
      __cil_tmp21 = *__cil_tmp20;
#line 102
      __cil_tmp22 = (Int32 *)(weight + __cil_tmp21);
#line 102
      __cil_tmp23 = (Int32 *)(heap + yy___0_ssa_1);
#line 102
      __cil_tmp24 = *__cil_tmp23;
#line 102
      __cil_tmp25 = (Int32 *)(weight + __cil_tmp24);
#line 102
      __cil_tmp26 = *__cil_tmp22;
#line 102
      __cil_tmp27 = *__cil_tmp25;
#line 102
      __cil_tmp13 = __cil_tmp26 < __cil_tmp27;
#line 102
      if (__cil_tmp13 != 0) {
#line 102
        yy___0_ssa_2 = yy___0_ssa_1 + 1;
      } else {
#line 105
        yy___0_ssa_2 = yy___0_ssa_1;
      }
    } else {
#line 109
      yy___0_ssa_2 = yy___0_ssa_1;
    }
#line 102
    __cil_tmp28 = *__cil_ap_tmp___2;
#line 102
    __cil_tmp29 = (Int32 *)(weight + __cil_tmp28);
#line 102
    __cil_tmp30 = (Int32 *)(heap + yy___0_ssa_2);
#line 102
    __cil_tmp31 = *__cil_tmp30;
#line 102
    __cil_tmp32 = (Int32 *)(weight + __cil_tmp31);
#line 102
    __cil_tmp33 = *__cil_tmp29;
#line 102
    __cil_tmp34 = *__cil_tmp32;
#line 102
    __cil_tmp14 = __cil_tmp33 < __cil_tmp34;
#line 102
    if (__cil_tmp14 != 0) {
#line 103
      return;
    } else {
#line 102
      __cil_tmp35 = (Int32 *)(heap + yy___0_ssa_2);
#line 102
      __cil_tmp36 = *__cil_ap_zz___1;
#line 102
      __cil_tmp37 = (Int32 *)(heap + __cil_tmp36);
#line 102
      *__cil_tmp37 = *__cil_tmp35;
#line 102
      *__cil_ap_zz___1 = yy___0_ssa_2;
#line 105
      BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_2(__cil_ap_nHeap, __cil_ap_n1,
                                                       __cil_ap_n2, __cil_ap_zz___1,
                                                       __cil_ap_tmp___2, heap, weight);
#line 109
      return;
    }
  }
#line 102
  __cil_tmp38 = *__cil_ap_tmp___2;
#line 102
  __cil_tmp39 = (Int32 *)(weight + __cil_tmp38);
#line 102
  __cil_tmp40 = (Int32 *)(heap + yy___0);
#line 102
  __cil_tmp41 = *__cil_tmp40;
#line 102
  __cil_tmp42 = (Int32 *)(weight + __cil_tmp41);
#line 102
  __cil_tmp43 = *__cil_tmp39;
#line 102
  __cil_tmp44 = *__cil_tmp42;
#line 102
  __cil_tmp15 = __cil_tmp43 < __cil_tmp44;
#line 102
  if (__cil_tmp15 != 0) {
#line 103
    return;
  } else {
#line 102
    __cil_tmp45 = (Int32 *)(heap + yy___0);
#line 102
    __cil_tmp46 = *__cil_ap_zz___1;
#line 102
    __cil_tmp47 = (Int32 *)(heap + __cil_tmp46);
#line 102
    *__cil_tmp47 = *__cil_tmp45;
#line 102
    *__cil_ap_zz___1 = yy___0;
#line 105
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_2(__cil_ap_nHeap, __cil_ap_n1,
                                                     __cil_ap_n2, __cil_ap_zz___1,
                                                     __cil_ap_tmp___2, heap, weight);
#line 109
    return;
  }
}
}
#line 114 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_3(Int32 *__cil_ap_nHeap , Int32 *__cil_ap_zz___2 ,
                                                      Int32 *__cil_ap_tmp___5 , Int32 *heap ,
                                                      Int32 *weight ) 
{ 
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  Int32 *__cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Int32 __cil_tmp10 ;
  Int32 *__cil_tmp11 ;
  Int32 __cil_tmp12 ;
  Int32 *__cil_tmp13 ;
  Int32 __cil_tmp14 ;
  Int32 __cil_tmp15 ;
  Int32 __cil_tmp16 ;
  Int32 __cil_tmp17 ;
  Int32 *__cil_tmp18 ;
  Int32 __cil_tmp19 ;
  Int32 *__cil_tmp20 ;
  Int32 __cil_tmp21 ;

  {
#line 109
  __cil_tmp7 = *__cil_ap_tmp___5;
#line 109
  __cil_tmp8 = (Int32 *)(weight + __cil_tmp7);
#line 109
  __cil_tmp9 = *__cil_ap_zz___2;
#line 109
  __cil_tmp10 = __cil_tmp9 >> 1;
#line 109
  __cil_tmp11 = (Int32 *)(heap + __cil_tmp10);
#line 109
  __cil_tmp12 = *__cil_tmp11;
#line 109
  __cil_tmp13 = (Int32 *)(weight + __cil_tmp12);
#line 109
  __cil_tmp14 = *__cil_tmp8;
#line 109
  __cil_tmp15 = *__cil_tmp13;
#line 109
  __cil_tmp6 = __cil_tmp14 < __cil_tmp15;
#line 109
  if (__cil_tmp6 != 0) {
#line 109
    __cil_tmp16 = *__cil_ap_zz___2;
#line 109
    __cil_tmp17 = __cil_tmp16 >> 1;
#line 109
    __cil_tmp18 = (Int32 *)(heap + __cil_tmp17);
#line 109
    __cil_tmp19 = *__cil_ap_zz___2;
#line 109
    __cil_tmp20 = (Int32 *)(heap + __cil_tmp19);
#line 109
    *__cil_tmp20 = *__cil_tmp18;
#line 109
    __cil_tmp21 = *__cil_ap_zz___2;
#line 109
    *__cil_ap_zz___2 = __cil_tmp21 >> 1;
#line 112
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_3(__cil_ap_nHeap, __cil_ap_zz___2,
                                                     __cil_ap_tmp___5, heap, weight);
#line 115
    return;
  } else {
#line 117
    return;
  }
}
}
#line 122 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1_cil_lr_1(Int32 *__cil_ap_i , Int32 *__cil_ap_zz ,
                                                      Int32 *__cil_ap_tmp___0 , Int32 *heap ,
                                                      Int32 *weight ) 
{ 
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  Int32 *__cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Int32 __cil_tmp10 ;
  Int32 *__cil_tmp11 ;
  Int32 __cil_tmp12 ;
  Int32 *__cil_tmp13 ;
  Int32 __cil_tmp14 ;
  Int32 __cil_tmp15 ;
  Int32 __cil_tmp16 ;
  Int32 __cil_tmp17 ;
  Int32 *__cil_tmp18 ;
  Int32 __cil_tmp19 ;
  Int32 *__cil_tmp20 ;
  Int32 __cil_tmp21 ;

  {
#line 95
  __cil_tmp7 = *__cil_ap_tmp___0;
#line 95
  __cil_tmp8 = (Int32 *)(weight + __cil_tmp7);
#line 95
  __cil_tmp9 = *__cil_ap_zz;
#line 95
  __cil_tmp10 = __cil_tmp9 >> 1;
#line 95
  __cil_tmp11 = (Int32 *)(heap + __cil_tmp10);
#line 95
  __cil_tmp12 = *__cil_tmp11;
#line 95
  __cil_tmp13 = (Int32 *)(weight + __cil_tmp12);
#line 95
  __cil_tmp14 = *__cil_tmp8;
#line 95
  __cil_tmp15 = *__cil_tmp13;
#line 95
  __cil_tmp6 = __cil_tmp14 < __cil_tmp15;
#line 95
  if (__cil_tmp6 != 0) {
#line 95
    __cil_tmp16 = *__cil_ap_zz;
#line 95
    __cil_tmp17 = __cil_tmp16 >> 1;
#line 95
    __cil_tmp18 = (Int32 *)(heap + __cil_tmp17);
#line 95
    __cil_tmp19 = *__cil_ap_zz;
#line 95
    __cil_tmp20 = (Int32 *)(heap + __cil_tmp19);
#line 95
    *__cil_tmp20 = *__cil_tmp18;
#line 95
    __cil_tmp21 = *__cil_ap_zz;
#line 95
    *__cil_ap_zz = __cil_tmp21 >> 1;
#line 98
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1_cil_lr_1(__cil_ap_i, __cil_ap_zz, __cil_ap_tmp___0,
                                                     heap, weight);
#line 101
    return;
  } else {
#line 103
    return;
  }
}
}
#line 108 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1(Int32 **__cil_ap_perm , Int32 *__cil_ap_pp ,
                                                Int32 *__cil_ap_i , UChar **__cil_ap_length ,
                                                Int32 *__cil_ap_alphaSize , Int32 j ) 
{ 
  Int32 j_ssa_1 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  Int32 __cil_tmp10 ;
  UChar *__cil_tmp11 ;
  UChar *__cil_tmp12 ;
  UChar __cil_tmp13 ;
  int __cil_tmp14 ;
  Int32 __cil_tmp15 ;
  Int32 *__cil_tmp16 ;
  Int32 __cil_tmp17 ;
  Int32 *__cil_tmp18 ;
  Int32 __cil_tmp19 ;

  {

#line 182
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1(__cil_ap_perm, __cil_ap_pp,
                                                                  __cil_ap_i, __cil_ap_length,
                                                                  __cil_ap_alphaSize,
                                                                  j);
#line 182
  __cil_tmp10 = *__cil_ap_alphaSize;
#line 182
  __cil_tmp8 = j < __cil_tmp10;
#line 182
  if (__cil_tmp8 != 0) {
#line 183
    __cil_tmp11 = *__cil_ap_length;
#line 183
    __cil_tmp12 = __cil_tmp11 + j;
#line 183
    __cil_tmp13 = *__cil_tmp12;
#line 183
    __cil_tmp14 = (int )__cil_tmp13;
#line 183
    __cil_tmp15 = *__cil_ap_i;
#line 183
    __cil_tmp9 = __cil_tmp14 == __cil_tmp15;
#line 183
    if (__cil_tmp9 != 0) {
#line 183
      __cil_tmp16 = *__cil_ap_perm;
#line 183
      __cil_tmp17 = *__cil_ap_pp;
#line 183
      __cil_tmp18 = __cil_tmp16 + __cil_tmp17;
#line 183
      *__cil_tmp18 = j;
#line 183
      __cil_tmp19 = *__cil_ap_pp;
#line 183
      *__cil_ap_pp = __cil_tmp19 + 1;
    } else {

    }
#line 182
    j_ssa_1 = j + 1;
#line 185
    BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1(__cil_ap_perm, __cil_ap_pp, __cil_ap_i,
                                               __cil_ap_length, __cil_ap_alphaSize,
                                               j_ssa_1);
#line 189
    return;
  } else {
#line 191
    return;
  }
}
}
#line 196 "huffman.c"
void BZ2_hbAssignCodes_cil_lr_1_cil_lr_1(Int32 **__cil_ap_code , UChar **__cil_ap_length ,
                                         Int32 *__cil_ap_maxLen , Int32 *__cil_ap_alphaSize ,
                                         Int32 *__cil_ap_n , Int32 *__cil_ap_vec ,
                                         Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  Int32 __cil_tmp11 ;
  UChar *__cil_tmp12 ;
  UChar *__cil_tmp13 ;
  UChar __cil_tmp14 ;
  int __cil_tmp15 ;
  Int32 __cil_tmp16 ;
  Int32 *__cil_tmp17 ;
  Int32 *__cil_tmp18 ;
  Int32 __cil_tmp19 ;

  {

#line 162
  return babel_wrapper_BZ2_hbAssignCodes_cil_lr_1_cil_lr_1(__cil_ap_code, __cil_ap_length,
                                                           __cil_ap_maxLen, __cil_ap_alphaSize,
                                                           __cil_ap_n, __cil_ap_vec,
                                                           i);
#line 162
  __cil_tmp11 = *__cil_ap_alphaSize;
#line 162
  __cil_tmp9 = i < __cil_tmp11;
#line 162
  if (__cil_tmp9 != 0) {
#line 163
    __cil_tmp12 = *__cil_ap_length;
#line 163
    __cil_tmp13 = __cil_tmp12 + i;
#line 163
    __cil_tmp14 = *__cil_tmp13;
#line 163
    __cil_tmp15 = (int )__cil_tmp14;
#line 163
    __cil_tmp16 = *__cil_ap_n;
#line 163
    __cil_tmp10 = __cil_tmp15 == __cil_tmp16;
#line 163
    if (__cil_tmp10 != 0) {
#line 163
      __cil_tmp17 = *__cil_ap_code;
#line 163
      __cil_tmp18 = __cil_tmp17 + i;
#line 163
      *__cil_tmp18 = *__cil_ap_vec;
#line 163
      __cil_tmp19 = *__cil_ap_vec;
#line 163
      *__cil_ap_vec = __cil_tmp19 + 1;
    } else {

    }
#line 162
    i_ssa_1 = i + 1;
#line 165
    BZ2_hbAssignCodes_cil_lr_1_cil_lr_1(__cil_ap_code, __cil_ap_length, __cil_ap_maxLen,
                                        __cil_ap_alphaSize, __cil_ap_n, __cil_ap_vec,
                                        i_ssa_1);
#line 169
    return;
  } else {
#line 171
    return;
  }
}
}
#line 176 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Int32 *__cil_ap_nNodes ,
                                             Int32 *__cil_ap_nHeap , Int32 *heap ,
                                             Int32 *weight , Int32 *parent , Int32 i ) 
{ 
  Int32 zz ;
  Int32 tmp___0 ;
  Int32 *__cil_pp_i ;
  Int32 *__cil_pp_zz ;
  Int32 *__cil_pp_tmp___0 ;
  Int32 *__cil_fp_i ;
  Int32 *__cil_fp_zz ;
  Int32 *__cil_fp_tmp___0 ;
  Int32 zz_ssa_1 ;
  Int32 tmp___0_ssa_1 ;
  Int32 i_ssa_1 ;
  Int32 zz_ssa_2 ;
  Int32 tmp___0_ssa_2 ;
  Int32 i_ssa_2 ;
  int __cil_tmp24 ;
  Int32 __cil_tmp25 ;
  Int32 *__cil_tmp26 ;
  Int32 __cil_tmp27 ;
  Int32 __cil_tmp28 ;
  Int32 *__cil_tmp29 ;
  Int32 *__cil_tmp30 ;
  Int32 *__cil_tmp31 ;

  {
#line 184
  __cil_pp_i = & i;
#line 185
  __cil_pp_zz = & zz;
#line 186
  __cil_pp_tmp___0 = & tmp___0;
#line 187
  __cil_fp_i = & i;
#line 188
  __cil_fp_zz = & zz;
#line 189
  __cil_fp_tmp___0 = & tmp___0;
#line 91
  __cil_tmp25 = *__cil_ap_alphaSize;
#line 91
  __cil_tmp24 = i <= __cil_tmp25;
#line 91
  if (__cil_tmp24 != 0) {
#line 92
    __cil_tmp26 = (Int32 *)(parent + i);
#line 92
    *__cil_tmp26 = -1;
#line 93
    __cil_tmp27 = *__cil_ap_nHeap;
#line 93
    *__cil_ap_nHeap = __cil_tmp27 + 1;
#line 94
    __cil_tmp28 = *__cil_ap_nHeap;
#line 94
    __cil_tmp29 = (Int32 *)(heap + __cil_tmp28);
#line 94
    *__cil_tmp29 = i;
#line 95
    zz_ssa_1 = *__cil_ap_nHeap;
#line 95
    __cil_tmp30 = (Int32 *)(heap + zz_ssa_1);
#line 95
    tmp___0_ssa_1 = *__cil_tmp30;
#line 98
    *__cil_fp_i = i;
#line 99
    *__cil_fp_zz = zz_ssa_1;
#line 100
    *__cil_fp_tmp___0 = tmp___0_ssa_1;
#line 95
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1_cil_lr_1(__cil_pp_i, __cil_pp_zz, __cil_pp_tmp___0,
                                                     heap, weight);
#line 97
    i_ssa_1 = *__cil_fp_i;
#line 98
    zz_ssa_2 = *__cil_fp_zz;
#line 99
    tmp___0_ssa_2 = *__cil_fp_tmp___0;
#line 95
    __cil_tmp31 = (Int32 *)(heap + zz_ssa_2);
#line 95
    *__cil_tmp31 = tmp___0_ssa_2;
#line 91
    i_ssa_2 = i_ssa_1 + 1;
#line 94
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1(__cil_ap_len, __cil_ap_alphaSize, __cil_ap_maxLen,
                                            __cil_ap_nNodes, __cil_ap_nHeap, heap,
                                            weight, parent, i_ssa_2);
#line 98
    return;
  } else {
#line 100
    return;
  }
}
}
#line 105 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Int32 *__cil_ap_nNodes ,
                                             Int32 *heap , Int32 *weight , Int32 *parent ,
                                             Int32 nHeap ) 
{ 
  Int32 n1 ;
  Int32 zz___0 ;
  Int32 tmp___1 ;
  Int32 n2 ;
  Int32 zz___1 ;
  Int32 tmp___2 ;
  int tmp___4 ;
  Int32 zz___2 ;
  Int32 tmp___5 ;
  Int32 *__cil_pp_nHeap ;
  Int32 *__cil_pp_n1 ;
  Int32 *__cil_pp_zz___0 ;
  Int32 *__cil_pp_tmp___1 ;
  Int32 *__cil_pp_n2 ;
  Int32 *__cil_pp_zz___1 ;
  Int32 *__cil_pp_tmp___2 ;
  Int32 *__cil_pp_zz___2 ;
  Int32 *__cil_pp_tmp___5 ;
  Int32 *__cil_fp_nHeap ;
  Int32 *__cil_fp_n1 ;
  Int32 *__cil_fp_zz___0 ;
  Int32 *__cil_fp_tmp___1 ;
  Int32 *__cil_fp_n2 ;
  Int32 *__cil_fp_zz___1 ;
  Int32 *__cil_fp_tmp___2 ;
  Int32 *__cil_fp_zz___2 ;
  Int32 *__cil_fp_tmp___5 ;
  Int32 n1_ssa_1 ;
  Int32 nHeap_ssa_1 ;
  Int32 zz___0_ssa_1 ;
  Int32 tmp___1_ssa_1 ;
  Int32 nHeap_ssa_2 ;
  Int32 n1_ssa_2 ;
  Int32 zz___0_ssa_2 ;
  Int32 tmp___1_ssa_2 ;
  Int32 n2_ssa_1 ;
  Int32 nHeap_ssa_3 ;
  Int32 zz___1_ssa_1 ;
  Int32 tmp___2_ssa_1 ;
  Int32 nHeap_ssa_4 ;
  Int32 n1_ssa_3 ;
  Int32 n2_ssa_2 ;
  Int32 zz___1_ssa_2 ;
  Int32 tmp___2_ssa_2 ;
  Int32 tmp___3_ssa_1 ;
  int tmp___4_ssa_1 ;
  Int32 nHeap_ssa_5 ;
  Int32 zz___2_ssa_1 ;
  Int32 tmp___5_ssa_1 ;
  Int32 nHeap_ssa_6 ;
  Int32 zz___2_ssa_2 ;
  Int32 tmp___5_ssa_2 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  Int32 *__cil_tmp66 ;
  Int32 *__cil_tmp67 ;
  Int32 *__cil_tmp68 ;
  Int32 *__cil_tmp69 ;
  Int32 *__cil_tmp70 ;
  Int32 *__cil_tmp71 ;
  Int32 *__cil_tmp72 ;
  Int32 *__cil_tmp73 ;
  Int32 *__cil_tmp74 ;
  Int32 *__cil_tmp75 ;
  Int32 __cil_tmp76 ;
  Int32 *__cil_tmp77 ;
  Int32 *__cil_tmp78 ;
  Int32 *__cil_tmp79 ;
  Int32 __cil_tmp80 ;
  Int32 *__cil_tmp81 ;
  Int32 __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  Int32 *__cil_tmp85 ;
  Int32 __cil_tmp86 ;
  Int32 *__cil_tmp87 ;
  Int32 __cil_tmp88 ;
  Int32 *__cil_tmp89 ;
  Int32 __cil_tmp90 ;
  unsigned int __cil_tmp91 ;
  Int32 *__cil_tmp92 ;
  Int32 __cil_tmp93 ;
  unsigned int __cil_tmp94 ;
  unsigned int __cil_tmp95 ;
  unsigned int __cil_tmp96 ;
  int __cil_tmp97 ;
  unsigned int __cil_tmp98 ;
  unsigned int __cil_tmp99 ;
  unsigned int __cil_tmp100 ;
  Int32 __cil_tmp101 ;
  Int32 *__cil_tmp102 ;
  Int32 __cil_tmp103 ;
  Int32 *__cil_tmp104 ;
  Int32 *__cil_tmp105 ;
  Int32 *__cil_tmp106 ;
  Int32 *__cil_tmp107 ;
  Int32 *__cil_tmp108 ;
  Int32 __cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  Int32 *__cil_tmp111 ;
  Int32 __cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  unsigned int __cil_tmp114 ;
  unsigned int __cil_tmp115 ;
  int __cil_tmp116 ;
  unsigned int __cil_tmp117 ;
  unsigned int __cil_tmp118 ;
  unsigned int __cil_tmp119 ;
  Int32 __cil_tmp120 ;
  Int32 *__cil_tmp121 ;
  Int32 __cil_tmp122 ;
  Int32 *__cil_tmp123 ;
  Int32 *__cil_tmp124 ;
  Int32 *__cil_tmp125 ;
  Int32 *__cil_tmp126 ;

  {
#line 119
  __cil_pp_nHeap = & nHeap;
#line 120
  __cil_pp_n1 = & n1;
#line 121
  __cil_pp_zz___0 = & zz___0;
#line 122
  __cil_pp_tmp___1 = & tmp___1;
#line 123
  __cil_pp_n2 = & n2;
#line 124
  __cil_pp_zz___1 = & zz___1;
#line 125
  __cil_pp_tmp___2 = & tmp___2;
#line 126
  __cil_pp_zz___2 = & zz___2;
#line 127
  __cil_pp_tmp___5 = & tmp___5;
#line 128
  __cil_fp_nHeap = & nHeap;
#line 129
  __cil_fp_n1 = & n1;
#line 130
  __cil_fp_zz___0 = & zz___0;
#line 131
  __cil_fp_tmp___1 = & tmp___1;
#line 132
  __cil_fp_n2 = & n2;
#line 133
  __cil_fp_zz___1 = & zz___1;
#line 134
  __cil_fp_tmp___2 = & tmp___2;
#line 135
  __cil_fp_zz___2 = & zz___2;
#line 136
  __cil_fp_tmp___5 = & tmp___5;
#line 100
  __cil_tmp64 = nHeap > 1;
#line 100
  if (__cil_tmp64 != 0) {
#line 101
    __cil_tmp66 = (Int32 *)(heap + 1);
#line 101
    n1_ssa_1 = *__cil_tmp66;
#line 101
    __cil_tmp67 = (Int32 *)(heap + nHeap);
#line 101
    __cil_tmp68 = (Int32 *)(heap + 1);
#line 101
    *__cil_tmp68 = *__cil_tmp67;
#line 101
    nHeap_ssa_1 = nHeap - 1;
#line 101
    zz___0_ssa_1 = 1;
#line 101
    __cil_tmp69 = (Int32 *)(heap + zz___0_ssa_1);
#line 101
    tmp___1_ssa_1 = *__cil_tmp69;
#line 104
    *__cil_fp_nHeap = nHeap_ssa_1;
#line 105
    *__cil_fp_n1 = n1_ssa_1;
#line 106
    *__cil_fp_zz___0 = zz___0_ssa_1;
#line 107
    *__cil_fp_tmp___1 = tmp___1_ssa_1;
#line 101
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_1(__cil_pp_nHeap, __cil_pp_n1,
                                                     __cil_pp_zz___0, __cil_pp_tmp___1,
                                                     heap, weight);
#line 104
    nHeap_ssa_2 = *__cil_fp_nHeap;
#line 105
    n1_ssa_2 = *__cil_fp_n1;
#line 106
    zz___0_ssa_2 = *__cil_fp_zz___0;
#line 107
    tmp___1_ssa_2 = *__cil_fp_tmp___1;
#line 101
    __cil_tmp70 = (Int32 *)(heap + zz___0_ssa_2);
#line 101
    *__cil_tmp70 = tmp___1_ssa_2;
#line 102
    __cil_tmp71 = (Int32 *)(heap + 1);
#line 102
    n2_ssa_1 = *__cil_tmp71;
#line 102
    __cil_tmp72 = (Int32 *)(heap + nHeap_ssa_2);
#line 102
    __cil_tmp73 = (Int32 *)(heap + 1);
#line 102
    *__cil_tmp73 = *__cil_tmp72;
#line 102
    nHeap_ssa_3 = nHeap_ssa_2 - 1;
#line 102
    zz___1_ssa_1 = 1;
#line 102
    __cil_tmp74 = (Int32 *)(heap + zz___1_ssa_1);
#line 102
    tmp___2_ssa_1 = *__cil_tmp74;
#line 105
    *__cil_fp_nHeap = nHeap_ssa_3;
#line 106
    *__cil_fp_n1 = n1_ssa_2;
#line 107
    *__cil_fp_n2 = n2_ssa_1;
#line 108
    *__cil_fp_zz___1 = zz___1_ssa_1;
#line 109
    *__cil_fp_tmp___2 = tmp___2_ssa_1;
#line 102
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_2(__cil_pp_nHeap, __cil_pp_n1,
                                                     __cil_pp_n2, __cil_pp_zz___1,
                                                     __cil_pp_tmp___2, heap, weight);
#line 105
    nHeap_ssa_4 = *__cil_fp_nHeap;
#line 106
    n1_ssa_3 = *__cil_fp_n1;
#line 107
    n2_ssa_2 = *__cil_fp_n2;
#line 108
    zz___1_ssa_2 = *__cil_fp_zz___1;
#line 109
    tmp___2_ssa_2 = *__cil_fp_tmp___2;
#line 102
    __cil_tmp75 = (Int32 *)(heap + zz___1_ssa_2);
#line 102
    *__cil_tmp75 = tmp___2_ssa_2;
#line 103
    __cil_tmp76 = *__cil_ap_nNodes;
#line 103
    *__cil_ap_nNodes = __cil_tmp76 + 1;
#line 104
    tmp___3_ssa_1 = *__cil_ap_nNodes;
#line 104
    __cil_tmp77 = (Int32 *)(parent + n2_ssa_2);
#line 104
    *__cil_tmp77 = tmp___3_ssa_1;
#line 104
    __cil_tmp78 = (Int32 *)(parent + n1_ssa_3);
#line 104
    *__cil_tmp78 = tmp___3_ssa_1;
#line 105
    __cil_tmp79 = (Int32 *)(weight + n1_ssa_3);
#line 105
    __cil_tmp80 = *__cil_tmp79;
#line 105
    __cil_tmp81 = (Int32 *)(weight + n2_ssa_2);
#line 105
    __cil_tmp82 = *__cil_tmp81;
#line 105
    __cil_tmp83 = __cil_tmp80 & 255;
#line 105
    __cil_tmp84 = __cil_tmp82 & 255;
#line 105
    __cil_tmp65 = __cil_tmp83 > __cil_tmp84;
#line 105
    if (__cil_tmp65 != 0) {
#line 105
      __cil_tmp85 = (Int32 *)(weight + n1_ssa_3);
#line 105
      __cil_tmp86 = *__cil_tmp85;
#line 105
      tmp___4_ssa_1 = __cil_tmp86 & 255;
    } else {
#line 105
      __cil_tmp87 = (Int32 *)(weight + n2_ssa_2);
#line 105
      __cil_tmp88 = *__cil_tmp87;
#line 105
      tmp___4_ssa_1 = __cil_tmp88 & 255;
    }
#line 105
    __cil_tmp89 = (Int32 *)(weight + n1_ssa_3);
#line 105
    __cil_tmp90 = *__cil_tmp89;
#line 105
    __cil_tmp91 = (unsigned int )__cil_tmp90;
#line 105
    __cil_tmp92 = (Int32 *)(weight + n2_ssa_2);
#line 105
    __cil_tmp93 = *__cil_tmp92;
#line 105
    __cil_tmp94 = (unsigned int )__cil_tmp93;
#line 105
    __cil_tmp95 = __cil_tmp91 & 4294967040U;
#line 105
    __cil_tmp96 = __cil_tmp94 & 4294967040U;
#line 105
    __cil_tmp97 = 1 + tmp___4_ssa_1;
#line 105
    __cil_tmp98 = __cil_tmp95 + __cil_tmp96;
#line 105
    __cil_tmp99 = (unsigned int )__cil_tmp97;
#line 105
    __cil_tmp100 = __cil_tmp98 | __cil_tmp99;
#line 105
    __cil_tmp101 = *__cil_ap_nNodes;
#line 105
    __cil_tmp102 = (Int32 *)(weight + __cil_tmp101);
#line 105
    *__cil_tmp102 = (Int32 )__cil_tmp100;
#line 106
    __cil_tmp103 = *__cil_ap_nNodes;
#line 106
    __cil_tmp104 = (Int32 *)(parent + __cil_tmp103);
#line 106
    *__cil_tmp104 = -1;
#line 107
    nHeap_ssa_5 = nHeap_ssa_4 + 1;
#line 108
    __cil_tmp105 = (Int32 *)(heap + nHeap_ssa_5);
#line 108
    *__cil_tmp105 = *__cil_ap_nNodes;
#line 109
    zz___2_ssa_1 = nHeap_ssa_5;
#line 109
    __cil_tmp106 = (Int32 *)(heap + zz___2_ssa_1);
#line 109
    tmp___5_ssa_1 = *__cil_tmp106;
#line 112
    *__cil_fp_nHeap = nHeap_ssa_5;
#line 113
    *__cil_fp_zz___2 = zz___2_ssa_1;
#line 114
    *__cil_fp_tmp___5 = tmp___5_ssa_1;
#line 109
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_3(__cil_pp_nHeap, __cil_pp_zz___2,
                                                     __cil_pp_tmp___5, heap, weight);
#line 111
    nHeap_ssa_6 = *__cil_fp_nHeap;
#line 112
    zz___2_ssa_2 = *__cil_fp_zz___2;
#line 113
    tmp___5_ssa_2 = *__cil_fp_tmp___5;
#line 109
    __cil_tmp107 = (Int32 *)(heap + zz___2_ssa_2);
#line 109
    *__cil_tmp107 = tmp___5_ssa_2;
#line 112
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2(__cil_ap_len, __cil_ap_alphaSize, __cil_ap_maxLen,
                                            __cil_ap_nNodes, heap, weight, parent,
                                            nHeap_ssa_6);
#line 116
    return;
  } else {
#line 118
    return;
  }
#line 105
  __cil_tmp108 = (Int32 *)(weight + n1);
#line 105
  __cil_tmp109 = *__cil_tmp108;
#line 105
  __cil_tmp110 = (unsigned int )__cil_tmp109;
#line 105
  __cil_tmp111 = (Int32 *)(weight + n2);
#line 105
  __cil_tmp112 = *__cil_tmp111;
#line 105
  __cil_tmp113 = (unsigned int )__cil_tmp112;
#line 105
  __cil_tmp114 = __cil_tmp110 & 4294967040U;
#line 105
  __cil_tmp115 = __cil_tmp113 & 4294967040U;
#line 105
  __cil_tmp116 = 1 + tmp___4;
#line 105
  __cil_tmp117 = __cil_tmp114 + __cil_tmp115;
#line 105
  __cil_tmp118 = (unsigned int )__cil_tmp116;
#line 105
  __cil_tmp119 = __cil_tmp117 | __cil_tmp118;
#line 105
  __cil_tmp120 = *__cil_ap_nNodes;
#line 105
  __cil_tmp121 = (Int32 *)(weight + __cil_tmp120);
#line 105
  *__cil_tmp121 = (Int32 )__cil_tmp119;
#line 106
  __cil_tmp122 = *__cil_ap_nNodes;
#line 106
  __cil_tmp123 = (Int32 *)(parent + __cil_tmp122);
#line 106
  *__cil_tmp123 = -1;
#line 107
  nHeap_ssa_1 = nHeap + 1;
#line 108
  __cil_tmp124 = (Int32 *)(heap + nHeap_ssa_1);
#line 108
  *__cil_tmp124 = *__cil_ap_nNodes;
#line 109
  zz___2_ssa_1 = nHeap_ssa_1;
#line 109
  __cil_tmp125 = (Int32 *)(heap + zz___2_ssa_1);
#line 109
  tmp___5_ssa_1 = *__cil_tmp125;
#line 112
  *__cil_fp_nHeap = nHeap_ssa_1;
#line 113
  *__cil_fp_zz___2 = zz___2_ssa_1;
#line 114
  *__cil_fp_tmp___5 = tmp___5_ssa_1;
#line 109
  BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2_cil_lr_3(__cil_pp_nHeap, __cil_pp_zz___2,
                                                   __cil_pp_tmp___5, heap, weight);
#line 111
  nHeap_ssa_2 = *__cil_fp_nHeap;
#line 112
  zz___2_ssa_2 = *__cil_fp_zz___2;
#line 113
  tmp___5_ssa_2 = *__cil_fp_tmp___5;
#line 109
  __cil_tmp126 = (Int32 *)(heap + zz___2_ssa_2);
#line 109
  *__cil_tmp126 = tmp___5_ssa_2;
#line 112
  BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2(__cil_ap_len, __cil_ap_alphaSize, __cil_ap_maxLen,
                                          __cil_ap_nNodes, heap, weight, parent, nHeap_ssa_2);
#line 115
  return;
}
}
#line 118 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Bool *__cil_ap_tooLong ,
                                             Int32 *parent , Int32 i ) 
{ 
  Int32 j ;
  Int32 *__cil_pp_i ;
  Int32 *__cil_pp_j ;
  Int32 *__cil_fp_i ;
  Int32 *__cil_fp_j ;
  Int32 j_ssa_1 ;
  Int32 k_ssa_1 ;
  Int32 i_ssa_1 ;
  Int32 j_ssa_2 ;
  Int32 i_ssa_2 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  Int32 __cil_tmp20 ;
  UChar *__cil_tmp21 ;
  Int32 __cil_tmp22 ;
  UChar *__cil_tmp23 ;
  Int32 __cil_tmp24 ;

  {
#line 123
  __cil_pp_i = & i;
#line 124
  __cil_pp_j = & j;
#line 125
  __cil_fp_i = & i;
#line 126
  __cil_fp_j = & j;
#line 115
  __cil_tmp20 = *__cil_ap_alphaSize;
#line 115
  __cil_tmp18 = i <= __cil_tmp20;
#line 115
  if (__cil_tmp18 != 0) {
#line 116
    j_ssa_1 = 0;
#line 117
    k_ssa_1 = i;
#line 120
    *__cil_fp_i = i;
#line 121
    *__cil_fp_j = j_ssa_1;
#line 118
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3_cil_lr_1(__cil_pp_i, __cil_pp_j, parent,
                                                     k_ssa_1);
#line 120
    i_ssa_1 = *__cil_fp_i;
#line 121
    j_ssa_2 = *__cil_fp_j;
#line 119
    __cil_tmp21 = *__cil_ap_len;
#line 119
    __cil_tmp22 = i_ssa_1 - 1;
#line 119
    __cil_tmp23 = __cil_tmp21 + __cil_tmp22;
#line 119
    *__cil_tmp23 = (UChar )j_ssa_2;
#line 120
    __cil_tmp24 = *__cil_ap_maxLen;
#line 120
    __cil_tmp19 = j_ssa_2 > __cil_tmp24;
#line 120
    if (__cil_tmp19 != 0) {
#line 120
      *__cil_ap_tooLong = (Bool )1;
    } else {

    }
#line 115
    i_ssa_2 = i_ssa_1 + 1;
#line 118
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3(__cil_ap_len, __cil_ap_alphaSize, __cil_ap_maxLen,
                                            __cil_ap_tooLong, parent, i_ssa_2);
#line 121
    return;
  } else {
#line 123
    return;
  }
}
}
#line 128 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_4(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                             Int32 *__cil_ap_maxLen , Int32 *weight ,
                                             Int32 i ) 
{ 
  Int32 j_ssa_1 ;
  Int32 j_ssa_2 ;
  Int32 i_ssa_1 ;
  int __cil_tmp10 ;
  Int32 __cil_tmp11 ;
  Int32 *__cil_tmp12 ;
  Int32 __cil_tmp13 ;
  Int32 __cil_tmp14 ;
  Int32 *__cil_tmp15 ;

  {
#line 142
  __cil_tmp11 = *__cil_ap_alphaSize;
#line 142
  __cil_tmp10 = i <= __cil_tmp11;
#line 142
  if (__cil_tmp10 != 0) {
#line 143
    __cil_tmp12 = (Int32 *)(weight + i);
#line 143
    __cil_tmp13 = *__cil_tmp12;
#line 143
    j_ssa_1 = __cil_tmp13 >> 8;
#line 144
    __cil_tmp14 = j_ssa_1 / 2;
#line 144
    j_ssa_2 = 1 + __cil_tmp14;
#line 145
    __cil_tmp15 = (Int32 *)(weight + i);
#line 145
    *__cil_tmp15 = j_ssa_2 << 8;
#line 142
    i_ssa_1 = i + 1;
#line 145
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_4(__cil_ap_len, __cil_ap_alphaSize, __cil_ap_maxLen,
                                            weight, i_ssa_1);
#line 148
    return;
  } else {
#line 150
    return;
  }
}
}
#line 155 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_1(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       UChar **__cil_ap_length , Int32 *__cil_ap_minLen ,
                                       Int32 *__cil_ap_maxLen , Int32 *__cil_ap_alphaSize ,
                                       Int32 *perm , Int32 pp , Int32 i ) 
{ 
  Int32 **__cil_pp_perm ;
  Int32 *__cil_pp_pp ;
  Int32 *__cil_pp_i ;
  Int32 **__cil_fp_perm ;
  Int32 *__cil_fp_pp ;
  Int32 *__cil_fp_i ;
  Int32 j_ssa_1 ;
  Int32 *perm_ssa_1 ;
  Int32 pp_ssa_1 ;
  Int32 i_ssa_1 ;
  Int32 i_ssa_2 ;
  int __cil_tmp22 ;
  Int32 __cil_tmp23 ;

  {
#line 160
  __cil_fp_i = & i;
#line 160
  __cil_fp_pp = & pp;
#line 160
  __cil_fp_perm = & perm;
#line 160
  __cil_pp_i = & i;
#line 160
  __cil_pp_pp = & pp;
#line 160
  __cil_pp_perm = & perm;
#line 160
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_1(__cil_pp_perm, __cil_pp_pp,
                                                         __cil_pp_i, __cil_fp_perm,
                                                         __cil_fp_pp, __cil_fp_i,
                                                         __cil_ap_limit, __cil_ap_base,
                                                         __cil_ap_length, __cil_ap_minLen,
                                                         __cil_ap_maxLen, __cil_ap_alphaSize,
                                                         perm, pp, i);
#line 160
  __cil_pp_perm = & perm;
#line 161
  __cil_pp_pp = & pp;
#line 162
  __cil_pp_i = & i;
#line 163
  __cil_fp_perm = & perm;
#line 164
  __cil_fp_pp = & pp;
#line 165
  __cil_fp_i = & i;
#line 181
  __cil_tmp23 = *__cil_ap_maxLen;
#line 181
  __cil_tmp22 = i <= __cil_tmp23;
#line 181
  if (__cil_tmp22 != 0) {
#line 182
    j_ssa_1 = 0;
#line 185
    *__cil_fp_perm = perm;
#line 186
    *__cil_fp_pp = pp;
#line 187
    *__cil_fp_i = i;
#line 182
    BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1(__cil_pp_perm, __cil_pp_pp, __cil_pp_i,
                                               __cil_ap_length, __cil_ap_alphaSize,
                                               j_ssa_1);
#line 185
    perm_ssa_1 = *__cil_fp_perm;
#line 186
    pp_ssa_1 = *__cil_fp_pp;
#line 187
    i_ssa_1 = *__cil_fp_i;
#line 181
    i_ssa_2 = i_ssa_1 + 1;
#line 184
    BZ2_hbCreateDecodeTables_cil_lr_1(__cil_ap_limit, __cil_ap_base, __cil_ap_length,
                                      __cil_ap_minLen, __cil_ap_maxLen, __cil_ap_alphaSize,
                                      perm_ssa_1, pp_ssa_1, i_ssa_2);
#line 188
    return;
  } else {
#line 190
    return;
  }
}
}
#line 195 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_2(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       UChar **__cil_ap_length , Int32 *__cil_ap_minLen ,
                                       Int32 *__cil_ap_maxLen , Int32 *__cil_ap_alphaSize ,
                                       Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp9 ;
  Int32 *__cil_tmp10 ;
  Int32 *__cil_tmp11 ;

  {

#line 185
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_2(__cil_ap_limit, __cil_ap_base,
                                                         __cil_ap_length, __cil_ap_minLen,
                                                         __cil_ap_maxLen, __cil_ap_alphaSize,
                                                         i);
#line 185
  __cil_tmp9 = i < 23;
#line 185
  if (__cil_tmp9 != 0) {
#line 185
    __cil_tmp10 = *__cil_ap_base;
#line 185
    __cil_tmp11 = __cil_tmp10 + i;
#line 185
    *__cil_tmp11 = 0;
#line 185
    i_ssa_1 = i + 1;
#line 188
    BZ2_hbCreateDecodeTables_cil_lr_2(__cil_ap_limit, __cil_ap_base, __cil_ap_length,
                                      __cil_ap_minLen, __cil_ap_maxLen, __cil_ap_alphaSize,
                                      i_ssa_1);
#line 192
    return;
  } else {
#line 194
    return;
  }
}
}
#line 199 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_3(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       UChar *length , Int32 alphaSize , Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp9 ;
  UChar *__cil_tmp10 ;
  UChar __cil_tmp11 ;
  int __cil_tmp12 ;
  Int32 *__cil_tmp13 ;
  int __cil_tmp14 ;
  Int32 *__cil_tmp15 ;
  Int32 __cil_tmp16 ;
  UChar *__cil_tmp17 ;
  UChar __cil_tmp18 ;
  int __cil_tmp19 ;
  Int32 *__cil_tmp20 ;
  int __cil_tmp21 ;
  Int32 *__cil_tmp22 ;

  {

#line 186
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_3(__cil_ap_limit, __cil_ap_base,
                                                         __cil_ap_minLen, __cil_ap_maxLen,
                                                         length, alphaSize, i);
#line 186
  __cil_tmp9 = i < alphaSize;
#line 186
  if (__cil_tmp9 != 0) {
#line 186
    __cil_tmp10 = length + i;
#line 186
    __cil_tmp11 = *__cil_tmp10;
#line 186
    __cil_tmp12 = (int )__cil_tmp11;
#line 186
    __cil_tmp13 = *__cil_ap_base;
#line 186
    __cil_tmp14 = __cil_tmp12 + 1;
#line 186
    __cil_tmp15 = __cil_tmp13 + __cil_tmp14;
#line 186
    __cil_tmp16 = *__cil_tmp15;
#line 186
    __cil_tmp17 = length + i;
#line 186
    __cil_tmp18 = *__cil_tmp17;
#line 186
    __cil_tmp19 = (int )__cil_tmp18;
#line 186
    __cil_tmp20 = *__cil_ap_base;
#line 186
    __cil_tmp21 = __cil_tmp19 + 1;
#line 186
    __cil_tmp22 = __cil_tmp20 + __cil_tmp21;
#line 186
    *__cil_tmp22 = __cil_tmp16 + 1;
#line 186
    i_ssa_1 = i + 1;
#line 189
    BZ2_hbCreateDecodeTables_cil_lr_3(__cil_ap_limit, __cil_ap_base, __cil_ap_minLen,
                                      __cil_ap_maxLen, length, alphaSize, i_ssa_1);
#line 192
    return;
  } else {
#line 194
    return;
  }
}
}
#line 199 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_4(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp7 ;
  Int32 *__cil_tmp8 ;
  Int32 *__cil_tmp9 ;
  Int32 *__cil_tmp10 ;
  Int32 __cil_tmp11 ;
  Int32 *__cil_tmp12 ;
  Int32 __cil_tmp13 ;
  Int32 __cil_tmp14 ;
  Int32 *__cil_tmp15 ;
  Int32 *__cil_tmp16 ;

  {

#line 188
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_4(__cil_ap_limit, __cil_ap_base,
                                                         __cil_ap_minLen, __cil_ap_maxLen,
                                                         i);
#line 188
  __cil_tmp7 = i < 23;
#line 188
  if (__cil_tmp7 != 0) {
#line 188
    __cil_tmp8 = *__cil_ap_base;
#line 188
    __cil_tmp9 = __cil_tmp8 + i;
#line 188
    __cil_tmp10 = *__cil_ap_base;
#line 188
    __cil_tmp11 = i - 1;
#line 188
    __cil_tmp12 = __cil_tmp10 + __cil_tmp11;
#line 188
    __cil_tmp13 = *__cil_tmp9;
#line 188
    __cil_tmp14 = *__cil_tmp12;
#line 188
    __cil_tmp15 = *__cil_ap_base;
#line 188
    __cil_tmp16 = __cil_tmp15 + i;
#line 188
    *__cil_tmp16 = __cil_tmp13 + __cil_tmp14;
#line 188
    i_ssa_1 = i + 1;
#line 191
    BZ2_hbCreateDecodeTables_cil_lr_4(__cil_ap_limit, __cil_ap_base, __cil_ap_minLen,
                                      __cil_ap_maxLen, i_ssa_1);
#line 194
    return;
  } else {
#line 196
    return;
  }
}
}
#line 201 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_5(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp7 ;
  Int32 *__cil_tmp8 ;
  Int32 *__cil_tmp9 ;

  {

#line 190
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_5(__cil_ap_limit, __cil_ap_base,
                                                         __cil_ap_minLen, __cil_ap_maxLen,
                                                         i);
#line 190
  __cil_tmp7 = i < 23;
#line 190
  if (__cil_tmp7 != 0) {
#line 190
    __cil_tmp8 = *__cil_ap_limit;
#line 190
    __cil_tmp9 = __cil_tmp8 + i;
#line 190
    *__cil_tmp9 = 0;
#line 190
    i_ssa_1 = i + 1;
#line 193
    BZ2_hbCreateDecodeTables_cil_lr_5(__cil_ap_limit, __cil_ap_base, __cil_ap_minLen,
                                      __cil_ap_maxLen, i_ssa_1);
#line 196
    return;
  } else {
#line 198
    return;
  }
}
}
#line 203 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_6(Int32 **__cil_ap_limit , Int32 **__cil_ap_base ,
                                       Int32 *__cil_ap_minLen , Int32 *__cil_ap_maxLen ,
                                       Int32 i , Int32 vec ) 
{ 
  Int32 vec_ssa_1 ;
  Int32 vec_ssa_2 ;
  Int32 i_ssa_1 ;
  int __cil_tmp10 ;
  Int32 __cil_tmp11 ;
  Int32 *__cil_tmp12 ;
  Int32 __cil_tmp13 ;
  Int32 *__cil_tmp14 ;
  Int32 *__cil_tmp15 ;
  Int32 *__cil_tmp16 ;
  Int32 __cil_tmp17 ;
  Int32 __cil_tmp18 ;
  Int32 __cil_tmp19 ;
  Int32 *__cil_tmp20 ;
  Int32 *__cil_tmp21 ;

  {

#line 193
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_6(__cil_ap_limit, __cil_ap_base,
                                                         __cil_ap_minLen, __cil_ap_maxLen,
                                                         i, vec);
#line 193
  __cil_tmp11 = *__cil_ap_maxLen;
#line 193
  __cil_tmp10 = i <= __cil_tmp11;
#line 193
  if (__cil_tmp10 != 0) {
#line 194
    __cil_tmp12 = *__cil_ap_base;
#line 194
    __cil_tmp13 = i + 1;
#line 194
    __cil_tmp14 = __cil_tmp12 + __cil_tmp13;
#line 194
    __cil_tmp15 = *__cil_ap_base;
#line 194
    __cil_tmp16 = __cil_tmp15 + i;
#line 194
    __cil_tmp17 = *__cil_tmp14;
#line 194
    __cil_tmp18 = *__cil_tmp16;
#line 194
    __cil_tmp19 = __cil_tmp17 - __cil_tmp18;
#line 194
    vec_ssa_1 = vec + __cil_tmp19;
#line 195
    __cil_tmp20 = *__cil_ap_limit;
#line 195
    __cil_tmp21 = __cil_tmp20 + i;
#line 195
    *__cil_tmp21 = vec_ssa_1 - 1;
#line 196
    vec_ssa_2 = vec_ssa_1 << 1;
#line 193
    i_ssa_1 = i + 1;
#line 196
    BZ2_hbCreateDecodeTables_cil_lr_6(__cil_ap_limit, __cil_ap_base, __cil_ap_minLen,
                                      __cil_ap_maxLen, i_ssa_1, vec_ssa_2);
#line 199
    return;
  } else {
#line 201
    return;
  }
}
}
#line 206 "huffman.c"
void BZ2_hbCreateDecodeTables_cil_lr_7(Int32 *limit , Int32 *base , Int32 maxLen ,
                                       Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  Int32 *__cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Int32 __cil_tmp10 ;
  Int32 *__cil_tmp11 ;
  Int32 __cil_tmp12 ;
  Int32 __cil_tmp13 ;
  Int32 *__cil_tmp14 ;

  {

#line 198
  return babel_wrapper_BZ2_hbCreateDecodeTables_cil_lr_7(limit, base, maxLen, i);
#line 198
  __cil_tmp6 = i <= maxLen;
#line 198
  if (__cil_tmp6 != 0) {
#line 199
    __cil_tmp7 = i - 1;
#line 199
    __cil_tmp8 = limit + __cil_tmp7;
#line 199
    __cil_tmp9 = *__cil_tmp8;
#line 199
    __cil_tmp10 = __cil_tmp9 + 1;
#line 199
    __cil_tmp11 = base + i;
#line 199
    __cil_tmp12 = __cil_tmp10 << 1;
#line 199
    __cil_tmp13 = *__cil_tmp11;
#line 199
    __cil_tmp14 = base + i;
#line 199
    *__cil_tmp14 = __cil_tmp12 - __cil_tmp13;
#line 198
    i_ssa_1 = i + 1;
#line 201
    BZ2_hbCreateDecodeTables_cil_lr_7(limit, base, maxLen, i_ssa_1);
#line 203
    return;
  } else {
#line 205
    return;
  }
}
}
#line 210 "huffman.c"
void BZ2_hbAssignCodes_cil_lr_1(Int32 *code , UChar *length , Int32 maxLen , Int32 alphaSize ,
                                Int32 n , Int32 vec ) 
{ 
  Int32 **__cil_pp_code ;
  UChar **__cil_pp_length ;
  Int32 *__cil_pp_maxLen ;
  Int32 *__cil_pp_alphaSize ;
  Int32 *__cil_pp_n ;
  Int32 *__cil_pp_vec ;
  Int32 **__cil_fp_code ;
  UChar **__cil_fp_length ;
  Int32 *__cil_fp_maxLen ;
  Int32 *__cil_fp_alphaSize ;
  Int32 *__cil_fp_n ;
  Int32 *__cil_fp_vec ;
  Int32 i_ssa_1 ;
  Int32 *code_ssa_1 ;
  UChar *length_ssa_1 ;
  Int32 maxLen_ssa_1 ;
  Int32 alphaSize_ssa_1 ;
  Int32 n_ssa_1 ;
  Int32 vec_ssa_1 ;
  Int32 vec_ssa_2 ;
  Int32 n_ssa_2 ;
  int __cil_tmp29 ;

  {
#line 213
  __cil_fp_vec = & vec;
#line 213
  __cil_fp_n = & n;
#line 213
  __cil_fp_alphaSize = & alphaSize;
#line 213
  __cil_fp_maxLen = & maxLen;
#line 213
  __cil_fp_length = & length;
#line 213
  __cil_fp_code = & code;
#line 213
  __cil_pp_vec = & vec;
#line 213
  __cil_pp_n = & n;
#line 213
  __cil_pp_alphaSize = & alphaSize;
#line 213
  __cil_pp_maxLen = & maxLen;
#line 213
  __cil_pp_length = & length;
#line 213
  __cil_pp_code = & code;
#line 213
  return babel_wrapper_BZ2_hbAssignCodes_cil_lr_1(__cil_pp_code, __cil_pp_length,
                                                  __cil_pp_maxLen, __cil_pp_alphaSize,
                                                  __cil_pp_n, __cil_pp_vec, __cil_fp_code,
                                                  __cil_fp_length, __cil_fp_maxLen,
                                                  __cil_fp_alphaSize, __cil_fp_n,
                                                  __cil_fp_vec, code, length, maxLen,
                                                  alphaSize, n, vec);
#line 213
  __cil_pp_code = & code;
#line 214
  __cil_pp_length = & length;
#line 215
  __cil_pp_maxLen = & maxLen;
#line 216
  __cil_pp_alphaSize = & alphaSize;
#line 217
  __cil_pp_n = & n;
#line 218
  __cil_pp_vec = & vec;
#line 219
  __cil_fp_code = & code;
#line 220
  __cil_fp_length = & length;
#line 221
  __cil_fp_maxLen = & maxLen;
#line 222
  __cil_fp_alphaSize = & alphaSize;
#line 223
  __cil_fp_n = & n;
#line 224
  __cil_fp_vec = & vec;
#line 161
  __cil_tmp29 = n <= maxLen;
#line 161
  if (__cil_tmp29 != 0) {
#line 162
    i_ssa_1 = 0;
#line 165
    *__cil_fp_code = code;
#line 166
    *__cil_fp_length = length;
#line 167
    *__cil_fp_maxLen = maxLen;
#line 168
    *__cil_fp_alphaSize = alphaSize;
#line 169
    *__cil_fp_n = n;
#line 170
    *__cil_fp_vec = vec;
#line 162
    BZ2_hbAssignCodes_cil_lr_1_cil_lr_1(__cil_pp_code, __cil_pp_length, __cil_pp_maxLen,
                                        __cil_pp_alphaSize, __cil_pp_n, __cil_pp_vec,
                                        i_ssa_1);
#line 165
    code_ssa_1 = *__cil_fp_code;
#line 166
    length_ssa_1 = *__cil_fp_length;
#line 167
    maxLen_ssa_1 = *__cil_fp_maxLen;
#line 168
    alphaSize_ssa_1 = *__cil_fp_alphaSize;
#line 169
    n_ssa_1 = *__cil_fp_n;
#line 170
    vec_ssa_1 = *__cil_fp_vec;
#line 164
    vec_ssa_2 = vec_ssa_1 << 1;
#line 161
    n_ssa_2 = n_ssa_1 + 1;
#line 164
    BZ2_hbAssignCodes_cil_lr_1(code_ssa_1, length_ssa_1, maxLen_ssa_1, alphaSize_ssa_1,
                               n_ssa_2, vec_ssa_2);
#line 167
    return;
  } else {
#line 169
    return;
  }
}
}
#line 174 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_1(UChar **__cil_ap_len , Int32 *__cil_ap_alphaSize ,
                                    Int32 *__cil_ap_maxLen , Int32 *freq , Int32 i ,
                                    Int32 *weight ) 
{ 
  int tmp ;
  int tmp_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  Int32 __cil_tmp12 ;
  Int32 *__cil_tmp13 ;
  Int32 __cil_tmp14 ;
  Int32 *__cil_tmp15 ;
  Int32 __cil_tmp16 ;
  Int32 *__cil_tmp17 ;
  Int32 __cil_tmp18 ;
  Int32 *__cil_tmp19 ;

  {
#line 79
  __cil_tmp12 = *__cil_ap_alphaSize;
#line 79
  __cil_tmp10 = i < __cil_tmp12;
#line 79
  if (__cil_tmp10 != 0) {
#line 80
    __cil_tmp13 = freq + i;
#line 80
    __cil_tmp14 = *__cil_tmp13;
#line 80
    __cil_tmp11 = __cil_tmp14 == 0;
#line 80
    if (__cil_tmp11 != 0) {
#line 80
      tmp_ssa_1 = 1;
    } else {
#line 80
      __cil_tmp15 = freq + i;
#line 80
      tmp_ssa_1 = *__cil_tmp15;
    }
#line 80
    __cil_tmp16 = i + 1;
#line 80
    __cil_tmp17 = (Int32 *)(weight + __cil_tmp16);
#line 80
    *__cil_tmp17 = tmp_ssa_1 << 8;
#line 79
    i_ssa_1 = i + 1;
#line 82
    BZ2_hbMakeCodeLengths_cil_lr_1(__cil_ap_len, __cil_ap_alphaSize, __cil_ap_maxLen,
                                   freq, i_ssa_1, weight);
#line 85
    return;
  } else {
#line 87
    return;
  }
#line 80
  __cil_tmp18 = i + 1;
#line 80
  __cil_tmp19 = (Int32 *)(weight + __cil_tmp18);
#line 80
  *__cil_tmp19 = tmp << 8;
#line 79
  i_ssa_1 = i + 1;
#line 82
  BZ2_hbMakeCodeLengths_cil_lr_1(__cil_ap_len, __cil_ap_alphaSize, __cil_ap_maxLen,
                                 freq, i_ssa_1, weight);
#line 85
  return;
}
}
#line 88 "huffman.c"
void BZ2_hbMakeCodeLengths_cil_lr_2(UChar *len , Int32 alphaSize , Int32 maxLen ,
                                    Int32 *heap , Int32 *weight , Int32 *parent ) 
{ 
  Int32 nNodes ;
  Int32 nHeap ;
  Bool tooLong ;
  UChar **__cil_pp_len ;
  Int32 *__cil_pp_alphaSize ;
  Int32 *__cil_pp_maxLen ;
  Int32 *__cil_pp_nNodes ;
  Int32 *__cil_pp_nHeap ;
  Bool *__cil_pp_tooLong ;
  UChar **__cil_fp_len ;
  Int32 *__cil_fp_alphaSize ;
  Int32 *__cil_fp_maxLen ;
  Int32 *__cil_fp_nNodes ;
  Int32 *__cil_fp_nHeap ;
  Bool *__cil_fp_tooLong ;
  Int32 nNodes_ssa_1 ;
  Int32 nHeap_ssa_1 ;
  Int32 i_ssa_1 ;
  UChar *len_ssa_1 ;
  Int32 alphaSize_ssa_1 ;
  Int32 maxLen_ssa_1 ;
  Int32 nNodes_ssa_2 ;
  Int32 nHeap_ssa_2 ;
  UChar *len_ssa_2 ;
  Int32 alphaSize_ssa_2 ;
  Int32 maxLen_ssa_2 ;
  Int32 nNodes_ssa_3 ;
  Bool tooLong_ssa_1 ;
  Int32 i_ssa_2 ;
  UChar *len_ssa_3 ;
  Int32 alphaSize_ssa_3 ;
  Int32 maxLen_ssa_3 ;
  Bool tooLong_ssa_2 ;
  Int32 i_ssa_3 ;
  UChar *len_ssa_4 ;
  Int32 alphaSize_ssa_4 ;
  Int32 maxLen_ssa_4 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  Int32 *mem_48 ;
  Int32 *mem_49 ;
  Int32 *mem_50 ;

  {
#line 94
  __cil_pp_len = & len;
#line 95
  __cil_pp_alphaSize = & alphaSize;
#line 96
  __cil_pp_maxLen = & maxLen;
#line 97
  __cil_pp_nNodes = & nNodes;
#line 98
  __cil_pp_nHeap = & nHeap;
#line 99
  __cil_pp_tooLong = & tooLong;
#line 100
  __cil_fp_len = & len;
#line 101
  __cil_fp_alphaSize = & alphaSize;
#line 102
  __cil_fp_maxLen = & maxLen;
#line 103
  __cil_fp_nNodes = & nNodes;
#line 104
  __cil_fp_nHeap = & nHeap;
#line 105
  __cil_fp_tooLong = & tooLong;
#line 84
  nNodes_ssa_1 = alphaSize;
#line 85
  nHeap_ssa_1 = 0;
#line 87
  mem_48 = (Int32 *)heap;
#line 87
  *mem_48 = 0;
#line 88
  mem_49 = (Int32 *)weight;
#line 88
  *mem_49 = 0;
#line 89
  mem_50 = (Int32 *)parent;
#line 89
  *mem_50 = -2;
#line 91
  i_ssa_1 = 1;
#line 94
  *__cil_fp_len = len;
#line 95
  *__cil_fp_alphaSize = alphaSize;
#line 96
  *__cil_fp_maxLen = maxLen;
#line 97
  *__cil_fp_nNodes = nNodes_ssa_1;
#line 98
  *__cil_fp_nHeap = nHeap_ssa_1;
#line 91
  BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_1(__cil_pp_len, __cil_pp_alphaSize, __cil_pp_maxLen,
                                          __cil_pp_nNodes, __cil_pp_nHeap, heap, weight,
                                          parent, i_ssa_1);
#line 94
  len_ssa_1 = *__cil_fp_len;
#line 95
  alphaSize_ssa_1 = *__cil_fp_alphaSize;
#line 96
  maxLen_ssa_1 = *__cil_fp_maxLen;
#line 97
  nNodes_ssa_2 = *__cil_fp_nNodes;
#line 98
  nHeap_ssa_2 = *__cil_fp_nHeap;
#line 98
  __cil_tmp63 = nHeap_ssa_2 < 260;
#line 98
  __cil_tmp61 = ! __cil_tmp63;
#line 98
  if (__cil_tmp61 != 0) {
#line 98
    BZ2_bz__AssertH__fail(2001);
  } else {

  }
#line 105
  *__cil_fp_len = len_ssa_1;
#line 106
  *__cil_fp_alphaSize = alphaSize_ssa_1;
#line 107
  *__cil_fp_maxLen = maxLen_ssa_1;
#line 108
  *__cil_fp_nNodes = nNodes_ssa_2;
#line 100
  BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_2(__cil_pp_len, __cil_pp_alphaSize, __cil_pp_maxLen,
                                          __cil_pp_nNodes, heap, weight, parent, nHeap_ssa_2);
#line 102
  len_ssa_2 = *__cil_fp_len;
#line 103
  alphaSize_ssa_2 = *__cil_fp_alphaSize;
#line 104
  maxLen_ssa_2 = *__cil_fp_maxLen;
#line 105
  nNodes_ssa_3 = *__cil_fp_nNodes;
#line 112
  __cil_tmp64 = nNodes_ssa_3 < 516;
#line 112
  __cil_tmp62 = ! __cil_tmp64;
#line 112
  if (__cil_tmp62 != 0) {
#line 112
    BZ2_bz__AssertH__fail(2002);
  } else {

  }
#line 114
  tooLong_ssa_1 = (Bool )0;
#line 115
  i_ssa_2 = 1;
#line 118
  *__cil_fp_len = len_ssa_2;
#line 119
  *__cil_fp_alphaSize = alphaSize_ssa_2;
#line 120
  *__cil_fp_maxLen = maxLen_ssa_2;
#line 121
  *__cil_fp_tooLong = tooLong_ssa_1;
#line 115
  BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_3(__cil_pp_len, __cil_pp_alphaSize, __cil_pp_maxLen,
                                          __cil_pp_tooLong, parent, i_ssa_2);
#line 117
  len_ssa_3 = *__cil_fp_len;
#line 118
  alphaSize_ssa_3 = *__cil_fp_alphaSize;
#line 119
  maxLen_ssa_3 = *__cil_fp_maxLen;
#line 120
  tooLong_ssa_2 = *__cil_fp_tooLong;
#line 123
  if (tooLong_ssa_2 == 0) {
#line 124
    return;
  } else {
#line 142
    i_ssa_3 = 1;
#line 145
    *__cil_fp_len = len_ssa_3;
#line 146
    *__cil_fp_alphaSize = alphaSize_ssa_3;
#line 147
    *__cil_fp_maxLen = maxLen_ssa_3;
#line 142
    BZ2_hbMakeCodeLengths_cil_lr_2_cil_lr_4(__cil_pp_len, __cil_pp_alphaSize, __cil_pp_maxLen,
                                            weight, i_ssa_3);
#line 144
    len_ssa_4 = *__cil_fp_len;
#line 145
    alphaSize_ssa_4 = *__cil_fp_alphaSize;
#line 146
    maxLen_ssa_4 = *__cil_fp_maxLen;
#line 149
    BZ2_hbMakeCodeLengths_cil_lr_2(len_ssa_4, alphaSize_ssa_4, maxLen_ssa_4, heap,
                                   weight, parent);
#line 152
    return;
  }
}
}
#include <gprolog.h>


PlBool babel__implicit_BZ2_hbAssignCodesc_0(Int32 * arg_0, UChar * arg_1, Int32  arg_2, Int32  arg_3, Int32  arg_4, Int32  arg_5) 
{
BZ2_hbAssignCodes_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTablesc_1(Int32 ** arg_0, Int32 ** arg_1, UChar ** arg_2, Int32 * arg_3, Int32 * arg_4, Int32 * arg_5, Int32 * arg_6, Int32  arg_7, Int32  arg_8) 
{
BZ2_hbCreateDecodeTables_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTablesc_2(Int32 ** arg_0, Int32 ** arg_1, UChar ** arg_2, Int32 * arg_3, Int32 * arg_4, Int32 * arg_5, Int32  arg_6) 
{
BZ2_hbCreateDecodeTables_cil_lr_2(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTablesc_3(Int32 ** arg_0, Int32 ** arg_1, Int32 * arg_2, Int32 * arg_3, UChar * arg_4, Int32  arg_5, Int32  arg_6) 
{
BZ2_hbCreateDecodeTables_cil_lr_3(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTablesc_4(Int32 ** arg_0, Int32 ** arg_1, Int32 * arg_2, Int32 * arg_3, Int32  arg_4) 
{
BZ2_hbCreateDecodeTables_cil_lr_4(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTablesc_5(Int32 ** arg_0, Int32 ** arg_1, Int32 * arg_2, Int32 * arg_3, Int32  arg_4) 
{
BZ2_hbCreateDecodeTables_cil_lr_5(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTablesc_6(Int32 ** arg_0, Int32 ** arg_1, Int32 * arg_2, Int32 * arg_3, Int32  arg_4, Int32  arg_5) 
{
BZ2_hbCreateDecodeTables_cil_lr_6(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTablesc_7(Int32 * arg_0, Int32 * arg_1, Int32  arg_2, Int32  arg_3) 
{
BZ2_hbCreateDecodeTables_cil_lr_7(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTables_cil_lr_1c_10(Int32 ** arg_0, Int32 * arg_1, Int32 * arg_2, UChar ** arg_3, Int32 * arg_4, Int32  arg_5) 
{
BZ2_hbCreateDecodeTables_cil_lr_1_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbCreateDecodeTables_cil_lr_1c_11(Int32 ** arg_0, Int32 ** arg_1, UChar ** arg_2, Int32 * arg_3, Int32 * arg_4, Int32 * arg_5, Int32 * arg_6, Int32  arg_7, Int32  arg_8) 
{
BZ2_hbCreateDecodeTables_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbAssignCodes_cil_lr_1c_18(Int32 ** arg_0, UChar ** arg_1, Int32 * arg_2, Int32 * arg_3, Int32 * arg_4, Int32 * arg_5, Int32  arg_6) 
{
BZ2_hbAssignCodes_cil_lr_1_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6);
return PL_TRUE;
}
PlBool babel__implicit_BZ2_hbAssignCodes_cil_lr_1c_19(Int32 * arg_0, UChar * arg_1, Int32  arg_2, Int32  arg_3, Int32  arg_4, Int32  arg_5) 
{
BZ2_hbAssignCodes_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
return PL_TRUE;
}
