#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 137 "bzlib.h"
typedef void BZFILE;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 161 "bzip2.c"
typedef char Char;
#line 162 "bzip2.c"
#line 163 "bzip2.c"
typedef unsigned char UChar;
#line 164 "bzip2.c"
typedef int Int32;
#line 165 "bzip2.c"
typedef unsigned int UInt32;
#line 166 "bzip2.c"
typedef short Int16;
#line 167 "bzip2.c"
typedef unsigned short UInt16;
#line 176 "bzip2.c"
typedef int IntNative;
#line 232 "bzip2.c"
struct __anonstruct_UInt64_56 {
   UChar b[8] ;
};
#line 232 "bzip2.c"
typedef struct __anonstruct_UInt64_56 UInt64;
#line 1694 "bzip2.c"
struct zzzz {
   Char *name ;
   struct zzzz *link ;
};
#line 1694 "bzip2.c"
typedef struct zzzz Cell;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 139 "bzlib.h"
extern BZFILE *BZ2_bzReadOpen(int *bzerror , FILE *f , int verbosity , int small ,
                              void *unused , int nUnused ) ;
#line 148
extern void BZ2_bzReadClose(int *bzerror , BZFILE *b ) ;
#line 153
extern void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) ;
#line 160
extern int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 167
extern BZFILE *BZ2_bzWriteOpen(int *bzerror , FILE *f , int blockSize100k , int verbosity ,
                               int workFactor ) ;
#line 175
extern void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 190
extern void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                               unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                               unsigned int *nbytes_out_hi32 ) ;
#line 233
extern char const   *BZ2_bzlibVersion(void) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 478
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 267
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 183 "bzip2.c"
Int32 verbosity  ;
#line 184 "bzip2.c"
Bool keepInputFiles  ;
#line 184 "bzip2.c"
Bool smallMode  ;
#line 184 "bzip2.c"
Bool deleteOutputOnInterrupt  ;
#line 185 "bzip2.c"
Bool forceOverwrite  ;
#line 185 "bzip2.c"
Bool testFailsExist  ;
#line 185 "bzip2.c"
Bool unzFailsExist  ;
#line 185 "bzip2.c"
Bool noisy  ;
#line 186 "bzip2.c"
Int32 numFileNames  ;
#line 186 "bzip2.c"
Int32 numFilesProcessed  ;
#line 186 "bzip2.c"
Int32 blockSize100k  ;
#line 187 "bzip2.c"
Int32 exitValue  ;
#line 199 "bzip2.c"
Int32 opMode  ;
#line 200 "bzip2.c"
Int32 srcMode  ;
#line 204 "bzip2.c"
Int32 longestFileName  ;
#line 205 "bzip2.c"
Char inName[1034]  ;
#line 206 "bzip2.c"
Char outName[1034]  ;
#line 207 "bzip2.c"
Char tmpName[1034]  ;
#line 208 "bzip2.c"
Char *progName  ;
#line 209 "bzip2.c"
Char progNameReally[1034]  ;
#line 210 "bzip2.c"
FILE *outputHandleJustInCase  ;
#line 211 "bzip2.c"
Int32 workFactor  ;
#line 213
static  __attribute__((__noreturn__)) void panic(Char const   *s ) ;
#line 214
static  __attribute__((__noreturn__)) void ioError(void) ;
#line 215
static  __attribute__((__noreturn__)) void outOfMemory(void) ;
#line 216
static  __attribute__((__noreturn__)) void configError(void) ;
#line 217
static  __attribute__((__noreturn__)) void crcError(void) ;
#line 218
static  __attribute__((__noreturn__)) void cleanUpAndFail(Int32 ec ) ;
#line 219
static  __attribute__((__noreturn__)) void compressedStreamEOF(void) ;
#line 221
static void copyFileName(Char *to , Char *from ) ;
#line 222
static void *myMalloc(Int32 n ) ;
#line 223
static void applySavedFileAttrToOutputFile(IntNative fd ) ;
#line 1033 "bzip2.c"
static struct stat fileMetaInfo  ;
#line 1104 "bzip2.c"
Char const   *zSuffix[4]  = {      ".bz2",      ".bz",      ".tbz2",      ".tbz"};
#line 1106 "bzip2.c"
Char const   *unzSuffix[4]  = {      "",      "",      ".tar",      ".tar"};
#line 1107
void addFlagsFromEnvVar_cil_lr_1_cil_lr_1(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) ;
#line 1109
void addFlagsFromEnvVar_cil_lr_1_cil_lr_2(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) ;
#line 1111
void addFlagsFromEnvVar_cil_lr_1_cil_lr_3(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p , Int32 *__cil_ap_k ,
                                          Int32 j ) ;
#line 1114
void addFlagsFromEnvVar_cil_lr_1(Cell **argList , Int32 i , Char *p ) ;
#line 1115
void snocString_cil_lr_1(Cell **__cil_ap_root , Char **__cil_ap_name , Cell **__cil_ap_tmp___3 ) ;
#line 1116
void pad_cil_lr_1(Char *s , Int32 i ) ;
#line 1117
void uInt64_toAscii_cil_lr_1(char **__cil_ap_outbuf , Int32 *__cil_ap_nBuf , UChar *buf ,
                             UInt64 n_copy ) ;
#line 1119
void uInt64_toAscii_cil_lr_2(char *outbuf , Int32 i , UChar *buf , Int32 nBuf ) ;
#line 1120
void uInt64_qrm10_cil_lr_1(UInt32 *__cil_ap_rem , UInt64 *n , Int32 i ) ;
#line 1121
int uInt64_isZero_cil_lr_1(Bool *__cil_ap___cil_ret3 , UInt64 *n , Int32 i ) ;
#line 1122
void uInt64_to_double_cil_lr_1(double *__cil_ap_sum , UInt64 *n , Int32 i , double base ) ;

int babel_wrapper_uInt64_from_UInt32s(UInt64 * n, UInt32  lo32, UInt32  hi32)                           // function name insert
   {
     // wrapper for function uInt64_from_UInt32s        // function name insert
      int return_value; //  return value type (how about array type)
                                                                                                                                                                                                              
     //rountine code
     int func;
     PlTerm arg[4];    //  function variable + return value insert
     PlBool res;
                                                                                                                                                                                                              
     func = Pl_Find_Atom("uInt64_from_UInt32s"); // function name insert
                                                                                                                                                                                                              
   //routine code
     Pl_Query_Begin(PL_FALSE);
                                                                                                                                                                                                              
   //prepare parameters
   //partial routine code, pass in parameter  // we need to init arguments and return value
   arg[0] = Pl_Mk_Integer(n);
 arg[1] = Pl_Mk_Positive(lo32);
 arg[2] = Pl_Mk_Positive(hi32);
                                                                                                                                                                                                              
   //routine code, reserve a place for return value
   arg[3] = Pl_Mk_Variable();
                                                                                                                                                                                                              
   //partial routine code, 2 is not routine. (number of arguments) + 1
     res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)
                                                                                                                                                                                                              
   //get return value, partial routine code, 1 is not routine
     return_value = Pl_Rd_Integer(arg[3]);        // insert ()
                                                                                                                                                                                                              
   //routine code
     Pl_Query_End(PL_KEEP_FOR_PROLOG);
                                                                                                                                                                                                              
   //routine code
     return 0;
     }
   
int babel_wrapper_uInt64_toAscii(char ** __cil_pp_outbuf, Int32 * __cil_pp_nBuf, char ** __cil_fp_outbuf, Int32 * __cil_fp_nBuf, char * outbuf, UInt64 * n)                           // function name insert
   {
     // wrapper for function uInt64_toAscii        // function name insert
      int return_value; //  return value type (how about array type)
                                                                                                                                                                                                              
     //rountine code
     int func;
     PlTerm arg[7];    //  function variable + return value insert
     PlBool res;
                                                                                                                                                                                                              
     func = Pl_Find_Atom("uInt64_toAscii"); // function name insert
                                                                                                                                                                                                              
   //routine code
     Pl_Query_Begin(PL_FALSE);
                                                                                                                                                                                                              
   //prepare parameters
   //partial routine code, pass in parameter  // we need to init arguments and return value
   arg[0] = Pl_Mk_Integer(__cil_pp_outbuf);
arg[1] = Pl_Mk_Integer(__cil_pp_nBuf);
arg[2] = Pl_Mk_Integer(__cil_fp_outbuf);
arg[3] = Pl_Mk_Integer(__cil_fp_nBuf);
arg[4] = Pl_Mk_Integer(outbuf);
arg[5] = Pl_Mk_Integer(n);
                                                                                                                                                                                                              
   //routine code, reserve a place for return value
   arg[6] = Pl_Mk_Variable();
                                                                                                                                                                                                              
   //partial routine code, 2 is not routine. (number of arguments) + 1
     res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)
                                                                                                                                                                                                              
   //get return value, partial routine code, 1 is not routine
     return_value = Pl_Rd_Integer(arg[6]);        // insert ()
                                                                                                                                                                                                              
   //routine code
     Pl_Query_End(PL_KEEP_FOR_PROLOG);
                                                                                                                                                                                                              
   //routine code
     return 0;
     }
   


   double  babel_wrapper_uInt64_to_double(double * __cil_pp_sum, double * __cil_fp_sum, UInt64 * n)                           // function name insert
      {
        // wrapper for function uInt64_to_double        // function name insert
         double  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("uInt64_to_double"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_sum);
arg[1] = Pl_Mk_Integer(__cil_fp_sum);
arg[2] = Pl_Mk_Integer(n);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Float(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Bool  babel_wrapper_uInt64_isZero(Bool * __cil_pp___cil_ret3, Bool * __cil_fp___cil_ret3, UInt64 * n)                           // function name insert
      {
        // wrapper for function uInt64_isZero        // function name insert
         Bool  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("uInt64_isZero"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp___cil_ret3);
arg[1] = Pl_Mk_Integer(__cil_fp___cil_ret3);
arg[2] = Pl_Mk_Integer(n);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Int32  babel_wrapper_uInt64_qrm10(UInt32 * __cil_pp_rem, UInt32 * __cil_fp_rem, UInt64 * n)                           // function name insert
      {
        // wrapper for function uInt64_qrm10        // function name insert
         Int32  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("uInt64_qrm10"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_rem);
arg[1] = Pl_Mk_Integer(__cil_fp_rem);
arg[2] = Pl_Mk_Integer(n);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Bool  babel_wrapper_myfeof(FILE * f)                           // function name insert
      {
        // wrapper for function myfeof        // function name insert
         Bool  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("myfeof"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_setExit(Int32 * __cil_gp_exitValue, Int32  v)                           // function name insert
      {
        // wrapper for function setExit        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("setExit"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_exitValue);
arg[1] = Pl_Mk_Integer(v);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_cadvise(Bool * __cil_gp_noisy, struct _IO_FILE ** __cil_gp_stderr)                           // function name insert
      {
        // wrapper for function cadvise        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("cadvise"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_noisy);
arg[1] = Pl_Mk_Integer(__cil_gp_stderr);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_showFileNames(Bool * __cil_gp_noisy, struct _IO_FILE ** __cil_gp_stderr)                           // function name insert
      {
        // wrapper for function showFileNames        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("showFileNames"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_noisy);
arg[1] = Pl_Mk_Integer(__cil_gp_stderr);
arg[2] = Pl_Mk_Integer(inName);
arg[3] = Pl_Mk_Integer(outName);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_cleanUpAndFail(struct stat * __cil_pp_statBuf, Int32 * __cil_gp_srcMode, Int32 * __cil_gp_opMode, Bool * __cil_gp_deleteOutputOnInterrupt, Bool * __cil_gp_noisy, struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName, FILE ** __cil_gp_outputHandleJustInCase, Int32 * __cil_gp_numFileNames, Int32 * __cil_gp_numFilesProcessed, Int32 * __cil_gp_exitValue, Int32  ec)                           // function name insert
      {
        // wrapper for function cleanUpAndFail        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[15];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("cleanUpAndFail"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_statBuf);
arg[1] = Pl_Mk_Integer(__cil_gp_srcMode);
arg[2] = Pl_Mk_Integer(__cil_gp_opMode);
arg[3] = Pl_Mk_Integer(__cil_gp_deleteOutputOnInterrupt);
arg[4] = Pl_Mk_Integer(__cil_gp_noisy);
arg[5] = Pl_Mk_Integer(__cil_gp_stderr);
arg[6] = Pl_Mk_Integer(__cil_gp_progName);
arg[7] = Pl_Mk_Integer(__cil_gp_outputHandleJustInCase);
arg[8] = Pl_Mk_Integer(__cil_gp_numFileNames);
arg[9] = Pl_Mk_Integer(__cil_gp_numFilesProcessed);
arg[10] = Pl_Mk_Integer(__cil_gp_exitValue);
arg[11] = Pl_Mk_Integer(ec);
arg[12] = Pl_Mk_Integer(inName);
arg[13] = Pl_Mk_Integer(outName);

      //routine code, reserve a place for return value
      arg[14] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 15, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[14]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_panic(struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName, Char const   * s)                           // function name insert
      {
        // wrapper for function panic        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("panic"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_progName);
arg[2] = Pl_Mk_Integer(s);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_crcError(struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName)                           // function name insert
      {
        // wrapper for function crcError        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("crcError"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_progName);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_compressedStreamEOF(Bool * __cil_gp_noisy, struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName)                           // function name insert
      {
        // wrapper for function compressedStreamEOF        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("compressedStreamEOF"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_noisy);
arg[1] = Pl_Mk_Integer(__cil_gp_stderr);
arg[2] = Pl_Mk_Integer(__cil_gp_progName);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_ioError(struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName)                           // function name insert
      {
        // wrapper for function ioError        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("ioError"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_progName);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_mySignalCatcher(struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName, IntNative  n)                           // function name insert
      {
        // wrapper for function mySignalCatcher        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("mySignalCatcher"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_progName);
arg[2] = Pl_Mk_Integer(n);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_mySIGSEGVorSIGBUScatcher(Int32 * __cil_gp_opMode, struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName, IntNative  n)                           // function name insert
      {
        // wrapper for function mySIGSEGVorSIGBUScatcher        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("mySIGSEGVorSIGBUScatcher"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_opMode);
arg[1] = Pl_Mk_Integer(__cil_gp_stderr);
arg[2] = Pl_Mk_Integer(__cil_gp_progName);
arg[3] = Pl_Mk_Integer(n);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_outOfMemory(struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName)                           // function name insert
      {
        // wrapper for function outOfMemory        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("outOfMemory"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_progName);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_configError(struct _IO_FILE ** __cil_gp_stderr, Int32 * __cil_gp_exitValue)                           // function name insert
      {
        // wrapper for function configError        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("configError"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_exitValue);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_pad(Int32 * __cil_gp_longestFileName, Char * s)                           // function name insert
      {
        // wrapper for function pad        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("pad"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_longestFileName);
arg[1] = Pl_Mk_Integer(s);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_copyFileName(struct _IO_FILE ** __cil_gp_stderr, Int32 * __cil_gp_exitValue, Char * to, Char * from)                           // function name insert
      {
        // wrapper for function copyFileName        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("copyFileName"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_exitValue);
arg[2] = Pl_Mk_Integer(to);
arg[3] = Pl_Mk_Integer(from);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   Bool  babel_wrapper_fileExists(Char * name)                           // function name insert
      {
        // wrapper for function fileExists        // function name insert
         Bool  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("fileExists"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(name);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   FILE * babel_wrapper_fopen_output_safely(Char * name, char const   * mode)                           // function name insert
      {
        // wrapper for function fopen_output_safely        // function name insert
         FILE * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("fopen_output_safely"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(name);
arg[1] = Pl_Mk_Integer(mode);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Bool  babel_wrapper_notAStandardFile(struct stat * __cil_pp_statBuf, Char * name)                           // function name insert
      {
        // wrapper for function notAStandardFile        // function name insert
         Bool  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("notAStandardFile"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_statBuf);
arg[1] = Pl_Mk_Integer(name);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Int32  babel_wrapper_countHardLinks(struct stat * __cil_pp_statBuf, Char * name)                           // function name insert
      {
        // wrapper for function countHardLinks        // function name insert
         Int32  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("countHardLinks"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_statBuf);
arg[1] = Pl_Mk_Integer(name);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_saveInputFileMetaInfo(struct stat * __cil_pp_fileMetaInfo, Char * srcName)                           // function name insert
      {
        // wrapper for function saveInputFileMetaInfo        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("saveInputFileMetaInfo"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_fileMetaInfo);
arg[1] = Pl_Mk_Integer(srcName);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_applySavedTimeInfoToOutputFile(struct utimbuf * __cil_pp_uTimBuf, struct stat * __cil_pp_fileMetaInfo, Char * dstName)                           // function name insert
      {
        // wrapper for function applySavedTimeInfoToOutputFile        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("applySavedTimeInfoToOutputFile"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_uTimBuf);
arg[1] = Pl_Mk_Integer(__cil_pp_fileMetaInfo);
arg[2] = Pl_Mk_Integer(dstName);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_applySavedFileAttrToOutputFile(struct stat * __cil_pp_fileMetaInfo, IntNative  fd)                           // function name insert
      {
        // wrapper for function applySavedFileAttrToOutputFile        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("applySavedFileAttrToOutputFile"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_fileMetaInfo);
arg[1] = Pl_Mk_Integer(fd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   Bool  babel_wrapper_containsDubiousChars(Char * name)                           // function name insert
      {
        // wrapper for function containsDubiousChars        // function name insert
         Bool  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("containsDubiousChars"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(name);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Bool  babel_wrapper_hasSuffix(Char * s, Char const   * suffix)                           // function name insert
      {
        // wrapper for function hasSuffix        // function name insert
         Bool  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("hasSuffix"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(s);
arg[1] = Pl_Mk_Integer(suffix);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Bool  babel_wrapper_mapSuffix(Char * name, Char const   * oldSuffix, Char const   * newSuffix)                           // function name insert
      {
        // wrapper for function mapSuffix        // function name insert
         Bool  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("mapSuffix"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(name);
arg[1] = Pl_Mk_Integer(oldSuffix);
arg[2] = Pl_Mk_Integer(newSuffix);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_license(struct _IO_FILE ** __cil_gp_stderr)                           // function name insert
      {
        // wrapper for function license        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("license"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_usage(struct _IO_FILE ** __cil_gp_stderr, Char * fullProgName)                           // function name insert
      {
        // wrapper for function usage        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("usage"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(fullProgName);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_redundant(struct _IO_FILE ** __cil_gp_stderr, Char ** __cil_gp_progName, Char * flag)                           // function name insert
      {
        // wrapper for function redundant        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("redundant"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_stderr);
arg[1] = Pl_Mk_Integer(__cil_gp_progName);
arg[2] = Pl_Mk_Integer(flag);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   void * babel_wrapper_myMalloc(Int32  n)                           // function name insert
      {
        // wrapper for function myMalloc        // function name insert
         void * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("myMalloc"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(n);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   Cell * babel_wrapper_mkCell()                           // function name insert
      {
        // wrapper for function mkCell        // function name insert
         Cell * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[1];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("mkCell"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      
      //routine code, reserve a place for return value
      arg[0] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 1, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[0]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_addFlagsFromEnvVar(Cell ** argList, Char * varName)                           // function name insert
      {
        // wrapper for function addFlagsFromEnvVar        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("addFlagsFromEnvVar"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(argList);
arg[1] = Pl_Mk_Integer(varName);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_addFlagsFromEnvVar_cil_lr_1_cil_lr_1(Cell *** __cil_ap_argList, Int32 * __cil_ap_i, Char ** __cil_ap_p)                           // function name insert
      {
        // wrapper for function addFlagsFromEnvVar_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("addFlagsFromEnvVar_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_argList);
arg[1] = Pl_Mk_Integer(__cil_ap_i);
arg[2] = Pl_Mk_Integer(__cil_ap_p);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_addFlagsFromEnvVar_cil_lr_1_cil_lr_2(Cell *** __cil_ap_argList, Int32 * __cil_ap_i, Char ** __cil_ap_p)                           // function name insert
      {
        // wrapper for function addFlagsFromEnvVar_cil_lr_1_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("addFlagsFromEnvVar_cil_lr_1_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_argList);
arg[1] = Pl_Mk_Integer(__cil_ap_i);
arg[2] = Pl_Mk_Integer(__cil_ap_p);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_addFlagsFromEnvVar_cil_lr_1_cil_lr_3(Cell *** __cil_ap_argList, Int32 * __cil_ap_i, Char ** __cil_ap_p, Int32 * __cil_ap_k, Int32  j)                           // function name insert
      {
        // wrapper for function addFlagsFromEnvVar_cil_lr_1_cil_lr_3        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("addFlagsFromEnvVar_cil_lr_1_cil_lr_3"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_argList);
arg[1] = Pl_Mk_Integer(__cil_ap_i);
arg[2] = Pl_Mk_Integer(__cil_ap_p);
arg[3] = Pl_Mk_Integer(__cil_ap_k);
arg[4] = Pl_Mk_Integer(j);
arg[5] = Pl_Mk_Integer(tmpName);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_pad_cil_lr_1(Int32 * __cil_gp_longestFileName, struct _IO_FILE ** __cil_gp_stderr, Char * s, Int32  i)                           // function name insert
      {
        // wrapper for function pad_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("pad_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_longestFileName);
arg[1] = Pl_Mk_Integer(__cil_gp_stderr);
arg[2] = Pl_Mk_Integer(s);
arg[3] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_uInt64_toAscii_cil_lr_2(char * outbuf, Int32  i, UChar * buf, Int32  nBuf)                           // function name insert
      {
        // wrapper for function uInt64_toAscii_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("uInt64_toAscii_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(outbuf);
arg[1] = Pl_Mk_Integer(i);
arg[2] = Pl_Mk_Integer(buf);
arg[3] = Pl_Mk_Integer(nBuf);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_uInt64_qrm10_cil_lr_1(UInt32 * __cil_ap_rem, UInt64 * n, Int32  i)                           // function name insert
      {
        // wrapper for function uInt64_qrm10_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("uInt64_qrm10_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_rem);
arg[1] = Pl_Mk_Integer(n);
arg[2] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int  babel_wrapper_uInt64_isZero_cil_lr_1(Bool * __cil_ap___cil_ret3, UInt64 * n, Int32  i)                           // function name insert
      {
        // wrapper for function uInt64_isZero_cil_lr_1        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("uInt64_isZero_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap___cil_ret3);
arg[1] = Pl_Mk_Integer(n);
arg[2] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_uInt64_to_double_cil_lr_1(double * __cil_ap_sum, UInt64 * n, Int32  i, double  base)                           // function name insert
      {
        // wrapper for function uInt64_to_double_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("uInt64_to_double_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_sum);
arg[1] = Pl_Mk_Integer(n);
arg[2] = Pl_Mk_Integer(i);
arg[3] = Pl_Mk_Float(base);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 237 "bzip2.c"
static void uInt64_from_UInt32s(UInt64 *n , UInt32 lo32 , UInt32 hi32 ) 
{ 
  UInt32 __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  UChar *__cil_tmp6 ;
  UChar *__cil_tmp7 ;
  UInt32 __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  UChar *__cil_tmp10 ;
  UChar *__cil_tmp11 ;
  UInt32 __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  UChar *__cil_tmp14 ;
  UChar *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  UChar *__cil_tmp17 ;
  UChar *__cil_tmp18 ;
  UInt32 __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  UChar *__cil_tmp21 ;
  UChar *__cil_tmp22 ;
  UInt32 __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  UChar *__cil_tmp25 ;
  UChar *__cil_tmp26 ;
  UInt32 __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  UChar *__cil_tmp29 ;
  UChar *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  UChar *__cil_tmp32 ;
  UChar *__cil_tmp33 ;
  UChar (*mem_34)[8] ;
  UChar (*mem_35)[8] ;
  UChar (*mem_36)[8] ;
  UChar (*mem_37)[8] ;
  UChar (*mem_38)[8] ;
  UChar (*mem_39)[8] ;
  UChar (*mem_40)[8] ;
  UChar (*mem_41)[8] ;

  {
#line 240
  return babel_wrapper_uInt64_from_UInt32s(n, lo32, hi32);

  __cil_tmp4 = hi32 >> 24;
#line 240
  __cil_tmp5 = __cil_tmp4 & 255U;
#line 240
  mem_34 = (UChar (*)[8])n;
#line 240
  __cil_tmp6 = *mem_34;
#line 240
  __cil_tmp7 = __cil_tmp6 + 7;
#line 240
  *__cil_tmp7 = (UChar )__cil_tmp5;
#line 241
  __cil_tmp8 = hi32 >> 16;
#line 241
  __cil_tmp9 = __cil_tmp8 & 255U;
#line 241
  mem_35 = (UChar (*)[8])n;
#line 241
  __cil_tmp10 = *mem_35;
#line 241
  __cil_tmp11 = __cil_tmp10 + 6;
#line 241
  *__cil_tmp11 = (UChar )__cil_tmp9;
#line 242
  __cil_tmp12 = hi32 >> 8;
#line 242
  __cil_tmp13 = __cil_tmp12 & 255U;
#line 242
  mem_36 = (UChar (*)[8])n;
#line 242
  __cil_tmp14 = *mem_36;
#line 242
  __cil_tmp15 = __cil_tmp14 + 5;
#line 242
  *__cil_tmp15 = (UChar )__cil_tmp13;
#line 243
  __cil_tmp16 = hi32 & 255U;
#line 243
  mem_37 = (UChar (*)[8])n;
#line 243
  __cil_tmp17 = *mem_37;
#line 243
  __cil_tmp18 = __cil_tmp17 + 4;
#line 243
  *__cil_tmp18 = (UChar )__cil_tmp16;
#line 244
  __cil_tmp19 = lo32 >> 24;
#line 244
  __cil_tmp20 = __cil_tmp19 & 255U;
#line 244
  mem_38 = (UChar (*)[8])n;
#line 244
  __cil_tmp21 = *mem_38;
#line 244
  __cil_tmp22 = __cil_tmp21 + 3;
#line 244
  *__cil_tmp22 = (UChar )__cil_tmp20;
#line 245
  __cil_tmp23 = lo32 >> 16;
#line 245
  __cil_tmp24 = __cil_tmp23 & 255U;
#line 245
  mem_39 = (UChar (*)[8])n;
#line 245
  __cil_tmp25 = *mem_39;
#line 245
  __cil_tmp26 = __cil_tmp25 + 2;
#line 245
  *__cil_tmp26 = (UChar )__cil_tmp24;
#line 246
  __cil_tmp27 = lo32 >> 8;
#line 246
  __cil_tmp28 = __cil_tmp27 & 255U;
#line 246
  mem_40 = (UChar (*)[8])n;
#line 246
  __cil_tmp29 = *mem_40;
#line 246
  __cil_tmp30 = __cil_tmp29 + 1;
#line 246
  *__cil_tmp30 = (UChar )__cil_tmp28;
#line 247
  __cil_tmp31 = lo32 & 255U;
#line 247
  mem_41 = (UChar (*)[8])n;
#line 247
  __cil_tmp32 = *mem_41;
#line 247
  __cil_tmp33 = __cil_tmp32;
#line 247
  *__cil_tmp33 = (UChar )__cil_tmp31;
#line 248
  return;
}
}
#line 251 "bzip2.c"
static double uInt64_to_double(UInt64 *n ) 
{ 
  double sum ;
  double *__cil_pp_sum ;
  double *__cil_fp_sum ;
  double base_ssa_1 ;
  double sum_ssa_1 ;
  Int32 i_ssa_1 ;
  double sum_ssa_2 ;

  {
#line 254
  __cil_fp_sum = & sum;
#line 254
  __cil_pp_sum = & sum;
#line 254
  return babel_wrapper_uInt64_to_double(__cil_pp_sum, __cil_fp_sum, n);
#line 254
  __cil_pp_sum = & sum;
#line 255
  __cil_fp_sum = & sum;
#line 255
  base_ssa_1 = 1.0;
#line 256
  sum_ssa_1 = 0.0;
#line 257
  i_ssa_1 = 0;
#line 260
  *__cil_fp_sum = sum_ssa_1;
#line 257
  uInt64_to_double_cil_lr_1(__cil_pp_sum, n, i_ssa_1, base_ssa_1);
#line 258
  sum_ssa_2 = *__cil_fp_sum;
#line 261
  return (sum_ssa_2);
}
}
#line 265 "bzip2.c"
static Bool uInt64_isZero(UInt64 *n ) 
{ 
  Bool __cil_ret3 ;
  Bool *__cil_pp___cil_ret3 ;
  Bool *__cil_fp___cil_ret3 ;
  Int32 i_ssa_1 ;
  int retflag4_ssa_1 ;
  Bool __cil_ret3_ssa_1 ;

  {
#line 268
  __cil_fp___cil_ret3 = & __cil_ret3;
#line 268
  __cil_pp___cil_ret3 = & __cil_ret3;
#line 268
  return babel_wrapper_uInt64_isZero(__cil_pp___cil_ret3, __cil_fp___cil_ret3, n);
#line 268
  __cil_pp___cil_ret3 = & __cil_ret3;
#line 269
  __cil_fp___cil_ret3 = & __cil_ret3;
#line 269
  i_ssa_1 = 0;
#line 273
  *__cil_fp___cil_ret3 = __cil_ret3;
#line 269
  retflag4_ssa_1 = uInt64_isZero_cil_lr_1(__cil_pp___cil_ret3, n, i_ssa_1);
#line 270
  __cil_ret3_ssa_1 = *__cil_fp___cil_ret3;
#line 269
  if (retflag4_ssa_1 != 0) {
#line 269
    return (__cil_ret3_ssa_1);
  } else {
#line 271
    return ((Bool )1);
  }
}
}
#line 276 "bzip2.c"
static Int32 uInt64_qrm10(UInt64 *n ) 
{ 
  UInt32 rem ;
  UInt32 *__cil_pp_rem ;
  UInt32 *__cil_fp_rem ;
  UInt32 rem_ssa_1 ;
  Int32 i_ssa_1 ;
  UInt32 rem_ssa_2 ;

  {
#line 279
  __cil_fp_rem = & rem;
#line 279
  __cil_pp_rem = & rem;
#line 279
  return babel_wrapper_uInt64_qrm10(__cil_pp_rem, __cil_fp_rem, n);
#line 279
  __cil_pp_rem = & rem;
#line 280
  __cil_fp_rem = & rem;
#line 281
  rem_ssa_1 = (UInt32 )0;
#line 282
  i_ssa_1 = 7;
#line 285
  *__cil_fp_rem = rem_ssa_1;
#line 282
  uInt64_qrm10_cil_lr_1(__cil_pp_rem, n, i_ssa_1);
#line 283
  rem_ssa_2 = *__cil_fp_rem;
#line 287
  return ((Int32 )rem_ssa_2);
}
}
#line 294 "bzip2.c"
static void uInt64_toAscii(char *outbuf , UInt64 *n ) 
{ 
  UChar buf[32] ;
  Int32 nBuf ;
  char **__cil_pp_outbuf ;
  Int32 *__cil_pp_nBuf ;
  char **__cil_fp_outbuf ;
  Int32 *__cil_fp_nBuf ;
  Int32 nBuf_ssa_1 ;
  UInt64 n_copy_ssa_1 ;
  char *outbuf_ssa_1 ;
  Int32 nBuf_ssa_2 ;
  Int32 i_ssa_1 ;
  char *__cil_tmp18 ;

  {
#line 298
  __cil_pp_outbuf = & outbuf;
#line 299
  __cil_pp_nBuf = & nBuf;
#line 300
  __cil_fp_outbuf = & outbuf;
#line 301
  __cil_fp_nBuf = & nBuf;
#line 299
  return babel_wrapper_uInt64_toAscii(__cil_pp_outbuf, __cil_pp_nBuf, __cil_fp_outbuf,
                                      __cil_fp_nBuf, outbuf, n);

  nBuf_ssa_1 = 0;
#line 300
  n_copy_ssa_1 = *n;
#line 303
  *__cil_fp_outbuf = outbuf;
#line 304
  *__cil_fp_nBuf = nBuf_ssa_1;
#line 301
  uInt64_toAscii_cil_lr_1(__cil_pp_outbuf, __cil_pp_nBuf, (UChar *)(buf), n_copy_ssa_1);
#line 302
  outbuf_ssa_1 = *__cil_fp_outbuf;
#line 303
  nBuf_ssa_2 = *__cil_fp_nBuf;
#line 306
  __cil_tmp18 = outbuf_ssa_1 + nBuf_ssa_2;
#line 306
  *__cil_tmp18 = (char)0;
#line 307
  i_ssa_1 = 0;
#line 307
  uInt64_toAscii_cil_lr_2(outbuf_ssa_1, i_ssa_1, (UChar *)(buf), nBuf_ssa_2);
#line 309
  return;
}
}
#line 317 "bzip2.c"
static Bool myfeof(FILE *f ) 
{ 
  int tmp_ssa_1 ;
  Int32 c_ssa_1 ;
  int __cil_tmp6 ;

  {

#line 320
  return babel_wrapper_myfeof(f);
#line 320
  tmp_ssa_1 = fgetc(f);
#line 320
  c_ssa_1 = tmp_ssa_1;
#line 321
  __cil_tmp6 = c_ssa_1 == -1;
#line 321
  if (__cil_tmp6 != 0) {
#line 321
    return ((Bool )1);
  } else {
#line 322
    ungetc(c_ssa_1, f);
#line 323
    return ((Bool )0);
  }
}
}
#line 328 "bzip2.c"
static void compressStream(FILE *stream , FILE *zStream ) 
{ 
  BZFILE *bzf ;
  UChar ibuf[5000] ;
  Int32 nIbuf ;
  UInt32 nbytes_in_lo32 ;
  UInt32 nbytes_in_hi32 ;
  UInt32 nbytes_out_lo32 ;
  UInt32 nbytes_out_hi32 ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  int tmp ;
  int tmp___0 ;
  Bool tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  Int32 fd ;
  int tmp___5 ;
  int tmp___6 ;
  Char buf_nin[32] ;
  Char buf_nout[32] ;
  UInt64 nbytes_in ;
  UInt64 nbytes_out ;
  double nbytes_in_d ;
  double nbytes_out_d ;

  {
#line 341
  tmp = ferror(stream);
#line 341
  if (tmp != 0) {
#line 341
    goto errhandler_io;
  } else {

  }
#line 342
  tmp___0 = ferror(zStream);
#line 342
  if (tmp___0 != 0) {
#line 342
    goto errhandler_io;
  } else {

  }
#line 344
  bzf = BZ2_bzWriteOpen(& bzerr, zStream, blockSize100k, verbosity, workFactor);
#line 346
  if (bzerr != 0) {
#line 346
    goto errhandler;
  } else {

  }
#line 348
  if (verbosity >= 2) {
#line 348
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  } else {

  }
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    tmp___1 = myfeof(stream);
#line 352
    if (tmp___1 != 0) {
#line 352
      goto while_break;
    } else {

    }
#line 353
    tmp___2 = fread((void * __restrict  )((void *)(ibuf)), sizeof(UChar ), (size_t )5000,
                    (FILE * __restrict  )stream);
#line 353
    nIbuf = (Int32 )tmp___2;
#line 354
    tmp___3 = ferror(stream);
#line 354
    if (tmp___3 != 0) {
#line 354
      goto errhandler_io;
    } else {

    }
#line 355
    if (nIbuf > 0) {
#line 355
      BZ2_bzWrite(& bzerr, bzf, (void *)(ibuf), nIbuf);
    } else {

    }
#line 356
    if (bzerr != 0) {
#line 356
      goto errhandler;
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  BZ2_bzWriteClose64(& bzerr, bzf, 0, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
#line 363
  if (bzerr != 0) {
#line 363
    goto errhandler;
  } else {

  }
#line 365
  tmp___4 = ferror(zStream);
#line 365
  if (tmp___4 != 0) {
#line 365
    goto errhandler_io;
  } else {

  }
#line 366
  ret = fflush(zStream);
#line 367
  if (ret == -1) {
#line 367
    goto errhandler_io;
  } else {

  }
#line 368
  if ((unsigned long )zStream != (unsigned long )stdout) {
#line 369
    tmp___5 = fileno(zStream);
#line 369
    fd = tmp___5;
#line 370
    if (fd < 0) {
#line 370
      goto errhandler_io;
    } else {

    }
#line 371
    applySavedFileAttrToOutputFile(fd);
#line 372
    ret = fclose(zStream);
#line 373
    outputHandleJustInCase = (FILE *)((void *)0);
#line 374
    if (ret == -1) {
#line 374
      goto errhandler_io;
    } else {

    }
  } else {

  }
#line 376
  outputHandleJustInCase = (FILE *)((void *)0);
#line 377
  tmp___6 = ferror(stream);
#line 377
  if (tmp___6 != 0) {
#line 377
    goto errhandler_io;
  } else {

  }
#line 378
  ret = fclose(stream);
#line 379
  if (ret == -1) {
#line 379
    goto errhandler_io;
  } else {

  }
#line 381
  if (verbosity >= 1) {
#line 382
    if (nbytes_in_lo32 == 0U) {
#line 382
      if (nbytes_in_hi32 == 0U) {
#line 383
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" no data compressed.\n");
      } else {
#line 382
        goto _L;
      }
    } else {
      _L: 
#line 388
      uInt64_from_UInt32s(& nbytes_in, nbytes_in_lo32, nbytes_in_hi32);
#line 390
      uInt64_from_UInt32s(& nbytes_out, nbytes_out_lo32, nbytes_out_hi32);
#line 392
      nbytes_in_d = uInt64_to_double(& nbytes_in);
#line 393
      nbytes_out_d = uInt64_to_double(& nbytes_out);
#line 394
      uInt64_toAscii(buf_nin, & nbytes_in);
#line 395
      uInt64_toAscii(buf_nout, & nbytes_out);
#line 396
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\n",
              nbytes_in_d / nbytes_out_d, (8.0 * nbytes_out_d) / nbytes_in_d, 100.0 * (1.0 - nbytes_out_d / nbytes_in_d),
              buf_nin, buf_nout);
    }
  } else {

  }
#line 407
  return;
  errhandler: 
#line 410
  BZ2_bzWriteClose64(& bzerr_dummy, bzf, 1, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
  {
#line 414
  if (bzerr == -9) {
#line 414
    goto case_neg_9;
  } else {

  }
#line 416
  if (bzerr == -3) {
#line 416
    goto case_neg_3;
  } else {

  }
#line 419
  if (bzerr == -6) {
#line 419
    goto errhandler_io;
  } else {

  }
#line 421
  goto switch_default;
  case_neg_9: /* CIL Label */ 
#line 415
  configError();
#line 415
  goto switch_break;
  case_neg_3: /* CIL Label */ 
#line 417
  outOfMemory();
#line 417
  goto switch_break;
  errhandler_io: 
  case_neg_6: /* CIL Label */ 
#line 420
  ioError();
#line 420
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 422
  panic("compress:unexpected error");
  switch_break: /* CIL Label */ ;
  }
#line 425
  panic("compress:end");
}
}
#line 432 "bzip2.c"
static Bool uncompressStream(FILE *zStream , FILE *stream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  Int32 fd ;
  int tmp___4 ;
  int tmp___5 ;
  Bool tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  UChar *mem_27 ;

  {
#line 443
  nUnused = 0;
#line 444
  streamNo = 0;
#line 449
  tmp = ferror(stream);
#line 449
  if (tmp != 0) {
#line 449
    goto errhandler_io;
  } else {

  }
#line 450
  tmp___0 = ferror(zStream);
#line 450
  if (tmp___0 != 0) {
#line 450
    goto errhandler_io;
  } else {

  }
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
#line 458
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 458
      goto errhandler;
    } else
#line 458
    if (bzerr != 0) {
#line 458
      goto errhandler;
    } else {

    }
#line 459
    streamNo ++;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      if (bzerr == 0) {

      } else {
#line 461
        goto while_break___0;
      }
#line 462
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
#line 463
      if (bzerr == -5) {
#line 463
        goto trycat;
      } else {

      }
#line 464
      if (bzerr == 0) {
#line 464
        goto _L;
      } else
#line 464
      if (bzerr == 4) {
        _L: 
#line 464
        if (nread > 0) {
#line 465
          fwrite((void const   * __restrict  )((void const   *)(obuf)), sizeof(UChar ),
                 (size_t )nread, (FILE * __restrict  )stream);
        } else {

        }
      } else {

      }
#line 466
      tmp___1 = ferror(stream);
#line 466
      if (tmp___1 != 0) {
#line 466
        goto errhandler_io;
      } else {

      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 468
    if (bzerr != 4) {
#line 468
      goto errhandler;
    } else {

    }
#line 470
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
#line 471
    if (bzerr != 0) {
#line 471
      panic("decompress:bzReadGetUnused");
    } else {

    }
#line 473
    unusedTmp = (UChar *)unusedTmpV;
#line 474
    i = 0;
    {
#line 474
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 474
      if (i < nUnused) {

      } else {
#line 474
        goto while_break___1;
      }
#line 474
      mem_27 = unusedTmp + i;
#line 474
      unused[i] = *mem_27;
#line 474
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 476
    BZ2_bzReadClose(& bzerr, bzf);
#line 477
    if (bzerr != 0) {
#line 477
      panic("decompress:bzReadGetUnused");
    } else {

    }
#line 479
    if (nUnused == 0) {
#line 479
      tmp___2 = myfeof(zStream);
#line 479
      if (tmp___2 != 0) {
#line 479
        goto while_break;
      } else {

      }
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
  closeok: 
#line 483
  tmp___3 = ferror(zStream);
#line 483
  if (tmp___3 != 0) {
#line 483
    goto errhandler_io;
  } else {

  }
#line 484
  if ((unsigned long )stream != (unsigned long )stdout) {
#line 485
    tmp___4 = fileno(stream);
#line 485
    fd = tmp___4;
#line 486
    if (fd < 0) {
#line 486
      goto errhandler_io;
    } else {

    }
#line 487
    applySavedFileAttrToOutputFile(fd);
  } else {

  }
#line 489
  ret = fclose(zStream);
#line 490
  if (ret == -1) {
#line 490
    goto errhandler_io;
  } else {

  }
#line 492
  tmp___5 = ferror(stream);
#line 492
  if (tmp___5 != 0) {
#line 492
    goto errhandler_io;
  } else {

  }
#line 493
  ret = fflush(stream);
#line 494
  if (ret != 0) {
#line 494
    goto errhandler_io;
  } else {

  }
#line 495
  if ((unsigned long )stream != (unsigned long )stdout) {
#line 496
    ret = fclose(stream);
#line 497
    outputHandleJustInCase = (FILE *)((void *)0);
#line 498
    if (ret == -1) {
#line 498
      goto errhandler_io;
    } else {

    }
  } else {

  }
#line 500
  outputHandleJustInCase = (FILE *)((void *)0);
#line 501
  if (verbosity >= 2) {
#line 501
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    ");
  } else {

  }
#line 502
  return ((Bool )1);
  trycat: 
#line 505
  if (forceOverwrite != 0) {
#line 506
    rewind(zStream);
    {
#line 507
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 508
      tmp___6 = myfeof(zStream);
#line 508
      if (tmp___6 != 0) {
#line 508
        goto while_break___2;
      } else {

      }
#line 509
      tmp___7 = fread((void * __restrict  )((void *)(obuf)), sizeof(UChar ), (size_t )5000,
                      (FILE * __restrict  )zStream);
#line 509
      nread = (Int32 )tmp___7;
#line 510
      tmp___8 = ferror(zStream);
#line 510
      if (tmp___8 != 0) {
#line 510
        goto errhandler_io;
      } else {

      }
#line 511
      if (nread > 0) {
#line 511
        fwrite((void const   * __restrict  )((void const   *)(obuf)), sizeof(UChar ),
               (size_t )nread, (FILE * __restrict  )stream);
      } else {

      }
#line 512
      tmp___9 = ferror(stream);
#line 512
      if (tmp___9 != 0) {
#line 512
        goto errhandler_io;
      } else {

      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 514
    goto closeok;
  } else {

  }
  errhandler: 
#line 518
  BZ2_bzReadClose(& bzerr_dummy, bzf);
  {
#line 520
  if (bzerr == -9) {
#line 520
    goto case_neg_9;
  } else {

  }
#line 523
  if (bzerr == -6) {
#line 523
    goto errhandler_io;
  } else {

  }
#line 525
  if (bzerr == -4) {
#line 525
    goto case_neg_4;
  } else {

  }
#line 527
  if (bzerr == -3) {
#line 527
    goto case_neg_3;
  } else {

  }
#line 529
  if (bzerr == -7) {
#line 529
    goto case_neg_7;
  } else {

  }
#line 531
  if (bzerr == -5) {
#line 531
    goto case_neg_5;
  } else {

  }
#line 543
  goto switch_default;
  case_neg_9: /* CIL Label */ 
#line 521
  configError();
#line 521
  goto switch_break;
  errhandler_io: 
  case_neg_6: /* CIL Label */ 
#line 524
  ioError();
#line 524
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 526
  crcError();
  case_neg_3: /* CIL Label */ 
#line 528
  outOfMemory();
  case_neg_7: /* CIL Label */ 
#line 530
  compressedStreamEOF();
  case_neg_5: /* CIL Label */ 
#line 532
  if ((unsigned long )zStream != (unsigned long )stdin) {
#line 532
    fclose(zStream);
  } else {

  }
#line 533
  if ((unsigned long )stream != (unsigned long )stdout) {
#line 533
    fclose(stream);
  } else {

  }
#line 534
  if (streamNo == 1) {
#line 535
    return ((Bool )0);
  } else {
#line 537
    if (noisy != 0) {
#line 538
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: trailing garbage after EOF ignored\n",
              progName, inName);
    } else {

    }
#line 541
    return ((Bool )1);
  }
  switch_default: /* CIL Label */ 
#line 544
  panic("decompress:unexpected error");
  switch_break: /* CIL Label */ ;
  }
#line 547
  panic("decompress:end");
#line 548
  return ((Bool )1);
}
}
#line 553 "bzip2.c"
static Bool testStream(FILE *zStream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  int tmp ;
  Bool tmp___0 ;
  int tmp___1 ;
  UChar *mem_17 ;

  {
#line 564
  nUnused = 0;
#line 565
  streamNo = 0;
#line 568
  tmp = ferror(zStream);
#line 568
  if (tmp != 0) {
#line 568
    goto errhandler_io;
  } else {

  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
#line 576
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 576
      goto errhandler;
    } else
#line 576
    if (bzerr != 0) {
#line 576
      goto errhandler;
    } else {

    }
#line 577
    streamNo ++;
    {
#line 579
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 579
      if (bzerr == 0) {

      } else {
#line 579
        goto while_break___0;
      }
#line 580
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
#line 581
      if (bzerr == -5) {
#line 581
        goto errhandler;
      } else {

      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 583
    if (bzerr != 4) {
#line 583
      goto errhandler;
    } else {

    }
#line 585
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
#line 586
    if (bzerr != 0) {
#line 586
      panic("test:bzReadGetUnused");
    } else {

    }
#line 588
    unusedTmp = (UChar *)unusedTmpV;
#line 589
    i = 0;
    {
#line 589
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 589
      if (i < nUnused) {

      } else {
#line 589
        goto while_break___1;
      }
#line 589
      mem_17 = unusedTmp + i;
#line 589
      unused[i] = *mem_17;
#line 589
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 591
    BZ2_bzReadClose(& bzerr, bzf);
#line 592
    if (bzerr != 0) {
#line 592
      panic("test:bzReadGetUnused");
    } else {

    }
#line 593
    if (nUnused == 0) {
#line 593
      tmp___0 = myfeof(zStream);
#line 593
      if (tmp___0 != 0) {
#line 593
        goto while_break;
      } else {

      }
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  tmp___1 = ferror(zStream);
#line 597
  if (tmp___1 != 0) {
#line 597
    goto errhandler_io;
  } else {

  }
#line 598
  ret = fclose(zStream);
#line 599
  if (ret == -1) {
#line 599
    goto errhandler_io;
  } else {

  }
#line 601
  if (verbosity >= 2) {
#line 601
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    ");
  } else {

  }
#line 602
  return ((Bool )1);
  errhandler: 
#line 605
  BZ2_bzReadClose(& bzerr_dummy, bzf);
#line 606
  if (verbosity == 0) {
#line 607
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: ",
            progName, inName);
  } else {

  }
  {
#line 609
  if (bzerr == -9) {
#line 609
    goto case_neg_9;
  } else {

  }
#line 612
  if (bzerr == -6) {
#line 612
    goto errhandler_io;
  } else {

  }
#line 614
  if (bzerr == -4) {
#line 614
    goto case_neg_4;
  } else {

  }
#line 618
  if (bzerr == -3) {
#line 618
    goto case_neg_3;
  } else {

  }
#line 620
  if (bzerr == -7) {
#line 620
    goto case_neg_7;
  } else {

  }
#line 624
  if (bzerr == -5) {
#line 624
    goto case_neg_5;
  } else {

  }
#line 636
  goto switch_default;
  case_neg_9: /* CIL Label */ 
#line 610
  configError();
#line 610
  goto switch_break;
  errhandler_io: 
  case_neg_6: /* CIL Label */ 
#line 613
  ioError();
#line 613
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 615
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"data integrity (CRC) error in data\n");
#line 617
  return ((Bool )0);
  case_neg_3: /* CIL Label */ 
#line 619
  outOfMemory();
  case_neg_7: /* CIL Label */ 
#line 621
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"file ends unexpectedly\n");
#line 623
  return ((Bool )0);
  case_neg_5: /* CIL Label */ 
#line 625
  if ((unsigned long )zStream != (unsigned long )stdin) {
#line 625
    fclose(zStream);
  } else {

  }
#line 626
  if (streamNo == 1) {
#line 627
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bad magic number (file not created by bzip2)\n");
#line 629
    return ((Bool )0);
  } else {
#line 631
    if (noisy != 0) {
#line 632
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"trailing garbage after EOF ignored\n");
    } else {

    }
#line 634
    return ((Bool )1);
  }
  switch_default: /* CIL Label */ 
#line 637
  panic("test:unexpected error");
  switch_break: /* CIL Label */ ;
  }
#line 640
  panic("test:end");
#line 641
  return ((Bool )1);
}
}
#line 650 "bzip2.c"
static void setExit(Int32 v ) 
{ 
  Int32 *__cil_gp_exitValue ;
  int __cil_tmp3 ;
  Int32 __cil_tmp4 ;

  {
#line 652
  __cil_gp_exitValue = & exitValue;
#line 652
  return babel_wrapper_setExit(__cil_gp_exitValue, v);
#line 652
  __cil_gp_exitValue = & exitValue;
#line 653
  __cil_tmp4 = *__cil_gp_exitValue;
#line 653
  __cil_tmp3 = v > __cil_tmp4;
#line 653
  if (__cil_tmp3 != 0) {
#line 653
    *__cil_gp_exitValue = v;
  } else {

  }
#line 654
  return;
}
}
#line 658 "bzip2.c"
static void cadvise(void) 
{ 
  Bool *__cil_gp_noisy ;
  struct _IO_FILE **__cil_gp_stderr ;
  Bool __cil_tmp3 ;
  struct _IO_FILE *__cil_tmp4 ;

  {
#line 660
  __cil_gp_stderr = & stderr;
#line 660
  __cil_gp_noisy = & noisy;
#line 660
  return babel_wrapper_cadvise(__cil_gp_noisy, __cil_gp_stderr);
#line 660
  __cil_gp_noisy = & noisy;
#line 661
  __cil_gp_stderr = & stderr;
#line 661
  __cil_tmp3 = *__cil_gp_noisy;
#line 661
  if (__cil_tmp3 != 0) {
#line 662
    __cil_tmp4 = *__cil_gp_stderr;
#line 662
    fprintf((FILE * __restrict  )__cil_tmp4, (char const   * __restrict  )"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n");
  } else {

  }
#line 669
  return;
}
}
#line 673 "bzip2.c"
static void showFileNames(void) 
{ 
  Bool *__cil_gp_noisy ;
  struct _IO_FILE **__cil_gp_stderr ;
  Bool __cil_tmp3 ;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;
  Char *__cil_tmp6 ;

  {
#line 675
  __cil_gp_stderr = & stderr;
#line 675
  __cil_gp_noisy = & noisy;
#line 675
  return babel_wrapper_showFileNames(__cil_gp_noisy, __cil_gp_stderr);
#line 675
  __cil_gp_noisy = & noisy;
#line 676
  __cil_gp_stderr = & stderr;
#line 676
  __cil_tmp3 = *__cil_gp_noisy;
#line 676
  if (__cil_tmp3 != 0) {
#line 677
    __cil_tmp4 = *__cil_gp_stderr;
#line 677
    __cil_tmp5 = inName;
#line 677
    __cil_tmp6 = outName;
#line 677
    fprintf((FILE * __restrict  )__cil_tmp4, (char const   * __restrict  )"\tInput file = %s, output file = %s\n",
            __cil_tmp5, __cil_tmp6);
  } else {

  }
#line 682
  return;
}
}
#line 686
static  __attribute__((__noreturn__)) void cleanUpAndFail(Int32 ec ) ;
#line 686 "bzip2.c"
static void cleanUpAndFail(Int32 ec ) 
{ 
  struct stat statBuf ;
  struct stat *__cil_pp_statBuf ;
  Int32 *__cil_gp_srcMode ;
  Int32 *__cil_gp_opMode ;
  Bool *__cil_gp_deleteOutputOnInterrupt ;
  Bool *__cil_gp_noisy ;
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  FILE **__cil_gp_outputHandleJustInCase ;
  Int32 *__cil_gp_numFileNames ;
  Int32 *__cil_gp_numFilesProcessed ;
  Int32 *__cil_gp_exitValue ;
  IntNative retVal_ssa_1 ;
  IntNative retVal_ssa_2 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  Bool __cil_tmp19 ;
  int __cil_tmp20 ;
  Bool __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  Bool __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  Int32 __cil_tmp27 ;
  Int32 __cil_tmp28 ;
  Char *__cil_tmp29 ;
  struct _IO_FILE *__cil_tmp30 ;
  Char *__cil_tmp31 ;
  Char *__cil_tmp32 ;
  FILE *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  FILE *__cil_tmp35 ;
  Char *__cil_tmp36 ;
  struct _IO_FILE *__cil_tmp37 ;
  Char *__cil_tmp38 ;
  struct _IO_FILE *__cil_tmp39 ;
  Char *__cil_tmp40 ;
  struct _IO_FILE *__cil_tmp41 ;
  Char *__cil_tmp42 ;
  struct _IO_FILE *__cil_tmp43 ;
  Char *__cil_tmp44 ;
  Char *__cil_tmp45 ;
  struct _IO_FILE *__cil_tmp46 ;
  Char *__cil_tmp47 ;
  Int32 __cil_tmp48 ;
  Int32 __cil_tmp49 ;
  Int32 __cil_tmp50 ;
  struct _IO_FILE *__cil_tmp51 ;
  Int32 __cil_tmp52 ;
  Int32 __cil_tmp53 ;
  Char *__cil_tmp54 ;
  Char *__cil_tmp55 ;
  Int32 __cil_tmp56 ;
  Int32 __cil_tmp57 ;
  Int32 __cil_tmp58 ;

  {
#line 689
  __cil_gp_exitValue = & exitValue;
#line 689
  __cil_gp_numFilesProcessed = & numFilesProcessed;
#line 689
  __cil_gp_numFileNames = & numFileNames;
#line 689
  __cil_gp_outputHandleJustInCase = & outputHandleJustInCase;
#line 689
  __cil_gp_progName = & progName;
#line 689
  __cil_gp_stderr = & stderr;
#line 689
  __cil_gp_noisy = & noisy;
#line 689
  __cil_gp_deleteOutputOnInterrupt = & deleteOutputOnInterrupt;
#line 689
  __cil_gp_opMode = & opMode;
#line 689
  __cil_gp_srcMode = & srcMode;
#line 689
  __cil_pp_statBuf = & statBuf;
#line 689
  return babel_wrapper_cleanUpAndFail(__cil_pp_statBuf, __cil_gp_srcMode, __cil_gp_opMode,
                                      __cil_gp_deleteOutputOnInterrupt, __cil_gp_noisy,
                                      __cil_gp_stderr, __cil_gp_progName, __cil_gp_outputHandleJustInCase,
                                      __cil_gp_numFileNames, __cil_gp_numFilesProcessed,
                                      __cil_gp_exitValue, ec);
#line 689
  __cil_pp_statBuf = & statBuf;
#line 690
  __cil_gp_srcMode = & srcMode;
#line 691
  __cil_gp_opMode = & opMode;
#line 692
  __cil_gp_deleteOutputOnInterrupt = & deleteOutputOnInterrupt;
#line 693
  __cil_gp_noisy = & noisy;
#line 694
  __cil_gp_stderr = & stderr;
#line 695
  __cil_gp_progName = & progName;
#line 696
  __cil_gp_outputHandleJustInCase = & outputHandleJustInCase;
#line 697
  __cil_gp_numFileNames = & numFileNames;
#line 698
  __cil_gp_numFilesProcessed = & numFilesProcessed;
#line 699
  __cil_gp_exitValue = & exitValue;
#line 692
  __cil_tmp27 = *__cil_gp_srcMode;
#line 692
  __cil_tmp17 = __cil_tmp27 == 3;
#line 692
  if (__cil_tmp17 != 0) {
#line 692
    __cil_tmp28 = *__cil_gp_opMode;
#line 692
    __cil_tmp18 = __cil_tmp28 != 3;
#line 692
    if (__cil_tmp18 != 0) {
#line 692
      __cil_tmp19 = *__cil_gp_deleteOutputOnInterrupt;
#line 692
      if (__cil_tmp19 != 0) {
#line 701
        __cil_tmp29 = inName;
#line 701
        retVal_ssa_1 = stat((char const   * __restrict  )((char const   *)__cil_tmp29),
                            (struct stat * __restrict  )__cil_pp_statBuf);
#line 702
        __cil_tmp20 = retVal_ssa_1 == 0;
#line 702
        if (__cil_tmp20 != 0) {
#line 703
          __cil_tmp21 = *__cil_gp_noisy;
#line 703
          if (__cil_tmp21 != 0) {
#line 704
            __cil_tmp30 = *__cil_gp_stderr;
#line 704
            __cil_tmp31 = *__cil_gp_progName;
#line 704
            __cil_tmp32 = outName;
#line 704
            fprintf((FILE * __restrict  )__cil_tmp30, (char const   * __restrict  )"%s: Deleting output file %s, if it exists.\n",
                    __cil_tmp31, __cil_tmp32);
          } else {

          }
#line 707
          __cil_tmp33 = *__cil_gp_outputHandleJustInCase;
#line 707
          __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 707
          __cil_tmp22 = __cil_tmp34 != (unsigned long )((void *)0);
#line 707
          if (__cil_tmp22 != 0) {
#line 708
            __cil_tmp35 = *__cil_gp_outputHandleJustInCase;
#line 708
            fclose(__cil_tmp35);
          } else {

          }
#line 709
          __cil_tmp36 = outName;
#line 709
          retVal_ssa_2 = remove((char const   *)__cil_tmp36);
#line 710
          __cil_tmp23 = retVal_ssa_2 != 0;
#line 710
          if (__cil_tmp23 != 0) {
#line 711
            __cil_tmp37 = *__cil_gp_stderr;
#line 711
            __cil_tmp38 = *__cil_gp_progName;
#line 711
            fprintf((FILE * __restrict  )__cil_tmp37, (char const   * __restrict  )"%s: WARNING: deletion of output file (apparently) failed.\n",
                    __cil_tmp38);
          } else {

          }
        } else {
#line 716
          __cil_tmp39 = *__cil_gp_stderr;
#line 716
          __cil_tmp40 = *__cil_gp_progName;
#line 716
          fprintf((FILE * __restrict  )__cil_tmp39, (char const   * __restrict  )"%s: WARNING: deletion of output file suppressed\n",
                  __cil_tmp40);
#line 719
          __cil_tmp41 = *__cil_gp_stderr;
#line 719
          __cil_tmp42 = *__cil_gp_progName;
#line 719
          fprintf((FILE * __restrict  )__cil_tmp41, (char const   * __restrict  )"%s:    since input file no longer exists.  Output file\n",
                  __cil_tmp42);
#line 722
          __cil_tmp43 = *__cil_gp_stderr;
#line 722
          __cil_tmp44 = *__cil_gp_progName;
#line 722
          __cil_tmp45 = outName;
#line 722
          fprintf((FILE * __restrict  )__cil_tmp43, (char const   * __restrict  )"%s:    `%s\' may be incomplete.\n",
                  __cil_tmp44, __cil_tmp45);
#line 725
          __cil_tmp46 = *__cil_gp_stderr;
#line 725
          __cil_tmp47 = *__cil_gp_progName;
#line 725
          fprintf((FILE * __restrict  )__cil_tmp46, (char const   * __restrict  )"%s:    I suggest doing an integrity test (bzip2 -tv) of it.\n",
                  __cil_tmp47);
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 732
  __cil_tmp24 = *__cil_gp_noisy;
#line 732
  if (__cil_tmp24 != 0) {
#line 732
    __cil_tmp48 = *__cil_gp_numFileNames;
#line 732
    __cil_tmp25 = __cil_tmp48 > 0;
#line 732
    if (__cil_tmp25 != 0) {
#line 732
      __cil_tmp49 = *__cil_gp_numFilesProcessed;
#line 732
      __cil_tmp50 = *__cil_gp_numFileNames;
#line 732
      __cil_tmp26 = __cil_tmp49 < __cil_tmp50;
#line 732
      if (__cil_tmp26 != 0) {
#line 733
        __cil_tmp51 = *__cil_gp_stderr;
#line 733
        __cil_tmp52 = *__cil_gp_numFileNames;
#line 733
        __cil_tmp53 = *__cil_gp_numFilesProcessed;
#line 733
        __cil_tmp54 = *__cil_gp_progName;
#line 733
        __cil_tmp55 = *__cil_gp_progName;
#line 733
        __cil_tmp56 = *__cil_gp_numFileNames;
#line 733
        __cil_tmp57 = __cil_tmp52 - __cil_tmp53;
#line 733
        fprintf((FILE * __restrict  )__cil_tmp51, (char const   * __restrict  )"%s: WARNING: some files have not been processed:\n%s:    %d specified on command line, %d not processed yet.\n\n",
                __cil_tmp54, __cil_tmp55, __cil_tmp56, __cil_tmp57);
      } else {

      }
    } else {

    }
  } else {

  }
#line 739
  setExit(ec);
#line 740
  __cil_tmp58 = *__cil_gp_exitValue;
#line 740
  exit(__cil_tmp58);
}
}
#line 745
static  __attribute__((__noreturn__)) void panic(Char const   *s ) ;
#line 745 "bzip2.c"
static void panic(Char const   *s ) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
#line 747
  __cil_gp_progName = & progName;
#line 747
  __cil_gp_stderr = & stderr;
#line 747
  return babel_wrapper_panic(__cil_gp_stderr, __cil_gp_progName, s);
#line 747
  __cil_gp_stderr = & stderr;
#line 748
  __cil_gp_progName = & progName;
#line 748
  __cil_tmp4 = *__cil_gp_stderr;
#line 748
  __cil_tmp5 = *__cil_gp_progName;
#line 748
  fprintf((FILE * __restrict  )__cil_tmp4, (char const   * __restrict  )"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to me at:\n\tjseward@bzip.org\n",
          __cil_tmp5, s);
#line 754
  showFileNames();
#line 755
  cleanUpAndFail(3);
}
}
#line 760
static  __attribute__((__noreturn__)) void crcError(void) ;
#line 760 "bzip2.c"
static void crcError(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  struct _IO_FILE *__cil_tmp3 ;
  Char *__cil_tmp4 ;

  {
#line 762
  __cil_gp_progName = & progName;
#line 762
  __cil_gp_stderr = & stderr;
#line 762
  return babel_wrapper_crcError(__cil_gp_stderr, __cil_gp_progName);
#line 762
  __cil_gp_stderr = & stderr;
#line 763
  __cil_gp_progName = & progName;
#line 763
  __cil_tmp3 = *__cil_gp_stderr;
#line 763
  __cil_tmp4 = *__cil_gp_progName;
#line 763
  fprintf((FILE * __restrict  )__cil_tmp3, (char const   * __restrict  )"\n%s: Data integrity error when decompressing.\n",
          __cil_tmp4);
#line 766
  showFileNames();
#line 767
  cadvise();
#line 768
  cleanUpAndFail(2);
}
}
#line 773
static  __attribute__((__noreturn__)) void compressedStreamEOF(void) ;
#line 773 "bzip2.c"
static void compressedStreamEOF(void) 
{ 
  Bool *__cil_gp_noisy ;
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  Bool __cil_tmp4 ;
  struct _IO_FILE *__cil_tmp5 ;
  Char *__cil_tmp6 ;
  Char *__cil_tmp7 ;

  {
#line 775
  __cil_gp_progName = & progName;
#line 775
  __cil_gp_stderr = & stderr;
#line 775
  __cil_gp_noisy = & noisy;
#line 775
  return babel_wrapper_compressedStreamEOF(__cil_gp_noisy, __cil_gp_stderr, __cil_gp_progName);
#line 775
  __cil_gp_noisy = & noisy;
#line 776
  __cil_gp_stderr = & stderr;
#line 777
  __cil_gp_progName = & progName;
#line 776
  __cil_tmp4 = *__cil_gp_noisy;
#line 776
  if (__cil_tmp4 != 0) {
#line 777
    __cil_tmp5 = *__cil_gp_stderr;
#line 777
    __cil_tmp6 = *__cil_gp_progName;
#line 777
    fprintf((FILE * __restrict  )__cil_tmp5, (char const   * __restrict  )"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
            __cil_tmp6);
#line 781
    __cil_tmp7 = *__cil_gp_progName;
#line 781
    perror((char const   *)__cil_tmp7);
#line 782
    showFileNames();
#line 783
    cadvise();
  } else {

  }
#line 785
  cleanUpAndFail(2);
}
}
#line 790
static  __attribute__((__noreturn__)) void ioError(void) ;
#line 790 "bzip2.c"
static void ioError(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  struct _IO_FILE *__cil_tmp3 ;
  Char *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
#line 792
  __cil_gp_progName = & progName;
#line 792
  __cil_gp_stderr = & stderr;
#line 792
  return babel_wrapper_ioError(__cil_gp_stderr, __cil_gp_progName);
#line 792
  __cil_gp_stderr = & stderr;
#line 793
  __cil_gp_progName = & progName;
#line 793
  __cil_tmp3 = *__cil_gp_stderr;
#line 793
  __cil_tmp4 = *__cil_gp_progName;
#line 793
  fprintf((FILE * __restrict  )__cil_tmp3, (char const   * __restrict  )"\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          __cil_tmp4);
#line 797
  __cil_tmp5 = *__cil_gp_progName;
#line 797
  perror((char const   *)__cil_tmp5);
#line 798
  showFileNames();
#line 799
  cleanUpAndFail(1);
}
}
#line 804 "bzip2.c"
static void mySignalCatcher(IntNative n ) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
#line 806
  __cil_gp_progName = & progName;
#line 806
  __cil_gp_stderr = & stderr;
#line 806
  return babel_wrapper_mySignalCatcher(__cil_gp_stderr, __cil_gp_progName, n);
#line 806
  __cil_gp_stderr = & stderr;
#line 807
  __cil_gp_progName = & progName;
#line 807
  __cil_tmp4 = *__cil_gp_stderr;
#line 807
  __cil_tmp5 = *__cil_gp_progName;
#line 807
  fprintf((FILE * __restrict  )__cil_tmp4, (char const   * __restrict  )"\n%s: Control-C or similar caught, quitting.\n",
          __cil_tmp5);
#line 810
  cleanUpAndFail(1);
}
}
#line 815 "bzip2.c"
static void mySIGSEGVorSIGBUScatcher(IntNative n ) 
{ 
  Int32 *__cil_gp_opMode ;
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  struct _IO_FILE *__cil_tmp8 ;
  Char *__cil_tmp9 ;
  struct _IO_FILE *__cil_tmp10 ;
  Char *__cil_tmp11 ;
  Int32 __cil_tmp12 ;

  {
#line 817
  __cil_gp_progName = & progName;
#line 817
  __cil_gp_stderr = & stderr;
#line 817
  __cil_gp_opMode = & opMode;
#line 817
  return babel_wrapper_mySIGSEGVorSIGBUScatcher(__cil_gp_opMode, __cil_gp_stderr,
                                                __cil_gp_progName, n);
#line 817
  __cil_gp_opMode = & opMode;
#line 818
  __cil_gp_stderr = & stderr;
#line 819
  __cil_gp_progName = & progName;
#line 818
  __cil_tmp7 = *__cil_gp_opMode;
#line 818
  __cil_tmp5 = __cil_tmp7 == 1;
#line 818
  if (__cil_tmp5 != 0) {
#line 819
    __cil_tmp8 = *__cil_gp_stderr;
#line 819
    __cil_tmp9 = *__cil_gp_progName;
#line 819
    fprintf((FILE * __restrict  )__cil_tmp8, (char const   * __restrict  )"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing.\n\n   Possible causes are (most likely first):\n   (1) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (2) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (3) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (1) and (2).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (1)\n   or (2), feel free to report it to me at: jseward@bzip.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n",
            __cil_tmp9);
  } else {
#line 840
    __cil_tmp10 = *__cil_gp_stderr;
#line 840
    __cil_tmp11 = *__cil_gp_progName;
#line 840
    fprintf((FILE * __restrict  )__cil_tmp10, (char const   * __restrict  )"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing.\n\n   Possible causes are (most likely first):\n   (1) The compressed data is corrupted, and bzip2\'s usual checks\n       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n   (2) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (3) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (4) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (2) and (3).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (2)\n   or (3), feel free to report it to me at: jseward@bzip.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n",
            __cil_tmp11);
  }
#line 863
  showFileNames();
#line 864
  __cil_tmp12 = *__cil_gp_opMode;
#line 864
  __cil_tmp6 = __cil_tmp12 == 1;
#line 864
  if (__cil_tmp6 != 0) {
#line 865
    cleanUpAndFail(3);
  } else {
#line 866
    cadvise();
#line 866
    cleanUpAndFail(2);
  }
}
}
#line 871
static  __attribute__((__noreturn__)) void outOfMemory(void) ;
#line 871 "bzip2.c"
static void outOfMemory(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  struct _IO_FILE *__cil_tmp3 ;
  Char *__cil_tmp4 ;

  {
#line 873
  __cil_gp_progName = & progName;
#line 873
  __cil_gp_stderr = & stderr;
#line 873
  return babel_wrapper_outOfMemory(__cil_gp_stderr, __cil_gp_progName);
#line 873
  __cil_gp_stderr = & stderr;
#line 874
  __cil_gp_progName = & progName;
#line 874
  __cil_tmp3 = *__cil_gp_stderr;
#line 874
  __cil_tmp4 = *__cil_gp_progName;
#line 874
  fprintf((FILE * __restrict  )__cil_tmp3, (char const   * __restrict  )"\n%s: couldn\'t allocate enough memory\n",
          __cil_tmp4);
#line 877
  showFileNames();
#line 878
  cleanUpAndFail(1);
}
}
#line 883
static  __attribute__((__noreturn__)) void configError(void) ;
#line 883 "bzip2.c"
static void configError(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Int32 *__cil_gp_exitValue ;
  struct _IO_FILE *__cil_tmp3 ;
  Int32 __cil_tmp4 ;

  {
#line 885
  __cil_gp_exitValue = & exitValue;
#line 885
  __cil_gp_stderr = & stderr;
#line 885
  return babel_wrapper_configError(__cil_gp_stderr, __cil_gp_exitValue);
#line 885
  __cil_gp_stderr = & stderr;
#line 886
  __cil_gp_exitValue = & exitValue;
#line 886
  __cil_tmp3 = *__cil_gp_stderr;
#line 886
  fprintf((FILE * __restrict  )__cil_tmp3, (char const   * __restrict  )"bzip2: I\'m not configured correctly for this platform!\n\tI require Int32, Int16 and Char to have sizes\n\tof 4, 2 and 1 bytes to run properly, and they don\'t.\n\tProbably you can fix this by defining them correctly,\n\tand recompiling.  Bye!\n");
#line 892
  setExit(3);
#line 893
  __cil_tmp4 = *__cil_gp_exitValue;
#line 893
  exit(__cil_tmp4);
}
}
#line 907 "bzip2.c"
static void pad(Char *s ) 
{ 
  Int32 *__cil_gp_longestFileName ;
  size_t tmp_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp8 ;
  Int32 __cil_tmp9 ;

  {
#line 909
  __cil_gp_longestFileName = & longestFileName;
#line 909
  return babel_wrapper_pad(__cil_gp_longestFileName, s);
#line 909
  __cil_gp_longestFileName = & longestFileName;
#line 911
  tmp_ssa_1 = strlen((char const   *)s);
#line 911
  __cil_tmp9 = *__cil_gp_longestFileName;
#line 911
  __cil_tmp8 = (Int32 )tmp_ssa_1 >= __cil_tmp9;
#line 911
  if (__cil_tmp8 != 0) {
#line 911
    return;
  } else {
#line 912
    i_ssa_1 = 1;
#line 912
    pad_cil_lr_1(s, i_ssa_1);
#line 914
    return;
  }
}
}
#line 918 "bzip2.c"
static void copyFileName(Char *to , Char *from ) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Int32 *__cil_gp_exitValue ;
  size_t tmp_ssa_1 ;
  int __cil_tmp7 ;
  struct _IO_FILE *__cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Char *__cil_tmp10 ;

  {
#line 920
  __cil_gp_exitValue = & exitValue;
#line 920
  __cil_gp_stderr = & stderr;
#line 920
  return babel_wrapper_copyFileName(__cil_gp_stderr, __cil_gp_exitValue, to, from);
#line 920
  __cil_gp_stderr = & stderr;
#line 921
  __cil_gp_exitValue = & exitValue;
#line 921
  tmp_ssa_1 = strlen((char const   *)from);
#line 921
  __cil_tmp7 = tmp_ssa_1 > 1024UL;
#line 921
  if (__cil_tmp7 != 0) {
#line 922
    __cil_tmp8 = *__cil_gp_stderr;
#line 922
    fprintf((FILE * __restrict  )__cil_tmp8, (char const   * __restrict  )"bzip2: file name\n`%s\'\nis suspiciously (more than %d chars) long.\nTry using a reasonable file name instead.  Sorry! :-)\n",
            from, 1024);
#line 929
    setExit(1);
#line 930
    __cil_tmp9 = *__cil_gp_exitValue;
#line 930
    exit(__cil_tmp9);
  } else {

  }
#line 933
  strncpy((char * __restrict  )to, (char const   * __restrict  )((char const   *)from),
          (size_t )1024);
#line 934
  __cil_tmp10 = to + 1024;
#line 934
  *__cil_tmp10 = (Char )'\000';
#line 935
  return;
}
}
#line 939 "bzip2.c"
static Bool fileExists(Char *name ) 
{ 
  FILE *tmp___0_ssa_1 ;
  FILE *tmp_ssa_1 ;
  Bool exists_ssa_1 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {

#line 942
  return babel_wrapper_fileExists(name);
#line 942
  tmp___0_ssa_1 = fopen((char const   * __restrict  )((char const   *)name), (char const   * __restrict  )"rb");
#line 942
  tmp_ssa_1 = tmp___0_ssa_1;
#line 943
  __cil_tmp9 = (unsigned long )tmp_ssa_1 != (unsigned long )((void *)0);
#line 943
  exists_ssa_1 = (Bool )__cil_tmp9;
#line 944
  __cil_tmp8 = (unsigned long )tmp_ssa_1 != (unsigned long )((void *)0);
#line 944
  if (__cil_tmp8 != 0) {
#line 944
    fclose(tmp_ssa_1);
  } else {

  }
#line 945
  return (exists_ssa_1);
}
}
#line 959 "bzip2.c"
static FILE *fopen_output_safely(Char *name , char const   *mode ) 
{ 
  FILE *fp ;
  IntNative fh_ssa_1 ;
  FILE *fp_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {

#line 965
  return babel_wrapper_fopen_output_safely(name, mode);
#line 965
  fh_ssa_1 = open((char const   *)name, 193, 384);
#line 966
  __cil_tmp7 = fh_ssa_1 == -1;
#line 966
  if (__cil_tmp7 != 0) {
#line 966
    return ((FILE *)0);
  } else {
#line 967
    fp_ssa_1 = fdopen(fh_ssa_1, mode);
#line 968
    __cil_tmp8 = (unsigned long )fp_ssa_1 == (unsigned long )((void *)0);
#line 968
    if (__cil_tmp8 != 0) {
#line 968
      close(fh_ssa_1);
    } else {

    }
#line 969
    return (fp_ssa_1);
  }
#line 969
  return (fp);
}
}
#line 980 "bzip2.c"
static Bool notAStandardFile(Char *name ) 
{ 
  struct stat statBuf ;
  struct stat *__cil_pp_statBuf ;
  IntNative i_ssa_1 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  __mode_t *__cil_tmp9 ;
  __mode_t __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
#line 983
  __cil_pp_statBuf = & statBuf;
#line 983
  return babel_wrapper_notAStandardFile(__cil_pp_statBuf, name);
#line 983
  __cil_pp_statBuf = & statBuf;
#line 986
  i_ssa_1 = lstat((char const   * __restrict  )((char const   *)name), (struct stat * __restrict  )__cil_pp_statBuf);
#line 987
  __cil_tmp6 = i_ssa_1 != 0;
#line 987
  if (__cil_tmp6 != 0) {
#line 987
    return ((Bool )1);
  } else {
#line 988
    __cil_tmp8 = (unsigned char *)__cil_pp_statBuf + 24;
#line 988
    __cil_tmp9 = (__mode_t *)__cil_tmp8;
#line 988
    __cil_tmp10 = *__cil_tmp9;
#line 988
    __cil_tmp11 = __cil_tmp10 & 61440U;
#line 988
    __cil_tmp7 = __cil_tmp11 == 32768U;
#line 988
    if (__cil_tmp7 != 0) {
#line 988
      return ((Bool )0);
    } else {
#line 989
      return ((Bool )1);
    }
  }
}
}
#line 997 "bzip2.c"
static Int32 countHardLinks(Char *name ) 
{ 
  struct stat statBuf ;
  struct stat *__cil_pp_statBuf ;
  IntNative i_ssa_1 ;
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  __nlink_t *__cil_tmp9 ;
  __nlink_t __cil_tmp10 ;
  __nlink_t __cil_tmp11 ;

  {
#line 1000
  __cil_pp_statBuf = & statBuf;
#line 1000
  return babel_wrapper_countHardLinks(__cil_pp_statBuf, name);
#line 1000
  __cil_pp_statBuf = & statBuf;
#line 1003
  i_ssa_1 = lstat((char const   * __restrict  )((char const   *)name), (struct stat * __restrict  )__cil_pp_statBuf);
#line 1004
  __cil_tmp6 = i_ssa_1 != 0;
#line 1004
  if (__cil_tmp6 != 0) {
#line 1004
    return (0);
  } else {
#line 1005
    __cil_tmp8 = (unsigned char *)__cil_pp_statBuf + 16;
#line 1005
    __cil_tmp9 = (__nlink_t *)__cil_tmp8;
#line 1005
    __cil_tmp10 = *__cil_tmp9;
#line 1005
    __cil_tmp11 = __cil_tmp10 - 1UL;
#line 1005
    __cil_tmp7 = (Int32 )__cil_tmp11;
#line 1005
    return (__cil_tmp7);
  }
}
}
#line 1037 "bzip2.c"
static void saveInputFileMetaInfo(Char *srcName ) 
{ 
  struct stat *__cil_pp_fileMetaInfo ;
  IntNative retVal_ssa_1 ;
  int __cil_tmp5 ;

  {
#line 1039
  __cil_pp_fileMetaInfo = & fileMetaInfo;
#line 1039
  return babel_wrapper_saveInputFileMetaInfo(__cil_pp_fileMetaInfo, srcName);
#line 1039
  __cil_pp_fileMetaInfo = & fileMetaInfo;
#line 1043
  retVal_ssa_1 = stat((char const   * __restrict  )((char const   *)srcName), (struct stat * __restrict  )__cil_pp_fileMetaInfo);
#line 1044
  __cil_tmp5 = retVal_ssa_1 != 0;
#line 1044
  if (__cil_tmp5 != 0) {
#line 1044
    ioError();
  } else {

  }
#line 1046
  return;
}
}
#line 1049 "bzip2.c"
static void applySavedTimeInfoToOutputFile(Char *dstName ) 
{ 
  struct utimbuf uTimBuf ;
  struct utimbuf *__cil_pp_uTimBuf ;
  struct stat *__cil_pp_fileMetaInfo ;
  IntNative retVal_ssa_1 ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  __time_t *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  __time_t *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  __time_t *__cil_tmp13 ;
  __time_t *mem_13 ;

  {
#line 1052
  __cil_pp_fileMetaInfo = & fileMetaInfo;
#line 1052
  __cil_pp_uTimBuf = & uTimBuf;
#line 1052
  return babel_wrapper_applySavedTimeInfoToOutputFile(__cil_pp_uTimBuf, __cil_pp_fileMetaInfo,
                                                      dstName);
#line 1052
  __cil_pp_uTimBuf = & uTimBuf;
#line 1053
  __cil_pp_fileMetaInfo = & fileMetaInfo;
#line 1056
  __cil_tmp8 = (unsigned char *)__cil_pp_fileMetaInfo + 72;
#line 1056
  __cil_tmp9 = (__time_t *)__cil_tmp8;
#line 1056
  mem_13 = (__time_t *)__cil_pp_uTimBuf;
#line 1056
  *mem_13 = *__cil_tmp9;
#line 1057
  __cil_tmp10 = (unsigned char *)__cil_pp_fileMetaInfo + 88;
#line 1057
  __cil_tmp11 = (__time_t *)__cil_tmp10;
#line 1057
  __cil_tmp12 = (unsigned char *)__cil_pp_uTimBuf + 8;
#line 1057
  __cil_tmp13 = (__time_t *)__cil_tmp12;
#line 1057
  *__cil_tmp13 = *__cil_tmp11;
#line 1059
  retVal_ssa_1 = utime((char const   *)dstName, (struct utimbuf  const  *)__cil_pp_uTimBuf);
#line 1060
  __cil_tmp7 = retVal_ssa_1 != 0;
#line 1060
  if (__cil_tmp7 != 0) {
#line 1060
    ioError();
  } else {

  }
#line 1062
  return;
}
}
#line 1064 "bzip2.c"
static void applySavedFileAttrToOutputFile(IntNative fd ) 
{ 
  struct stat *__cil_pp_fileMetaInfo ;
  IntNative retVal_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  __mode_t *__cil_tmp7 ;
  __mode_t __cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  __uid_t *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  __gid_t *__cil_tmp12 ;
  __uid_t __cil_tmp13 ;
  __gid_t __cil_tmp14 ;

  {
#line 1066
  __cil_pp_fileMetaInfo = & fileMetaInfo;
#line 1066
  return babel_wrapper_applySavedFileAttrToOutputFile(__cil_pp_fileMetaInfo, fd);
#line 1066
  __cil_pp_fileMetaInfo = & fileMetaInfo;
#line 1070
  __cil_tmp6 = (unsigned char *)__cil_pp_fileMetaInfo + 24;
#line 1070
  __cil_tmp7 = (__mode_t *)__cil_tmp6;
#line 1070
  __cil_tmp8 = *__cil_tmp7;
#line 1070
  retVal_ssa_1 = fchmod(fd, __cil_tmp8);
#line 1071
  __cil_tmp5 = retVal_ssa_1 != 0;
#line 1071
  if (__cil_tmp5 != 0) {
#line 1071
    ioError();
  } else {

  }
#line 1073
  __cil_tmp9 = (unsigned char *)__cil_pp_fileMetaInfo + 28;
#line 1073
  __cil_tmp10 = (__uid_t *)__cil_tmp9;
#line 1073
  __cil_tmp11 = (unsigned char *)__cil_pp_fileMetaInfo + 32;
#line 1073
  __cil_tmp12 = (__gid_t *)__cil_tmp11;
#line 1073
  __cil_tmp13 = *__cil_tmp10;
#line 1073
  __cil_tmp14 = *__cil_tmp12;
#line 1073
  fchown(fd, __cil_tmp13, __cil_tmp14);
#line 1078
  return;
}
}
#line 1082 "bzip2.c"
static Bool containsDubiousChars(Char *name ) 
{ 


  {

#line 1089
  return babel_wrapper_containsDubiousChars(name);
#line 1089
  return ((Bool )0);
}
}
#line 1109 "bzip2.c"
static Bool hasSuffix(Char *s , Char const   *suffix ) 
{ 
  size_t tmp_ssa_1 ;
  Int32 ns_ssa_1 ;
  size_t tmp___0_ssa_1 ;
  Int32 nx_ssa_1 ;
  int tmp___1_ssa_1 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  Char *__cil_tmp15 ;
  Char *__cil_tmp16 ;

  {

#line 1112
  return babel_wrapper_hasSuffix(s, suffix);
#line 1112
  tmp_ssa_1 = strlen((char const   *)s);
#line 1112
  ns_ssa_1 = (Int32 )tmp_ssa_1;
#line 1113
  tmp___0_ssa_1 = strlen(suffix);
#line 1113
  nx_ssa_1 = (Int32 )tmp___0_ssa_1;
#line 1114
  __cil_tmp13 = ns_ssa_1 < nx_ssa_1;
#line 1114
  if (__cil_tmp13 != 0) {
#line 1114
    return ((Bool )0);
  } else {
#line 1115
    __cil_tmp15 = s + ns_ssa_1;
#line 1115
    __cil_tmp16 = __cil_tmp15 - nx_ssa_1;
#line 1115
    tmp___1_ssa_1 = strcmp((char const   *)__cil_tmp16, suffix);
#line 1115
    __cil_tmp14 = tmp___1_ssa_1 == 0;
#line 1115
    if (__cil_tmp14 != 0) {
#line 1115
      return ((Bool )1);
    } else {
#line 1116
      return ((Bool )0);
    }
  }
}
}
#line 1119 "bzip2.c"
static Bool mapSuffix(Char *name , Char const   *oldSuffix , Char const   *newSuffix ) 
{ 
  Bool tmp_ssa_1 ;
  size_t tmp___0_ssa_1 ;
  size_t tmp___1_ssa_1 ;
  size_t __cil_tmp10 ;
  Char *__cil_tmp11 ;

  {

#line 1124
  return babel_wrapper_mapSuffix(name, oldSuffix, newSuffix);
#line 1124
  tmp_ssa_1 = hasSuffix(name, oldSuffix);
#line 1124
  if (tmp_ssa_1 != 0) {
#line 1125
    tmp___0_ssa_1 = strlen((char const   *)name);
#line 1125
    tmp___1_ssa_1 = strlen(oldSuffix);
#line 1125
    __cil_tmp10 = tmp___0_ssa_1 - tmp___1_ssa_1;
#line 1125
    __cil_tmp11 = name + __cil_tmp10;
#line 1125
    *__cil_tmp11 = (Char )0;
#line 1126
    strcat((char * __restrict  )name, (char const   * __restrict  )newSuffix);
#line 1127
    return ((Bool )1);
  } else {
#line 1124
    return ((Bool )0);
  }
}
}
#line 1132 "bzip2.c"
static void compress(Char *name ) 
{ 
  FILE *inStr ;
  FILE *outStr ;
  Int32 n ;
  Int32 i ;
  struct stat statBuf ;
  Bool tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  IntNative retVal ;
  int tmp___17 ;

  {
#line 1140
  deleteOutputOnInterrupt = (Bool )0;
#line 1142
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1142
    if (srcMode != 1) {
#line 1143
      panic("compress: bad modes\n");
    } else {

    }
  } else {

  }
  {
#line 1146
  if (srcMode == 1) {
#line 1146
    goto case_1;
  } else {

  }
#line 1150
  if (srcMode == 3) {
#line 1150
    goto case_3;
  } else {

  }
#line 1155
  if (srcMode == 2) {
#line 1155
    goto case_2;
  } else {

  }
#line 1145
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1147
  copyFileName(inName, (Char *)"(stdin)");
#line 1148
  copyFileName(outName, (Char *)"(stdout)");
#line 1149
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1151
  copyFileName(inName, name);
#line 1152
  copyFileName(outName, name);
#line 1153
  strcat((char * __restrict  )(outName), (char const   * __restrict  )".bz2");
#line 1154
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1156
  copyFileName(inName, name);
#line 1157
  copyFileName(outName, (Char *)"(stdout)");
#line 1158
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1161
  if (srcMode != 1) {
#line 1161
    tmp = containsDubiousChars(inName);
#line 1161
    if (tmp != 0) {
#line 1162
      if (noisy != 0) {
#line 1163
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: There are no files matching `%s\'.\n",
                progName, inName);
      } else {

      }
#line 1165
      setExit(1);
#line 1166
      return;
    } else {

    }
  } else {

  }
#line 1168
  if (srcMode != 1) {
#line 1168
    tmp___2 = fileExists(inName);
#line 1168
    if (tmp___2 == 0) {
#line 1169
      tmp___0 = __errno_location();
#line 1169
      tmp___1 = strerror(*tmp___0);
#line 1169
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input file %s: %s.\n",
              progName, inName, tmp___1);
#line 1171
      setExit(1);
#line 1172
      return;
    } else {

    }
  } else {

  }
#line 1174
  i = 0;
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1174
    if (i < 4) {

    } else {
#line 1174
      goto while_break;
    }
#line 1175
    tmp___3 = hasSuffix(inName, zSuffix[i]);
#line 1175
    if (tmp___3 != 0) {
#line 1176
      if (noisy != 0) {
#line 1177
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s already has %s suffix.\n",
                progName, inName, zSuffix[i]);
      } else {

      }
#line 1180
      setExit(1);
#line 1181
      return;
    } else {

    }
#line 1174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  if (srcMode == 3) {
#line 1184
    goto _L;
  } else
#line 1184
  if (srcMode == 2) {
    _L: 
#line 1185
    stat((char const   * __restrict  )((char const   *)(inName)), (struct stat * __restrict  )(& statBuf));
#line 1186
    if ((statBuf.st_mode & 61440U) == 16384U) {
#line 1187
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1190
      setExit(1);
#line 1191
      return;
    } else {

    }
  } else {

  }
#line 1194
  if (srcMode == 3) {
#line 1194
    if (forceOverwrite == 0) {
#line 1194
      tmp___4 = notAStandardFile(inName);
#line 1194
      if (tmp___4 != 0) {
#line 1195
        if (noisy != 0) {
#line 1196
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s is not a normal file.\n",
                  progName, inName);
        } else {

        }
#line 1198
        setExit(1);
#line 1199
        return;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1201
  if (srcMode == 3) {
#line 1201
    tmp___5 = fileExists(outName);
#line 1201
    if (tmp___5 != 0) {
#line 1202
      if (forceOverwrite != 0) {
#line 1203
        remove((char const   *)(outName));
      } else {
#line 1205
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Output file %s already exists.\n",
                progName, outName);
#line 1207
        setExit(1);
#line 1208
        return;
      }
    } else {

    }
  } else {

  }
#line 1211
  if (srcMode == 3) {
#line 1211
    if (forceOverwrite == 0) {
#line 1211
      n = countHardLinks(inName);
#line 1211
      if (n > 0) {
#line 1213
        if (n > 1) {
#line 1213
          tmp___6 = "s";
        } else {
#line 1213
          tmp___6 = "";
        }
#line 1213
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s has %d other link%s.\n",
                progName, inName, n, tmp___6);
#line 1215
        setExit(1);
#line 1216
        return;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1219
  if (srcMode == 3) {
#line 1222
    saveInputFileMetaInfo(inName);
  } else {

  }
  {
#line 1226
  if (srcMode == 1) {
#line 1226
    goto case_1___0;
  } else {

  }
#line 1240
  if (srcMode == 2) {
#line 1240
    goto case_2___0;
  } else {

  }
#line 1261
  if (srcMode == 3) {
#line 1261
    goto case_3___0;
  } else {

  }
#line 1280
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 1228
  inStr = stdin;
#line 1229
  outStr = stdout;
#line 1230
  tmp___7 = fileno(stdout);
#line 1230
  tmp___8 = isatty(tmp___7);
#line 1230
  if (tmp___8 != 0) {
#line 1231
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: I won\'t write compressed data to a terminal.\n",
            progName);
#line 1234
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1236
    setExit(1);
#line 1237
    return;
  } else {

  }
#line 1239
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 1242
  inStr = fopen((char const   * __restrict  )((char const   *)(inName)), (char const   * __restrict  )"rb");
#line 1243
  outStr = stdout;
#line 1244
  tmp___9 = fileno(stdout);
#line 1244
  tmp___10 = isatty(tmp___9);
#line 1244
  if (tmp___10 != 0) {
#line 1245
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: I won\'t write compressed data to a terminal.\n",
            progName);
#line 1248
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1250
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1250
      fclose(inStr);
    } else {

    }
#line 1251
    setExit(1);
#line 1252
    return;
  } else {

  }
#line 1254
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1255
    tmp___11 = __errno_location();
#line 1255
    tmp___12 = strerror(*tmp___11);
#line 1255
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___12);
#line 1257
    setExit(1);
#line 1258
    return;
  } else {

  }
#line 1260
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 1263
  inStr = fopen((char const   * __restrict  )((char const   *)(inName)), (char const   * __restrict  )"rb");
#line 1264
  outStr = fopen_output_safely(outName, "wb");
#line 1265
  if ((unsigned long )outStr == (unsigned long )((void *)0)) {
#line 1266
    tmp___13 = __errno_location();
#line 1266
    tmp___14 = strerror(*tmp___13);
#line 1266
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t create output file %s: %s.\n",
            progName, outName, tmp___14);
#line 1268
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1268
      fclose(inStr);
    } else {

    }
#line 1269
    setExit(1);
#line 1270
    return;
  } else {

  }
#line 1272
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1273
    tmp___15 = __errno_location();
#line 1273
    tmp___16 = strerror(*tmp___15);
#line 1273
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___16);
#line 1275
    if ((unsigned long )outStr != (unsigned long )((void *)0)) {
#line 1275
      fclose(outStr);
    } else {

    }
#line 1276
    setExit(1);
#line 1277
    return;
  } else {

  }
#line 1279
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1282
  panic("compress: bad srcMode");
#line 1283
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1286
  if (verbosity >= 1) {
#line 1287
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %s: ", inName);
#line 1288
    pad(inName);
#line 1289
    fflush(stderr);
  } else {

  }
#line 1293
  outputHandleJustInCase = outStr;
#line 1294
  deleteOutputOnInterrupt = (Bool )1;
#line 1295
  compressStream(inStr, outStr);
#line 1296
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1299
  if (srcMode == 3) {
#line 1300
    applySavedTimeInfoToOutputFile(outName);
#line 1301
    deleteOutputOnInterrupt = (Bool )0;
#line 1302
    if (keepInputFiles == 0) {
#line 1303
      tmp___17 = remove((char const   *)(inName));
#line 1303
      retVal = tmp___17;
#line 1304
      if (retVal != 0) {
#line 1304
        ioError();
      } else {

      }
    } else {

    }
  } else {

  }
#line 1308
  deleteOutputOnInterrupt = (Bool )0;
#line 1309
  return;
}
}
#line 1313 "bzip2.c"
static void uncompress(Char *name ) 
{ 
  FILE *inStr ;
  FILE *outStr ;
  Int32 n ;
  Int32 i ;
  Bool magicNumberOK ;
  Bool cantGuess ;
  struct stat statBuf ;
  Bool tmp ;
  Bool tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  IntNative retVal ;
  int tmp___15 ;
  IntNative retVal___0 ;
  int tmp___16 ;

  {
#line 1323
  deleteOutputOnInterrupt = (Bool )0;
#line 1325
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1325
    if (srcMode != 1) {
#line 1326
      panic("uncompress: bad modes\n");
    } else {

    }
  } else {

  }
#line 1328
  cantGuess = (Bool )0;
  {
#line 1330
  if (srcMode == 1) {
#line 1330
    goto case_1;
  } else {

  }
#line 1334
  if (srcMode == 3) {
#line 1334
    goto case_3;
  } else {

  }
#line 1343
  if (srcMode == 2) {
#line 1343
    goto case_2;
  } else {

  }
#line 1329
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1331
  copyFileName(inName, (Char *)"(stdin)");
#line 1332
  copyFileName(outName, (Char *)"(stdout)");
#line 1333
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1335
  copyFileName(inName, name);
#line 1336
  copyFileName(outName, name);
#line 1337
  i = 0;
  {
#line 1337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1337
    if (i < 4) {

    } else {
#line 1337
      goto while_break;
    }
#line 1338
    tmp = mapSuffix(outName, zSuffix[i], unzSuffix[i]);
#line 1338
    if (tmp != 0) {
#line 1339
      goto zzz;
    } else {

    }
#line 1337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1340
  cantGuess = (Bool )1;
#line 1341
  strcat((char * __restrict  )(outName), (char const   * __restrict  )".out");
#line 1342
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1344
  copyFileName(inName, name);
#line 1345
  copyFileName(outName, (Char *)"(stdout)");
#line 1346
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  zzz: 
#line 1350
  if (srcMode != 1) {
#line 1350
    tmp___0 = containsDubiousChars(inName);
#line 1350
    if (tmp___0 != 0) {
#line 1351
      if (noisy != 0) {
#line 1352
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: There are no files matching `%s\'.\n",
                progName, inName);
      } else {

      }
#line 1354
      setExit(1);
#line 1355
      return;
    } else {

    }
  } else {

  }
#line 1357
  if (srcMode != 1) {
#line 1357
    tmp___3 = fileExists(inName);
#line 1357
    if (tmp___3 == 0) {
#line 1358
      tmp___1 = __errno_location();
#line 1358
      tmp___2 = strerror(*tmp___1);
#line 1358
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input file %s: %s.\n",
              progName, inName, tmp___2);
#line 1360
      setExit(1);
#line 1361
      return;
    } else {

    }
  } else {

  }
#line 1363
  if (srcMode == 3) {
#line 1363
    goto _L;
  } else
#line 1363
  if (srcMode == 2) {
    _L: 
#line 1364
    stat((char const   * __restrict  )((char const   *)(inName)), (struct stat * __restrict  )(& statBuf));
#line 1365
    if ((statBuf.st_mode & 61440U) == 16384U) {
#line 1366
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1369
      setExit(1);
#line 1370
      return;
    } else {

    }
  } else {

  }
#line 1373
  if (srcMode == 3) {
#line 1373
    if (forceOverwrite == 0) {
#line 1373
      tmp___4 = notAStandardFile(inName);
#line 1373
      if (tmp___4 != 0) {
#line 1374
        if (noisy != 0) {
#line 1375
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s is not a normal file.\n",
                  progName, inName);
        } else {

        }
#line 1377
        setExit(1);
#line 1378
        return;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1380
  if (cantGuess != 0) {
#line 1381
    if (noisy != 0) {
#line 1382
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t guess original name for %s -- using %s\n",
              progName, inName, outName);
    } else {

    }
  } else {

  }
#line 1387
  if (srcMode == 3) {
#line 1387
    tmp___5 = fileExists(outName);
#line 1387
    if (tmp___5 != 0) {
#line 1388
      if (forceOverwrite != 0) {
#line 1389
        remove((char const   *)(outName));
      } else {
#line 1391
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Output file %s already exists.\n",
                progName, outName);
#line 1393
        setExit(1);
#line 1394
        return;
      }
    } else {

    }
  } else {

  }
#line 1397
  if (srcMode == 3) {
#line 1397
    if (forceOverwrite == 0) {
#line 1397
      n = countHardLinks(inName);
#line 1397
      if (n > 0) {
#line 1399
        if (n > 1) {
#line 1399
          tmp___6 = "s";
        } else {
#line 1399
          tmp___6 = "";
        }
#line 1399
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s has %d other link%s.\n",
                progName, inName, n, tmp___6);
#line 1401
        setExit(1);
#line 1402
        return;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1405
  if (srcMode == 3) {
#line 1408
    saveInputFileMetaInfo(inName);
  } else {

  }
  {
#line 1412
  if (srcMode == 1) {
#line 1412
    goto case_1___0;
  } else {

  }
#line 1426
  if (srcMode == 2) {
#line 1426
    goto case_2___0;
  } else {

  }
#line 1438
  if (srcMode == 3) {
#line 1438
    goto case_3___0;
  } else {

  }
#line 1457
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 1414
  inStr = stdin;
#line 1415
  outStr = stdout;
#line 1416
  tmp___7 = fileno(stdin);
#line 1416
  tmp___8 = isatty(tmp___7);
#line 1416
  if (tmp___8 != 0) {
#line 1417
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: I won\'t read compressed data from a terminal.\n",
            progName);
#line 1420
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1422
    setExit(1);
#line 1423
    return;
  } else {

  }
#line 1425
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 1428
  inStr = fopen((char const   * __restrict  )((char const   *)(inName)), (char const   * __restrict  )"rb");
#line 1429
  outStr = stdout;
#line 1430
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1431
    tmp___9 = __errno_location();
#line 1431
    tmp___10 = strerror(*tmp___9);
#line 1431
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input file %s:%s.\n",
            progName, inName, tmp___10);
#line 1433
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1433
      fclose(inStr);
    } else {

    }
#line 1434
    setExit(1);
#line 1435
    return;
  } else {

  }
#line 1437
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 1440
  inStr = fopen((char const   * __restrict  )((char const   *)(inName)), (char const   * __restrict  )"rb");
#line 1441
  outStr = fopen_output_safely(outName, "wb");
#line 1442
  if ((unsigned long )outStr == (unsigned long )((void *)0)) {
#line 1443
    tmp___11 = __errno_location();
#line 1443
    tmp___12 = strerror(*tmp___11);
#line 1443
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t create output file %s: %s.\n",
            progName, outName, tmp___12);
#line 1445
    if ((unsigned long )inStr != (unsigned long )((void *)0)) {
#line 1445
      fclose(inStr);
    } else {

    }
#line 1446
    setExit(1);
#line 1447
    return;
  } else {

  }
#line 1449
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1450
    tmp___13 = __errno_location();
#line 1450
    tmp___14 = strerror(*tmp___13);
#line 1450
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input file %s: %s.\n",
            progName, inName, tmp___14);
#line 1452
    if ((unsigned long )outStr != (unsigned long )((void *)0)) {
#line 1452
      fclose(outStr);
    } else {

    }
#line 1453
    setExit(1);
#line 1454
    return;
  } else {

  }
#line 1456
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1459
  panic("uncompress: bad srcMode");
#line 1460
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1463
  if (verbosity >= 1) {
#line 1464
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %s: ", inName);
#line 1465
    pad(inName);
#line 1466
    fflush(stderr);
  } else {

  }
#line 1470
  outputHandleJustInCase = outStr;
#line 1471
  deleteOutputOnInterrupt = (Bool )1;
#line 1472
  magicNumberOK = uncompressStream(inStr, outStr);
#line 1473
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1476
  if (magicNumberOK != 0) {
#line 1477
    if (srcMode == 3) {
#line 1478
      applySavedTimeInfoToOutputFile(outName);
#line 1479
      deleteOutputOnInterrupt = (Bool )0;
#line 1480
      if (keepInputFiles == 0) {
#line 1481
        tmp___15 = remove((char const   *)(inName));
#line 1481
        retVal = tmp___15;
#line 1482
        if (retVal != 0) {
#line 1482
          ioError();
        } else {

        }
      } else {

      }
    } else {

    }
  } else {
#line 1486
    unzFailsExist = (Bool )1;
#line 1487
    deleteOutputOnInterrupt = (Bool )0;
#line 1488
    if (srcMode == 3) {
#line 1489
      tmp___16 = remove((char const   *)(outName));
#line 1489
      retVal___0 = tmp___16;
#line 1490
      if (retVal___0 != 0) {
#line 1490
        ioError();
      } else {

      }
    } else {

    }
  }
#line 1493
  deleteOutputOnInterrupt = (Bool )0;
#line 1495
  if (magicNumberOK != 0) {
#line 1496
    if (verbosity >= 1) {
#line 1497
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"done\n");
    } else {

    }
  } else {
#line 1499
    setExit(2);
#line 1500
    if (verbosity >= 1) {
#line 1501
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"not a bzip2 file.\n");
    } else {
#line 1502
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is not a bzip2 file.\n",
              progName, inName);
    }
  }
#line 1507
  return;
}
}
#line 1511 "bzip2.c"
static void testf(Char *name ) 
{ 
  FILE *inStr ;
  Bool allOK ;
  struct stat statBuf ;
  Bool tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 1518
  deleteOutputOnInterrupt = (Bool )0;
#line 1520
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1520
    if (srcMode != 1) {
#line 1521
      panic("testf: bad modes\n");
    } else {

    }
  } else {

  }
#line 1523
  copyFileName(outName, (Char *)"(none)");
  {
#line 1525
  if (srcMode == 1) {
#line 1525
    goto case_1;
  } else {

  }
#line 1526
  if (srcMode == 3) {
#line 1526
    goto case_3;
  } else {

  }
#line 1527
  if (srcMode == 2) {
#line 1527
    goto case_2;
  } else {

  }
#line 1524
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1525
  copyFileName(inName, (Char *)"(stdin)");
#line 1525
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1526
  copyFileName(inName, name);
#line 1526
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1527
  copyFileName(inName, name);
#line 1527
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1530
  if (srcMode != 1) {
#line 1530
    tmp = containsDubiousChars(inName);
#line 1530
    if (tmp != 0) {
#line 1531
      if (noisy != 0) {
#line 1532
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: There are no files matching `%s\'.\n",
                progName, inName);
      } else {

      }
#line 1534
      setExit(1);
#line 1535
      return;
    } else {

    }
  } else {

  }
#line 1537
  if (srcMode != 1) {
#line 1537
    tmp___2 = fileExists(inName);
#line 1537
    if (tmp___2 == 0) {
#line 1538
      tmp___0 = __errno_location();
#line 1538
      tmp___1 = strerror(*tmp___0);
#line 1538
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input %s: %s.\n",
              progName, inName, tmp___1);
#line 1540
      setExit(1);
#line 1541
      return;
    } else {

    }
  } else {

  }
#line 1543
  if (srcMode != 1) {
#line 1544
    stat((char const   * __restrict  )((char const   *)(inName)), (struct stat * __restrict  )(& statBuf));
#line 1545
    if ((statBuf.st_mode & 61440U) == 16384U) {
#line 1546
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Input file %s is a directory.\n",
              progName, inName);
#line 1549
      setExit(1);
#line 1550
      return;
    } else {

    }
  } else {

  }
  {
#line 1555
  if (srcMode == 1) {
#line 1555
    goto case_1___0;
  } else {

  }
#line 1569
  if (srcMode == 2) {
#line 1569
    goto case_2___0;
  } else {

  }
#line 1568
  if (srcMode == 3) {
#line 1568
    goto case_2___0;
  } else {

  }
#line 1578
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 1557
  tmp___3 = fileno(stdin);
#line 1557
  tmp___4 = isatty(tmp___3);
#line 1557
  if (tmp___4 != 0) {
#line 1558
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: I won\'t read compressed data from a terminal.\n",
            progName);
#line 1561
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: For help, type: `%s --help\'.\n",
            progName, progName);
#line 1563
    setExit(1);
#line 1564
    return;
  } else {

  }
#line 1566
  inStr = stdin;
#line 1567
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
#line 1570
  inStr = fopen((char const   * __restrict  )((char const   *)(inName)), (char const   * __restrict  )"rb");
#line 1571
  if ((unsigned long )inStr == (unsigned long )((void *)0)) {
#line 1572
    tmp___5 = __errno_location();
#line 1572
    tmp___6 = strerror(*tmp___5);
#line 1572
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Can\'t open input file %s:%s.\n",
            progName, inName, tmp___6);
#line 1574
    setExit(1);
#line 1575
    return;
  } else {

  }
#line 1577
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1580
  panic("testf: bad srcMode");
#line 1581
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1584
  if (verbosity >= 1) {
#line 1585
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %s: ", inName);
#line 1586
    pad(inName);
#line 1587
    fflush(stderr);
  } else {

  }
#line 1591
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1592
  allOK = testStream(inStr);
#line 1594
  if (allOK != 0) {
#line 1594
    if (verbosity >= 1) {
#line 1594
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ok\n");
    } else {

    }
  } else {

  }
#line 1595
  if (allOK == 0) {
#line 1595
    testFailsExist = (Bool )1;
  } else {

  }
#line 1596
  return;
}
}
#line 1600 "bzip2.c"
static void license(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  char const   *tmp_ssa_1 ;
  struct _IO_FILE *__cil_tmp4 ;

  {
#line 1602
  __cil_gp_stderr = & stderr;
#line 1602
  return babel_wrapper_license(__cil_gp_stderr);
#line 1602
  __cil_gp_stderr = & stderr;
#line 1603
  tmp_ssa_1 = BZ2_bzlibVersion();
#line 1603
  __cil_tmp4 = *__cil_gp_stderr;
#line 1603
  fprintf((FILE * __restrict  )__cil_tmp4, (char const   * __restrict  )"bzip2, a block-sorting file compressor.  Version %s.\n   \n   Copyright (C) 1996-2010 by Julian Seward.\n   \n   This program is free software; you can redistribute it and/or modify\n   it under the terms set out in the LICENSE file, which is included\n   in the bzip2-1.0.6 source distribution.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   LICENSE file for more details.\n   \n",
          tmp_ssa_1);
#line 1621
  return;
}
}
#line 1625 "bzip2.c"
static void usage(Char *fullProgName ) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  char const   *tmp_ssa_1 ;
  struct _IO_FILE *__cil_tmp5 ;

  {
#line 1627
  __cil_gp_stderr = & stderr;
#line 1627
  return babel_wrapper_usage(__cil_gp_stderr, fullProgName);
#line 1627
  __cil_gp_stderr = & stderr;
#line 1628
  tmp_ssa_1 = BZ2_bzlibVersion();
#line 1628
  __cil_tmp5 = *__cil_gp_stderr;
#line 1628
  fprintf((FILE * __restrict  )__cil_tmp5, (char const   * __restrict  )"bzip2, a block-sorting file compressor.  Version %s.\n\n   usage: %s [flags and input files in any order]\n\n   -h --help           print this message\n   -d --decompress     force decompression\n   -z --compress       force compression\n   -k --keep           keep (don\'t delete) input files\n   -f --force          overwrite existing output files\n   -t --test           test compressed file integrity\n   -c --stdout         output to standard out\n   -q --quiet          suppress noncritical error messages\n   -v --verbose        be verbose (a 2nd -v gives more)\n   -L --license        display software version & license\n   -V --version        display software version & license\n   -s --small          use less memory (at most 2500k)\n   -1 .. -9            set block size to 100k .. 900k\n   --fast              alias for -1\n   --best              alias for -9\n\n   If invoked as `bzip2\', default action is to compress.\n              as `bunzip2\',  default action is to decompress.\n              as `bzcat\', default action is to decompress to stdout.\n\n   If no file names are given, bzip2 compresses or decompresses\n   from standard input to standard output.  You can combine\n   short flags, so `-v -4\' means the same as -v4 or -4v, &c.\n\n",
          tmp_ssa_1, fullProgName);
#line 1665
  return;
}
}
#line 1669 "bzip2.c"
static void redundant(Char *flag ) 
{ 
  struct _IO_FILE **__cil_gp_stderr ;
  Char **__cil_gp_progName ;
  struct _IO_FILE *__cil_tmp4 ;
  Char *__cil_tmp5 ;

  {
#line 1671
  __cil_gp_progName = & progName;
#line 1671
  __cil_gp_stderr = & stderr;
#line 1671
  return babel_wrapper_redundant(__cil_gp_stderr, __cil_gp_progName, flag);
#line 1671
  __cil_gp_stderr = & stderr;
#line 1672
  __cil_gp_progName = & progName;
#line 1672
  __cil_tmp4 = *__cil_gp_stderr;
#line 1672
  __cil_tmp5 = *__cil_gp_progName;
#line 1672
  fprintf((FILE * __restrict  )__cil_tmp4, (char const   * __restrict  )"%s: %s is redundant in versions 0.9.5 and above\n",
          __cil_tmp5, flag);
#line 1676
  return;
}
}
#line 1703 "bzip2.c"
static void *myMalloc(Int32 n ) 
{ 
  void *p_ssa_1 ;
  int __cil_tmp4 ;

  {

#line 1708
  return babel_wrapper_myMalloc(n);
#line 1708
  p_ssa_1 = malloc((size_t )n);
#line 1709
  __cil_tmp4 = (unsigned long )p_ssa_1 == (unsigned long )((void *)0);
#line 1709
  if (__cil_tmp4 != 0) {
#line 1709
    outOfMemory();
  } else {

  }
#line 1710
  return (p_ssa_1);
}
}
#line 1715 "bzip2.c"
static Cell *mkCell(void) 
{ 
  void *tmp_ssa_1 ;
  Cell *c_ssa_1 ;
  unsigned char *__cil_tmp5 ;
  struct zzzz **__cil_tmp6 ;
  Char **mem_5 ;

  {

#line 1720
  return babel_wrapper_mkCell();
#line 1720
  tmp_ssa_1 = myMalloc((Int32 )sizeof(Cell ));
#line 1720
  c_ssa_1 = (Cell *)tmp_ssa_1;
#line 1721
  mem_5 = (Char **)c_ssa_1;
#line 1721
  *mem_5 = (Char *)0;
#line 1722
  __cil_tmp5 = (unsigned char *)c_ssa_1 + 8;
#line 1722
  __cil_tmp6 = (struct zzzz **)__cil_tmp5;
#line 1722
  *__cil_tmp6 = (struct zzzz *)0;
#line 1723
  return (c_ssa_1);
}
}
#line 1728 "bzip2.c"
static Cell *snocString(Cell *root , Char *name ) 
{ 
  Cell *tmp___3 ;
  Cell **__cil_pp_root ;
  Char **__cil_pp_name ;
  Cell **__cil_pp_tmp___3 ;
  Cell **__cil_fp_root ;
  Char **__cil_fp_name ;
  Cell **__cil_fp_tmp___3 ;
  Cell *tmp___0_ssa_1 ;
  Cell *tmp_ssa_1 ;
  size_t tmp___1_ssa_1 ;
  void *tmp___2_ssa_1 ;
  Cell *tmp___3_ssa_1 ;
  Cell *root_ssa_1 ;
  Char *name_ssa_1 ;
  Cell *tmp___3_ssa_2 ;
  int __cil_tmp22 ;
  size_t __cil_tmp23 ;
  Char *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  struct zzzz **__cil_tmp26 ;
  struct zzzz *__cil_tmp27 ;
  Char **mem_24 ;
  Char **mem_25 ;
  struct zzzz **mem_26 ;

  {
#line 1731
  __cil_pp_root = & root;
#line 1732
  __cil_pp_name = & name;
#line 1733
  __cil_pp_tmp___3 = & tmp___3;
#line 1734
  __cil_fp_root = & root;
#line 1735
  __cil_fp_name = & name;
#line 1736
  __cil_fp_tmp___3 = & tmp___3;
#line 1731
  __cil_tmp22 = (unsigned long )root == (unsigned long )((void *)0);
#line 1731
  if (__cil_tmp22 != 0) {
#line 1732
    tmp___0_ssa_1 = mkCell();
#line 1732
    tmp_ssa_1 = tmp___0_ssa_1;
#line 1733
    tmp___1_ssa_1 = strlen((char const   *)name);
#line 1733
    __cil_tmp23 = 5UL + tmp___1_ssa_1;
#line 1733
    tmp___2_ssa_1 = myMalloc((Int32 )__cil_tmp23);
#line 1733
    mem_24 = (Char **)tmp_ssa_1;
#line 1733
    *mem_24 = (Char *)tmp___2_ssa_1;
#line 1734
    mem_25 = (Char **)tmp_ssa_1;
#line 1734
    __cil_tmp24 = *mem_25;
#line 1734
    strcpy((char * __restrict  )__cil_tmp24, (char const   * __restrict  )((char const   *)name));
#line 1735
    return (tmp_ssa_1);
  } else {
#line 1737
    tmp___3_ssa_1 = root;
#line 1740
    *__cil_fp_root = root;
#line 1741
    *__cil_fp_name = name;
#line 1742
    *__cil_fp_tmp___3 = tmp___3_ssa_1;
#line 1738
    snocString_cil_lr_1(__cil_pp_root, __cil_pp_name, __cil_pp_tmp___3);
#line 1739
    root_ssa_1 = *__cil_fp_root;
#line 1740
    name_ssa_1 = *__cil_fp_name;
#line 1741
    tmp___3_ssa_2 = *__cil_fp_tmp___3;
#line 1739
    __cil_tmp25 = (unsigned char *)tmp___3_ssa_2 + 8;
#line 1739
    __cil_tmp26 = (struct zzzz **)__cil_tmp25;
#line 1739
    __cil_tmp27 = *__cil_tmp26;
#line 1739
    mem_26 = (struct zzzz **)((unsigned char *)tmp___3_ssa_2 + 8);
#line 1739
    *mem_26 = snocString(__cil_tmp27, name_ssa_1);
#line 1740
    return (root_ssa_1);
  }
}
}
#line 1746 "bzip2.c"
static void addFlagsFromEnvVar(Cell **argList , Char *varName ) 
{ 
  Char *envbase_ssa_1 ;
  Char *p_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp13 ;

  {

#line 1752
  return babel_wrapper_addFlagsFromEnvVar(argList, varName);
#line 1752
  envbase_ssa_1 = getenv((char const   *)varName);
#line 1753
  __cil_tmp13 = (unsigned long )envbase_ssa_1 != (unsigned long )((void *)0);
#line 1753
  if (__cil_tmp13 != 0) {
#line 1754
    p_ssa_1 = envbase_ssa_1;
#line 1755
    i_ssa_1 = 0;
#line 1756
    addFlagsFromEnvVar_cil_lr_1(argList, i_ssa_1, p_ssa_1);
  } else {

  }
#line 1770
  return;
}
}
#line 1776 "bzip2.c"
IntNative main(IntNative argc , Char **argv ) 
{ 
  Int32 i ;
  Int32 j ;
  Char *tmp ;
  Cell *argList ;
  Cell *aa ;
  Bool decode ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  Cell *aa2 ;
  Char **mem_42 ;
  Char **mem_43 ;
  Char *mem_44 ;
  Char *mem_45 ;
  Char *mem_46 ;
  Char *mem_47 ;
  Char *mem_48 ;
  Char *mem_49 ;
  Char *mem_50 ;
  Char *mem_51 ;

  {
  Pl_Start_Prolog(argc, argv);
#line 1785
  if (sizeof(Int32 ) != 4UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(UInt32 ) != 4UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(Int16 ) != 2UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(UInt16 ) != 2UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(Char ) != 1UL) {
#line 1788
    configError();
  } else
#line 1785
  if (sizeof(UChar ) != 1UL) {
#line 1788
    configError();
  } else {

  }
#line 1791
  outputHandleJustInCase = (FILE *)((void *)0);
#line 1792
  smallMode = (Bool )0;
#line 1793
  keepInputFiles = (Bool )0;
#line 1794
  forceOverwrite = (Bool )0;
#line 1795
  noisy = (Bool )1;
#line 1796
  verbosity = 0;
#line 1797
  blockSize100k = 9;
#line 1798
  testFailsExist = (Bool )0;
#line 1799
  unzFailsExist = (Bool )0;
#line 1800
  numFileNames = 0;
#line 1801
  numFilesProcessed = 0;
#line 1802
  workFactor = 30;
#line 1803
  deleteOutputOnInterrupt = (Bool )0;
#line 1804
  exitValue = 0;
#line 1805
  j = 0;
#line 1808
  signal(11, & mySIGSEGVorSIGBUScatcher);
#line 1811
  signal(7, & mySIGSEGVorSIGBUScatcher);
#line 1815
  copyFileName(inName, (Char *)"(none)");
#line 1816
  copyFileName(outName, (Char *)"(none)");
#line 1818
  mem_42 = argv + 0;
#line 1818
  copyFileName(progNameReally, *mem_42);
#line 1819
  progName = & progNameReally[0];
#line 1820
  tmp = & progNameReally[0];
  {
#line 1820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1820
    if ((int )*tmp != 0) {

    } else {
#line 1820
      goto while_break;
    }
#line 1821
    if ((int )*tmp == 47) {
#line 1821
      progName = tmp + 1;
    } else {

    }
#line 1820
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1827
  argList = (Cell *)((void *)0);
#line 1828
  addFlagsFromEnvVar(& argList, (Char *)"BZIP2");
#line 1829
  addFlagsFromEnvVar(& argList, (Char *)"BZIP");
#line 1830
  i = 1;
  {
#line 1830
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1830
    if (i <= argc - 1) {

    } else {
#line 1830
      goto while_break___0;
    }
#line 1831
    mem_43 = argv + i;
#line 1831
    argList = snocString(argList, *mem_43);
#line 1830
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1835
  longestFileName = 7;
#line 1836
  numFileNames = 0;
#line 1837
  decode = (Bool )1;
#line 1838
  aa = argList;
  {
#line 1838
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1838
    if ((unsigned long )aa != (unsigned long )((void *)0)) {

    } else {
#line 1838
      goto while_break___1;
    }
#line 1839
    tmp___0 = strcmp((char const   *)aa->name, "--");
#line 1839
    if (tmp___0 == 0) {
#line 1839
      decode = (Bool )0;
#line 1839
      goto __Cont;
    } else {

    }
    {
#line 1840
    mem_44 = aa->name + 0;
#line 1840
    if ((int )*mem_44 == 45) {
#line 1840
      if (decode != 0) {
#line 1840
        goto __Cont;
      } else {

      }
    } else {

    }
    }
#line 1841
    numFileNames ++;
#line 1842
    tmp___2 = strlen((char const   *)aa->name);
#line 1842
    if (longestFileName < (Int32 )tmp___2) {
#line 1843
      tmp___1 = strlen((char const   *)aa->name);
#line 1843
      longestFileName = (Int32 )tmp___1;
    } else {

    }
    __Cont: 
#line 1838
    aa = aa->link;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1848
  if (numFileNames == 0) {
#line 1849
    srcMode = 1;
  } else {
#line 1849
    srcMode = 3;
  }
#line 1854
  opMode = 1;
#line 1856
  tmp___3 = strstr((char const   *)progName, "unzip");
#line 1856
  if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
#line 1858
    opMode = 2;
  } else {
#line 1856
    tmp___4 = strstr((char const   *)progName, "UNZIP");
#line 1856
    if ((unsigned long )tmp___4 != (unsigned long )((char *)0)) {
#line 1858
      opMode = 2;
    } else {

    }
  }
#line 1860
  tmp___5 = strstr((char const   *)progName, "z2cat");
#line 1860
  if ((unsigned long )tmp___5 != (unsigned long )((char *)0)) {
#line 1860
    goto _L;
  } else {
#line 1860
    tmp___6 = strstr((char const   *)progName, "Z2CAT");
#line 1860
    if ((unsigned long )tmp___6 != (unsigned long )((char *)0)) {
#line 1860
      goto _L;
    } else {
#line 1860
      tmp___7 = strstr((char const   *)progName, "zcat");
#line 1860
      if ((unsigned long )tmp___7 != (unsigned long )((char *)0)) {
#line 1860
        goto _L;
      } else {
#line 1860
        tmp___8 = strstr((char const   *)progName, "ZCAT");
#line 1860
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
          _L: 
#line 1864
          opMode = 2;
#line 1865
          if (numFileNames == 0) {
#line 1865
            srcMode = 1;
          } else {
#line 1865
            srcMode = 2;
          }
        } else {

        }
      }
    }
  }
#line 1870
  aa = argList;
  {
#line 1870
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1870
    if ((unsigned long )aa != (unsigned long )((void *)0)) {

    } else {
#line 1870
      goto while_break___2;
    }
#line 1871
    tmp___9 = strcmp((char const   *)aa->name, "--");
#line 1871
    if (tmp___9 == 0) {
#line 1871
      goto while_break___2;
    } else {

    }
    {
#line 1872
    mem_45 = aa->name + 0;
#line 1872
    if ((int )*mem_45 == 45) {
      {
#line 1872
      mem_46 = aa->name + 1;
#line 1872
      if ((int )*mem_46 != 45) {
#line 1873
        j = 1;
        {
#line 1873
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1873
          mem_47 = aa->name + j;
#line 1873
          if ((int )*mem_47 != 0) {

          } else {
#line 1873
            goto while_break___3;
          }
          }
          {
#line 1874
          mem_48 = aa->name + j;
          {
#line 1875
          if ((int )*mem_48 == 99) {
#line 1875
            goto case_99;
          } else {

          }
#line 1876
          if ((int )*mem_48 == 100) {
#line 1876
            goto case_100;
          } else {

          }
#line 1877
          if ((int )*mem_48 == 122) {
#line 1877
            goto case_122;
          } else {

          }
#line 1878
          if ((int )*mem_48 == 102) {
#line 1878
            goto case_102;
          } else {

          }
#line 1879
          if ((int )*mem_48 == 116) {
#line 1879
            goto case_116;
          } else {

          }
#line 1880
          if ((int )*mem_48 == 107) {
#line 1880
            goto case_107;
          } else {

          }
#line 1881
          if ((int )*mem_48 == 115) {
#line 1881
            goto case_115;
          } else {

          }
#line 1882
          if ((int )*mem_48 == 113) {
#line 1882
            goto case_113;
          } else {

          }
#line 1883
          if ((int )*mem_48 == 49) {
#line 1883
            goto case_49;
          } else {

          }
#line 1884
          if ((int )*mem_48 == 50) {
#line 1884
            goto case_50;
          } else {

          }
#line 1885
          if ((int )*mem_48 == 51) {
#line 1885
            goto case_51;
          } else {

          }
#line 1886
          if ((int )*mem_48 == 52) {
#line 1886
            goto case_52;
          } else {

          }
#line 1887
          if ((int )*mem_48 == 53) {
#line 1887
            goto case_53;
          } else {

          }
#line 1888
          if ((int )*mem_48 == 54) {
#line 1888
            goto case_54;
          } else {

          }
#line 1889
          if ((int )*mem_48 == 55) {
#line 1889
            goto case_55;
          } else {

          }
#line 1890
          if ((int )*mem_48 == 56) {
#line 1890
            goto case_56;
          } else {

          }
#line 1891
          if ((int )*mem_48 == 57) {
#line 1891
            goto case_57;
          } else {

          }
#line 1893
          if ((int )*mem_48 == 86) {
#line 1893
            goto case_86;
          } else {

          }
#line 1892
          if ((int )*mem_48 == 76) {
#line 1892
            goto case_86;
          } else {

          }
#line 1894
          if ((int )*mem_48 == 118) {
#line 1894
            goto case_118;
          } else {

          }
#line 1895
          if ((int )*mem_48 == 104) {
#line 1895
            goto case_104;
          } else {

          }
#line 1898
          goto switch_default;
          case_99: /* CIL Label */ 
#line 1875
          srcMode = 2;
#line 1875
          goto switch_break;
          case_100: /* CIL Label */ 
#line 1876
          opMode = 2;
#line 1876
          goto switch_break;
          case_122: /* CIL Label */ 
#line 1877
          opMode = 1;
#line 1877
          goto switch_break;
          case_102: /* CIL Label */ 
#line 1878
          forceOverwrite = (Bool )1;
#line 1878
          goto switch_break;
          case_116: /* CIL Label */ 
#line 1879
          opMode = 3;
#line 1879
          goto switch_break;
          case_107: /* CIL Label */ 
#line 1880
          keepInputFiles = (Bool )1;
#line 1880
          goto switch_break;
          case_115: /* CIL Label */ 
#line 1881
          smallMode = (Bool )1;
#line 1881
          goto switch_break;
          case_113: /* CIL Label */ 
#line 1882
          noisy = (Bool )0;
#line 1882
          goto switch_break;
          case_49: /* CIL Label */ 
#line 1883
          blockSize100k = 1;
#line 1883
          goto switch_break;
          case_50: /* CIL Label */ 
#line 1884
          blockSize100k = 2;
#line 1884
          goto switch_break;
          case_51: /* CIL Label */ 
#line 1885
          blockSize100k = 3;
#line 1885
          goto switch_break;
          case_52: /* CIL Label */ 
#line 1886
          blockSize100k = 4;
#line 1886
          goto switch_break;
          case_53: /* CIL Label */ 
#line 1887
          blockSize100k = 5;
#line 1887
          goto switch_break;
          case_54: /* CIL Label */ 
#line 1888
          blockSize100k = 6;
#line 1888
          goto switch_break;
          case_55: /* CIL Label */ 
#line 1889
          blockSize100k = 7;
#line 1889
          goto switch_break;
          case_56: /* CIL Label */ 
#line 1890
          blockSize100k = 8;
#line 1890
          goto switch_break;
          case_57: /* CIL Label */ 
#line 1891
          blockSize100k = 9;
#line 1891
          goto switch_break;
          case_86: /* CIL Label */ 
          case_76: /* CIL Label */ 
#line 1893
          license();
#line 1893
          goto switch_break;
          case_118: /* CIL Label */ 
#line 1894
          verbosity ++;
#line 1894
          goto switch_break;
          case_104: /* CIL Label */ 
#line 1895
          usage(progName);
#line 1896
          exit(0);
#line 1897
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 1898
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Bad flag `%s\'\n",
                  progName, aa->name);
#line 1900
          usage(progName);
#line 1901
          exit(1);
#line 1902
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
          }
#line 1873
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {

      }
      }
    } else {

    }
    }
#line 1870
    aa = aa->link;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1909
  aa = argList;
  {
#line 1909
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1909
    if ((unsigned long )aa != (unsigned long )((void *)0)) {

    } else {
#line 1909
      goto while_break___4;
    }
#line 1910
    tmp___10 = strcmp((char const   *)aa->name, "--");
#line 1910
    if (tmp___10 == 0) {
#line 1910
      goto while_break___4;
    } else {

    }
#line 1911
    tmp___28 = strcmp((char const   *)aa->name, "--stdout");
#line 1911
    if (tmp___28 == 0) {
#line 1911
      srcMode = 2;
    } else {
#line 1912
      tmp___27 = strcmp((char const   *)aa->name, "--decompress");
#line 1912
      if (tmp___27 == 0) {
#line 1912
        opMode = 2;
      } else {
#line 1913
        tmp___26 = strcmp((char const   *)aa->name, "--compress");
#line 1913
        if (tmp___26 == 0) {
#line 1913
          opMode = 1;
        } else {
#line 1914
          tmp___25 = strcmp((char const   *)aa->name, "--force");
#line 1914
          if (tmp___25 == 0) {
#line 1914
            forceOverwrite = (Bool )1;
          } else {
#line 1915
            tmp___24 = strcmp((char const   *)aa->name, "--test");
#line 1915
            if (tmp___24 == 0) {
#line 1915
              opMode = 3;
            } else {
#line 1916
              tmp___23 = strcmp((char const   *)aa->name, "--keep");
#line 1916
              if (tmp___23 == 0) {
#line 1916
                keepInputFiles = (Bool )1;
              } else {
#line 1917
                tmp___22 = strcmp((char const   *)aa->name, "--small");
#line 1917
                if (tmp___22 == 0) {
#line 1917
                  smallMode = (Bool )1;
                } else {
#line 1918
                  tmp___21 = strcmp((char const   *)aa->name, "--quiet");
#line 1918
                  if (tmp___21 == 0) {
#line 1918
                    noisy = (Bool )0;
                  } else {
#line 1919
                    tmp___20 = strcmp((char const   *)aa->name, "--version");
#line 1919
                    if (tmp___20 == 0) {
#line 1919
                      license();
                    } else {
#line 1920
                      tmp___19 = strcmp((char const   *)aa->name, "--license");
#line 1920
                      if (tmp___19 == 0) {
#line 1920
                        license();
                      } else {
#line 1921
                        tmp___18 = strcmp((char const   *)aa->name, "--exponential");
#line 1921
                        if (tmp___18 == 0) {
#line 1921
                          workFactor = 1;
                        } else {
#line 1922
                          tmp___17 = strcmp((char const   *)aa->name, "--repetitive-best");
#line 1922
                          if (tmp___17 == 0) {
#line 1922
                            redundant(aa->name);
                          } else {
#line 1923
                            tmp___16 = strcmp((char const   *)aa->name, "--repetitive-fast");
#line 1923
                            if (tmp___16 == 0) {
#line 1923
                              redundant(aa->name);
                            } else {
#line 1924
                              tmp___15 = strcmp((char const   *)aa->name, "--fast");
#line 1924
                              if (tmp___15 == 0) {
#line 1924
                                blockSize100k = 1;
                              } else {
#line 1925
                                tmp___14 = strcmp((char const   *)aa->name, "--best");
#line 1925
                                if (tmp___14 == 0) {
#line 1925
                                  blockSize100k = 9;
                                } else {
#line 1926
                                  tmp___13 = strcmp((char const   *)aa->name, "--verbose");
#line 1926
                                  if (tmp___13 == 0) {
#line 1926
                                    verbosity ++;
                                  } else {
#line 1927
                                    tmp___12 = strcmp((char const   *)aa->name, "--help");
#line 1927
                                    if (tmp___12 == 0) {
#line 1927
                                      usage(progName);
#line 1927
                                      exit(0);
                                    } else {
#line 1929
                                      tmp___11 = strncmp((char const   *)aa->name,
                                                         "--", (size_t )2);
#line 1929
                                      if (tmp___11 == 0) {
#line 1930
                                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Bad flag `%s\'\n",
                                                progName, aa->name);
#line 1931
                                        usage(progName);
#line 1932
                                        exit(1);
                                      } else {

                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1909
    aa = aa->link;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1936
  if (verbosity > 4) {
#line 1936
    verbosity = 4;
  } else {

  }
#line 1937
  if (opMode == 1) {
#line 1937
    if (smallMode != 0) {
#line 1937
      if (blockSize100k > 2) {
#line 1938
        blockSize100k = 2;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1940
  if (opMode == 3) {
#line 1940
    if (srcMode == 2) {
#line 1941
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: -c and -t cannot be used together.\n",
              progName);
#line 1943
      exit(1);
    } else {

    }
  } else {

  }
#line 1946
  if (srcMode == 2) {
#line 1946
    if (numFileNames == 0) {
#line 1947
      srcMode = 1;
    } else {

    }
  } else {

  }
#line 1949
  if (opMode != 1) {
#line 1949
    blockSize100k = 0;
  } else {

  }
#line 1951
  if (srcMode == 3) {
#line 1952
    signal(2, & mySignalCatcher);
#line 1953
    signal(15, & mySignalCatcher);
#line 1955
    signal(1, & mySignalCatcher);
  } else {

  }
#line 1959
  if (opMode == 1) {
#line 1960
    if (srcMode == 1) {
#line 1961
      compress((Char *)((void *)0));
    } else {
#line 1963
      decode = (Bool )1;
#line 1964
      aa = argList;
      {
#line 1964
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1964
        if ((unsigned long )aa != (unsigned long )((void *)0)) {

        } else {
#line 1964
          goto while_break___5;
        }
#line 1965
        tmp___29 = strcmp((char const   *)aa->name, "--");
#line 1965
        if (tmp___29 == 0) {
#line 1965
          decode = (Bool )0;
#line 1965
          goto __Cont___0;
        } else {

        }
        {
#line 1966
        mem_49 = aa->name + 0;
#line 1966
        if ((int )*mem_49 == 45) {
#line 1966
          if (decode != 0) {
#line 1966
            goto __Cont___0;
          } else {

          }
        } else {

        }
        }
#line 1967
        numFilesProcessed ++;
#line 1968
        compress(aa->name);
        __Cont___0: 
#line 1964
        aa = aa->link;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  } else
#line 1974
  if (opMode == 2) {
#line 1975
    unzFailsExist = (Bool )0;
#line 1976
    if (srcMode == 1) {
#line 1977
      uncompress((Char *)((void *)0));
    } else {
#line 1979
      decode = (Bool )1;
#line 1980
      aa = argList;
      {
#line 1980
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1980
        if ((unsigned long )aa != (unsigned long )((void *)0)) {

        } else {
#line 1980
          goto while_break___6;
        }
#line 1981
        tmp___30 = strcmp((char const   *)aa->name, "--");
#line 1981
        if (tmp___30 == 0) {
#line 1981
          decode = (Bool )0;
#line 1981
          goto __Cont___1;
        } else {

        }
        {
#line 1982
        mem_50 = aa->name + 0;
#line 1982
        if ((int )*mem_50 == 45) {
#line 1982
          if (decode != 0) {
#line 1982
            goto __Cont___1;
          } else {

          }
        } else {

        }
        }
#line 1983
        numFilesProcessed ++;
#line 1984
        uncompress(aa->name);
        __Cont___1: 
#line 1980
        aa = aa->link;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1987
    if (unzFailsExist != 0) {
#line 1988
      setExit(2);
#line 1989
      exit(exitValue);
    } else {

    }
  } else {
#line 1994
    testFailsExist = (Bool )0;
#line 1995
    if (srcMode == 1) {
#line 1996
      testf((Char *)((void *)0));
    } else {
#line 1998
      decode = (Bool )1;
#line 1999
      aa = argList;
      {
#line 1999
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1999
        if ((unsigned long )aa != (unsigned long )((void *)0)) {

        } else {
#line 1999
          goto while_break___7;
        }
#line 2000
        tmp___31 = strcmp((char const   *)aa->name, "--");
#line 2000
        if (tmp___31 == 0) {
#line 2000
          decode = (Bool )0;
#line 2000
          goto __Cont___2;
        } else {

        }
        {
#line 2001
        mem_51 = aa->name + 0;
#line 2001
        if ((int )*mem_51 == 45) {
#line 2001
          if (decode != 0) {
#line 2001
            goto __Cont___2;
          } else {

          }
        } else {

        }
        }
#line 2002
        numFilesProcessed ++;
#line 2003
        testf(aa->name);
        __Cont___2: 
#line 1999
        aa = aa->link;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 2006
    if (testFailsExist != 0) {
#line 2006
      if (noisy != 0) {
#line 2007
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n");
#line 2012
        setExit(2);
#line 2013
        exit(exitValue);
      } else {

      }
    } else {

    }
  }
#line 2020
  aa = argList;
  {
#line 2021
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2021
    if ((unsigned long )aa != (unsigned long )((void *)0)) {

    } else {
#line 2021
      goto while_break___8;
    }
#line 2022
    aa2 = aa->link;
#line 2023
    if ((unsigned long )aa->name != (unsigned long )((void *)0)) {
#line 2023
      free((void *)aa->name);
    } else {

    }
#line 2024
    free((void *)aa);
#line 2025
    aa = aa2;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
  Pl_Stop_Prolog();
#line 2028
  return (exitValue);
  }
}
}
#line 2031 "bzip2.c"
void addFlagsFromEnvVar_cil_lr_1_cil_lr_1(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) 
{ 
  unsigned short const   **tmp_ssa_1 ;
  int __cil_tmp6 ;
  Char *__cil_tmp7 ;
  Char *__cil_tmp8 ;
  Char __cil_tmp9 ;
  unsigned short const   *__cil_tmp10 ;
  Int32 __cil_tmp11 ;
  unsigned short const   *__cil_tmp12 ;
  unsigned short __cil_tmp13 ;
  int __cil_tmp14 ;
  Char *__cil_tmp15 ;

  {

#line 1760
  return babel_wrapper_addFlagsFromEnvVar_cil_lr_1_cil_lr_1(__cil_ap_argList, __cil_ap_i,
                                                            __cil_ap_p);
#line 1760
  tmp_ssa_1 = __ctype_b_loc();
#line 1760
  __cil_tmp7 = *__cil_ap_p;
#line 1760
  __cil_tmp8 = __cil_tmp7 + 0;
#line 1760
  __cil_tmp9 = *__cil_tmp8;
#line 1760
  __cil_tmp10 = *tmp_ssa_1;
#line 1760
  __cil_tmp11 = (Int32 )__cil_tmp9;
#line 1760
  __cil_tmp12 = __cil_tmp10 + __cil_tmp11;
#line 1760
  __cil_tmp13 = (unsigned short )*__cil_tmp12;
#line 1760
  __cil_tmp14 = (int )((int const   )__cil_tmp13);
#line 1760
  __cil_tmp6 = __cil_tmp14 & 8192;
#line 1760
  if (__cil_tmp6 != 0) {
#line 1760
    __cil_tmp15 = *__cil_ap_p;
#line 1760
    *__cil_ap_p = __cil_tmp15 + 1;
#line 1763
    addFlagsFromEnvVar_cil_lr_1_cil_lr_1(__cil_ap_argList, __cil_ap_i, __cil_ap_p);
#line 1765
    return;
  } else {
#line 1767
    return;
  }
}
}
#line 1772 "bzip2.c"
void addFlagsFromEnvVar_cil_lr_1_cil_lr_2(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p ) 
{ 
  unsigned short const   **tmp___0_ssa_1 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  Char *__cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Char *__cil_tmp10 ;
  Char __cil_tmp11 ;
  int __cil_tmp12 ;
  Char *__cil_tmp13 ;
  Int32 __cil_tmp14 ;
  Char *__cil_tmp15 ;
  Char __cil_tmp16 ;
  unsigned short const   *__cil_tmp17 ;
  Int32 __cil_tmp18 ;
  unsigned short const   *__cil_tmp19 ;
  unsigned short __cil_tmp20 ;
  int __cil_tmp21 ;
  Int32 __cil_tmp22 ;

  {

#line 1761
  return babel_wrapper_addFlagsFromEnvVar_cil_lr_1_cil_lr_2(__cil_ap_argList, __cil_ap_i,
                                                            __cil_ap_p);
#line 1761
  __cil_tmp8 = *__cil_ap_p;
#line 1761
  __cil_tmp9 = *__cil_ap_i;
#line 1761
  __cil_tmp10 = __cil_tmp8 + __cil_tmp9;
#line 1761
  __cil_tmp11 = *__cil_tmp10;
#line 1761
  __cil_tmp12 = (int )__cil_tmp11;
#line 1761
  __cil_tmp6 = __cil_tmp12 != 0;
#line 1761
  if (__cil_tmp6 != 0) {
#line 1761
    tmp___0_ssa_1 = __ctype_b_loc();
#line 1761
    __cil_tmp13 = *__cil_ap_p;
#line 1761
    __cil_tmp14 = *__cil_ap_i;
#line 1761
    __cil_tmp15 = __cil_tmp13 + __cil_tmp14;
#line 1761
    __cil_tmp16 = *__cil_tmp15;
#line 1761
    __cil_tmp17 = *tmp___0_ssa_1;
#line 1761
    __cil_tmp18 = (Int32 )__cil_tmp16;
#line 1761
    __cil_tmp19 = __cil_tmp17 + __cil_tmp18;
#line 1761
    __cil_tmp20 = (unsigned short )*__cil_tmp19;
#line 1761
    __cil_tmp21 = (int )((int const   )__cil_tmp20);
#line 1761
    __cil_tmp7 = __cil_tmp21 & 8192;
#line 1761
    if (__cil_tmp7 != 0) {
#line 1762
      return;
    } else {
#line 1761
      __cil_tmp22 = *__cil_ap_i;
#line 1761
      *__cil_ap_i = __cil_tmp22 + 1;
#line 1764
      addFlagsFromEnvVar_cil_lr_1_cil_lr_2(__cil_ap_argList, __cil_ap_i, __cil_ap_p);
#line 1766
      return;
    }
  } else {
#line 1770
    return;
  }
}
}
#line 1775 "bzip2.c"
void addFlagsFromEnvVar_cil_lr_1_cil_lr_3(Cell ***__cil_ap_argList , Int32 *__cil_ap_i ,
                                          Char **__cil_ap_p , Int32 *__cil_ap_k ,
                                          Int32 j ) 
{ 
  Int32 j_ssa_1 ;
  int __cil_tmp7 ;
  Int32 __cil_tmp8 ;
  Char *__cil_tmp9 ;
  Char *__cil_tmp10 ;
  Char *__cil_tmp11 ;

  {

#line 1764
  return babel_wrapper_addFlagsFromEnvVar_cil_lr_1_cil_lr_3(__cil_ap_argList, __cil_ap_i,
                                                            __cil_ap_p, __cil_ap_k,
                                                            j);
#line 1764
  __cil_tmp8 = *__cil_ap_k;
#line 1764
  __cil_tmp7 = j < __cil_tmp8;
#line 1764
  if (__cil_tmp7 != 0) {
#line 1764
    __cil_tmp9 = *__cil_ap_p;
#line 1764
    __cil_tmp10 = __cil_tmp9 + j;
#line 1764
    __cil_tmp11 = tmpName + j;
#line 1764
    *__cil_tmp11 = *__cil_tmp10;
#line 1764
    j_ssa_1 = j + 1;
#line 1767
    addFlagsFromEnvVar_cil_lr_1_cil_lr_3(__cil_ap_argList, __cil_ap_i, __cil_ap_p,
                                         __cil_ap_k, j_ssa_1);
#line 1770
    return;
  } else {
#line 1772
    return;
  }
}
}
#line 1777 "bzip2.c"
void addFlagsFromEnvVar_cil_lr_1(Cell **argList , Int32 i , Char *p ) 
{ 
  Int32 k ;
  Cell ***__cil_pp_argList ;
  Int32 *__cil_pp_i ;
  Char **__cil_pp_p ;
  Int32 *__cil_pp_k ;
  Cell ***__cil_fp_argList ;
  Int32 *__cil_fp_i ;
  Char **__cil_fp_p ;
  Int32 *__cil_fp_k ;
  Char *p_ssa_1 ;
  Int32 i_ssa_1 ;
  Cell **argList_ssa_1 ;
  Int32 i_ssa_2 ;
  Char *p_ssa_2 ;
  Cell **argList_ssa_2 ;
  Int32 i_ssa_3 ;
  Char *p_ssa_3 ;
  Int32 k_ssa_1 ;
  Int32 k_ssa_2 ;
  Int32 j_ssa_1 ;
  Cell **argList_ssa_3 ;
  Int32 i_ssa_4 ;
  Char *p_ssa_4 ;
  Int32 k_ssa_3 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  Char *__cil_tmp34 ;
  Char __cil_tmp35 ;
  int __cil_tmp36 ;
  Char *__cil_tmp37 ;
  Cell *__cil_tmp38 ;
  Char *__cil_tmp39 ;

  {
#line 1780
  __cil_pp_argList = & argList;
#line 1781
  __cil_pp_i = & i;
#line 1782
  __cil_pp_p = & p;
#line 1783
  __cil_pp_k = & k;
#line 1784
  __cil_fp_argList = & argList;
#line 1785
  __cil_fp_i = & i;
#line 1786
  __cil_fp_p = & p;
#line 1787
  __cil_fp_k = & k;
#line 1757
  __cil_tmp34 = p + i;
#line 1757
  __cil_tmp35 = *__cil_tmp34;
#line 1757
  __cil_tmp36 = (int )__cil_tmp35;
#line 1757
  __cil_tmp31 = __cil_tmp36 == 0;
#line 1757
  if (__cil_tmp31 != 0) {
#line 1758
    return;
  } else {
#line 1758
    p_ssa_1 = p + i;
#line 1759
    i_ssa_1 = 0;
#line 1762
    *__cil_fp_argList = argList;
#line 1763
    *__cil_fp_i = i_ssa_1;
#line 1764
    *__cil_fp_p = p_ssa_1;
#line 1760
    addFlagsFromEnvVar_cil_lr_1_cil_lr_1(__cil_pp_argList, __cil_pp_i, __cil_pp_p);
#line 1761
    argList_ssa_1 = *__cil_fp_argList;
#line 1762
    i_ssa_2 = *__cil_fp_i;
#line 1763
    p_ssa_2 = *__cil_fp_p;
#line 1766
    *__cil_fp_argList = argList_ssa_1;
#line 1767
    *__cil_fp_i = i_ssa_2;
#line 1768
    *__cil_fp_p = p_ssa_2;
#line 1761
    addFlagsFromEnvVar_cil_lr_1_cil_lr_2(__cil_pp_argList, __cil_pp_i, __cil_pp_p);
#line 1762
    argList_ssa_2 = *__cil_fp_argList;
#line 1763
    i_ssa_3 = *__cil_fp_i;
#line 1764
    p_ssa_3 = *__cil_fp_p;
#line 1762
    __cil_tmp32 = i_ssa_3 > 0;
#line 1762
    if (__cil_tmp32 != 0) {
#line 1763
      k_ssa_1 = i_ssa_3;
#line 1763
      __cil_tmp33 = k_ssa_1 > 1024;
#line 1763
      if (__cil_tmp33 != 0) {
#line 1763
        k_ssa_2 = 1024;
      } else {
#line 1766
        k_ssa_2 = k_ssa_1;
      }
#line 1764
      j_ssa_1 = 0;
#line 1767
      *__cil_fp_argList = argList_ssa_2;
#line 1768
      *__cil_fp_i = i_ssa_3;
#line 1769
      *__cil_fp_p = p_ssa_3;
#line 1770
      *__cil_fp_k = k_ssa_2;
#line 1764
      addFlagsFromEnvVar_cil_lr_1_cil_lr_3(__cil_pp_argList, __cil_pp_i, __cil_pp_p,
                                           __cil_pp_k, j_ssa_1);
#line 1766
      argList_ssa_3 = *__cil_fp_argList;
#line 1767
      i_ssa_4 = *__cil_fp_i;
#line 1768
      p_ssa_4 = *__cil_fp_p;
#line 1769
      k_ssa_3 = *__cil_fp_k;
#line 1765
      __cil_tmp37 = tmpName + k_ssa_3;
#line 1765
      *__cil_tmp37 = (Char )0;
#line 1766
      __cil_tmp38 = *argList_ssa_3;
#line 1766
      __cil_tmp39 = tmpName;
#line 1766
      *argList_ssa_3 = snocString(__cil_tmp38, __cil_tmp39);
    } else {
#line 1769
      argList_ssa_3 = argList_ssa_2;
#line 1770
      i_ssa_4 = i_ssa_3;
#line 1771
      p_ssa_4 = p_ssa_3;
    }
#line 1775
    addFlagsFromEnvVar_cil_lr_1(argList_ssa_3, i_ssa_4, p_ssa_4);
#line 1777
    return;
  }
}
}
#line 1782 "bzip2.c"
void snocString_cil_lr_1(Cell **__cil_ap_root , Char **__cil_ap_name , Cell **__cil_ap_tmp___3 ) 
{ 
  int __cil_tmp4 ;
  Cell *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  struct zzzz **__cil_tmp8 ;
  struct zzzz *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  Cell *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  struct zzzz **__cil_tmp14 ;

  {
#line 1738
  __cil_tmp5 = *__cil_ap_tmp___3;
#line 1738
  __cil_tmp6 = (unsigned char *)__cil_tmp5;
#line 1738
  __cil_tmp7 = __cil_tmp6 + 8;
#line 1738
  __cil_tmp8 = (struct zzzz **)__cil_tmp7;
#line 1738
  __cil_tmp9 = *__cil_tmp8;
#line 1738
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 1738
  __cil_tmp4 = __cil_tmp10 != (unsigned long )((void *)0);
#line 1738
  if (__cil_tmp4 != 0) {
#line 1738
    __cil_tmp11 = *__cil_ap_tmp___3;
#line 1738
    __cil_tmp12 = (unsigned char *)__cil_tmp11;
#line 1738
    __cil_tmp13 = __cil_tmp12 + 8;
#line 1738
    __cil_tmp14 = (struct zzzz **)__cil_tmp13;
#line 1738
    *__cil_ap_tmp___3 = *__cil_tmp14;
#line 1741
    snocString_cil_lr_1(__cil_ap_root, __cil_ap_name, __cil_ap_tmp___3);
#line 1743
    return;
  } else {
#line 1745
    return;
  }
}
}
#line 1750 "bzip2.c"
void pad_cil_lr_1(Char *s , Int32 i ) 
{ 
  Int32 *__cil_gp_longestFileName ;
  struct _IO_FILE **__cil_gp_stderr ;
  size_t tmp___0_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp8 ;
  Int32 __cil_tmp9 ;
  Int32 __cil_tmp10 ;
  struct _IO_FILE *__cil_tmp11 ;

  {
#line 1752
  __cil_gp_stderr = & stderr;
#line 1752
  __cil_gp_longestFileName = & longestFileName;
#line 1752
  return babel_wrapper_pad_cil_lr_1(__cil_gp_longestFileName, __cil_gp_stderr, s,
                                    i);
#line 1752
  __cil_gp_longestFileName = & longestFileName;
#line 1753
  __cil_gp_stderr = & stderr;
#line 912
  tmp___0_ssa_1 = strlen((char const   *)s);
#line 912
  __cil_tmp9 = *__cil_gp_longestFileName;
#line 912
  __cil_tmp10 = __cil_tmp9 - (Int32 )tmp___0_ssa_1;
#line 912
  __cil_tmp8 = i <= __cil_tmp10;
#line 912
  if (__cil_tmp8 != 0) {
#line 913
    __cil_tmp11 = *__cil_gp_stderr;
#line 913
    fprintf((FILE * __restrict  )__cil_tmp11, (char const   * __restrict  )" ");
#line 912
    i_ssa_1 = i + 1;
#line 915
    pad_cil_lr_1(s, i_ssa_1);
#line 917
    return;
  } else {
#line 919
    return;
  }
}
}
#line 924 "bzip2.c"
void uInt64_toAscii_cil_lr_1(char **__cil_ap_outbuf , Int32 *__cil_ap_nBuf , UChar *buf ,
                             UInt64 n_copy ) 
{ 
  UInt64 *__cil_pp_n_copy ;
  Int32 q_ssa_1 ;
  Bool tmp_ssa_1 ;
  Int32 __cil_tmp10 ;
  Int32 __cil_tmp11 ;
  UChar *__cil_tmp12 ;
  Int32 __cil_tmp13 ;

  {
#line 927
  __cil_pp_n_copy = & n_copy;
#line 302
  q_ssa_1 = uInt64_qrm10(__cil_pp_n_copy);
#line 303
  __cil_tmp10 = q_ssa_1 + 48;
#line 303
  __cil_tmp11 = *__cil_ap_nBuf;
#line 303
  __cil_tmp12 = (UChar *)(buf + __cil_tmp11);
#line 303
  *__cil_tmp12 = (UChar )__cil_tmp10;
#line 304
  __cil_tmp13 = *__cil_ap_nBuf;
#line 304
  *__cil_ap_nBuf = __cil_tmp13 + 1;
#line 301
  tmp_ssa_1 = uInt64_isZero(__cil_pp_n_copy);
#line 301
  if (tmp_ssa_1 != 0) {
#line 302
    return;
  } else {
#line 305
    uInt64_toAscii_cil_lr_1(__cil_ap_outbuf, __cil_ap_nBuf, buf, n_copy);
#line 307
    return;
  }
}
}
#line 311 "bzip2.c"
void uInt64_toAscii_cil_lr_2(char *outbuf , Int32 i , UChar *buf , Int32 nBuf ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp6 ;
  Int32 __cil_tmp7 ;
  Int32 __cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar __cil_tmp10 ;
  char *__cil_tmp11 ;

  {

#line 307
  return babel_wrapper_uInt64_toAscii_cil_lr_2(outbuf, i, buf, nBuf);
#line 307
  __cil_tmp6 = i < nBuf;
#line 307
  if (__cil_tmp6 != 0) {
#line 308
    __cil_tmp7 = nBuf - i;
#line 308
    __cil_tmp8 = __cil_tmp7 - 1;
#line 308
    __cil_tmp9 = (UChar *)(buf + __cil_tmp8);
#line 308
    __cil_tmp10 = *__cil_tmp9;
#line 308
    __cil_tmp11 = outbuf + i;
#line 308
    *__cil_tmp11 = (char )__cil_tmp10;
#line 307
    i_ssa_1 = i + 1;
#line 310
    uInt64_toAscii_cil_lr_2(outbuf, i_ssa_1, buf, nBuf);
#line 312
    return;
  } else {
#line 314
    return;
  }
}
}
#line 319 "bzip2.c"
void uInt64_qrm10_cil_lr_1(UInt32 *__cil_ap_rem , UInt64 *n , Int32 i ) 
{ 
  UInt32 tmp_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp7 ;
  UInt32 __cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar *__cil_tmp10 ;
  UChar __cil_tmp11 ;
  UInt32 __cil_tmp12 ;
  UInt32 __cil_tmp13 ;
  UInt32 __cil_tmp14 ;
  UChar *__cil_tmp15 ;
  UChar *__cil_tmp16 ;
  UChar (*mem_16)[8] ;
  UChar (*mem_17)[8] ;

  {

#line 282
  return babel_wrapper_uInt64_qrm10_cil_lr_1(__cil_ap_rem, n, i);
#line 282
  __cil_tmp7 = i >= 0;
#line 282
  if (__cil_tmp7 != 0) {
#line 283
    __cil_tmp8 = *__cil_ap_rem;
#line 283
    mem_16 = (UChar (*)[8])n;
#line 283
    __cil_tmp9 = *mem_16;
#line 283
    __cil_tmp10 = __cil_tmp9 + i;
#line 283
    __cil_tmp11 = *__cil_tmp10;
#line 283
    __cil_tmp12 = __cil_tmp8 * 256U;
#line 283
    __cil_tmp13 = (UInt32 )__cil_tmp11;
#line 283
    tmp_ssa_1 = __cil_tmp12 + __cil_tmp13;
#line 284
    __cil_tmp14 = tmp_ssa_1 / 10U;
#line 284
    mem_17 = (UChar (*)[8])n;
#line 284
    __cil_tmp15 = *mem_17;
#line 284
    __cil_tmp16 = __cil_tmp15 + i;
#line 284
    *__cil_tmp16 = (UChar )__cil_tmp14;
#line 285
    *__cil_ap_rem = tmp_ssa_1 % 10U;
#line 282
    i_ssa_1 = i - 1;
#line 285
    uInt64_qrm10_cil_lr_1(__cil_ap_rem, n, i_ssa_1);
#line 287
    return;
  } else {
#line 289
    return;
  }
}
}
#line 294 "bzip2.c"
int uInt64_isZero_cil_lr_1(Bool *__cil_ap___cil_ret3 , UInt64 *n , Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int retflag4_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar *__cil_tmp10 ;
  UChar __cil_tmp11 ;
  int __cil_tmp12 ;
  UChar (*mem_12)[8] ;

  {

#line 269
  return babel_wrapper_uInt64_isZero_cil_lr_1(__cil_ap___cil_ret3, n, i);
#line 269
  __cil_tmp7 = i < 8;
#line 269
  if (__cil_tmp7 != 0) {
#line 270
    mem_12 = (UChar (*)[8])n;
#line 270
    __cil_tmp9 = *mem_12;
#line 270
    __cil_tmp10 = __cil_tmp9 + i;
#line 270
    __cil_tmp11 = *__cil_tmp10;
#line 270
    __cil_tmp12 = (int )__cil_tmp11;
#line 270
    __cil_tmp8 = __cil_tmp12 != 0;
#line 270
    if (__cil_tmp8 != 0) {
#line 270
      *__cil_ap___cil_ret3 = (Bool )0;
#line 272
      return (1);
    } else {
#line 269
      i_ssa_1 = i + 1;
#line 272
      retflag4_ssa_1 = uInt64_isZero_cil_lr_1(__cil_ap___cil_ret3, n, i_ssa_1);
#line 274
      return (retflag4_ssa_1);
    }
  } else {
#line 278
    return (0);
  }
}
}
#line 283 "bzip2.c"
void uInt64_to_double_cil_lr_1(double *__cil_ap_sum , UInt64 *n , Int32 i , double base ) 
{ 
  double base_ssa_1 ;
  Int32 i_ssa_1 ;
  int __cil_tmp7 ;
  UChar *__cil_tmp8 ;
  UChar *__cil_tmp9 ;
  UChar __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  UChar (*mem_14)[8] ;

  {

#line 257
  return babel_wrapper_uInt64_to_double_cil_lr_1(__cil_ap_sum, n, i, base);
#line 257
  __cil_tmp7 = i < 8;
#line 257
  if (__cil_tmp7 != 0) {
#line 258
    mem_14 = (UChar (*)[8])n;
#line 258
    __cil_tmp8 = *mem_14;
#line 258
    __cil_tmp9 = __cil_tmp8 + i;
#line 258
    __cil_tmp10 = *__cil_tmp9;
#line 258
    __cil_tmp11 = (double )__cil_tmp10;
#line 258
    __cil_tmp12 = *__cil_ap_sum;
#line 258
    __cil_tmp13 = base * __cil_tmp11;
#line 258
    *__cil_ap_sum = __cil_tmp12 + __cil_tmp13;
#line 259
    base_ssa_1 = base * 256.0;
#line 257
    i_ssa_1 = i + 1;
#line 260
    uInt64_to_double_cil_lr_1(__cil_ap_sum, n, i_ssa_1, base_ssa_1);
#line 262
    return;
  } else {
#line 264
    return;
  }
}
}
#include <gprolog.h>

PlBool babel_ptrR(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

		return PL_TRUE;
}

PlBool babel_ptrR_byte(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

	return PL_TRUE;
}

PlBool babel_ptrE(PlLong* p,  PlLong e, PlLong len)
{
	if (p == 0)
	    return PL_FALSE;

	switch(len)
		{
		    case 1:
		    	*(unsigned char*)p = (unsigned char)e;
		    	break;
		    case 2:
		    	*(short*) p = (short)e;
		    	break;
		    case 4:
		    	*(int*)p = (int)e;
		    	break;
		    case 8:
		    	*(long long*)p = (long long)e;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrL\n");
		}

        return PL_TRUE;
}

PlBool babel_ptrFR(double* fp, PlLong ptr, PlLong len)
{
  if(len == 2)
  *(double *)fp = *(double *)ptr;
   else if (len == 1)
  *(float *)fp = *(float *)ptr;
  else
  return PL_FALSE;

  return PL_TRUE;
}

PlBool babel_ptrFW(PlLong ptr, double f, PlLong len)
{
  if (len == 2)
  *(double *)ptr = f;
   else if (len == 1)
  *(float *)ptr = f;
  else
  return PL_FALSE;
  
  return PL_TRUE;
}

PlBool babel__implicit_uInt64_to_doublec_0(double * arg_0, UInt64 * arg_1, Int32  arg_2, double  arg_3) 
{
uInt64_to_double_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_uInt64_isZeroc_1(Bool * arg_0, UInt64 * arg_1, Int32  arg_2, PlLong * babel_ret) 
{
*babel_ret = uInt64_isZero_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_uInt64_qrm10c_2(UInt32 * arg_0, UInt64 * arg_1, Int32  arg_2) 
{
uInt64_qrm10_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_myfeofc_3(FILE * arg_0, PlLong * babel_ret) 
{
*babel_ret = fgetc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_myfeofc_4(Int32  arg_0, FILE * arg_1) 
{
ungetc(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_cadvisec_5(FILE * __restrict   arg_0, char const   * __restrict   arg_1) 
{
fprintf(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_showFileNamesc_6(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2, Char * arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_7(char const   * __restrict   arg_0, struct stat * __restrict   arg_1, PlLong * babel_ret) 
{
*babel_ret = stat(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_8(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2, Char * arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_9(FILE * arg_0) 
{
fclose(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_10(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = remove(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_11(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_12(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_13(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_14(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2, Char * arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_15(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_16(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2, Char * arg_3, Int32  arg_4, Int32  arg_5) 
{
fprintf(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_17(Int32  arg_0) 
{
setExit(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_cleanUpAndFailc_18(Int32  arg_0) 
{
exit(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_panicc_19(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2, Char const   * arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_panicc_20(int dumy) 
{
showFileNames();
return PL_TRUE;
}
PlBool babel__implicit_panicc_21(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_crcErrorc_22(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_crcErrorc_23(int dumy) 
{
showFileNames();
return PL_TRUE;
}
PlBool babel__implicit_crcErrorc_24(int dumy) 
{
cadvise();
return PL_TRUE;
}
PlBool babel__implicit_crcErrorc_25(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_compressedStreamEOFc_26(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_compressedStreamEOFc_27(char const   * arg_0) 
{
perror(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_compressedStreamEOFc_28(int dumy) 
{
showFileNames();
return PL_TRUE;
}
PlBool babel__implicit_compressedStreamEOFc_29(int dumy) 
{
cadvise();
return PL_TRUE;
}
PlBool babel__implicit_compressedStreamEOFc_30(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_ioErrorc_31(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_ioErrorc_32(char const   * arg_0) 
{
perror(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_ioErrorc_33(int dumy) 
{
showFileNames();
return PL_TRUE;
}
PlBool babel__implicit_ioErrorc_34(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_mySignalCatcherc_35(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_mySignalCatcherc_36(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_mySIGSEGVorSIGBUScatcherc_37(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_mySIGSEGVorSIGBUScatcherc_38(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_mySIGSEGVorSIGBUScatcherc_39(int dumy) 
{
showFileNames();
return PL_TRUE;
}
PlBool babel__implicit_mySIGSEGVorSIGBUScatcherc_40(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_mySIGSEGVorSIGBUScatcherc_41(int dumy) 
{
cadvise();
return PL_TRUE;
}
PlBool babel__implicit_mySIGSEGVorSIGBUScatcherc_42(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_outOfMemoryc_43(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_outOfMemoryc_44(int dumy) 
{
showFileNames();
return PL_TRUE;
}
PlBool babel__implicit_outOfMemoryc_45(int arg_0) 
{
cleanUpAndFail(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_configErrorc_46(FILE * __restrict   arg_0, char const   * __restrict   arg_1) 
{
fprintf(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_configErrorc_47(int arg_0) 
{
setExit(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_configErrorc_48(Int32  arg_0) 
{
exit(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_padc_49(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_padc_50(Char * arg_0, Int32  arg_1) 
{
pad_cil_lr_1(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_copyFileNamec_51(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copyFileNamec_52(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2, int arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_copyFileNamec_53(int arg_0) 
{
setExit(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copyFileNamec_54(Int32  arg_0) 
{
exit(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copyFileNamec_55(char * __restrict   arg_0, char const   * __restrict   arg_1, size_t  arg_2) 
{
strncpy(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_fileExistsc_56(char const   * __restrict   arg_0, char const   * __restrict   arg_1, PlLong * babel_ret) 
{
*babel_ret = fopen(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_fileExistsc_57(FILE * arg_0) 
{
fclose(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_fopen_output_safelyc_58(char const   * arg_0, int arg_1, int arg_2, PlLong * babel_ret) 
{
*babel_ret = open(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_fopen_output_safelyc_59(IntNative  arg_0, char const   * arg_1, PlLong * babel_ret) 
{
*babel_ret = fdopen(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_fopen_output_safelyc_60(IntNative  arg_0) 
{
close(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_notAStandardFilec_61(char const   * __restrict   arg_0, struct stat * __restrict   arg_1, PlLong * babel_ret) 
{
*babel_ret = lstat(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_countHardLinksc_62(char const   * __restrict   arg_0, struct stat * __restrict   arg_1, PlLong * babel_ret) 
{
*babel_ret = lstat(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_saveInputFileMetaInfoc_63(char const   * __restrict   arg_0, struct stat * __restrict   arg_1, PlLong * babel_ret) 
{
*babel_ret = stat(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_saveInputFileMetaInfoc_64(int dumy) 
{
ioError();
return PL_TRUE;
}
PlBool babel__implicit_applySavedTimeInfoToOutputFilec_65(char const   * arg_0, struct utimbuf  const  * arg_1, PlLong * babel_ret) 
{
*babel_ret = utime(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_applySavedTimeInfoToOutputFilec_66(int dumy) 
{
ioError();
return PL_TRUE;
}
PlBool babel__implicit_applySavedFileAttrToOutputFilec_67(IntNative  arg_0, __mode_t  arg_1, PlLong * babel_ret) 
{
*babel_ret = fchmod(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_applySavedFileAttrToOutputFilec_68(int dumy) 
{
ioError();
return PL_TRUE;
}
PlBool babel__implicit_applySavedFileAttrToOutputFilec_69(IntNative  arg_0, __uid_t  arg_1, __gid_t  arg_2) 
{
fchown(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_hasSuffixc_70(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_hasSuffixc_71(Char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_hasSuffixc_72(char const   * arg_0, Char const   * arg_1, PlLong * babel_ret) 
{
*babel_ret = strcmp(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_mapSuffixc_73(Char * arg_0, Char const   * arg_1, PlLong * babel_ret) 
{
*babel_ret = hasSuffix(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_mapSuffixc_74(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_mapSuffixc_75(Char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_mapSuffixc_76(char * __restrict   arg_0, char const   * __restrict   arg_1) 
{
strcat(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_licensec_77(PlLong * babel_ret) 
{
*babel_ret = BZ2_bzlibVersion();
return PL_TRUE;
}
PlBool babel__implicit_licensec_78(FILE * __restrict   arg_0, char const   * __restrict   arg_1, char const   * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_usagec_79(PlLong * babel_ret) 
{
*babel_ret = BZ2_bzlibVersion();
return PL_TRUE;
}
PlBool babel__implicit_usagec_80(FILE * __restrict   arg_0, char const   * __restrict   arg_1, char const   * arg_2, Char * arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_redundantc_81(FILE * __restrict   arg_0, char const   * __restrict   arg_1, Char * arg_2, Char * arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_myMallocc_82(size_t  arg_0, PlLong * babel_ret) 
{
*babel_ret = malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_myMallocc_83(int dumy) 
{
outOfMemory();
return PL_TRUE;
}
PlBool babel__implicit_mkCellc_84(Int32  arg_0, PlLong * babel_ret) 
{
*babel_ret = myMalloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_addFlagsFromEnvVarc_85(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = getenv(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_addFlagsFromEnvVarc_86(Cell ** arg_0, Int32  arg_1, Char * arg_2) 
{
addFlagsFromEnvVar_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_addFlagsFromEnvVar_cil_lr_1_cil_lr_1c_87(PlLong * babel_ret) 
{
*babel_ret = __ctype_b_loc();
return PL_TRUE;
}
PlBool babel__implicit_addFlagsFromEnvVar_cil_lr_1_cil_lr_2c_89(PlLong * babel_ret) 
{
*babel_ret = __ctype_b_loc();
return PL_TRUE;
}
PlBool babel__implicit_pad_cil_lr_1c_92(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_pad_cil_lr_1c_93(FILE * __restrict   arg_0, char const   * __restrict   arg_1) 
{
fprintf(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_pad_cil_lr_1c_94(Char * arg_0, Int32  arg_1) 
{
pad_cil_lr_1(arg_0, arg_1);
return PL_TRUE;
}


PlBool babel__implicit_uInt64_toAsciic_0(char ** arg_0, Int32 * arg_1, UChar * arg_2, UInt64  arg_3) 
{
uInt64_toAscii_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_uInt64_toAsciic_1(char * arg_0, Int32  arg_1, UChar * arg_2, Int32  arg_3) 
{
uInt64_toAscii_cil_lr_2(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
