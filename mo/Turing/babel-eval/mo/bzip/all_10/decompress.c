/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 48 "bzlib.h"
struct __anonstruct_bz_stream_26 {
   char *next_in ;
   unsigned int avail_in ;
   unsigned int total_in_lo32 ;
   unsigned int total_in_hi32 ;
   char *next_out ;
   unsigned int avail_out ;
   unsigned int total_out_lo32 ;
   unsigned int total_out_hi32 ;
   void *state ;
   void *(*bzalloc)(void * , int  , int  ) ;
   void (*bzfree)(void * , void * ) ;
   void *opaque ;
};
#line 48 "bzlib.h"
typedef struct __anonstruct_bz_stream_26 bz_stream;
#line 42 "bzlib_private.h"
typedef unsigned char Bool;
#line 43 "bzlib_private.h"
typedef unsigned char UChar;
#line 44 "bzlib_private.h"
typedef int Int32;
#line 45 "bzlib_private.h"
typedef unsigned int UInt32;
#line 47 "bzlib_private.h"
typedef unsigned short UInt16;
#line 347 "bzlib_private.h"
struct __anonstruct_DState_28 {
   bz_stream *strm ;
   Int32 state ;
   UChar state_out_ch ;
   Int32 state_out_len ;
   Bool blockRandomised ;
   Int32 rNToGo ;
   Int32 rTPos ;
   UInt32 bsBuff ;
   Int32 bsLive ;
   Int32 blockSize100k ;
   Bool smallDecompress ;
   Int32 currBlockNo ;
   Int32 verbosity ;
   Int32 origPtr ;
   UInt32 tPos ;
   Int32 k0 ;
   Int32 unzftab[256] ;
   Int32 nblock_used ;
   Int32 cftab[257] ;
   Int32 cftabCopy[257] ;
   UInt32 *tt ;
   UInt16 *ll16 ;
   UChar *ll4 ;
   UInt32 storedBlockCRC ;
   UInt32 storedCombinedCRC ;
   UInt32 calculatedBlockCRC ;
   UInt32 calculatedCombinedCRC ;
   Int32 nInUse ;
   Bool inUse[256] ;
   Bool inUse16[16] ;
   UChar seqToUnseq[256] ;
   UChar mtfa[4096] ;
   Int32 mtfbase[16] ;
   UChar selector[18002] ;
   UChar selectorMtf[18002] ;
   UChar len[6][258] ;
   Int32 limit[6][258] ;
   Int32 base[6][258] ;
   Int32 perm[6][258] ;
   Int32 minLens[6] ;
   Int32 save_i ;
   Int32 save_j ;
   Int32 save_t ;
   Int32 save_alphaSize ;
   Int32 save_nGroups ;
   Int32 save_nSelectors ;
   Int32 save_EOB ;
   Int32 save_groupNo ;
   Int32 save_groupPos ;
   Int32 save_nextSym ;
   Int32 save_nblockMAX ;
   Int32 save_nblock ;
   Int32 save_es ;
   Int32 save_N ;
   Int32 save_curr ;
   Int32 save_zt ;
   Int32 save_zn ;
   Int32 save_zvec ;
   Int32 save_zj ;
   Int32 save_gSel ;
   Int32 save_gMinlen ;
   Int32 *save_gLimit ;
   Int32 *save_gBase ;
   Int32 *save_gPerm ;
};
#line 347 "bzlib_private.h"
typedef struct __anonstruct_DState_28 DState;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 58 "bzlib_private.h"
extern void BZ2_bz__AssertH__fail(int errcode ) ;
#line 131
extern Int32 BZ2_rNums[512] ;
#line 484
extern Int32 BZ2_indexIntoF(Int32  , Int32 * ) ;
#line 487
Int32 BZ2_decompress(DState *s ) ;
#line 490
extern void BZ2_hbCreateDecodeTables(Int32 * , Int32 * , Int32 * , UChar * , Int32  ,
                                     Int32  , Int32  ) ;
void makeMaps_d_cil_lr_1(DState *s , Int32 i ) ;
#line 26 "decompress.c"
static void makeMaps_d(DState *s ) 
{ 
  Int32 i_ssa_1 ;
  unsigned char *__cil_tmp4 ;
  Int32 *__cil_tmp5 ;

  {
  {
#line 30
  __cil_tmp4 = (unsigned char *)s + 3192;
#line 30
  __cil_tmp5 = (Int32 *)__cil_tmp4;
#line 30
  *__cil_tmp5 = 0;
#line 31
  i_ssa_1 = 0;
  }
  {
#line 31
  makeMaps_d_cil_lr_1(s, i_ssa_1);
  }
#line 36
  return;
}
}
#line 106 "decompress.c"
Int32 BZ2_decompress(DState *s ) 
{ 
  UChar uc ;
  Int32 retVal ;
  Int32 minLen ;
  Int32 maxLen ;
  bz_stream *strm ;
  Int32 i ;
  Int32 j ;
  Int32 t ;
  Int32 alphaSize ;
  Int32 nGroups ;
  Int32 nSelectors ;
  Int32 EOB ;
  Int32 groupNo ;
  Int32 groupPos ;
  Int32 nextSym ;
  Int32 nblockMAX ;
  Int32 nblock ;
  Int32 es ;
  Int32 N ;
  Int32 curr ;
  Int32 zt ;
  Int32 zn ;
  Int32 zvec ;
  Int32 zj ;
  Int32 gSel ;
  Int32 gMinlen ;
  Int32 *gLimit ;
  Int32 *gBase ;
  Int32 *gPerm ;
  UInt32 v ;
  UInt32 v___0 ;
  UInt32 v___1 ;
  UInt32 v___2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  UInt32 v___3 ;
  UInt32 v___4 ;
  UInt32 v___5 ;
  UInt32 v___6 ;
  UInt32 v___7 ;
  UInt32 v___8 ;
  UInt32 v___9 ;
  UInt32 v___10 ;
  UInt32 v___11 ;
  UInt32 v___12 ;
  UInt32 v___13 ;
  UInt32 v___14 ;
  UInt32 v___15 ;
  UInt32 v___16 ;
  UInt32 v___17 ;
  UInt32 v___18 ;
  UInt32 v___19 ;
  UInt32 v___20 ;
  UInt32 v___21 ;
  UChar pos[6] ;
  UChar tmp___2 ;
  UChar v___22 ;
  UInt32 v___23 ;
  UInt32 v___24 ;
  UInt32 v___25 ;
  Int32 ii ;
  Int32 jj ;
  Int32 kk ;
  UInt32 v___26 ;
  UInt32 v___27 ;
  UInt32 v___28 ;
  UInt32 v___29 ;
  Int32 ii___0 ;
  Int32 jj___0 ;
  Int32 kk___0 ;
  Int32 pp ;
  Int32 lno ;
  Int32 off ;
  UInt32 nn ;
  Int32 z ;
  UInt32 v___30 ;
  UInt32 v___31 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  UInt32 v___32 ;
  UInt32 v___33 ;
  UInt32 v___34 ;
  UInt32 v___35 ;
  UInt32 v___36 ;
  UInt32 v___37 ;
  UInt32 v___38 ;
  UInt32 v___39 ;
  UInt32 v___40 ;

  {
#line 111
  strm = s->strm;
#line 139
  if (s->state == 10) {
#line 141
    s->save_i = 0;
#line 142
    s->save_j = 0;
#line 143
    s->save_t = 0;
#line 144
    s->save_alphaSize = 0;
#line 145
    s->save_nGroups = 0;
#line 146
    s->save_nSelectors = 0;
#line 147
    s->save_EOB = 0;
#line 148
    s->save_groupNo = 0;
#line 149
    s->save_groupPos = 0;
#line 150
    s->save_nextSym = 0;
#line 151
    s->save_nblockMAX = 0;
#line 152
    s->save_nblock = 0;
#line 153
    s->save_es = 0;
#line 154
    s->save_N = 0;
#line 155
    s->save_curr = 0;
#line 156
    s->save_zt = 0;
#line 157
    s->save_zn = 0;
#line 158
    s->save_zvec = 0;
#line 159
    s->save_zj = 0;
#line 160
    s->save_gSel = 0;
#line 161
    s->save_gMinlen = 0;
#line 162
    s->save_gLimit = (Int32 *)((void *)0);
#line 163
    s->save_gBase = (Int32 *)((void *)0);
#line 164
    s->save_gPerm = (Int32 *)((void *)0);
  }
#line 168
  i = s->save_i;
#line 169
  j = s->save_j;
#line 170
  t = s->save_t;
#line 171
  alphaSize = s->save_alphaSize;
#line 172
  nGroups = s->save_nGroups;
#line 173
  nSelectors = s->save_nSelectors;
#line 174
  EOB = s->save_EOB;
#line 175
  groupNo = s->save_groupNo;
#line 176
  groupPos = s->save_groupPos;
#line 177
  nextSym = s->save_nextSym;
#line 178
  nblockMAX = s->save_nblockMAX;
#line 179
  nblock = s->save_nblock;
#line 180
  es = s->save_es;
#line 181
  N = s->save_N;
#line 182
  curr = s->save_curr;
#line 183
  zt = s->save_zt;
#line 184
  zn = s->save_zn;
#line 185
  zvec = s->save_zvec;
#line 186
  zj = s->save_zj;
#line 187
  gSel = s->save_gSel;
#line 188
  gMinlen = s->save_gMinlen;
#line 189
  gLimit = s->save_gLimit;
#line 190
  gBase = s->save_gBase;
#line 191
  gPerm = s->save_gPerm;
#line 193
  retVal = 0;
#line 195
  switch (s->state) {
  case 10: 
#line 197
  s->state = 10;
#line 197
  while (1) {
#line 197
    if (s->bsLive >= 8) {
#line 197
      v = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 197
      s->bsLive -= 8;
#line 197
      uc = (UChar )v;
#line 197
      break;
    }
#line 197
    if ((s->strm)->avail_in == 0U) {
#line 197
      retVal = 0;
#line 197
      goto save_state_and_return;
    }
#line 197
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 197
    s->bsLive += 8;
#line 197
    ((s->strm)->next_in) ++;
#line 197
    ((s->strm)->avail_in) --;
#line 197
    ((s->strm)->total_in_lo32) ++;
#line 197
    if ((s->strm)->total_in_lo32 == 0U) {
#line 197
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 198
  if ((int )uc != 66) {
#line 198
    retVal = -5;
#line 198
    goto save_state_and_return;
  }
  case 11: 
#line 200
  s->state = 11;
#line 200
  while (1) {
#line 200
    if (s->bsLive >= 8) {
#line 200
      v___0 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 200
      s->bsLive -= 8;
#line 200
      uc = (UChar )v___0;
#line 200
      break;
    }
#line 200
    if ((s->strm)->avail_in == 0U) {
#line 200
      retVal = 0;
#line 200
      goto save_state_and_return;
    }
#line 200
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 200
    s->bsLive += 8;
#line 200
    ((s->strm)->next_in) ++;
#line 200
    ((s->strm)->avail_in) --;
#line 200
    ((s->strm)->total_in_lo32) ++;
#line 200
    if ((s->strm)->total_in_lo32 == 0U) {
#line 200
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 201
  if ((int )uc != 90) {
#line 201
    retVal = -5;
#line 201
    goto save_state_and_return;
  }
  case 12: 
#line 203
  s->state = 12;
#line 203
  while (1) {
#line 203
    if (s->bsLive >= 8) {
#line 203
      v___1 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 203
      s->bsLive -= 8;
#line 203
      uc = (UChar )v___1;
#line 203
      break;
    }
#line 203
    if ((s->strm)->avail_in == 0U) {
#line 203
      retVal = 0;
#line 203
      goto save_state_and_return;
    }
#line 203
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 203
    s->bsLive += 8;
#line 203
    ((s->strm)->next_in) ++;
#line 203
    ((s->strm)->avail_in) --;
#line 203
    ((s->strm)->total_in_lo32) ++;
#line 203
    if ((s->strm)->total_in_lo32 == 0U) {
#line 203
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 204
  if ((int )uc != 104) {
#line 204
    retVal = -5;
#line 204
    goto save_state_and_return;
  }
  case 13: 
#line 206
  s->state = 13;
#line 206
  while (1) {
#line 206
    if (s->bsLive >= 8) {
#line 206
      v___2 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 206
      s->bsLive -= 8;
#line 206
      s->blockSize100k = (Int32 )v___2;
#line 206
      break;
    }
#line 206
    if ((s->strm)->avail_in == 0U) {
#line 206
      retVal = 0;
#line 206
      goto save_state_and_return;
    }
#line 206
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 206
    s->bsLive += 8;
#line 206
    ((s->strm)->next_in) ++;
#line 206
    ((s->strm)->avail_in) --;
#line 206
    ((s->strm)->total_in_lo32) ++;
#line 206
    if ((s->strm)->total_in_lo32 == 0U) {
#line 206
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 207
  if (s->blockSize100k < 49) {
#line 208
    retVal = -5;
#line 208
    goto save_state_and_return;
  } else
#line 207
  if (s->blockSize100k > 57) {
#line 208
    retVal = -5;
#line 208
    goto save_state_and_return;
  }
#line 209
  s->blockSize100k -= 48;
#line 211
  if (s->smallDecompress) {
#line 212
    tmp = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(UInt16 )),
                             1);
#line 212
    s->ll16 = (UInt16 *)tmp;
#line 213
    tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar )),
                                 1);
#line 213
    s->ll4 = (UChar *)tmp___0;
#line 216
    if ((unsigned long )s->ll16 == (unsigned long )((void *)0)) {
#line 216
      retVal = -3;
#line 216
      goto save_state_and_return;
    } else
#line 216
    if ((unsigned long )s->ll4 == (unsigned long )((void *)0)) {
#line 216
      retVal = -3;
#line 216
      goto save_state_and_return;
    }
  } else {
#line 218
    tmp___1 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(Int32 )),
                                 1);
#line 218
    s->tt = (UInt32 *)tmp___1;
#line 219
    if ((unsigned long )s->tt == (unsigned long )((void *)0)) {
#line 219
      retVal = -3;
#line 219
      goto save_state_and_return;
    }
  }
  case 14: 
#line 222
  s->state = 14;
#line 222
  while (1) {
#line 222
    if (s->bsLive >= 8) {
#line 222
      v___3 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 222
      s->bsLive -= 8;
#line 222
      uc = (UChar )v___3;
#line 222
      break;
    }
#line 222
    if ((s->strm)->avail_in == 0U) {
#line 222
      retVal = 0;
#line 222
      goto save_state_and_return;
    }
#line 222
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 222
    s->bsLive += 8;
#line 222
    ((s->strm)->next_in) ++;
#line 222
    ((s->strm)->avail_in) --;
#line 222
    ((s->strm)->total_in_lo32) ++;
#line 222
    if ((s->strm)->total_in_lo32 == 0U) {
#line 222
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 224
  if ((int )uc == 23) {
#line 224
    goto endhdr_2;
  }
#line 225
  if ((int )uc != 49) {
#line 225
    retVal = -4;
#line 225
    goto save_state_and_return;
  }
  case 15: 
#line 226
  s->state = 15;
#line 226
  while (1) {
#line 226
    if (s->bsLive >= 8) {
#line 226
      v___4 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 226
      s->bsLive -= 8;
#line 226
      uc = (UChar )v___4;
#line 226
      break;
    }
#line 226
    if ((s->strm)->avail_in == 0U) {
#line 226
      retVal = 0;
#line 226
      goto save_state_and_return;
    }
#line 226
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 226
    s->bsLive += 8;
#line 226
    ((s->strm)->next_in) ++;
#line 226
    ((s->strm)->avail_in) --;
#line 226
    ((s->strm)->total_in_lo32) ++;
#line 226
    if ((s->strm)->total_in_lo32 == 0U) {
#line 226
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 227
  if ((int )uc != 65) {
#line 227
    retVal = -4;
#line 227
    goto save_state_and_return;
  }
  case 16: 
#line 228
  s->state = 16;
#line 228
  while (1) {
#line 228
    if (s->bsLive >= 8) {
#line 228
      v___5 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 228
      s->bsLive -= 8;
#line 228
      uc = (UChar )v___5;
#line 228
      break;
    }
#line 228
    if ((s->strm)->avail_in == 0U) {
#line 228
      retVal = 0;
#line 228
      goto save_state_and_return;
    }
#line 228
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 228
    s->bsLive += 8;
#line 228
    ((s->strm)->next_in) ++;
#line 228
    ((s->strm)->avail_in) --;
#line 228
    ((s->strm)->total_in_lo32) ++;
#line 228
    if ((s->strm)->total_in_lo32 == 0U) {
#line 228
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 229
  if ((int )uc != 89) {
#line 229
    retVal = -4;
#line 229
    goto save_state_and_return;
  }
  case 17: 
#line 230
  s->state = 17;
#line 230
  while (1) {
#line 230
    if (s->bsLive >= 8) {
#line 230
      v___6 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 230
      s->bsLive -= 8;
#line 230
      uc = (UChar )v___6;
#line 230
      break;
    }
#line 230
    if ((s->strm)->avail_in == 0U) {
#line 230
      retVal = 0;
#line 230
      goto save_state_and_return;
    }
#line 230
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 230
    s->bsLive += 8;
#line 230
    ((s->strm)->next_in) ++;
#line 230
    ((s->strm)->avail_in) --;
#line 230
    ((s->strm)->total_in_lo32) ++;
#line 230
    if ((s->strm)->total_in_lo32 == 0U) {
#line 230
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 231
  if ((int )uc != 38) {
#line 231
    retVal = -4;
#line 231
    goto save_state_and_return;
  }
  case 18: 
#line 232
  s->state = 18;
#line 232
  while (1) {
#line 232
    if (s->bsLive >= 8) {
#line 232
      v___7 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 232
      s->bsLive -= 8;
#line 232
      uc = (UChar )v___7;
#line 232
      break;
    }
#line 232
    if ((s->strm)->avail_in == 0U) {
#line 232
      retVal = 0;
#line 232
      goto save_state_and_return;
    }
#line 232
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 232
    s->bsLive += 8;
#line 232
    ((s->strm)->next_in) ++;
#line 232
    ((s->strm)->avail_in) --;
#line 232
    ((s->strm)->total_in_lo32) ++;
#line 232
    if ((s->strm)->total_in_lo32 == 0U) {
#line 232
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 233
  if ((int )uc != 83) {
#line 233
    retVal = -4;
#line 233
    goto save_state_and_return;
  }
  case 19: 
#line 234
  s->state = 19;
#line 234
  while (1) {
#line 234
    if (s->bsLive >= 8) {
#line 234
      v___8 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 234
      s->bsLive -= 8;
#line 234
      uc = (UChar )v___8;
#line 234
      break;
    }
#line 234
    if ((s->strm)->avail_in == 0U) {
#line 234
      retVal = 0;
#line 234
      goto save_state_and_return;
    }
#line 234
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 234
    s->bsLive += 8;
#line 234
    ((s->strm)->next_in) ++;
#line 234
    ((s->strm)->avail_in) --;
#line 234
    ((s->strm)->total_in_lo32) ++;
#line 234
    if ((s->strm)->total_in_lo32 == 0U) {
#line 234
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 235
  if ((int )uc != 89) {
#line 235
    retVal = -4;
#line 235
    goto save_state_and_return;
  }
#line 237
  (s->currBlockNo) ++;
#line 238
  if (s->verbosity >= 2) {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    [%d: huff+mtf ",
            s->currBlockNo);
  }
#line 241
  s->storedBlockCRC = (UInt32 )0;
  case 20: 
#line 242
  s->state = 20;
#line 242
  while (1) {
#line 242
    if (s->bsLive >= 8) {
#line 242
      v___9 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 242
      s->bsLive -= 8;
#line 242
      uc = (UChar )v___9;
#line 242
      break;
    }
#line 242
    if ((s->strm)->avail_in == 0U) {
#line 242
      retVal = 0;
#line 242
      goto save_state_and_return;
    }
#line 242
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 242
    s->bsLive += 8;
#line 242
    ((s->strm)->next_in) ++;
#line 242
    ((s->strm)->avail_in) --;
#line 242
    ((s->strm)->total_in_lo32) ++;
#line 242
    if ((s->strm)->total_in_lo32 == 0U) {
#line 242
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 243
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 21: 
#line 244
  s->state = 21;
#line 244
  while (1) {
#line 244
    if (s->bsLive >= 8) {
#line 244
      v___10 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 244
      s->bsLive -= 8;
#line 244
      uc = (UChar )v___10;
#line 244
      break;
    }
#line 244
    if ((s->strm)->avail_in == 0U) {
#line 244
      retVal = 0;
#line 244
      goto save_state_and_return;
    }
#line 244
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 244
    s->bsLive += 8;
#line 244
    ((s->strm)->next_in) ++;
#line 244
    ((s->strm)->avail_in) --;
#line 244
    ((s->strm)->total_in_lo32) ++;
#line 244
    if ((s->strm)->total_in_lo32 == 0U) {
#line 244
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 245
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 22: 
#line 246
  s->state = 22;
#line 246
  while (1) {
#line 246
    if (s->bsLive >= 8) {
#line 246
      v___11 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 246
      s->bsLive -= 8;
#line 246
      uc = (UChar )v___11;
#line 246
      break;
    }
#line 246
    if ((s->strm)->avail_in == 0U) {
#line 246
      retVal = 0;
#line 246
      goto save_state_and_return;
    }
#line 246
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 246
    s->bsLive += 8;
#line 246
    ((s->strm)->next_in) ++;
#line 246
    ((s->strm)->avail_in) --;
#line 246
    ((s->strm)->total_in_lo32) ++;
#line 246
    if ((s->strm)->total_in_lo32 == 0U) {
#line 246
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 247
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 23: 
#line 248
  s->state = 23;
#line 248
  while (1) {
#line 248
    if (s->bsLive >= 8) {
#line 248
      v___12 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 248
      s->bsLive -= 8;
#line 248
      uc = (UChar )v___12;
#line 248
      break;
    }
#line 248
    if ((s->strm)->avail_in == 0U) {
#line 248
      retVal = 0;
#line 248
      goto save_state_and_return;
    }
#line 248
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 248
    s->bsLive += 8;
#line 248
    ((s->strm)->next_in) ++;
#line 248
    ((s->strm)->avail_in) --;
#line 248
    ((s->strm)->total_in_lo32) ++;
#line 248
    if ((s->strm)->total_in_lo32 == 0U) {
#line 248
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 249
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 24: 
#line 251
  s->state = 24;
#line 251
  while (1) {
#line 251
    if (s->bsLive >= 1) {
#line 251
      v___13 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 251
      (s->bsLive) --;
#line 251
      s->blockRandomised = (Bool )v___13;
#line 251
      break;
    }
#line 251
    if ((s->strm)->avail_in == 0U) {
#line 251
      retVal = 0;
#line 251
      goto save_state_and_return;
    }
#line 251
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 251
    s->bsLive += 8;
#line 251
    ((s->strm)->next_in) ++;
#line 251
    ((s->strm)->avail_in) --;
#line 251
    ((s->strm)->total_in_lo32) ++;
#line 251
    if ((s->strm)->total_in_lo32 == 0U) {
#line 251
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 253
  s->origPtr = 0;
  case 25: 
#line 254
  s->state = 25;
#line 254
  while (1) {
#line 254
    if (s->bsLive >= 8) {
#line 254
      v___14 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 254
      s->bsLive -= 8;
#line 254
      uc = (UChar )v___14;
#line 254
      break;
    }
#line 254
    if ((s->strm)->avail_in == 0U) {
#line 254
      retVal = 0;
#line 254
      goto save_state_and_return;
    }
#line 254
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 254
    s->bsLive += 8;
#line 254
    ((s->strm)->next_in) ++;
#line 254
    ((s->strm)->avail_in) --;
#line 254
    ((s->strm)->total_in_lo32) ++;
#line 254
    if ((s->strm)->total_in_lo32 == 0U) {
#line 254
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 255
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case 26: 
#line 256
  s->state = 26;
#line 256
  while (1) {
#line 256
    if (s->bsLive >= 8) {
#line 256
      v___15 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 256
      s->bsLive -= 8;
#line 256
      uc = (UChar )v___15;
#line 256
      break;
    }
#line 256
    if ((s->strm)->avail_in == 0U) {
#line 256
      retVal = 0;
#line 256
      goto save_state_and_return;
    }
#line 256
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 256
    s->bsLive += 8;
#line 256
    ((s->strm)->next_in) ++;
#line 256
    ((s->strm)->avail_in) --;
#line 256
    ((s->strm)->total_in_lo32) ++;
#line 256
    if ((s->strm)->total_in_lo32 == 0U) {
#line 256
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 257
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case 27: 
#line 258
  s->state = 27;
#line 258
  while (1) {
#line 258
    if (s->bsLive >= 8) {
#line 258
      v___16 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 258
      s->bsLive -= 8;
#line 258
      uc = (UChar )v___16;
#line 258
      break;
    }
#line 258
    if ((s->strm)->avail_in == 0U) {
#line 258
      retVal = 0;
#line 258
      goto save_state_and_return;
    }
#line 258
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 258
    s->bsLive += 8;
#line 258
    ((s->strm)->next_in) ++;
#line 258
    ((s->strm)->avail_in) --;
#line 258
    ((s->strm)->total_in_lo32) ++;
#line 258
    if ((s->strm)->total_in_lo32 == 0U) {
#line 258
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 259
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
#line 261
  if (s->origPtr < 0) {
#line 262
    retVal = -4;
#line 262
    goto save_state_and_return;
  }
#line 263
  if (s->origPtr > 10 + 100000 * s->blockSize100k) {
#line 264
    retVal = -4;
#line 264
    goto save_state_and_return;
  }
#line 267
  i = 0;
#line 267
  while (i < 16) {
    case 28: 
#line 268
    s->state = 28;
#line 268
    while (1) {
#line 268
      if (s->bsLive >= 1) {
#line 268
        v___17 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 268
        (s->bsLive) --;
#line 268
        uc = (UChar )v___17;
#line 268
        break;
      }
#line 268
      if ((s->strm)->avail_in == 0U) {
#line 268
        retVal = 0;
#line 268
        goto save_state_and_return;
      }
#line 268
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 268
      s->bsLive += 8;
#line 268
      ((s->strm)->next_in) ++;
#line 268
      ((s->strm)->avail_in) --;
#line 268
      ((s->strm)->total_in_lo32) ++;
#line 268
      if ((s->strm)->total_in_lo32 == 0U) {
#line 268
        ((s->strm)->total_in_hi32) ++;
      }
    }
#line 269
    if ((int )uc == 1) {
#line 270
      s->inUse16[i] = (Bool )1;
    } else {
#line 271
      s->inUse16[i] = (Bool )0;
    }
#line 267
    i ++;
  }
#line 274
  i = 0;
#line 274
  while (i < 256) {
#line 274
    s->inUse[i] = (Bool )0;
#line 274
    i ++;
  }
#line 276
  i = 0;
#line 276
  while (i < 16) {
#line 277
    if (s->inUse16[i]) {
#line 278
      j = 0;
#line 278
      while (j < 16) {
        case 29: 
#line 279
        s->state = 29;
#line 279
        while (1) {
#line 279
          if (s->bsLive >= 1) {
#line 279
            v___18 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 279
            (s->bsLive) --;
#line 279
            uc = (UChar )v___18;
#line 279
            break;
          }
#line 279
          if ((s->strm)->avail_in == 0U) {
#line 279
            retVal = 0;
#line 279
            goto save_state_and_return;
          }
#line 279
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 279
          s->bsLive += 8;
#line 279
          ((s->strm)->next_in) ++;
#line 279
          ((s->strm)->avail_in) --;
#line 279
          ((s->strm)->total_in_lo32) ++;
#line 279
          if ((s->strm)->total_in_lo32 == 0U) {
#line 279
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 280
        if ((int )uc == 1) {
#line 280
          s->inUse[i * 16 + j] = (Bool )1;
        }
#line 278
        j ++;
      }
    }
#line 276
    i ++;
  }
#line 282
  makeMaps_d(s);
#line 283
  if (s->nInUse == 0) {
#line 283
    retVal = -4;
#line 283
    goto save_state_and_return;
  }
#line 284
  alphaSize = s->nInUse + 2;
  case 30: 
#line 287
  s->state = 30;
#line 287
  while (1) {
#line 287
    if (s->bsLive >= 3) {
#line 287
      v___19 = (s->bsBuff >> (s->bsLive - 3)) & (unsigned int )((1 << 3) - 1);
#line 287
      s->bsLive -= 3;
#line 287
      nGroups = (Int32 )v___19;
#line 287
      break;
    }
#line 287
    if ((s->strm)->avail_in == 0U) {
#line 287
      retVal = 0;
#line 287
      goto save_state_and_return;
    }
#line 287
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 287
    s->bsLive += 8;
#line 287
    ((s->strm)->next_in) ++;
#line 287
    ((s->strm)->avail_in) --;
#line 287
    ((s->strm)->total_in_lo32) ++;
#line 287
    if ((s->strm)->total_in_lo32 == 0U) {
#line 287
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 288
  if (nGroups < 2) {
#line 288
    retVal = -4;
#line 288
    goto save_state_and_return;
  } else
#line 288
  if (nGroups > 6) {
#line 288
    retVal = -4;
#line 288
    goto save_state_and_return;
  }
  case 31: 
#line 289
  s->state = 31;
#line 289
  while (1) {
#line 289
    if (s->bsLive >= 15) {
#line 289
      v___20 = (s->bsBuff >> (s->bsLive - 15)) & (unsigned int )((1 << 15) - 1);
#line 289
      s->bsLive -= 15;
#line 289
      nSelectors = (Int32 )v___20;
#line 289
      break;
    }
#line 289
    if ((s->strm)->avail_in == 0U) {
#line 289
      retVal = 0;
#line 289
      goto save_state_and_return;
    }
#line 289
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 289
    s->bsLive += 8;
#line 289
    ((s->strm)->next_in) ++;
#line 289
    ((s->strm)->avail_in) --;
#line 289
    ((s->strm)->total_in_lo32) ++;
#line 289
    if ((s->strm)->total_in_lo32 == 0U) {
#line 289
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 290
  if (nSelectors < 1) {
#line 290
    retVal = -4;
#line 290
    goto save_state_and_return;
  }
#line 291
  i = 0;
#line 291
  while (i < nSelectors) {
#line 292
    j = 0;
#line 293
    while (1) {
      case 32: 
#line 294
      s->state = 32;
#line 294
      while (1) {
#line 294
        if (s->bsLive >= 1) {
#line 294
          v___21 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 294
          (s->bsLive) --;
#line 294
          uc = (UChar )v___21;
#line 294
          break;
        }
#line 294
        if ((s->strm)->avail_in == 0U) {
#line 294
          retVal = 0;
#line 294
          goto save_state_and_return;
        }
#line 294
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 294
        s->bsLive += 8;
#line 294
        ((s->strm)->next_in) ++;
#line 294
        ((s->strm)->avail_in) --;
#line 294
        ((s->strm)->total_in_lo32) ++;
#line 294
        if ((s->strm)->total_in_lo32 == 0U) {
#line 294
          ((s->strm)->total_in_hi32) ++;
        }
      }
#line 295
      if ((int )uc == 0) {
#line 295
        break;
      }
#line 296
      j ++;
#line 297
      if (j >= nGroups) {
#line 297
        retVal = -4;
#line 297
        goto save_state_and_return;
      }
    }
#line 299
    s->selectorMtf[i] = (UChar )j;
#line 291
    i ++;
  }
#line 305
  v___22 = (UChar )0;
#line 305
  while ((int )v___22 < nGroups) {
#line 305
    pos[v___22] = v___22;
#line 305
    v___22 = (UChar )((int )v___22 + 1);
  }
#line 307
  i = 0;
#line 307
  while (i < nSelectors) {
#line 308
    v___22 = s->selectorMtf[i];
#line 309
    tmp___2 = pos[v___22];
#line 310
    while ((int )v___22 > 0) {
#line 310
      pos[v___22] = pos[(int )v___22 - 1];
#line 310
      v___22 = (UChar )((int )v___22 - 1);
    }
#line 311
    pos[0] = tmp___2;
#line 312
    s->selector[i] = tmp___2;
#line 307
    i ++;
  }
#line 317
  t = 0;
#line 317
  while (t < nGroups) {
    case 33: 
#line 318
    s->state = 33;
#line 318
    while (1) {
#line 318
      if (s->bsLive >= 5) {
#line 318
        v___23 = (s->bsBuff >> (s->bsLive - 5)) & (unsigned int )((1 << 5) - 1);
#line 318
        s->bsLive -= 5;
#line 318
        curr = (Int32 )v___23;
#line 318
        break;
      }
#line 318
      if ((s->strm)->avail_in == 0U) {
#line 318
        retVal = 0;
#line 318
        goto save_state_and_return;
      }
#line 318
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 318
      s->bsLive += 8;
#line 318
      ((s->strm)->next_in) ++;
#line 318
      ((s->strm)->avail_in) --;
#line 318
      ((s->strm)->total_in_lo32) ++;
#line 318
      if ((s->strm)->total_in_lo32 == 0U) {
#line 318
        ((s->strm)->total_in_hi32) ++;
      }
    }
#line 319
    i = 0;
#line 319
    while (i < alphaSize) {
#line 320
      while (1) {
#line 321
        if (curr < 1) {
#line 321
          retVal = -4;
#line 321
          goto save_state_and_return;
        } else
#line 321
        if (curr > 20) {
#line 321
          retVal = -4;
#line 321
          goto save_state_and_return;
        }
        case 34: 
#line 322
        s->state = 34;
#line 322
        while (1) {
#line 322
          if (s->bsLive >= 1) {
#line 322
            v___24 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 322
            (s->bsLive) --;
#line 322
            uc = (UChar )v___24;
#line 322
            break;
          }
#line 322
          if ((s->strm)->avail_in == 0U) {
#line 322
            retVal = 0;
#line 322
            goto save_state_and_return;
          }
#line 322
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 322
          s->bsLive += 8;
#line 322
          ((s->strm)->next_in) ++;
#line 322
          ((s->strm)->avail_in) --;
#line 322
          ((s->strm)->total_in_lo32) ++;
#line 322
          if ((s->strm)->total_in_lo32 == 0U) {
#line 322
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 323
        if ((int )uc == 0) {
#line 323
          break;
        }
        case 35: 
#line 324
        s->state = 35;
#line 324
        while (1) {
#line 324
          if (s->bsLive >= 1) {
#line 324
            v___25 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 324
            (s->bsLive) --;
#line 324
            uc = (UChar )v___25;
#line 324
            break;
          }
#line 324
          if ((s->strm)->avail_in == 0U) {
#line 324
            retVal = 0;
#line 324
            goto save_state_and_return;
          }
#line 324
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 324
          s->bsLive += 8;
#line 324
          ((s->strm)->next_in) ++;
#line 324
          ((s->strm)->avail_in) --;
#line 324
          ((s->strm)->total_in_lo32) ++;
#line 324
          if ((s->strm)->total_in_lo32 == 0U) {
#line 324
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 325
        if ((int )uc == 0) {
#line 325
          curr ++;
        } else {
#line 325
          curr --;
        }
      }
#line 327
      s->len[t][i] = (UChar )curr;
#line 319
      i ++;
    }
#line 317
    t ++;
  }
#line 332
  t = 0;
#line 332
  while (t < nGroups) {
#line 333
    minLen = 32;
#line 334
    maxLen = 0;
#line 335
    i = 0;
#line 335
    while (i < alphaSize) {
#line 336
      if ((int )s->len[t][i] > maxLen) {
#line 336
        maxLen = (Int32 )s->len[t][i];
      }
#line 337
      if ((int )s->len[t][i] < minLen) {
#line 337
        minLen = (Int32 )s->len[t][i];
      }
#line 335
      i ++;
    }
#line 339
    BZ2_hbCreateDecodeTables(& s->limit[t][0], & s->base[t][0], & s->perm[t][0], & s->len[t][0],
                             minLen, maxLen, alphaSize);
#line 346
    s->minLens[t] = minLen;
#line 332
    t ++;
  }
#line 351
  EOB = s->nInUse + 1;
#line 352
  nblockMAX = 100000 * s->blockSize100k;
#line 353
  groupNo = -1;
#line 354
  groupPos = 0;
#line 356
  i = 0;
#line 356
  while (i <= 255) {
#line 356
    s->unzftab[i] = 0;
#line 356
    i ++;
  }
#line 361
  kk = 4095;
#line 362
  ii = 15;
#line 362
  while (ii >= 0) {
#line 363
    jj = 15;
#line 363
    while (jj >= 0) {
#line 364
      s->mtfa[kk] = (UChar )(ii * 16 + jj);
#line 365
      kk --;
#line 363
      jj --;
    }
#line 367
    s->mtfbase[ii] = kk + 1;
#line 362
    ii --;
  }
#line 372
  nblock = 0;
#line 373
  if (groupPos == 0) {
#line 373
    groupNo ++;
#line 373
    if (groupNo >= nSelectors) {
#line 373
      retVal = -4;
#line 373
      goto save_state_and_return;
    }
#line 373
    groupPos = 50;
#line 373
    gSel = (Int32 )s->selector[groupNo];
#line 373
    gMinlen = s->minLens[gSel];
#line 373
    gLimit = & s->limit[gSel][0];
#line 373
    gPerm = & s->perm[gSel][0];
#line 373
    gBase = & s->base[gSel][0];
  }
#line 373
  groupPos --;
#line 373
  zn = gMinlen;
  case 36: 
#line 373
  s->state = 36;
#line 373
  while (1) {
#line 373
    if (s->bsLive >= zn) {
#line 373
      v___26 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 373
      s->bsLive -= zn;
#line 373
      zvec = (Int32 )v___26;
#line 373
      break;
    }
#line 373
    if ((s->strm)->avail_in == 0U) {
#line 373
      retVal = 0;
#line 373
      goto save_state_and_return;
    }
#line 373
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 373
    s->bsLive += 8;
#line 373
    ((s->strm)->next_in) ++;
#line 373
    ((s->strm)->avail_in) --;
#line 373
    ((s->strm)->total_in_lo32) ++;
#line 373
    if ((s->strm)->total_in_lo32 == 0U) {
#line 373
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 373
  while (1) {
#line 373
    if (zn > 20) {
#line 373
      retVal = -4;
#line 373
      goto save_state_and_return;
    }
#line 373
    if (zvec <= *(gLimit + zn)) {
#line 373
      break;
    }
#line 373
    zn ++;
    case 37: 
#line 373
    s->state = 37;
#line 373
    while (1) {
#line 373
      if (s->bsLive >= 1) {
#line 373
        v___27 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 373
        (s->bsLive) --;
#line 373
        zj = (Int32 )v___27;
#line 373
        break;
      }
#line 373
      if ((s->strm)->avail_in == 0U) {
#line 373
        retVal = 0;
#line 373
        goto save_state_and_return;
      }
#line 373
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 373
      s->bsLive += 8;
#line 373
      ((s->strm)->next_in) ++;
#line 373
      ((s->strm)->avail_in) --;
#line 373
      ((s->strm)->total_in_lo32) ++;
#line 373
      if ((s->strm)->total_in_lo32 == 0U) {
#line 373
        ((s->strm)->total_in_hi32) ++;
      }
    }
#line 373
    zvec = (zvec << 1) | zj;
  }
#line 373
  if (zvec - *(gBase + zn) < 0) {
#line 373
    retVal = -4;
#line 373
    goto save_state_and_return;
  } else
#line 373
  if (zvec - *(gBase + zn) >= 258) {
#line 373
    retVal = -4;
#line 373
    goto save_state_and_return;
  }
#line 373
  nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 375
  while (! (nextSym == EOB)) {
#line 379
    if (nextSym == 0) {
#line 379
      goto _L;
    } else
#line 379
    if (nextSym == 1) {
      _L: /* CIL Label */ 
#line 381
      es = -1;
#line 382
      N = 1;
#line 383
      while (1) {
#line 390
        if (N >= 2097152) {
#line 390
          retVal = -4;
#line 390
          goto save_state_and_return;
        }
#line 391
        if (nextSym == 0) {
#line 391
          es += N;
        } else
#line 392
        if (nextSym == 1) {
#line 392
          es += 2 * N;
        }
#line 393
        N *= 2;
#line 394
        if (groupPos == 0) {
#line 394
          groupNo ++;
#line 394
          if (groupNo >= nSelectors) {
#line 394
            retVal = -4;
#line 394
            goto save_state_and_return;
          }
#line 394
          groupPos = 50;
#line 394
          gSel = (Int32 )s->selector[groupNo];
#line 394
          gMinlen = s->minLens[gSel];
#line 394
          gLimit = & s->limit[gSel][0];
#line 394
          gPerm = & s->perm[gSel][0];
#line 394
          gBase = & s->base[gSel][0];
        }
#line 394
        groupPos --;
#line 394
        zn = gMinlen;
        case 38: 
#line 394
        s->state = 38;
#line 394
        while (1) {
#line 394
          if (s->bsLive >= zn) {
#line 394
            v___28 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 394
            s->bsLive -= zn;
#line 394
            zvec = (Int32 )v___28;
#line 394
            break;
          }
#line 394
          if ((s->strm)->avail_in == 0U) {
#line 394
            retVal = 0;
#line 394
            goto save_state_and_return;
          }
#line 394
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 394
          s->bsLive += 8;
#line 394
          ((s->strm)->next_in) ++;
#line 394
          ((s->strm)->avail_in) --;
#line 394
          ((s->strm)->total_in_lo32) ++;
#line 394
          if ((s->strm)->total_in_lo32 == 0U) {
#line 394
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 394
        while (1) {
#line 394
          if (zn > 20) {
#line 394
            retVal = -4;
#line 394
            goto save_state_and_return;
          }
#line 394
          if (zvec <= *(gLimit + zn)) {
#line 394
            break;
          }
#line 394
          zn ++;
          case 39: 
#line 394
          s->state = 39;
#line 394
          while (1) {
#line 394
            if (s->bsLive >= 1) {
#line 394
              v___29 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 394
              (s->bsLive) --;
#line 394
              zj = (Int32 )v___29;
#line 394
              break;
            }
#line 394
            if ((s->strm)->avail_in == 0U) {
#line 394
              retVal = 0;
#line 394
              goto save_state_and_return;
            }
#line 394
            s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 394
            s->bsLive += 8;
#line 394
            ((s->strm)->next_in) ++;
#line 394
            ((s->strm)->avail_in) --;
#line 394
            ((s->strm)->total_in_lo32) ++;
#line 394
            if ((s->strm)->total_in_lo32 == 0U) {
#line 394
              ((s->strm)->total_in_hi32) ++;
            }
          }
#line 394
          zvec = (zvec << 1) | zj;
        }
#line 394
        if (zvec - *(gBase + zn) < 0) {
#line 394
          retVal = -4;
#line 394
          goto save_state_and_return;
        } else
#line 394
        if (zvec - *(gBase + zn) >= 258) {
#line 394
          retVal = -4;
#line 394
          goto save_state_and_return;
        }
#line 394
        nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 383
        if (! (nextSym == 0)) {
#line 383
          if (! (nextSym == 1)) {
#line 383
            break;
          }
        }
      }
#line 398
      es ++;
#line 399
      uc = s->seqToUnseq[s->mtfa[s->mtfbase[0]]];
#line 400
      s->unzftab[uc] += es;
#line 402
      if (s->smallDecompress) {
#line 403
        while (es > 0) {
#line 404
          if (nblock >= nblockMAX) {
#line 404
            retVal = -4;
#line 404
            goto save_state_and_return;
          }
#line 405
          *(s->ll16 + nblock) = (UInt16 )uc;
#line 406
          nblock ++;
#line 407
          es --;
        }
      } else {
#line 410
        while (es > 0) {
#line 411
          if (nblock >= nblockMAX) {
#line 411
            retVal = -4;
#line 411
            goto save_state_and_return;
          }
#line 412
          *(s->tt + nblock) = (UInt32 )uc;
#line 413
          nblock ++;
#line 414
          es --;
        }
      }
#line 417
      continue;
    } else {
#line 421
      if (nblock >= nblockMAX) {
#line 421
        retVal = -4;
#line 421
        goto save_state_and_return;
      }
#line 427
      nn = (UInt32 )(nextSym - 1);
#line 429
      if (nn < 16U) {
#line 431
        pp = s->mtfbase[0];
#line 432
        uc = s->mtfa[(UInt32 )pp + nn];
#line 433
        while (nn > 3U) {
#line 434
          z = (Int32 )((UInt32 )pp + nn);
#line 435
          s->mtfa[z] = s->mtfa[z - 1];
#line 436
          s->mtfa[z - 1] = s->mtfa[z - 2];
#line 437
          s->mtfa[z - 2] = s->mtfa[z - 3];
#line 438
          s->mtfa[z - 3] = s->mtfa[z - 4];
#line 439
          nn -= 4U;
        }
#line 441
        while (nn > 0U) {
#line 442
          s->mtfa[(UInt32 )pp + nn] = s->mtfa[((UInt32 )pp + nn) - 1U];
#line 442
          nn --;
        }
#line 444
        s->mtfa[pp] = uc;
      } else {
#line 447
        lno = (Int32 )(nn / 16U);
#line 448
        off = (Int32 )(nn % 16U);
#line 449
        pp = s->mtfbase[lno] + off;
#line 450
        uc = s->mtfa[pp];
#line 451
        while (pp > s->mtfbase[lno]) {
#line 452
          s->mtfa[pp] = s->mtfa[pp - 1];
#line 452
          pp --;
        }
#line 454
        (s->mtfbase[lno]) ++;
#line 455
        while (lno > 0) {
#line 456
          (s->mtfbase[lno]) --;
#line 457
          s->mtfa[s->mtfbase[lno]] = s->mtfa[(s->mtfbase[lno - 1] + 16) - 1];
#line 459
          lno --;
        }
#line 461
        (s->mtfbase[0]) --;
#line 462
        s->mtfa[s->mtfbase[0]] = uc;
#line 463
        if (s->mtfbase[0] == 0) {
#line 464
          kk___0 = 4095;
#line 465
          ii___0 = 15;
#line 465
          while (ii___0 >= 0) {
#line 466
            jj___0 = 15;
#line 466
            while (jj___0 >= 0) {
#line 467
              s->mtfa[kk___0] = s->mtfa[s->mtfbase[ii___0] + jj___0];
#line 468
              kk___0 --;
#line 466
              jj___0 --;
            }
#line 470
            s->mtfbase[ii___0] = kk___0 + 1;
#line 465
            ii___0 --;
          }
        }
      }
#line 477
      (s->unzftab[s->seqToUnseq[uc]]) ++;
#line 478
      if (s->smallDecompress) {
#line 479
        *(s->ll16 + nblock) = (UInt16 )s->seqToUnseq[uc];
      } else {
#line 480
        *(s->tt + nblock) = (UInt32 )s->seqToUnseq[uc];
      }
#line 481
      nblock ++;
#line 483
      if (groupPos == 0) {
#line 483
        groupNo ++;
#line 483
        if (groupNo >= nSelectors) {
#line 483
          retVal = -4;
#line 483
          goto save_state_and_return;
        }
#line 483
        groupPos = 50;
#line 483
        gSel = (Int32 )s->selector[groupNo];
#line 483
        gMinlen = s->minLens[gSel];
#line 483
        gLimit = & s->limit[gSel][0];
#line 483
        gPerm = & s->perm[gSel][0];
#line 483
        gBase = & s->base[gSel][0];
      }
#line 483
      groupPos --;
#line 483
      zn = gMinlen;
      case 40: 
#line 483
      s->state = 40;
#line 483
      while (1) {
#line 483
        if (s->bsLive >= zn) {
#line 483
          v___30 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 483
          s->bsLive -= zn;
#line 483
          zvec = (Int32 )v___30;
#line 483
          break;
        }
#line 483
        if ((s->strm)->avail_in == 0U) {
#line 483
          retVal = 0;
#line 483
          goto save_state_and_return;
        }
#line 483
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 483
        s->bsLive += 8;
#line 483
        ((s->strm)->next_in) ++;
#line 483
        ((s->strm)->avail_in) --;
#line 483
        ((s->strm)->total_in_lo32) ++;
#line 483
        if ((s->strm)->total_in_lo32 == 0U) {
#line 483
          ((s->strm)->total_in_hi32) ++;
        }
      }
#line 483
      while (1) {
#line 483
        if (zn > 20) {
#line 483
          retVal = -4;
#line 483
          goto save_state_and_return;
        }
#line 483
        if (zvec <= *(gLimit + zn)) {
#line 483
          break;
        }
#line 483
        zn ++;
        case 41: 
#line 483
        s->state = 41;
#line 483
        while (1) {
#line 483
          if (s->bsLive >= 1) {
#line 483
            v___31 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 483
            (s->bsLive) --;
#line 483
            zj = (Int32 )v___31;
#line 483
            break;
          }
#line 483
          if ((s->strm)->avail_in == 0U) {
#line 483
            retVal = 0;
#line 483
            goto save_state_and_return;
          }
#line 483
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 483
          s->bsLive += 8;
#line 483
          ((s->strm)->next_in) ++;
#line 483
          ((s->strm)->avail_in) --;
#line 483
          ((s->strm)->total_in_lo32) ++;
#line 483
          if ((s->strm)->total_in_lo32 == 0U) {
#line 483
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 483
        zvec = (zvec << 1) | zj;
      }
#line 483
      if (zvec - *(gBase + zn) < 0) {
#line 483
        retVal = -4;
#line 483
        goto save_state_and_return;
      } else
#line 483
      if (zvec - *(gBase + zn) >= 258) {
#line 483
        retVal = -4;
#line 483
        goto save_state_and_return;
      }
#line 483
      nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 484
      continue;
    }
  }
#line 491
  if (s->origPtr < 0) {
#line 492
    retVal = -4;
#line 492
    goto save_state_and_return;
  } else
#line 491
  if (s->origPtr >= nblock) {
#line 492
    retVal = -4;
#line 492
    goto save_state_and_return;
  }
#line 496
  i = 0;
#line 496
  while (i <= 255) {
#line 497
    if (s->unzftab[i] < 0) {
#line 498
      retVal = -4;
#line 498
      goto save_state_and_return;
    } else
#line 497
    if (s->unzftab[i] > nblock) {
#line 498
      retVal = -4;
#line 498
      goto save_state_and_return;
    }
#line 496
    i ++;
  }
#line 501
  s->cftab[0] = 0;
#line 502
  i = 1;
#line 502
  while (i <= 256) {
#line 502
    s->cftab[i] = s->unzftab[i - 1];
#line 502
    i ++;
  }
#line 503
  i = 1;
#line 503
  while (i <= 256) {
#line 503
    s->cftab[i] += s->cftab[i - 1];
#line 503
    i ++;
  }
#line 505
  i = 0;
#line 505
  while (i <= 256) {
#line 506
    if (s->cftab[i] < 0) {
#line 508
      retVal = -4;
#line 508
      goto save_state_and_return;
    } else
#line 506
    if (s->cftab[i] > nblock) {
#line 508
      retVal = -4;
#line 508
      goto save_state_and_return;
    }
#line 505
    i ++;
  }
#line 512
  i = 1;
#line 512
  while (i <= 256) {
#line 513
    if (s->cftab[i - 1] > s->cftab[i]) {
#line 514
      retVal = -4;
#line 514
      goto save_state_and_return;
    }
#line 512
    i ++;
  }
#line 518
  s->state_out_len = 0;
#line 519
  s->state_out_ch = (UChar )0;
#line 520
  s->calculatedBlockCRC = (UInt32 )4294967295L;
#line 521
  s->state = 2;
#line 522
  if (s->verbosity >= 2) {
#line 522
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rt+rld");
  }
#line 524
  if (s->smallDecompress) {
#line 527
    i = 0;
#line 527
    while (i <= 256) {
#line 527
      s->cftabCopy[i] = s->cftab[i];
#line 527
      i ++;
    }
#line 530
    i = 0;
#line 530
    while (i < nblock) {
#line 531
      uc = (UChar )*(s->ll16 + i);
#line 532
      *(s->ll16 + i) = (UInt16 )(s->cftabCopy[uc] & 65535);
#line 532
      if ((i & 1) == 0) {
#line 532
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 240) | (s->cftabCopy[uc] >> 16));
      } else {
#line 532
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 15) | ((s->cftabCopy[uc] >> 16) << 4));
      }
#line 533
      (s->cftabCopy[uc]) ++;
#line 530
      i ++;
    }
#line 537
    i = s->origPtr;
#line 538
    j = (Int32 )((UInt32 )*(s->ll16 + i) | ((((UInt32 )*(s->ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
#line 539
    while (1) {
#line 540
      tmp___3 = (Int32 )((UInt32 )*(s->ll16 + j) | ((((UInt32 )*(s->ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
#line 541
      *(s->ll16 + j) = (UInt16 )(i & 65535);
#line 541
      if ((j & 1) == 0) {
#line 541
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 240) | (i >> 16));
      } else {
#line 541
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 15) | ((i >> 16) << 4));
      }
#line 542
      i = j;
#line 543
      j = tmp___3;
#line 539
      if (! (i != s->origPtr)) {
#line 539
        break;
      }
    }
#line 547
    s->tPos = (UInt32 )s->origPtr;
#line 548
    s->nblock_used = 0;
#line 549
    if (s->blockRandomised) {
#line 550
      s->rNToGo = 0;
#line 550
      s->rTPos = 0;
#line 551
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 551
        return ((Int32 )((Bool )1));
      }
#line 551
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 551
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 551
      (s->nblock_used) ++;
#line 552
      if (s->rNToGo == 0) {
#line 552
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 552
        (s->rTPos) ++;
#line 552
        if (s->rTPos == 512) {
#line 552
          s->rTPos = 0;
        }
      }
#line 552
      (s->rNToGo) --;
#line 552
      if (s->rNToGo == 1) {
#line 552
        tmp___4 = 1;
      } else {
#line 552
        tmp___4 = 0;
      }
#line 552
      s->k0 ^= tmp___4;
    } else {
#line 554
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 554
        return ((Int32 )((Bool )1));
      }
#line 554
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 554
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 554
      (s->nblock_used) ++;
    }
  } else {
#line 560
    i = 0;
#line 560
    while (i < nblock) {
#line 561
      uc = (UChar )(*(s->tt + i) & 255U);
#line 562
      *(s->tt + s->cftab[uc]) |= (unsigned int )(i << 8);
#line 563
      (s->cftab[uc]) ++;
#line 560
      i ++;
    }
#line 566
    s->tPos = *(s->tt + s->origPtr) >> 8;
#line 567
    s->nblock_used = 0;
#line 568
    if (s->blockRandomised) {
#line 569
      s->rNToGo = 0;
#line 569
      s->rTPos = 0;
#line 570
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 570
        return ((Int32 )((Bool )1));
      }
#line 570
      s->tPos = *(s->tt + s->tPos);
#line 570
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 570
      s->tPos >>= 8;
#line 570
      (s->nblock_used) ++;
#line 571
      if (s->rNToGo == 0) {
#line 571
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 571
        (s->rTPos) ++;
#line 571
        if (s->rTPos == 512) {
#line 571
          s->rTPos = 0;
        }
      }
#line 571
      (s->rNToGo) --;
#line 571
      if (s->rNToGo == 1) {
#line 571
        tmp___5 = 1;
      } else {
#line 571
        tmp___5 = 0;
      }
#line 571
      s->k0 ^= tmp___5;
    } else {
#line 573
      if (s->tPos >= 100000U * (UInt32 )s->blockSize100k) {
#line 573
        return ((Int32 )((Bool )1));
      }
#line 573
      s->tPos = *(s->tt + s->tPos);
#line 573
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 573
      s->tPos >>= 8;
#line 573
      (s->nblock_used) ++;
    }
  }
#line 578
  retVal = 0;
#line 578
  goto save_state_and_return;
  endhdr_2: 
  case 42: 
#line 584
  s->state = 42;
#line 584
  while (1) {
#line 584
    if (s->bsLive >= 8) {
#line 584
      v___32 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 584
      s->bsLive -= 8;
#line 584
      uc = (UChar )v___32;
#line 584
      break;
    }
#line 584
    if ((s->strm)->avail_in == 0U) {
#line 584
      retVal = 0;
#line 584
      goto save_state_and_return;
    }
#line 584
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 584
    s->bsLive += 8;
#line 584
    ((s->strm)->next_in) ++;
#line 584
    ((s->strm)->avail_in) --;
#line 584
    ((s->strm)->total_in_lo32) ++;
#line 584
    if ((s->strm)->total_in_lo32 == 0U) {
#line 584
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 585
  if ((int )uc != 114) {
#line 585
    retVal = -4;
#line 585
    goto save_state_and_return;
  }
  case 43: 
#line 586
  s->state = 43;
#line 586
  while (1) {
#line 586
    if (s->bsLive >= 8) {
#line 586
      v___33 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 586
      s->bsLive -= 8;
#line 586
      uc = (UChar )v___33;
#line 586
      break;
    }
#line 586
    if ((s->strm)->avail_in == 0U) {
#line 586
      retVal = 0;
#line 586
      goto save_state_and_return;
    }
#line 586
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 586
    s->bsLive += 8;
#line 586
    ((s->strm)->next_in) ++;
#line 586
    ((s->strm)->avail_in) --;
#line 586
    ((s->strm)->total_in_lo32) ++;
#line 586
    if ((s->strm)->total_in_lo32 == 0U) {
#line 586
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 587
  if ((int )uc != 69) {
#line 587
    retVal = -4;
#line 587
    goto save_state_and_return;
  }
  case 44: 
#line 588
  s->state = 44;
#line 588
  while (1) {
#line 588
    if (s->bsLive >= 8) {
#line 588
      v___34 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 588
      s->bsLive -= 8;
#line 588
      uc = (UChar )v___34;
#line 588
      break;
    }
#line 588
    if ((s->strm)->avail_in == 0U) {
#line 588
      retVal = 0;
#line 588
      goto save_state_and_return;
    }
#line 588
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 588
    s->bsLive += 8;
#line 588
    ((s->strm)->next_in) ++;
#line 588
    ((s->strm)->avail_in) --;
#line 588
    ((s->strm)->total_in_lo32) ++;
#line 588
    if ((s->strm)->total_in_lo32 == 0U) {
#line 588
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 589
  if ((int )uc != 56) {
#line 589
    retVal = -4;
#line 589
    goto save_state_and_return;
  }
  case 45: 
#line 590
  s->state = 45;
#line 590
  while (1) {
#line 590
    if (s->bsLive >= 8) {
#line 590
      v___35 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 590
      s->bsLive -= 8;
#line 590
      uc = (UChar )v___35;
#line 590
      break;
    }
#line 590
    if ((s->strm)->avail_in == 0U) {
#line 590
      retVal = 0;
#line 590
      goto save_state_and_return;
    }
#line 590
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 590
    s->bsLive += 8;
#line 590
    ((s->strm)->next_in) ++;
#line 590
    ((s->strm)->avail_in) --;
#line 590
    ((s->strm)->total_in_lo32) ++;
#line 590
    if ((s->strm)->total_in_lo32 == 0U) {
#line 590
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 591
  if ((int )uc != 80) {
#line 591
    retVal = -4;
#line 591
    goto save_state_and_return;
  }
  case 46: 
#line 592
  s->state = 46;
#line 592
  while (1) {
#line 592
    if (s->bsLive >= 8) {
#line 592
      v___36 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 592
      s->bsLive -= 8;
#line 592
      uc = (UChar )v___36;
#line 592
      break;
    }
#line 592
    if ((s->strm)->avail_in == 0U) {
#line 592
      retVal = 0;
#line 592
      goto save_state_and_return;
    }
#line 592
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 592
    s->bsLive += 8;
#line 592
    ((s->strm)->next_in) ++;
#line 592
    ((s->strm)->avail_in) --;
#line 592
    ((s->strm)->total_in_lo32) ++;
#line 592
    if ((s->strm)->total_in_lo32 == 0U) {
#line 592
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 593
  if ((int )uc != 144) {
#line 593
    retVal = -4;
#line 593
    goto save_state_and_return;
  }
#line 595
  s->storedCombinedCRC = (UInt32 )0;
  case 47: 
#line 596
  s->state = 47;
#line 596
  while (1) {
#line 596
    if (s->bsLive >= 8) {
#line 596
      v___37 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 596
      s->bsLive -= 8;
#line 596
      uc = (UChar )v___37;
#line 596
      break;
    }
#line 596
    if ((s->strm)->avail_in == 0U) {
#line 596
      retVal = 0;
#line 596
      goto save_state_and_return;
    }
#line 596
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 596
    s->bsLive += 8;
#line 596
    ((s->strm)->next_in) ++;
#line 596
    ((s->strm)->avail_in) --;
#line 596
    ((s->strm)->total_in_lo32) ++;
#line 596
    if ((s->strm)->total_in_lo32 == 0U) {
#line 596
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 597
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 48: 
#line 598
  s->state = 48;
#line 598
  while (1) {
#line 598
    if (s->bsLive >= 8) {
#line 598
      v___38 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 598
      s->bsLive -= 8;
#line 598
      uc = (UChar )v___38;
#line 598
      break;
    }
#line 598
    if ((s->strm)->avail_in == 0U) {
#line 598
      retVal = 0;
#line 598
      goto save_state_and_return;
    }
#line 598
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 598
    s->bsLive += 8;
#line 598
    ((s->strm)->next_in) ++;
#line 598
    ((s->strm)->avail_in) --;
#line 598
    ((s->strm)->total_in_lo32) ++;
#line 598
    if ((s->strm)->total_in_lo32 == 0U) {
#line 598
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 599
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 49: 
#line 600
  s->state = 49;
#line 600
  while (1) {
#line 600
    if (s->bsLive >= 8) {
#line 600
      v___39 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 600
      s->bsLive -= 8;
#line 600
      uc = (UChar )v___39;
#line 600
      break;
    }
#line 600
    if ((s->strm)->avail_in == 0U) {
#line 600
      retVal = 0;
#line 600
      goto save_state_and_return;
    }
#line 600
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 600
    s->bsLive += 8;
#line 600
    ((s->strm)->next_in) ++;
#line 600
    ((s->strm)->avail_in) --;
#line 600
    ((s->strm)->total_in_lo32) ++;
#line 600
    if ((s->strm)->total_in_lo32 == 0U) {
#line 600
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 601
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 50: 
#line 602
  s->state = 50;
#line 602
  while (1) {
#line 602
    if (s->bsLive >= 8) {
#line 602
      v___40 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 602
      s->bsLive -= 8;
#line 602
      uc = (UChar )v___40;
#line 602
      break;
    }
#line 602
    if ((s->strm)->avail_in == 0U) {
#line 602
      retVal = 0;
#line 602
      goto save_state_and_return;
    }
#line 602
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 602
    s->bsLive += 8;
#line 602
    ((s->strm)->next_in) ++;
#line 602
    ((s->strm)->avail_in) --;
#line 602
    ((s->strm)->total_in_lo32) ++;
#line 602
    if ((s->strm)->total_in_lo32 == 0U) {
#line 602
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 603
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
#line 605
  s->state = 1;
#line 606
  retVal = 4;
#line 606
  goto save_state_and_return;
  default: 
#line 608
  BZ2_bz__AssertH__fail(4001);
  }
#line 611
  BZ2_bz__AssertH__fail(4002);
  save_state_and_return: 
#line 615
  s->save_i = i;
#line 616
  s->save_j = j;
#line 617
  s->save_t = t;
#line 618
  s->save_alphaSize = alphaSize;
#line 619
  s->save_nGroups = nGroups;
#line 620
  s->save_nSelectors = nSelectors;
#line 621
  s->save_EOB = EOB;
#line 622
  s->save_groupNo = groupNo;
#line 623
  s->save_groupPos = groupPos;
#line 624
  s->save_nextSym = nextSym;
#line 625
  s->save_nblockMAX = nblockMAX;
#line 626
  s->save_nblock = nblock;
#line 627
  s->save_es = es;
#line 628
  s->save_N = N;
#line 629
  s->save_curr = curr;
#line 630
  s->save_zt = zt;
#line 631
  s->save_zn = zn;
#line 632
  s->save_zvec = zvec;
#line 633
  s->save_zj = zj;
#line 634
  s->save_gSel = gSel;
#line 635
  s->save_gMinlen = gMinlen;
#line 636
  s->save_gLimit = gLimit;
#line 637
  s->save_gBase = gBase;
#line 638
  s->save_gPerm = gPerm;
#line 640
  return (retVal);
}
}
void makeMaps_d_cil_lr_1(DState *s , Int32 i ) 
{ 
  Int32 i_ssa_1 ;
  int __cil_tmp4 ;
  Bool __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  Bool (*__cil_tmp7)[256] ;
  Bool *__cil_tmp8 ;
  Bool *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  UChar (*__cil_tmp11)[256] ;
  unsigned char *__cil_tmp12 ;
  Int32 *__cil_tmp13 ;
  UChar *__cil_tmp14 ;
  Int32 __cil_tmp15 ;
  UChar *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  Int32 *__cil_tmp18 ;
  Int32 __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  Int32 *__cil_tmp21 ;

  {
  {
#line 31
  __cil_tmp4 = i < 256;
#line 31
  if (__cil_tmp4) {
    {
#line 32
    __cil_tmp6 = (unsigned char *)s + 3196;
#line 32
    __cil_tmp7 = (Bool (*)[256])__cil_tmp6;
#line 32
    __cil_tmp8 = *__cil_tmp7;
#line 32
    __cil_tmp9 = __cil_tmp8 + i;
#line 32
    __cil_tmp5 = *__cil_tmp9;
#line 32
    if (__cil_tmp5) {
      {
#line 33
      __cil_tmp10 = (unsigned char *)s + 3468;
#line 33
      __cil_tmp11 = (UChar (*)[256])__cil_tmp10;
#line 33
      __cil_tmp12 = (unsigned char *)s + 3192;
#line 33
      __cil_tmp13 = (Int32 *)__cil_tmp12;
#line 33
      __cil_tmp14 = *__cil_tmp11;
#line 33
      __cil_tmp15 = *__cil_tmp13;
#line 33
      __cil_tmp16 = __cil_tmp14 + __cil_tmp15;
#line 33
      *__cil_tmp16 = (UChar )i;
#line 34
      __cil_tmp17 = (unsigned char *)s + 3192;
#line 34
      __cil_tmp18 = (Int32 *)__cil_tmp17;
#line 34
      __cil_tmp19 = *__cil_tmp18;
#line 34
      __cil_tmp20 = (unsigned char *)s + 3192;
#line 34
      __cil_tmp21 = (Int32 *)__cil_tmp20;
#line 34
      *__cil_tmp21 = __cil_tmp19 + 1;
      }
    } else {

    }
    }
    {
#line 31
    i_ssa_1 = i + 1;
    }
    {
    makeMaps_d_cil_lr_1(s, i_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
  {
#line 31
  i_ssa_1 = i + 1;
  }
  {
  makeMaps_d_cil_lr_1(s, i_ssa_1);
  }
  return;
}
}
