#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 216 "/usr/lib/gcc/x86_64-redhat-linux/5.1.1/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/bits/types.h"
typedef long __syscall_slong_t;
#line 40 "/usr/lib/gcc/x86_64-redhat-linux/5.1.1/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 62 "/usr/include/sys/stat.h"
typedef __mode_t mode_t;
#line 46 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 82 "/usr/include/glob.h"
struct __anonstruct_glob_t_9 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   void *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , void * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , void * __restrict   ) ;
};
#line 82 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_9 glob_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 144 "file_list.c"
struct __anonstruct_file_info_t_29 {
   char *name ;
   char *full_path ;
   struct stat stat ;
};
#line 144 "file_list.c"
typedef struct __anonstruct_file_info_t_29 file_info_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsnprintf(char * __restrict  __s , size_t __maxlen ,
                                                   char const   * __restrict  __format ,
                                                   __gnuc_va_list __arg ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 398
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 262 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1,2),
__leaf__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 146 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) glob)(char const   * __restrict  __pattern ,
                                                                           int __flags ,
                                                                           int (*__errfunc)(char const   * ,
                                                                                            int  ) ,
                                                                           glob_t * __restrict  __pglob ) ;
#line 151
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) globfree)(glob_t *__pglob ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 195
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 8 "file_list.h"
int file_nlst(int out , char const   *cur_dir , char const   *filespec ) ;
#line 9
int file_list(int out , char const   *cur_dir , char const   *filespec ) ;
#line 10 "daemon_assert.h"
extern void daemon_assert_fail(char const   *assertion , char const   *file , int line ,
                               char const   *function ) ;
#line 57 "file_list.c"
static int is_valid_dir(char const   *dir ) ;
#line 58
static void fdprintf(int fd , char const   *fmt  , ...) ;
#line 59
static char const   *skip_ls_options(char const   *filespec ) ;
#line 60
void skip_ls_options_cil_lr_1_cil_lr_1(char const   **__cil_ap_filespec ) ;
#line 61
void skip_ls_options_cil_lr_1_cil_lr_2(char const   **__cil_ap_filespec ) ;
#line 62
void skip_ls_options_cil_lr_1_cil_lr_3(char const   **__cil_ap_filespec ) ;
#line 63
void skip_ls_options_cil_lr_1(char const   **__cil_ap_filespec ) ;
#line 64
void file_nlst_cil_lr_1(glob_t *__cil_ap_glob_buf , int out , int dir_len , char *pattern ,
                        int i ) ;
   int  babel_wrapper_is_valid_dir(char const   * dir)                           // function name insert
      {
        // wrapper for function is_valid_dir        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("is_valid_dir"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(dir);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   char const   * babel_wrapper_skip_ls_options(char const   ** __cil_pp_filespec, char const   ** __cil_fp_filespec, char const   * filespec)                           // function name insert
      {
        // wrapper for function skip_ls_options        // function name insert
         char const   * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("skip_ls_options"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_filespec);
arg[1] = Pl_Mk_Integer(__cil_fp_filespec);
arg[2] = Pl_Mk_Integer(filespec);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_skip_ls_options_cil_lr_1_cil_lr_1(char const   ** __cil_ap_filespec)                           // function name insert
      {
        // wrapper for function skip_ls_options_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("skip_ls_options_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_filespec);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_skip_ls_options_cil_lr_1_cil_lr_2(char const   ** __cil_ap_filespec)                           // function name insert
      {
        // wrapper for function skip_ls_options_cil_lr_1_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("skip_ls_options_cil_lr_1_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_filespec);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_skip_ls_options_cil_lr_1_cil_lr_3(char const   ** __cil_ap_filespec)                           // function name insert
      {
        // wrapper for function skip_ls_options_cil_lr_1_cil_lr_3        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("skip_ls_options_cil_lr_1_cil_lr_3"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_filespec);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_skip_ls_options_cil_lr_1(char const   ** __cil_ap_filespec)                           // function name insert
      {
        // wrapper for function skip_ls_options_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("skip_ls_options_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_filespec);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 76 "file_list.c"
int file_nlst(int out , char const   *cur_dir , char const   *filespec ) 
{ 
  char pattern[4097] ;
  glob_t glob_buf ;
  glob_t *__cil_pp_glob_buf ;
  int tmp_ssa_1 ;
  int dir_len_ssa_1 ;
  size_t tmp___0_ssa_1 ;
  size_t tmp___1_ssa_1 ;
  int glob_ret_ssa_1 ;
  int i_ssa_1 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  char const   *__cil_tmp32 ;
  char __cil_tmp33 ;
  int __cil_tmp34 ;
  char *__cil_tmp35 ;
  char const   *__cil_tmp36 ;
  char __cil_tmp37 ;
  int __cil_tmp38 ;
  char *__cil_tmp39 ;
  char const   *__cil_tmp40 ;
  char __cil_tmp41 ;
  int __cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  int __cil_tmp45 ;
  size_t __cil_tmp46 ;
  size_t __cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;

  {
#line 80
  __cil_pp_glob_buf = & glob_buf;
#line 85
  __cil_tmp22 = out >= 0;
#line 85
  if (__cil_tmp22 == 0) {
#line 85
    daemon_assert_fail("out >= 0", "file_list.c", 85, "file_nlst");
  } else {

  }
#line 86
  tmp_ssa_1 = is_valid_dir(cur_dir);
#line 86
  if (tmp_ssa_1 == 0) {
#line 86
    daemon_assert_fail("is_valid_dir(cur_dir)", "file_list.c", 86, "file_nlst");
  } else {

  }
#line 87
  __cil_tmp23 = (unsigned long )filespec != (unsigned long )((void *)0);
#line 87
  if (__cil_tmp23 == 0) {
#line 87
    daemon_assert_fail("filespec != ((void *)0)", "file_list.c", 87, "file_nlst");
  } else {

  }
#line 89
  __cil_tmp32 = filespec + 0;
#line 89
  __cil_tmp33 = (char )*__cil_tmp32;
#line 89
  __cil_tmp34 = (int )((int const   )__cil_tmp33);
#line 89
  __cil_tmp24 = __cil_tmp34 == 47;
#line 89
  if (__cil_tmp24 != 0) {
#line 91
    dir_len_ssa_1 = 0;
  } else {
#line 93
    __cil_tmp35 = pattern;
#line 93
    strcpy((char * __restrict  )__cil_tmp35, (char const   * __restrict  )cur_dir);
#line 94
    __cil_tmp36 = cur_dir + 0;
#line 94
    __cil_tmp37 = (char )*__cil_tmp36;
#line 94
    __cil_tmp38 = (int )((int const   )__cil_tmp37);
#line 94
    __cil_tmp25 = __cil_tmp38 != 47;
#line 94
    if (__cil_tmp25 != 0) {
#line 95
      __cil_tmp39 = pattern;
#line 95
      strcat((char * __restrict  )__cil_tmp39, (char const   * __restrict  )"/");
    } else {
#line 94
      __cil_tmp40 = cur_dir + 1;
#line 94
      __cil_tmp41 = (char )*__cil_tmp40;
#line 94
      __cil_tmp42 = (int )((int const   )__cil_tmp41);
#line 94
      __cil_tmp26 = __cil_tmp42 != 0;
#line 94
      if (__cil_tmp26 != 0) {
#line 95
        __cil_tmp43 = pattern;
#line 95
        strcat((char * __restrict  )__cil_tmp43, (char const   * __restrict  )"/");
      } else {

      }
    }
#line 97
    __cil_tmp44 = pattern;
#line 97
    tmp___0_ssa_1 = strlen((char const   *)__cil_tmp44);
#line 97
    dir_len_ssa_1 = (int )tmp___0_ssa_1;
  }
#line 101
  tmp___1_ssa_1 = strlen(filespec);
#line 101
  __cil_tmp45 = dir_len_ssa_1 + 1;
#line 101
  __cil_tmp46 = (size_t )__cil_tmp45;
#line 101
  __cil_tmp47 = __cil_tmp46 + tmp___1_ssa_1;
#line 101
  __cil_tmp27 = __cil_tmp47 > 4096UL;
#line 101
  if (__cil_tmp27 != 0) {
#line 102
    fdprintf(out, "Error; Path name too long\r\n");
#line 103
    return (0);
  } else {
#line 105
    __cil_tmp48 = pattern;
#line 105
    strcat((char * __restrict  )__cil_tmp48, (char const   * __restrict  )filespec);
#line 108
    memset((void *)__cil_pp_glob_buf, 0, sizeof(glob_buf));
#line 109
    __cil_tmp49 = pattern;
#line 109
    __cil_tmp50 = 1 << 2;
#line 109
    __cil_tmp51 = 1 | __cil_tmp50;
#line 109
    __cil_tmp52 = 1 << 7;
#line 109
    __cil_tmp53 = __cil_tmp51 | __cil_tmp52;
#line 109
    glob_ret_ssa_1 = glob((char const   * __restrict  )((char const   *)__cil_tmp49),
                          __cil_tmp53, (int (*)(char const   * , int  ))0, (glob_t * __restrict  )__cil_pp_glob_buf);
#line 113
    __cil_tmp28 = glob_ret_ssa_1 == 1;
#line 113
    if (__cil_tmp28 != 0) {
#line 114
      fdprintf(out, "Error; Out of memory\r\n");
#line 115
      return (0);
    } else {
#line 117
      __cil_tmp29 = glob_ret_ssa_1 == 3;
#line 117
      if (__cil_tmp29 != 0) {
#line 118
        return (1);
      } else {
#line 121
        __cil_tmp30 = glob_ret_ssa_1 == 2;
#line 121
        if (__cil_tmp30 != 0) {
#line 122
          fdprintf(out, "Error; Read error\r\n");
#line 123
          return (0);
        } else {
#line 125
          __cil_tmp31 = glob_ret_ssa_1 != 0;
#line 125
          if (__cil_tmp31 != 0) {
#line 126
            fdprintf(out, "Error; Unknown glob() error %d\r\n", glob_ret_ssa_1);
#line 127
            return (0);
          } else {
#line 131
            i_ssa_1 = 0;
#line 131
            file_nlst_cil_lr_1(__cil_pp_glob_buf, out, dir_len_ssa_1, (char *)(pattern),
                               i_ssa_1);
#line 140
            globfree(__cil_pp_glob_buf);
#line 141
            return (1);
          }
        }
      }
    }
  }
}
}
#line 150 "file_list.c"
int file_list(int out , char const   *cur_dir , char const   *filespec ) 
{ 
  int dir_len ;
  char pattern[4097] ;
  int glob_ret ;
  glob_t glob_buf ;
  int i ;
  file_info_t *file_info ;
  int num_files ;
  unsigned long total_blocks ;
  char *file_name ;
  mode_t mode ;
  time_t now ;
  struct tm tm_now ;
  double age ;
  char date_buf[13] ;
  char link___0[4097] ;
  int link_len ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int __attribute__((__gnu_inline__))  tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  ssize_t tmp___17 ;
  char const   *mem_39 ;
  char const   *mem_40 ;
  char const   *mem_41 ;
  char **mem_42 ;
  char **mem_43 ;
  file_info_t *mem_44 ;
  file_info_t *mem_45 ;
  file_info_t *mem_46 ;
  char **mem_47 ;
  file_info_t *mem_48 ;
  file_info_t *mem_49 ;
  file_info_t *mem_50 ;
  file_info_t *mem_51 ;
  file_info_t *mem_52 ;
  file_info_t *mem_53 ;
  file_info_t *mem_54 ;
  file_info_t *mem_55 ;
  file_info_t *mem_56 ;

  {
#line 170
  if (out < 0) {
#line 170
    daemon_assert_fail("out >= 0", "file_list.c", 170, "file_list");
  } else {

  }
#line 171
  tmp = is_valid_dir(cur_dir);
#line 171
  if (tmp == 0) {
#line 171
    daemon_assert_fail("is_valid_dir(cur_dir)", "file_list.c", 171, "file_list");
  } else {

  }
#line 172
  if ((unsigned long )filespec == (unsigned long )((void *)0)) {
#line 172
    daemon_assert_fail("filespec != ((void *)0)", "file_list.c", 172, "file_list");
  } else {

  }
#line 174
  filespec = skip_ls_options(filespec);
  {
#line 176
  mem_39 = filespec + 0;
#line 176
  if ((int const   )*mem_39 == 47) {
#line 178
    dir_len = 0;
  } else {
#line 180
    strcpy((char * __restrict  )(pattern), (char const   * __restrict  )cur_dir);
    {
#line 181
    mem_40 = cur_dir + 0;
#line 181
    if ((int const   )*mem_40 != 47) {
#line 182
      strcat((char * __restrict  )(pattern), (char const   * __restrict  )"/");
    } else {
      {
#line 181
      mem_41 = cur_dir + 1;
#line 181
      if ((int const   )*mem_41 != 0) {
#line 182
        strcat((char * __restrict  )(pattern), (char const   * __restrict  )"/");
      } else {

      }
      }
    }
    }
#line 184
    tmp___0 = strlen((char const   *)(pattern));
#line 184
    dir_len = (int )tmp___0;
  }
  }
#line 188
  tmp___1 = strlen(filespec);
#line 188
  if ((size_t )(dir_len + 1) + tmp___1 > 4096UL) {
#line 189
    fdprintf(out, "Error; Path name too long\r\n");
#line 190
    return (0);
  } else {

  }
#line 192
  strcat((char * __restrict  )(pattern), (char const   * __restrict  )filespec);
#line 195
  memset((void *)(& glob_buf), 0, sizeof(glob_buf));
#line 196
  glob_ret = glob((char const   * __restrict  )((char const   *)(pattern)), 1, (int (*)(char const   * ,
                                                                                        int  ))((void *)0),
                  (glob_t * __restrict  )(& glob_buf));
#line 200
  if (glob_ret == 3) {
#line 202
    fdprintf(out, "total 0\r\n");
#line 203
    return (1);
  } else
#line 204
  if (glob_ret == 1) {
#line 205
    fdprintf(out, "Error; Out of memory\r\n");
#line 206
    return (0);
  } else
#line 208
  if (glob_ret == 2) {
#line 209
    fdprintf(out, "Error; Read error\r\n");
#line 210
    return (0);
  } else
#line 212
  if (glob_ret != 0) {
#line 213
    fdprintf(out, "Error; Unknown glob() error %d\r\n", glob_ret);
#line 214
    return (0);
  } else {

  }
#line 219
  tmp___2 = __builtin_alloca(sizeof(file_info_t ) * glob_buf.gl_pathc);
#line 219
  file_info = (file_info_t *)tmp___2;
#line 223
  if ((unsigned long )file_info == (unsigned long )((void *)0)) {
#line 224
    fdprintf(out, "Error; Out of memory\r\n");
#line 225
    globfree(& glob_buf);
#line 226
    return (0);
  } else {

  }
#line 230
  num_files = 0;
#line 231
  total_blocks = 0UL;
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if ((size_t )i < glob_buf.gl_pathc) {

    } else {
#line 232
      goto while_break;
    }
#line 233
    mem_42 = glob_buf.gl_pathv + i;
#line 233
    file_name = *mem_42;
#line 234
    tmp___3 = memcmp((void const   *)file_name, (void const   *)(pattern), (size_t )dir_len);
#line 234
    if (tmp___3 == 0) {
#line 235
      file_name += dir_len;
    } else {

    }
#line 237
    mem_43 = glob_buf.gl_pathv + i;
#line 237
    mem_44 = file_info + num_files;
#line 237
    tmp___4 = lstat((char const   * __restrict  )((char const   *)*mem_43), (struct stat * __restrict  )(& mem_44->stat));
#line 237
    if (tmp___4 == (int __attribute__((__gnu_inline__))  )0) {
#line 241
      mem_45 = file_info + num_files;
#line 241
      mem_45->name = file_name;
#line 242
      mem_46 = file_info + num_files;
#line 242
      mem_47 = glob_buf.gl_pathv + i;
#line 242
      mem_46->full_path = *mem_47;
#line 243
      num_files ++;
    } else {

    }
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  fdprintf(out, "total %lu\r\n", total_blocks);
#line 249
  time(& now);
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if (i < num_files) {

    } else {
#line 250
      goto while_break___0;
    }
#line 252
    mem_48 = file_info + i;
#line 252
    mode = mem_48->stat.st_mode;
    {
#line 256
    if ((mode & 61440U) == 49152U) {
#line 256
      goto case_49152;
    } else {

    }
#line 257
    if ((mode & 61440U) == 40960U) {
#line 257
      goto case_40960;
    } else {

    }
#line 258
    if ((mode & 61440U) == 24576U) {
#line 258
      goto case_24576;
    } else {

    }
#line 259
    if ((mode & 61440U) == 16384U) {
#line 259
      goto case_16384;
    } else {

    }
#line 260
    if ((mode & 61440U) == 8192U) {
#line 260
      goto case_8192;
    } else {

    }
#line 261
    if ((mode & 61440U) == 4096U) {
#line 261
      goto case_4096;
    } else {

    }
#line 262
    goto switch_default;
    case_49152: /* CIL Label */ 
#line 256
    fdprintf(out, "s");
#line 256
    goto switch_break;
    case_40960: /* CIL Label */ 
#line 257
    fdprintf(out, "l");
#line 257
    goto switch_break;
    case_24576: /* CIL Label */ 
#line 258
    fdprintf(out, "b");
#line 258
    goto switch_break;
    case_16384: /* CIL Label */ 
#line 259
    fdprintf(out, "d");
#line 259
    goto switch_break;
    case_8192: /* CIL Label */ 
#line 260
    fdprintf(out, "c");
#line 260
    goto switch_break;
    case_4096: /* CIL Label */ 
#line 261
    fdprintf(out, "p");
#line 261
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 262
    fdprintf(out, "-");
    switch_break: /* CIL Label */ ;
    }
#line 266
    if ((mode & 256U) != 0) {
#line 266
      tmp___5 = "r";
    } else {
#line 266
      tmp___5 = "-";
    }
#line 266
    fdprintf(out, tmp___5);
#line 267
    if ((mode & 128U) != 0) {
#line 267
      tmp___6 = "w";
    } else {
#line 267
      tmp___6 = "-";
    }
#line 267
    fdprintf(out, tmp___6);
#line 268
    if ((mode & 2048U) != 0) {
#line 269
      if ((mode & 64U) != 0) {
#line 269
        tmp___7 = "s";
      } else {
#line 269
        tmp___7 = "S";
      }
#line 269
      fdprintf(out, tmp___7);
    } else {
#line 271
      if ((mode & 64U) != 0) {
#line 271
        tmp___8 = "x";
      } else {
#line 271
        tmp___8 = "-";
      }
#line 271
      fdprintf(out, tmp___8);
    }
#line 273
    if ((mode & (unsigned int )(256 >> 3)) != 0) {
#line 273
      tmp___9 = "r";
    } else {
#line 273
      tmp___9 = "-";
    }
#line 273
    fdprintf(out, tmp___9);
#line 274
    if ((mode & (unsigned int )(128 >> 3)) != 0) {
#line 274
      tmp___10 = "w";
    } else {
#line 274
      tmp___10 = "-";
    }
#line 274
    fdprintf(out, tmp___10);
#line 275
    if ((mode & 1024U) != 0) {
#line 276
      if ((mode & (unsigned int )(64 >> 3)) != 0) {
#line 276
        tmp___11 = "s";
      } else {
#line 276
        tmp___11 = "S";
      }
#line 276
      fdprintf(out, tmp___11);
    } else {
#line 278
      if ((mode & (unsigned int )(64 >> 3)) != 0) {
#line 278
        tmp___12 = "x";
      } else {
#line 278
        tmp___12 = "-";
      }
#line 278
      fdprintf(out, tmp___12);
    }
#line 280
    if ((mode & (unsigned int )((256 >> 3) >> 3)) != 0) {
#line 280
      tmp___13 = "r";
    } else {
#line 280
      tmp___13 = "-";
    }
#line 280
    fdprintf(out, tmp___13);
#line 281
    if ((mode & (unsigned int )((128 >> 3) >> 3)) != 0) {
#line 281
      tmp___14 = "w";
    } else {
#line 281
      tmp___14 = "-";
    }
#line 281
    fdprintf(out, tmp___14);
#line 282
    if ((mode & 512U) != 0) {
#line 283
      if ((mode & (unsigned int )((64 >> 3) >> 3)) != 0) {
#line 283
        tmp___15 = "t";
      } else {
#line 283
        tmp___15 = "T";
      }
#line 283
      fdprintf(out, tmp___15);
    } else {
#line 285
      if ((mode & (unsigned int )((64 >> 3) >> 3)) != 0) {
#line 285
        tmp___16 = "x";
      } else {
#line 285
        tmp___16 = "-";
      }
#line 285
      fdprintf(out, tmp___16);
    }
#line 289
    mem_49 = file_info + i;
#line 289
    mem_50 = file_info + i;
#line 289
    mem_51 = file_info + i;
#line 289
    fdprintf(out, " %3d %-8d %-8d ", mem_49->stat.st_nlink, mem_50->stat.st_uid, mem_51->stat.st_gid);
#line 305
    mem_52 = file_info + i;
#line 305
    fdprintf(out, "%8lu ", (unsigned long )mem_52->stat.st_size);
#line 309
    mem_53 = file_info + i;
#line 309
    localtime_r((time_t const   * __restrict  )((time_t const   *)(& mem_53->stat.st_mtim.tv_sec)),
                (struct tm * __restrict  )(& tm_now));
#line 310
    mem_54 = file_info + i;
#line 310
    age = difftime(now, mem_54->stat.st_mtim.tv_sec);
#line 311
    if (age > (double )15552000) {
#line 312
      strftime((char * __restrict  )(date_buf), sizeof(date_buf), (char const   * __restrict  )"%b %e  %Y",
               (struct tm  const  * __restrict  )((struct tm  const  *)(& tm_now)));
    } else
#line 311
    if (age < (double )-15552000) {
#line 312
      strftime((char * __restrict  )(date_buf), sizeof(date_buf), (char const   * __restrict  )"%b %e  %Y",
               (struct tm  const  * __restrict  )((struct tm  const  *)(& tm_now)));
    } else {
#line 314
      strftime((char * __restrict  )(date_buf), sizeof(date_buf), (char const   * __restrict  )"%b %e %H:%M",
               (struct tm  const  * __restrict  )((struct tm  const  *)(& tm_now)));
    }
#line 316
    fdprintf(out, "%s ", date_buf);
#line 319
    mem_55 = file_info + i;
#line 319
    fdprintf(out, "%s", mem_55->name);
#line 322
    if ((mode & 61440U) == 40960U) {
#line 323
      mem_56 = file_info + i;
#line 323
      tmp___17 = readlink((char const   * __restrict  )((char const   *)mem_56->full_path),
                          (char * __restrict  )(link___0), sizeof(link___0));
#line 323
      link_len = (int )tmp___17;
#line 324
      if (link_len > 0) {
#line 325
        fdprintf(out, " -> ");
#line 326
        link___0[link_len] = (char )'\000';
#line 327
        fdprintf(out, "%s", link___0);
      } else {

      }
    } else {

    }
#line 332
    fdprintf(out, "\r\n");
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 339
  globfree(& glob_buf);
#line 340
  return (1);
}
}
#line 343 "file_list.c"
static int is_valid_dir(char const   *dir ) 
{ 
  size_t tmp_ssa_1 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;
  char __cil_tmp8 ;
  int __cil_tmp9 ;

  {

#line 346
  return babel_wrapper_is_valid_dir(dir);
#line 346
  __cil_tmp4 = (unsigned long )dir == (unsigned long )((void *)0);
#line 346
  if (__cil_tmp4 != 0) {
#line 347
    return (0);
  } else {
#line 351
    __cil_tmp7 = dir + 0;
#line 351
    __cil_tmp8 = (char )*__cil_tmp7;
#line 351
    __cil_tmp9 = (int )((int const   )__cil_tmp8);
#line 351
    __cil_tmp5 = __cil_tmp9 != 47;
#line 351
    if (__cil_tmp5 != 0) {
#line 352
      return (0);
    } else {
#line 356
      tmp_ssa_1 = strlen(dir);
#line 356
      __cil_tmp6 = tmp_ssa_1 > 4096UL;
#line 356
      if (__cil_tmp6 != 0) {
#line 357
        return (0);
      } else {
#line 361
        return (1);
      }
    }
  }
}
}
#line 364 "file_list.c"
static void fdprintf(int fd , char const   *fmt  , ...) 
{ 
  char buf[4097] ;
  int buflen ;
  va_list ap ;
  int amt_written ;
  int write_ret ;
  ssize_t tmp ;

  {
#line 372
  if (fd < 0) {
#line 372
    daemon_assert_fail("fd >= 0", "file_list.c", 372, "fdprintf");
  } else {

  }
#line 373
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 373
    daemon_assert_fail("fmt != ((void *)0)", "file_list.c", 373, "fdprintf");
  } else {

  }
#line 375
  __builtin_va_start(ap, fmt);
#line 376
  buflen = vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
                     ap);
#line 377
  __builtin_va_end(ap);
#line 378
  if (buflen <= 0) {
#line 379
    return;
  } else {

  }
#line 381
  if ((unsigned long )buflen >= sizeof(buf)) {
#line 382
    buflen = (int )(sizeof(buf) - 1UL);
  } else {

  }
#line 385
  amt_written = 0;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (amt_written < buflen) {

    } else {
#line 386
      goto while_break;
    }
#line 387
    tmp = write(fd, (void const   *)(buf + amt_written), (size_t )(buflen - amt_written));
#line 387
    write_ret = (int )tmp;
#line 388
    if (write_ret <= 0) {
#line 389
      return;
    } else {

    }
#line 391
    amt_written += write_ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 399 "file_list.c"
static char const   *skip_ls_options(char const   *filespec ) 
{ 
  char const   **__cil_pp_filespec ;
  char const   **__cil_fp_filespec ;
  char const   *filespec_ssa_1 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 401
  __cil_fp_filespec = & filespec;
#line 401
  __cil_pp_filespec = & filespec;
#line 401
  return babel_wrapper_skip_ls_options(__cil_pp_filespec, __cil_fp_filespec, filespec);
#line 401
  __cil_pp_filespec = & filespec;
#line 402
  __cil_fp_filespec = & filespec;
#line 402
  __cil_tmp8 = (unsigned long )filespec != (unsigned long )((void *)0);
#line 402
  if (__cil_tmp8 == 0) {
#line 402
    daemon_assert_fail("filespec != ((void *)0)", "file_list.c", 402, "skip_ls_options");
  } else {

  }
#line 407
  *__cil_fp_filespec = filespec;
#line 404
  skip_ls_options_cil_lr_1(__cil_pp_filespec);
#line 405
  filespec_ssa_1 = *__cil_fp_filespec;
#line 431
  __cil_tmp9 = (unsigned long )filespec_ssa_1 != (unsigned long )((void *)0);
#line 431
  if (__cil_tmp9 == 0) {
#line 431
    daemon_assert_fail("filespec != ((void *)0)", "file_list.c", 431, "skip_ls_options");
  } else {

  }
#line 433
  return (filespec_ssa_1);
}
}
#line 436 "file_list.c"
void skip_ls_options_cil_lr_1_cil_lr_1(char const   **__cil_ap_filespec ) 
{ 
  unsigned short const   **tmp_ssa_1 ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;
  char __cil_tmp6 ;
  unsigned short const   *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned short const   *__cil_tmp9 ;
  unsigned short __cil_tmp10 ;
  int __cil_tmp11 ;
  char const   *__cil_tmp12 ;

  {

#line 414
  return babel_wrapper_skip_ls_options_cil_lr_1_cil_lr_1(__cil_ap_filespec);
#line 414
  tmp_ssa_1 = __ctype_b_loc();
#line 414
  __cil_tmp5 = *__cil_ap_filespec;
#line 414
  __cil_tmp6 = (char )*__cil_tmp5;
#line 414
  __cil_tmp7 = *tmp_ssa_1;
#line 414
  __cil_tmp8 = (int )__cil_tmp6;
#line 414
  __cil_tmp9 = __cil_tmp7 + __cil_tmp8;
#line 414
  __cil_tmp10 = (unsigned short )*__cil_tmp9;
#line 414
  __cil_tmp11 = (int )((int const   )__cil_tmp10);
#line 414
  __cil_tmp4 = __cil_tmp11 & 8192;
#line 414
  if (__cil_tmp4 != 0) {
#line 415
    __cil_tmp12 = *__cil_ap_filespec;
#line 415
    *__cil_ap_filespec = __cil_tmp12 + 1;
#line 418
    skip_ls_options_cil_lr_1_cil_lr_1(__cil_ap_filespec);
#line 420
    return;
  } else {
#line 422
    return;
  }
}
}
#line 427 "file_list.c"
void skip_ls_options_cil_lr_1_cil_lr_2(char const   **__cil_ap_filespec ) 
{ 
  unsigned short const   **tmp___0_ssa_1 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  char __cil_tmp7 ;
  int __cil_tmp8 ;
  char const   *__cil_tmp9 ;
  char __cil_tmp10 ;
  unsigned short const   *__cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned short const   *__cil_tmp13 ;
  unsigned short __cil_tmp14 ;
  int __cil_tmp15 ;
  char const   *__cil_tmp16 ;

  {

#line 421
  return babel_wrapper_skip_ls_options_cil_lr_1_cil_lr_2(__cil_ap_filespec);
#line 421
  __cil_tmp6 = *__cil_ap_filespec;
#line 421
  __cil_tmp7 = (char )*__cil_tmp6;
#line 421
  __cil_tmp8 = (int )((int const   )__cil_tmp7);
#line 421
  __cil_tmp4 = __cil_tmp8 != 0;
#line 421
  if (__cil_tmp4 != 0) {
#line 421
    tmp___0_ssa_1 = __ctype_b_loc();
#line 421
    __cil_tmp9 = *__cil_ap_filespec;
#line 421
    __cil_tmp10 = (char )*__cil_tmp9;
#line 421
    __cil_tmp11 = *tmp___0_ssa_1;
#line 421
    __cil_tmp12 = (int )__cil_tmp10;
#line 421
    __cil_tmp13 = __cil_tmp11 + __cil_tmp12;
#line 421
    __cil_tmp14 = (unsigned short )*__cil_tmp13;
#line 421
    __cil_tmp15 = (int )((int const   )__cil_tmp14);
#line 421
    __cil_tmp5 = __cil_tmp15 & 8192;
#line 421
    if (__cil_tmp5 != 0) {
#line 422
      return;
    } else {
#line 422
      __cil_tmp16 = *__cil_ap_filespec;
#line 422
      *__cil_ap_filespec = __cil_tmp16 + 1;
#line 425
      skip_ls_options_cil_lr_1_cil_lr_2(__cil_ap_filespec);
#line 427
      return;
    }
  } else {
#line 431
    return;
  }
}
}
#line 436 "file_list.c"
void skip_ls_options_cil_lr_1_cil_lr_3(char const   **__cil_ap_filespec ) 
{ 
  unsigned short const   **tmp___1_ssa_1 ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;
  char __cil_tmp6 ;
  unsigned short const   *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned short const   *__cil_tmp9 ;
  unsigned short __cil_tmp10 ;
  int __cil_tmp11 ;
  char const   *__cil_tmp12 ;

  {

#line 426
  return babel_wrapper_skip_ls_options_cil_lr_1_cil_lr_3(__cil_ap_filespec);
#line 426
  tmp___1_ssa_1 = __ctype_b_loc();
#line 426
  __cil_tmp5 = *__cil_ap_filespec;
#line 426
  __cil_tmp6 = (char )*__cil_tmp5;
#line 426
  __cil_tmp7 = *tmp___1_ssa_1;
#line 426
  __cil_tmp8 = (int )__cil_tmp6;
#line 426
  __cil_tmp9 = __cil_tmp7 + __cil_tmp8;
#line 426
  __cil_tmp10 = (unsigned short )*__cil_tmp9;
#line 426
  __cil_tmp11 = (int )((int const   )__cil_tmp10);
#line 426
  __cil_tmp4 = __cil_tmp11 & 8192;
#line 426
  if (__cil_tmp4 != 0) {
#line 427
    __cil_tmp12 = *__cil_ap_filespec;
#line 427
    *__cil_ap_filespec = __cil_tmp12 + 1;
#line 430
    skip_ls_options_cil_lr_1_cil_lr_3(__cil_ap_filespec);
#line 432
    return;
  } else {
#line 434
    return;
  }
}
}
#line 439 "file_list.c"
void skip_ls_options_cil_lr_1(char const   **__cil_ap_filespec ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char const   *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  char const   *__cil_tmp13 ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  char __cil_tmp18 ;
  int __cil_tmp19 ;
  char const   *__cil_tmp20 ;

  {

#line 406
  return babel_wrapper_skip_ls_options_cil_lr_1(__cil_ap_filespec);
#line 406
  __cil_tmp8 = *__cil_ap_filespec;
#line 406
  __cil_tmp9 = (char )*__cil_tmp8;
#line 406
  __cil_tmp10 = (int )((int const   )__cil_tmp9);
#line 406
  __cil_tmp5 = __cil_tmp10 != 45;
#line 406
  if (__cil_tmp5 != 0) {
#line 407
    return;
  } else {
#line 409
    __cil_tmp11 = *__cil_ap_filespec;
#line 409
    *__cil_ap_filespec = __cil_tmp11 + 1;
#line 412
    __cil_tmp12 = *__cil_ap_filespec;
#line 412
    __cil_tmp13 = __cil_tmp12 + 0;
#line 412
    __cil_tmp14 = (char )*__cil_tmp13;
#line 412
    __cil_tmp15 = (int )((int const   )__cil_tmp14);
#line 412
    __cil_tmp6 = __cil_tmp15 == 45;
#line 412
    if (__cil_tmp6 != 0) {
#line 412
      __cil_tmp16 = *__cil_ap_filespec;
#line 412
      __cil_tmp17 = __cil_tmp16 + 1;
#line 412
      __cil_tmp18 = (char )*__cil_tmp17;
#line 412
      __cil_tmp19 = (int )((int const   )__cil_tmp18);
#line 412
      __cil_tmp7 = __cil_tmp19 == 32;
#line 412
      if (__cil_tmp7 != 0) {
#line 413
        __cil_tmp20 = *__cil_ap_filespec;
#line 413
        *__cil_ap_filespec = __cil_tmp20 + 2;
#line 414
        skip_ls_options_cil_lr_1_cil_lr_1(__cil_ap_filespec);
#line 416
        return;
      } else {
#line 421
        skip_ls_options_cil_lr_1_cil_lr_2(__cil_ap_filespec);
#line 426
        skip_ls_options_cil_lr_1_cil_lr_3(__cil_ap_filespec);
#line 429
        skip_ls_options_cil_lr_1(__cil_ap_filespec);
#line 431
        return;
      }
    } else {
#line 421
      skip_ls_options_cil_lr_1_cil_lr_2(__cil_ap_filespec);
#line 426
      skip_ls_options_cil_lr_1_cil_lr_3(__cil_ap_filespec);
#line 429
      skip_ls_options_cil_lr_1(__cil_ap_filespec);
#line 431
      return;
    }
  }
}
}
#line 438 "file_list.c"
void file_nlst_cil_lr_1(glob_t *__cil_ap_glob_buf , int out , int dir_len , char *pattern ,
                        int i ) 
{ 
  char *file_name ;
  char *file_name_ssa_1 ;
  int tmp___2_ssa_1 ;
  char *file_name_ssa_2 ;
  int i_ssa_1 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  char ***__cil_tmp16 ;
  char **__cil_tmp17 ;
  char **__cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t *mem_19 ;

  {
#line 131
  mem_19 = (size_t *)__cil_ap_glob_buf;
#line 131
  __cil_tmp14 = *mem_19;
#line 131
  __cil_tmp12 = (size_t )i < __cil_tmp14;
#line 131
  if (__cil_tmp12 != 0) {
#line 132
    __cil_tmp15 = (unsigned char *)__cil_ap_glob_buf + 8;
#line 132
    __cil_tmp16 = (char ***)__cil_tmp15;
#line 132
    __cil_tmp17 = *__cil_tmp16;
#line 132
    __cil_tmp18 = __cil_tmp17 + i;
#line 132
    file_name_ssa_1 = *__cil_tmp18;
#line 133
    __cil_tmp19 = (char *)pattern;
#line 133
    tmp___2_ssa_1 = memcmp((void const   *)file_name_ssa_1, (void const   *)__cil_tmp19,
                           (size_t )dir_len);
#line 133
    __cil_tmp13 = tmp___2_ssa_1 == 0;
#line 133
    if (__cil_tmp13 != 0) {
#line 134
      file_name_ssa_2 = file_name_ssa_1 + dir_len;
    } else {
#line 137
      file_name_ssa_2 = file_name_ssa_1;
    }
#line 136
    fdprintf(out, "%s\r\n", file_name_ssa_2);
#line 131
    i_ssa_1 = i + 1;
#line 134
    file_nlst_cil_lr_1(__cil_ap_glob_buf, out, dir_len, pattern, i_ssa_1);
#line 136
    return;
  } else {
#line 138
    return;
  }
#line 136
  fdprintf(out, "%s\r\n", file_name);
#line 131
  i_ssa_1 = i + 1;
#line 134
  file_nlst_cil_lr_1(__cil_ap_glob_buf, out, dir_len, pattern, i_ssa_1);
#line 136
  return;
}
}
#include <gprolog.h>













































































































PlBool babel__implicit_is_valid_dirc_0(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_optionsc_1(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_optionsc_2(char const   ** arg_0) 
{
skip_ls_options_cil_lr_1(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_optionsc_3(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1_cil_lr_1c_4(PlLong * babel_ret) 
{
*babel_ret = __ctype_b_loc();
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1_cil_lr_2c_6(PlLong * babel_ret) 
{
*babel_ret = __ctype_b_loc();
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1_cil_lr_3c_8(PlLong * babel_ret) 
{
*babel_ret = __ctype_b_loc();
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1c_10(char const   ** arg_0) 
{
skip_ls_options_cil_lr_1_cil_lr_1(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1c_11(char const   ** arg_0) 
{
skip_ls_options_cil_lr_1_cil_lr_2(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1c_12(char const   ** arg_0) 
{
skip_ls_options_cil_lr_1_cil_lr_3(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1c_14(char const   ** arg_0) 
{
skip_ls_options_cil_lr_1_cil_lr_2(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_skip_ls_options_cil_lr_1c_15(char const   ** arg_0) 
{
skip_ls_options_cil_lr_1_cil_lr_3(arg_0);
return PL_TRUE;
}
