#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 216 "/usr/lib/gcc/x86_64-redhat-linux/5.1.1/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 131 "/usr/include/bits/types.h"
typedef long __off_t;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 28 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 49 "af_portability.h"
typedef struct sockaddr_in sockaddr_storage_t;
#line 48 "ftp_command.h"
union __anonunion_arg_27 {
   char string[4097] ;
   sockaddr_storage_t host_port ;
   int num ;
   off_t offset ;
};
#line 48 "ftp_command.h"
struct __anonstruct_ftp_command_t_26 {
   char command[5] ;
   int num_arg ;
   union __anonunion_arg_27 arg[2] ;
};
#line 48 "ftp_command.h"
typedef struct __anonstruct_ftp_command_t_26 ftp_command_t;
#line 32 "ftp_command.c"
struct __anonstruct_command_def_28 {
   char *name ;
   int arg_type ;
};
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 398
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 537
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 60 "ftp_command.h"
int ftp_command_parse(char const   *input , ftp_command_t *cmd ) ;
#line 10 "daemon_assert.h"
extern void daemon_assert_fail(char const   *assertion , char const   *file , int line ,
                               char const   *function ) ;
#line 32 "ftp_command.c"
struct __anonstruct_command_def_28 command_def[25]  = 
#line 32 "ftp_command.c"
  {      {(char *)"USER", 1}, 
        {(char *)"PASS", 1}, 
        {(char *)"CWD", 1}, 
        {(char *)"CDUP", 0}, 
        {(char *)"QUIT", 0}, 
        {(char *)"PORT", 3}, 
        {(char *)"LPRT", 8}, 
        {(char *)"EPRT", 9}, 
        {(char *)"PASV", 0}, 
        {(char *)"LPSV", 0}, 
        {(char *)"EPSV", 10}, 
        {(char *)"TYPE", 4}, 
        {(char *)"STRU", 5}, 
        {(char *)"MODE", 6}, 
        {(char *)"RETR", 1}, 
        {(char *)"STOR", 1}, 
        {(char *)"PWD", 0}, 
        {(char *)"LIST", 2}, 
        {(char *)"NLST", 2}, 
        {(char *)"SYST", 0}, 
        {(char *)"HELP", 2}, 
        {(char *)"NOOP", 0}, 
        {(char *)"REST", 7}, 
        {(char *)"SIZE", 1}, 
        {(char *)"MDTM", 1}};
#line 66
static char const   *copy_string(char *dst , char const   *src ) ;
#line 67
static char const   *parse_host_port(struct sockaddr_in *addr , char const   *s ) ;
#line 68
static char const   *parse_number(int *num , char const   *s , int max_num ) ;
#line 69
static char const   *parse_offset(off_t *ofs , char const   *s ) ;
#line 70
static char const   *parse_host_port_long(sockaddr_storage_t *sa , char const   *s ) ;
#line 71
static char const   *parse_host_port_ext(sockaddr_storage_t *sa , char const   *s ) ;
#line 72
int parse_offset_cil_lr_1(off_t **__cil_ap_ofs , char const   **__cil_ap_s , off_t *__cil_ap_tmp_ofs ,
                          char const   **__cil_ap___cil_ret8 , off_t max_ofs ) ;
#line 74
int parse_number_cil_lr_1(int **__cil_ap_num , char const   **__cil_ap_s , int *__cil_ap_max_num ,
                          int *__cil_ap_tmp , char const   **__cil_ap___cil_ret8 ) ;
#line 76
void copy_string_cil_lr_1(char **__cil_ap_dst , char const   **__cil_ap_src , int *__cil_ap_i ) ;
   char const   * babel_wrapper_copy_string(char ** __cil_pp_dst, char const   ** __cil_pp_src, int * __cil_pp_i, char ** __cil_fp_dst, char const   ** __cil_fp_src, int * __cil_fp_i, char * dst, char const   * src)                           // function name insert
      {
        // wrapper for function copy_string        // function name insert
         char const   * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[9];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("copy_string"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_dst);
arg[1] = Pl_Mk_Integer(__cil_pp_src);
arg[2] = Pl_Mk_Integer(__cil_pp_i);
arg[3] = Pl_Mk_Integer(__cil_fp_dst);
arg[4] = Pl_Mk_Integer(__cil_fp_src);
arg[5] = Pl_Mk_Integer(__cil_fp_i);
arg[6] = Pl_Mk_Integer(dst);
arg[7] = Pl_Mk_Integer(src);

      //routine code, reserve a place for return value
      arg[8] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 9, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[8]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   char const   * babel_wrapper_parse_number(int ** __cil_pp_num, char const   ** __cil_pp_s, int * __cil_pp_max_num, int * __cil_pp_tmp, char const   ** __cil_pp___cil_ret8, int ** __cil_fp_num, char const   ** __cil_fp_s, int * __cil_fp_max_num, int * __cil_fp_tmp, char const   ** __cil_fp___cil_ret8, int * num, char const   * s, int  max_num)                           // function name insert
      {
        // wrapper for function parse_number        // function name insert
         char const   * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[14];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("parse_number"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_num);
arg[1] = Pl_Mk_Integer(__cil_pp_s);
arg[2] = Pl_Mk_Integer(__cil_pp_max_num);
arg[3] = Pl_Mk_Integer(__cil_pp_tmp);
arg[4] = Pl_Mk_Integer(__cil_pp___cil_ret8);
arg[5] = Pl_Mk_Integer(__cil_fp_num);
arg[6] = Pl_Mk_Integer(__cil_fp_s);
arg[7] = Pl_Mk_Integer(__cil_fp_max_num);
arg[8] = Pl_Mk_Integer(__cil_fp_tmp);
arg[9] = Pl_Mk_Integer(__cil_fp___cil_ret8);
arg[10] = Pl_Mk_Integer(num);
arg[11] = Pl_Mk_Integer(s);
arg[12] = Pl_Mk_Integer(max_num);

      //routine code, reserve a place for return value
      arg[13] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 14, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[13]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int  babel_wrapper_parse_number_cil_lr_1(int ** __cil_ap_num, char const   ** __cil_ap_s, int * __cil_ap_max_num, int * __cil_ap_tmp, char const   ** __cil_ap___cil_ret8)                           // function name insert
      {
        // wrapper for function parse_number_cil_lr_1        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("parse_number_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_num);
arg[1] = Pl_Mk_Integer(__cil_ap_s);
arg[2] = Pl_Mk_Integer(__cil_ap_max_num);
arg[3] = Pl_Mk_Integer(__cil_ap_tmp);
arg[4] = Pl_Mk_Integer(__cil_ap___cil_ret8);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_copy_string_cil_lr_1(char ** __cil_ap_dst, char const   ** __cil_ap_src, int * __cil_ap_i)                           // function name insert
      {
        // wrapper for function copy_string_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("copy_string_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_dst);
arg[1] = Pl_Mk_Integer(__cil_ap_src);
arg[2] = Pl_Mk_Integer(__cil_ap_i);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 73 "ftp_command.c"
int ftp_command_parse(char const   *input , ftp_command_t *cmd ) 
{ 
  int i ;
  int len ;
  int match ;
  ftp_command_t tmp ;
  int c ;
  char const   *optional_number ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int __res ;
  int __attribute__((__gnu_inline__))  tmp___4 ;
  __int32_t const   **tmp___5 ;
  int __res___0 ;
  int __attribute__((__gnu_inline__))  tmp___7 ;
  __int32_t const   **tmp___8 ;
  int __res___1 ;
  int __attribute__((__gnu_inline__))  tmp___10 ;
  __int32_t const   **tmp___11 ;
  int __res___2 ;
  int __attribute__((__gnu_inline__))  tmp___13 ;
  __int32_t const   **tmp___14 ;
  int __res___3 ;
  int __attribute__((__gnu_inline__))  tmp___16 ;
  __int32_t const   **tmp___17 ;
  int __res___4 ;
  int __attribute__((__gnu_inline__))  tmp___19 ;
  __int32_t const   **tmp___20 ;
  int __res___5 ;
  int __attribute__((__gnu_inline__))  tmp___22 ;
  __int32_t const   **tmp___23 ;
  char const   *mem_33 ;
  char const   *mem_34 ;
  char const   *mem_35 ;
  __int32_t const   *mem_36 ;
  char const   *mem_37 ;
  char const   *mem_38 ;
  char const   *mem_39 ;
  __int32_t const   *mem_40 ;
  char const   *mem_41 ;
  char const   *mem_42 ;
  char const   *mem_43 ;
  __int32_t const   *mem_44 ;
  __int32_t const   *mem_45 ;
  __int32_t const   *mem_46 ;
  __int32_t const   *mem_47 ;
  __int32_t const   *mem_48 ;

  {
#line 82
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 82
    daemon_assert_fail("input != ((void *)0)", "ftp_command.c", 82, "ftp_command_parse");
  } else {

  }
#line 83
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 83
    daemon_assert_fail("cmd != ((void *)0)", "ftp_command.c", 83, "ftp_command_parse");
  } else {

  }
#line 86
  match = -1;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if ((unsigned long )i < sizeof(command_def) / sizeof(command_def[0])) {
#line 87
      if (match != -1) {
#line 87
        goto while_break;
      } else {

      }
    } else {
#line 87
      goto while_break;
    }
#line 88
    tmp___0 = strlen((char const   *)command_def[i].name);
#line 88
    len = (int )tmp___0;
#line 89
    tmp___1 = strncasecmp(input, (char const   *)command_def[i].name, (size_t )len);
#line 89
    if (tmp___1 == 0) {
#line 90
      match = i;
    } else {

    }
#line 87
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if (match == -1) {
#line 96
    return (0);
  } else {

  }
#line 98
  if (match < 0) {
#line 98
    daemon_assert_fail("match >= 0", "ftp_command.c", 98, "ftp_command_parse");
  } else {

  }
#line 99
  if ((unsigned long )match >= sizeof(command_def) / sizeof(command_def[0])) {
#line 99
    daemon_assert_fail("match < (sizeof(command_def) / sizeof(command_def[0]))", "ftp_command.c",
                       99, "ftp_command_parse");
  } else {

  }
#line 102
  strcpy((char * __restrict  )(tmp.command), (char const   * __restrict  )((char const   *)command_def[match].name));
#line 105
  tmp___2 = strlen((char const   *)command_def[match].name);
#line 105
  input += tmp___2;
  {
#line 109
  if (command_def[match].arg_type == 0) {
#line 109
    goto case_0;
  } else {

  }
#line 113
  if (command_def[match].arg_type == 1) {
#line 113
    goto case_1;
  } else {

  }
#line 122
  if (command_def[match].arg_type == 2) {
#line 122
    goto case_2;
  } else {

  }
#line 132
  if (command_def[match].arg_type == 3) {
#line 132
    goto case_3;
  } else {

  }
#line 146
  if (command_def[match].arg_type == 8) {
#line 146
    goto case_8;
  } else {

  }
#line 160
  if (command_def[match].arg_type == 9) {
#line 160
    goto case_9;
  } else {

  }
#line 174
  if (command_def[match].arg_type == 10) {
#line 174
    goto case_10;
  } else {

  }
#line 198
  if (command_def[match].arg_type == 4) {
#line 198
    goto case_4;
  } else {

  }
#line 243
  if (command_def[match].arg_type == 5) {
#line 243
    goto case_5;
  } else {

  }
#line 259
  if (command_def[match].arg_type == 6) {
#line 259
    goto case_6;
  } else {

  }
#line 275
  if (command_def[match].arg_type == 7) {
#line 275
    goto case_7;
  } else {

  }
#line 287
  goto switch_default;
  case_0: /* CIL Label */ 
#line 111
  tmp.num_arg = 0;
#line 112
  goto switch_break;
  case_1: /* CIL Label */ 
#line 115
  if ((int const   )*input != 32) {
#line 116
    return (0);
  } else {

  }
#line 118
  input ++;
#line 119
  input = copy_string(tmp.arg[0].string, input);
#line 120
  tmp.num_arg = 1;
#line 121
  goto switch_break;
  case_2: /* CIL Label */ 
#line 124
  if ((int const   )*input == 32) {
#line 125
    input ++;
#line 126
    input = copy_string(tmp.arg[0].string, input);
#line 127
    tmp.num_arg = 1;
  } else {
#line 129
    tmp.num_arg = 0;
  }
#line 131
  goto switch_break;
  case_3: /* CIL Label */ 
#line 134
  if ((int const   )*input != 32) {
#line 135
    return (0);
  } else {

  }
#line 137
  input ++;
#line 140
  input = parse_host_port(& tmp.arg[0].host_port, input);
#line 141
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 142
    return (0);
  } else {

  }
#line 144
  tmp.num_arg = 1;
#line 145
  goto switch_break;
  case_8: /* CIL Label */ 
#line 148
  if ((int const   )*input != 32) {
#line 149
    return (0);
  } else {

  }
#line 151
  input ++;
#line 154
  input = parse_host_port_long(& tmp.arg[0].host_port, input);
#line 155
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 156
    return (0);
  } else {

  }
#line 158
  tmp.num_arg = 1;
#line 159
  goto switch_break;
  case_9: /* CIL Label */ 
#line 162
  if ((int const   )*input != 32) {
#line 163
    return (0);
  } else {

  }
#line 165
  input ++;
#line 168
  input = parse_host_port_ext(& tmp.arg[0].host_port, input);
#line 169
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 170
    return (0);
  } else {

  }
#line 172
  tmp.num_arg = 1;
#line 173
  goto switch_break;
  case_10: /* CIL Label */ 
#line 177
  if ((int const   )*input == 32) {
#line 178
    input ++;
#line 179
    optional_number = parse_number(& tmp.arg[0].num, input, 255);
#line 180
    if ((unsigned long )optional_number != (unsigned long )((void *)0)) {
#line 181
      input = optional_number;
    } else {
      {
#line 183
      mem_33 = input + 0;
#line 183
      if (sizeof(*mem_33) > 1UL) {
#line 183
        mem_34 = input + 0;
#line 183
        tmp___4 = tolower((int )*mem_34);
#line 183
        __res = (int )tmp___4;
      } else {
#line 183
        tmp___5 = __ctype_tolower_loc();
#line 183
        mem_35 = input + 0;
#line 183
        mem_36 = *tmp___5 + (int )*mem_35;
#line 183
        __res = (int )*mem_36;
      }
      }
#line 185
      if (__res == 97) {
        {
#line 184
        mem_37 = input + 1;
#line 184
        if (sizeof(*mem_37) > 1UL) {
#line 184
          mem_38 = input + 1;
#line 184
          tmp___7 = tolower((int )*mem_38);
#line 184
          __res___0 = (int )tmp___7;
        } else {
#line 184
          tmp___8 = __ctype_tolower_loc();
#line 184
          mem_39 = input + 1;
#line 184
          mem_40 = *tmp___8 + (int )*mem_39;
#line 184
          __res___0 = (int )*mem_40;
        }
        }
#line 185
        if (__res___0 == 108) {
          {
#line 185
          mem_41 = input + 2;
#line 185
          if (sizeof(*mem_41) > 1UL) {
#line 185
            mem_42 = input + 2;
#line 185
            tmp___10 = tolower((int )*mem_42);
#line 185
            __res___1 = (int )tmp___10;
          } else {
#line 185
            tmp___11 = __ctype_tolower_loc();
#line 185
            mem_43 = input + 2;
#line 185
            mem_44 = *tmp___11 + (int )*mem_43;
#line 185
            __res___1 = (int )*mem_44;
          }
          }
#line 185
          if (__res___1 == 108) {
#line 187
            tmp.arg[0].num = -1;
#line 188
            input += 3;
          } else {
#line 190
            return (0);
          }
        } else {
#line 190
          return (0);
        }
      } else {
#line 190
        return (0);
      }
    }
#line 193
    tmp.num_arg = 1;
  } else {
#line 195
    tmp.num_arg = 0;
  }
#line 197
  goto switch_break;
  case_4: /* CIL Label */ 
#line 200
  if ((int const   )*input != 32) {
#line 201
    return (0);
  } else {

  }
#line 203
  input ++;
#line 205
  if (sizeof(*input) > 1UL) {
#line 205
    tmp___13 = toupper((int )*input);
#line 205
    __res___2 = (int )tmp___13;
  } else {
#line 205
    tmp___14 = __ctype_toupper_loc();
#line 205
    mem_45 = *tmp___14 + (int )*input;
#line 205
    __res___2 = (int )*mem_45;
  }
#line 205
  c = __res___2;
#line 206
  if (c == 65) {
#line 206
    goto _L;
  } else
#line 206
  if (c == 69) {
    _L: 
#line 207
    tmp.arg[0].string[0] = (char )c;
#line 208
    tmp.arg[0].string[1] = (char )'\000';
#line 209
    input ++;
#line 211
    if ((int const   )*input == 32) {
#line 212
      input ++;
#line 213
      if (sizeof(*input) > 1UL) {
#line 213
        tmp___16 = toupper((int )*input);
#line 213
        __res___3 = (int )tmp___16;
      } else {
#line 213
        tmp___17 = __ctype_toupper_loc();
#line 213
        mem_46 = *tmp___17 + (int )*input;
#line 213
        __res___3 = (int )*mem_46;
      }
#line 213
      c = __res___3;
#line 214
      if (c != 78) {
#line 214
        if (c != 84) {
#line 214
          if (c != 67) {
#line 215
            return (0);
          } else {

          }
        } else {

        }
      } else {

      }
#line 217
      tmp.arg[1].string[0] = (char )c;
#line 218
      tmp.arg[1].string[1] = (char )'\000';
#line 219
      input ++;
#line 220
      tmp.num_arg = 2;
    } else {
#line 222
      tmp.num_arg = 1;
    }
  } else
#line 224
  if (c == 73) {
#line 225
    tmp.arg[0].string[0] = (char )'I';
#line 226
    tmp.arg[0].string[1] = (char )'\000';
#line 227
    input ++;
#line 228
    tmp.num_arg = 1;
  } else
#line 229
  if (c == 76) {
#line 230
    tmp.arg[0].string[0] = (char )'L';
#line 231
    tmp.arg[0].string[1] = (char )'\000';
#line 232
    input ++;
#line 233
    input = parse_number(& tmp.arg[1].num, input, 255);
#line 234
    if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 235
      return (0);
    } else {

    }
#line 237
    tmp.num_arg = 2;
  } else {
#line 239
    return (0);
  }
#line 242
  goto switch_break;
  case_5: /* CIL Label */ 
#line 245
  if ((int const   )*input != 32) {
#line 246
    return (0);
  } else {

  }
#line 248
  input ++;
#line 250
  if (sizeof(*input) > 1UL) {
#line 250
    tmp___19 = toupper((int )*input);
#line 250
    __res___4 = (int )tmp___19;
  } else {
#line 250
    tmp___20 = __ctype_toupper_loc();
#line 250
    mem_47 = *tmp___20 + (int )*input;
#line 250
    __res___4 = (int )*mem_47;
  }
#line 250
  c = __res___4;
#line 251
  if (c != 70) {
#line 251
    if (c != 82) {
#line 251
      if (c != 80) {
#line 252
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
#line 254
  input ++;
#line 255
  tmp.arg[0].string[0] = (char )c;
#line 256
  tmp.arg[0].string[1] = (char )'\000';
#line 257
  tmp.num_arg = 1;
#line 258
  goto switch_break;
  case_6: /* CIL Label */ 
#line 261
  if ((int const   )*input != 32) {
#line 262
    return (0);
  } else {

  }
#line 264
  input ++;
#line 266
  if (sizeof(*input) > 1UL) {
#line 266
    tmp___22 = toupper((int )*input);
#line 266
    __res___5 = (int )tmp___22;
  } else {
#line 266
    tmp___23 = __ctype_toupper_loc();
#line 266
    mem_48 = *tmp___23 + (int )*input;
#line 266
    __res___5 = (int )*mem_48;
  }
#line 266
  c = __res___5;
#line 267
  if (c != 83) {
#line 267
    if (c != 66) {
#line 267
      if (c != 67) {
#line 268
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
#line 270
  input ++;
#line 271
  tmp.arg[0].string[0] = (char )c;
#line 272
  tmp.arg[0].string[1] = (char )'\000';
#line 273
  tmp.num_arg = 1;
#line 274
  goto switch_break;
  case_7: /* CIL Label */ 
#line 277
  if ((int const   )*input != 32) {
#line 278
    return (0);
  } else {

  }
#line 280
  input ++;
#line 281
  input = parse_offset(& tmp.arg[0].offset, input);
#line 282
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 283
    return (0);
  } else {

  }
#line 285
  tmp.num_arg = 1;
#line 286
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 289
  daemon_assert_fail("0", "ftp_command.c", 289, "ftp_command_parse");
  switch_break: /* CIL Label */ ;
  }
#line 293
  if ((int const   )*input != 10) {
#line 294
    return (0);
  } else {

  }
#line 298
  *cmd = tmp;
#line 299
  return (1);
}
}
#line 303 "ftp_command.c"
static char const   *copy_string(char *dst , char const   *src ) 
{ 
  int i ;
  char **__cil_pp_dst ;
  char const   **__cil_pp_src ;
  int *__cil_pp_i ;
  char **__cil_fp_dst ;
  char const   **__cil_fp_src ;
  int *__cil_fp_i ;
  int i_ssa_1 ;
  char *dst_ssa_1 ;
  char const   *src_ssa_1 ;
  int i_ssa_2 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 306
  __cil_fp_i = & i;
#line 306
  __cil_fp_src = & src;
#line 306
  __cil_fp_dst = & dst;
#line 306
  __cil_pp_i = & i;
#line 306
  __cil_pp_src = & src;
#line 306
  __cil_pp_dst = & dst;
#line 306
  return babel_wrapper_copy_string(__cil_pp_dst, __cil_pp_src, __cil_pp_i, __cil_fp_dst,
                                   __cil_fp_src, __cil_fp_i, dst, src);
#line 306
  __cil_pp_dst = & dst;
#line 307
  __cil_pp_src = & src;
#line 308
  __cil_pp_i = & i;
#line 309
  __cil_fp_dst = & dst;
#line 310
  __cil_fp_src = & src;
#line 311
  __cil_fp_i = & i;
#line 307
  __cil_tmp14 = (unsigned long )dst != (unsigned long )((void *)0);
#line 307
  if (__cil_tmp14 == 0) {
#line 307
    daemon_assert_fail("dst != ((void *)0)", "ftp_command.c", 307, "copy_string");
  } else {

  }
#line 308
  __cil_tmp15 = (unsigned long )src != (unsigned long )((void *)0);
#line 308
  if (__cil_tmp15 == 0) {
#line 308
    daemon_assert_fail("src != ((void *)0)", "ftp_command.c", 308, "copy_string");
  } else {

  }
#line 310
  i_ssa_1 = 0;
#line 313
  *__cil_fp_dst = dst;
#line 314
  *__cil_fp_src = src;
#line 315
  *__cil_fp_i = i_ssa_1;
#line 310
  copy_string_cil_lr_1(__cil_pp_dst, __cil_pp_src, __cil_pp_i);
#line 311
  dst_ssa_1 = *__cil_fp_dst;
#line 312
  src_ssa_1 = *__cil_fp_src;
#line 313
  i_ssa_2 = *__cil_fp_i;
#line 313
  __cil_tmp17 = dst_ssa_1 + i_ssa_2;
#line 313
  *__cil_tmp17 = (char )'\000';
#line 315
  __cil_tmp16 = src_ssa_1 + i_ssa_2;
#line 315
  return (__cil_tmp16);
}
}
#line 319 "ftp_command.c"
static char const   *parse_host_port(struct sockaddr_in *addr , char const   *s ) 
{ 
  int i ;
  int octets[6] ;
  char addr_str[16] ;
  int port ;
  struct in_addr in_addr ;
  int tmp ;
  unsigned short __v ;
  unsigned short __x ;

  {
#line 327
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 327
    daemon_assert_fail("addr != ((void *)0)", "ftp_command.c", 327, "parse_host_port");
  } else {

  }
#line 328
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 328
    daemon_assert_fail("s != ((void *)0)", "ftp_command.c", 328, "parse_host_port");
  } else {

  }
#line 331
  i = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (i < 5) {

    } else {
#line 331
      goto while_break;
    }
#line 332
    s = parse_number(& octets[i], s, 255);
#line 333
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 334
      return ((char const   *)((void *)0));
    } else {

    }
#line 336
    if ((int const   )*s != 44) {
#line 337
      return ((char const   *)((void *)0));
    } else {

    }
#line 339
    s ++;
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  s = parse_number(& octets[5], s, 255);
#line 344
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 345
    return ((char const   *)((void *)0));
  } else {

  }
#line 348
  if (octets[0] < 0) {
#line 348
    daemon_assert_fail("octets[0] >= 0", "ftp_command.c", 348, "parse_host_port");
  } else {

  }
#line 349
  if (octets[0] > 255) {
#line 349
    daemon_assert_fail("octets[0] <= 255", "ftp_command.c", 349, "parse_host_port");
  } else {

  }
#line 350
  if (octets[1] < 0) {
#line 350
    daemon_assert_fail("octets[1] >= 0", "ftp_command.c", 350, "parse_host_port");
  } else {

  }
#line 351
  if (octets[1] > 255) {
#line 351
    daemon_assert_fail("octets[1] <= 255", "ftp_command.c", 351, "parse_host_port");
  } else {

  }
#line 352
  if (octets[2] < 0) {
#line 352
    daemon_assert_fail("octets[2] >= 0", "ftp_command.c", 352, "parse_host_port");
  } else {

  }
#line 353
  if (octets[2] > 255) {
#line 353
    daemon_assert_fail("octets[2] <= 255", "ftp_command.c", 353, "parse_host_port");
  } else {

  }
#line 354
  if (octets[3] < 0) {
#line 354
    daemon_assert_fail("octets[3] >= 0", "ftp_command.c", 354, "parse_host_port");
  } else {

  }
#line 355
  if (octets[3] > 255) {
#line 355
    daemon_assert_fail("octets[3] <= 255", "ftp_command.c", 355, "parse_host_port");
  } else {

  }
#line 358
  sprintf((char * __restrict  )(addr_str), (char const   * __restrict  )"%d.%d.%d.%d",
          octets[0], octets[1], octets[2], octets[3]);
#line 360
  port = (octets[4] << 8) | octets[5];
#line 362
  tmp = inet_aton((char const   *)(addr_str), & in_addr);
#line 362
  if (tmp == 0) {
#line 363
    return ((char const   *)((void *)0));
  } else {

  }
#line 371
  addr->sin_family = (sa_family_t )2;
#line 372
  addr->sin_addr = in_addr;
#line 373
  __x = (unsigned short )port;
#line 373
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 373
  addr->sin_port = __v;
#line 376
  return (s);
}
}
#line 381 "ftp_command.c"
static char const   *parse_host_port_long(sockaddr_storage_t *sa , char const   *s ) 
{ 
  int i ;
  int family ;
  int tmp ;
  int addr_len ;
  unsigned char addr[255] ;
  int port_len ;
  unsigned char port[255] ;
  unsigned short __v ;
  unsigned short __x ;
  struct sockaddr *mem_12 ;
  struct sockaddr *mem_13 ;

  {
#line 392
  s = parse_number(& family, s, 255);
#line 393
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 394
    return ((char const   *)((void *)0));
  } else {

  }
#line 396
  if ((int const   )*s != 44) {
#line 397
    return ((char const   *)((void *)0));
  } else {

  }
#line 399
  s ++;
#line 402
  s = parse_number(& addr_len, s, 255);
#line 403
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 404
    return ((char const   *)((void *)0));
  } else {

  }
#line 406
  if ((int const   )*s != 44) {
#line 407
    return ((char const   *)((void *)0));
  } else {

  }
#line 409
  s ++;
#line 412
  i = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (i < addr_len) {

    } else {
#line 412
      goto while_break;
    }
#line 413
    if ((unsigned long )i >= sizeof(addr) / sizeof(addr[0])) {
#line 413
      daemon_assert_fail("i < sizeof(addr)/sizeof(addr[0])", "ftp_command.c", 413,
                         "parse_host_port_long");
    } else {

    }
#line 414
    s = parse_number(& tmp, s, 255);
#line 415
    addr[i] = (unsigned char )tmp;
#line 416
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 417
      return ((char const   *)((void *)0));
    } else {

    }
#line 419
    if ((int const   )*s != 44) {
#line 420
      return ((char const   *)((void *)0));
    } else {

    }
#line 422
    s ++;
#line 412
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  s = parse_number(& port_len, s, 255);
#line 427
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 428
    return ((char const   *)((void *)0));
  } else {

  }
#line 432
  i = 0;
  {
#line 432
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 432
    if (i < port_len) {

    } else {
#line 432
      goto while_break___0;
    }
#line 433
    if ((int const   )*s != 44) {
#line 434
      return ((char const   *)((void *)0));
    } else {

    }
#line 436
    s ++;
#line 437
    if ((unsigned long )i >= sizeof(port) / sizeof(port[0])) {
#line 437
      daemon_assert_fail("i < sizeof(port)/sizeof(port[0])", "ftp_command.c", 437,
                         "parse_host_port_long");
    } else {

    }
#line 438
    s = parse_number(& tmp, s, 255);
#line 439
    port[i] = (unsigned char )tmp;
#line 432
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 443
  if (family == 4) {
#line 444
    mem_12 = (struct sockaddr *)sa;
#line 444
    mem_12->sa_family = (sa_family_t )2;
#line 445
    if ((unsigned long )addr_len != sizeof(struct in_addr )) {
#line 446
      return ((char const   *)((void *)0));
    } else {

    }
#line 448
    if (port_len != 2) {
#line 449
      return ((char const   *)((void *)0));
    } else {

    }
#line 451
    memcpy((void * __restrict  )((void *)(& sa->sin_addr)), (void const   * __restrict  )((void const   *)(addr)),
           (size_t )addr_len);
#line 452
    __x = (unsigned short )(((int )port[0] << 8) + (int )port[1]);
#line 452
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 452
    sa->sin_port = __v;
  } else {
#line 468
    mem_13 = (struct sockaddr *)sa;
#line 468
    mem_13->sa_family = (sa_family_t )-1;
  }
#line 472
  return (s);
}
}
#line 475 "ftp_command.c"
static char const   *parse_host_port_ext(sockaddr_storage_t *sa , char const   *s ) 
{ 
  int delimeter ;
  int family ;
  char *p ;
  int len ;
  char addr_str[256] ;
  int port ;
  char *tmp___0 ;
  struct in_addr in_addr ;
  int tmp___1 ;
  unsigned short __v ;
  unsigned short __x ;
  struct sockaddr *mem_14 ;

  {
#line 485
  if ((int const   )*s < 33) {
#line 486
    return ((char const   *)((void *)0));
  } else
#line 485
  if ((int const   )*s > 126) {
#line 486
    return ((char const   *)((void *)0));
  } else {

  }
#line 488
  delimeter = (int )*s;
#line 489
  s ++;
#line 492
  if ((int const   )*s == 49) {
#line 493
    family = 2;
  } else {
#line 501
    return ((char const   *)((void *)0));
  }
#line 503
  s ++;
#line 504
  if ((int const   )*s != (int const   )delimeter) {
#line 505
    return ((char const   *)((void *)0));
  } else {

  }
#line 507
  s ++;
#line 510
  tmp___0 = __builtin_strchr((char *)s, delimeter);
#line 510
  p = tmp___0;
#line 511
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 512
    return ((char const   *)((void *)0));
  } else {

  }
#line 514
  len = (int )(p - (char *)s);
#line 515
  if ((unsigned long )len >= sizeof(addr_str)) {
#line 516
    return ((char const   *)((void *)0));
  } else {

  }
#line 518
  memcpy((void * __restrict  )((void *)(addr_str)), (void const   * __restrict  )((void const   *)s),
         (size_t )len);
#line 519
  addr_str[len] = (char )'\000';
#line 520
  s = (char const   *)(p + 1);
#line 523
  s = parse_number(& port, s, 65535);
#line 524
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 525
    return ((char const   *)((void *)0));
  } else {

  }
#line 527
  if ((int const   )*s != (int const   )delimeter) {
#line 528
    return ((char const   *)((void *)0));
  } else {

  }
#line 530
  s ++;
#line 538
  tmp___1 = inet_aton((char const   *)(addr_str), & in_addr);
#line 538
  if (tmp___1 == 0) {
#line 539
    return ((char const   *)((void *)0));
  } else {

  }
#line 548
  sa->sin_addr = in_addr;
#line 569
  mem_14 = (struct sockaddr *)sa;
#line 569
  mem_14->sa_family = (sa_family_t )family;
#line 570
  __x = (unsigned short )port;
#line 570
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 570
  sa->sin_port = __v;
#line 573
  return (s);
}
}
#line 579 "ftp_command.c"
static char const   *parse_number(int *num , char const   *s , int max_num ) 
{ 
  int tmp ;
  char const   *__cil_ret8 ;
  int **__cil_pp_num ;
  char const   **__cil_pp_s ;
  int *__cil_pp_max_num ;
  int *__cil_pp_tmp ;
  char const   **__cil_pp___cil_ret8 ;
  int **__cil_fp_num ;
  char const   **__cil_fp_s ;
  int *__cil_fp_max_num ;
  int *__cil_fp_tmp ;
  char const   **__cil_fp___cil_ret8 ;
  unsigned short const   **tmp___0_ssa_1 ;
  int tmp_ssa_1 ;
  char const   *s_ssa_1 ;
  int retflag9_ssa_1 ;
  int *num_ssa_1 ;
  char const   *s_ssa_2 ;
  int max_num_ssa_1 ;
  int tmp_ssa_2 ;
  char const   *__cil_ret8_ssa_1 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  char __cil_tmp36 ;
  unsigned short const   *__cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned short const   *__cil_tmp39 ;
  unsigned short __cil_tmp40 ;
  int __cil_tmp41 ;
  char __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;

  {
#line 583
  __cil_fp___cil_ret8 = & __cil_ret8;
#line 583
  __cil_fp_tmp = & tmp;
#line 583
  __cil_fp_max_num = & max_num;
#line 583
  __cil_fp_s = & s;
#line 583
  __cil_fp_num = & num;
#line 583
  __cil_pp___cil_ret8 = & __cil_ret8;
#line 583
  __cil_pp_tmp = & tmp;
#line 583
  __cil_pp_max_num = & max_num;
#line 583
  __cil_pp_s = & s;
#line 583
  __cil_pp_num = & num;
#line 583
  return babel_wrapper_parse_number(__cil_pp_num, __cil_pp_s, __cil_pp_max_num, __cil_pp_tmp,
                                    __cil_pp___cil_ret8, __cil_fp_num, __cil_fp_s,
                                    __cil_fp_max_num, __cil_fp_tmp, __cil_fp___cil_ret8,
                                    num, s, max_num);
#line 583
  __cil_pp_num = & num;
#line 584
  __cil_pp_s = & s;
#line 585
  __cil_pp_max_num = & max_num;
#line 586
  __cil_pp_tmp = & tmp;
#line 587
  __cil_pp___cil_ret8 = & __cil_ret8;
#line 588
  __cil_fp_num = & num;
#line 589
  __cil_fp_s = & s;
#line 590
  __cil_fp_max_num = & max_num;
#line 591
  __cil_fp_tmp = & tmp;
#line 592
  __cil_fp___cil_ret8 = & __cil_ret8;
#line 584
  __cil_tmp29 = (unsigned long )s != (unsigned long )((void *)0);
#line 584
  if (__cil_tmp29 == 0) {
#line 584
    daemon_assert_fail("s != ((void *)0)", "ftp_command.c", 584, "parse_number");
  } else {

  }
#line 585
  __cil_tmp30 = (unsigned long )num != (unsigned long )((void *)0);
#line 585
  if (__cil_tmp30 == 0) {
#line 585
    daemon_assert_fail("num != ((void *)0)", "ftp_command.c", 585, "parse_number");
  } else {

  }
#line 588
  tmp___0_ssa_1 = __ctype_b_loc();
#line 588
  __cil_tmp36 = (char )*s;
#line 588
  __cil_tmp37 = *tmp___0_ssa_1;
#line 588
  __cil_tmp38 = (int )__cil_tmp36;
#line 588
  __cil_tmp39 = __cil_tmp37 + __cil_tmp38;
#line 588
  __cil_tmp40 = (unsigned short )*__cil_tmp39;
#line 588
  __cil_tmp41 = (int )((int const   )__cil_tmp40);
#line 588
  __cil_tmp31 = __cil_tmp41 & 2048;
#line 588
  if (__cil_tmp31 != 0) {
#line 591
    __cil_tmp42 = (char )*s;
#line 591
    __cil_tmp43 = (int )((int const   )__cil_tmp42);
#line 591
    __cil_tmp44 = __cil_tmp43 - 48;
#line 591
    tmp_ssa_1 = __cil_tmp44;
#line 592
    s_ssa_1 = s + 1;
#line 596
    *__cil_fp_num = num;
#line 597
    *__cil_fp_s = s_ssa_1;
#line 598
    *__cil_fp_max_num = max_num;
#line 599
    *__cil_fp_tmp = tmp_ssa_1;
#line 600
    *__cil_fp___cil_ret8 = __cil_ret8;
#line 595
    retflag9_ssa_1 = parse_number_cil_lr_1(__cil_pp_num, __cil_pp_s, __cil_pp_max_num,
                                           __cil_pp_tmp, __cil_pp___cil_ret8);
#line 597
    num_ssa_1 = *__cil_fp_num;
#line 598
    s_ssa_2 = *__cil_fp_s;
#line 599
    max_num_ssa_1 = *__cil_fp_max_num;
#line 600
    tmp_ssa_2 = *__cil_fp_tmp;
#line 601
    __cil_ret8_ssa_1 = *__cil_fp___cil_ret8;
#line 595
    if (retflag9_ssa_1 != 0) {
#line 595
      return (__cil_ret8_ssa_1);
    } else {
#line 608
      __cil_tmp32 = tmp_ssa_2 >= 0;
#line 608
      if (__cil_tmp32 == 0) {
#line 608
        daemon_assert_fail("tmp >= 0", "ftp_command.c", 608, "parse_number");
      } else {

      }
#line 609
      __cil_tmp33 = tmp_ssa_2 <= max_num_ssa_1;
#line 609
      if (__cil_tmp33 == 0) {
#line 609
        daemon_assert_fail("tmp <= max_num", "ftp_command.c", 609, "parse_number");
      } else {

      }
#line 612
      *num_ssa_1 = tmp_ssa_2;
#line 613
      return (s_ssa_2);
    }
#line 609
    __cil_tmp34 = tmp <= max_num;
#line 609
    if (__cil_tmp34 == 0) {
#line 609
      daemon_assert_fail("tmp <= max_num", "ftp_command.c", 609, "parse_number");
    } else {

    }
#line 612
    *num = tmp;
#line 613
    return (s);
  } else {
#line 589
    return ((char const   *)0);
  }
#line 609
  __cil_tmp35 = tmp <= max_num;
#line 609
  if (__cil_tmp35 == 0) {
#line 609
    daemon_assert_fail("tmp <= max_num", "ftp_command.c", 609, "parse_number");
  } else {

  }
#line 612
  *num = tmp;
#line 613
  return (s);
}
}
#line 616 "ftp_command.c"
static char const   *parse_offset(off_t *ofs , char const   *s ) 
{ 
  off_t tmp_ofs ;
  char const   *__cil_ret8 ;
  off_t **__cil_pp_ofs ;
  char const   **__cil_pp_s ;
  off_t *__cil_pp_tmp_ofs ;
  char const   **__cil_pp___cil_ret8 ;
  off_t **__cil_fp_ofs ;
  char const   **__cil_fp_s ;
  off_t *__cil_fp_tmp_ofs ;
  char const   **__cil_fp___cil_ret8 ;
  off_t max_ofs_ssa_1 ;
  unsigned short const   **tmp_ssa_1 ;
  off_t tmp_ofs_ssa_1 ;
  char const   *s_ssa_1 ;
  int retflag9_ssa_1 ;
  off_t *ofs_ssa_1 ;
  char const   *s_ssa_2 ;
  off_t tmp_ofs_ssa_2 ;
  char const   *__cil_ret8_ssa_1 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  char __cil_tmp34 ;
  unsigned short const   *__cil_tmp35 ;
  int __cil_tmp36 ;
  unsigned short const   *__cil_tmp37 ;
  unsigned short __cil_tmp38 ;
  int __cil_tmp39 ;
  char __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
#line 620
  __cil_pp_ofs = & ofs;
#line 621
  __cil_pp_s = & s;
#line 622
  __cil_pp_tmp_ofs = & tmp_ofs;
#line 623
  __cil_pp___cil_ret8 = & __cil_ret8;
#line 624
  __cil_fp_ofs = & ofs;
#line 625
  __cil_fp_s = & s;
#line 626
  __cil_fp_tmp_ofs = & tmp_ofs;
#line 627
  __cil_fp___cil_ret8 = & __cil_ret8;
#line 622
  __cil_tmp27 = (unsigned long )ofs != (unsigned long )((void *)0);
#line 622
  if (__cil_tmp27 == 0) {
#line 622
    daemon_assert_fail("ofs != ((void *)0)", "ftp_command.c", 622, "parse_offset");
  } else {

  }
#line 623
  __cil_tmp28 = (unsigned long )s != (unsigned long )((void *)0);
#line 623
  if (__cil_tmp28 == 0) {
#line 623
    daemon_assert_fail("s != ((void *)0)", "ftp_command.c", 623, "parse_offset");
  } else {

  }
#line 626
  __cil_tmp29 = sizeof(off_t ) == 8UL;
#line 626
  if (__cil_tmp29 != 0) {
#line 627
    max_ofs_ssa_1 = (off_t )9223372036854775807LL;
  } else {
#line 628
    __cil_tmp30 = sizeof(off_t ) == 4UL;
#line 628
    if (__cil_tmp30 != 0) {
#line 629
      max_ofs_ssa_1 = (off_t )2147483647LL;
    } else {
#line 630
      __cil_tmp31 = sizeof(off_t ) == 2UL;
#line 630
      if (__cil_tmp31 != 0) {
#line 631
        max_ofs_ssa_1 = (off_t )32767LL;
      } else {
#line 633
        max_ofs_ssa_1 = (off_t )0;
      }
    }
  }
#line 635
  __cil_tmp32 = max_ofs_ssa_1 != 0L;
#line 635
  if (__cil_tmp32 == 0) {
#line 635
    daemon_assert_fail("max_ofs != 0", "ftp_command.c", 635, "parse_offset");
  } else {

  }
#line 638
  tmp_ssa_1 = __ctype_b_loc();
#line 638
  __cil_tmp34 = (char )*s;
#line 638
  __cil_tmp35 = *tmp_ssa_1;
#line 638
  __cil_tmp36 = (int )__cil_tmp34;
#line 638
  __cil_tmp37 = __cil_tmp35 + __cil_tmp36;
#line 638
  __cil_tmp38 = (unsigned short )*__cil_tmp37;
#line 638
  __cil_tmp39 = (int )((int const   )__cil_tmp38);
#line 638
  __cil_tmp33 = __cil_tmp39 & 2048;
#line 638
  if (__cil_tmp33 != 0) {
#line 641
    __cil_tmp40 = (char )*s;
#line 641
    __cil_tmp41 = (int )((int const   )__cil_tmp40);
#line 641
    __cil_tmp42 = __cil_tmp41 - 48;
#line 641
    tmp_ofs_ssa_1 = (off_t )__cil_tmp42;
#line 642
    s_ssa_1 = s + 1;
#line 646
    *__cil_fp_ofs = ofs;
#line 647
    *__cil_fp_s = s_ssa_1;
#line 648
    *__cil_fp_tmp_ofs = tmp_ofs_ssa_1;
#line 649
    *__cil_fp___cil_ret8 = __cil_ret8;
#line 645
    retflag9_ssa_1 = parse_offset_cil_lr_1(__cil_pp_ofs, __cil_pp_s, __cil_pp_tmp_ofs,
                                           __cil_pp___cil_ret8, max_ofs_ssa_1);
#line 647
    ofs_ssa_1 = *__cil_fp_ofs;
#line 648
    s_ssa_2 = *__cil_fp_s;
#line 649
    tmp_ofs_ssa_2 = *__cil_fp_tmp_ofs;
#line 650
    __cil_ret8_ssa_1 = *__cil_fp___cil_ret8;
#line 645
    if (retflag9_ssa_1 != 0) {
#line 645
      return (__cil_ret8_ssa_1);
    } else {
#line 659
      *ofs_ssa_1 = tmp_ofs_ssa_2;
#line 660
      return (s_ssa_2);
    }
  } else {
#line 639
    return ((char const   *)0);
  }
}
}
#line 644 "ftp_command.c"
int parse_offset_cil_lr_1(off_t **__cil_ap_ofs , char const   **__cil_ap_s , off_t *__cil_ap_tmp_ofs ,
                          char const   **__cil_ap___cil_ret8 , off_t max_ofs ) 
{ 
  unsigned short const   **tmp___0_ssa_1 ;
  int cur_digit_ssa_1 ;
  int retflag8_ssa_1 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  char __cil_tmp15 ;
  unsigned short const   *__cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned short const   *__cil_tmp18 ;
  unsigned short __cil_tmp19 ;
  int __cil_tmp20 ;
  char const   *__cil_tmp21 ;
  char __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  off_t __cil_tmp25 ;
  off_t __cil_tmp26 ;
  off_t __cil_tmp27 ;
  off_t __cil_tmp28 ;
  off_t __cil_tmp29 ;
  char const   *__cil_tmp30 ;

  {
#line 645
  tmp___0_ssa_1 = __ctype_b_loc();
#line 645
  __cil_tmp14 = *__cil_ap_s;
#line 645
  __cil_tmp15 = (char )*__cil_tmp14;
#line 645
  __cil_tmp16 = *tmp___0_ssa_1;
#line 645
  __cil_tmp17 = (int )__cil_tmp15;
#line 645
  __cil_tmp18 = __cil_tmp16 + __cil_tmp17;
#line 645
  __cil_tmp19 = (unsigned short )*__cil_tmp18;
#line 645
  __cil_tmp20 = (int )((int const   )__cil_tmp19);
#line 645
  __cil_tmp12 = __cil_tmp20 & 2048;
#line 645
  if (__cil_tmp12 != 0) {
#line 646
    __cil_tmp21 = *__cil_ap_s;
#line 646
    __cil_tmp22 = (char )*__cil_tmp21;
#line 646
    __cil_tmp23 = (int )((int const   )__cil_tmp22);
#line 646
    __cil_tmp24 = __cil_tmp23 - 48;
#line 646
    cur_digit_ssa_1 = __cil_tmp24;
#line 649
    __cil_tmp25 = *__cil_ap_tmp_ofs;
#line 649
    __cil_tmp26 = max_ofs - (off_t )cur_digit_ssa_1;
#line 649
    __cil_tmp27 = __cil_tmp25 * 10L;
#line 649
    __cil_tmp13 = __cil_tmp26 < __cil_tmp27;
#line 649
    if (__cil_tmp13 != 0) {
#line 650
      *__cil_ap___cil_ret8 = (char const   *)0;
#line 652
      return (1);
    } else {
#line 653
      __cil_tmp28 = *__cil_ap_tmp_ofs;
#line 653
      *__cil_ap_tmp_ofs = __cil_tmp28 * 10L;
#line 654
      __cil_tmp29 = *__cil_ap_tmp_ofs;
#line 654
      *__cil_ap_tmp_ofs = __cil_tmp29 + (off_t )cur_digit_ssa_1;
#line 655
      __cil_tmp30 = *__cil_ap_s;
#line 655
      *__cil_ap_s = __cil_tmp30 + 1;
#line 658
      retflag8_ssa_1 = parse_offset_cil_lr_1(__cil_ap_ofs, __cil_ap_s, __cil_ap_tmp_ofs,
                                             __cil_ap___cil_ret8, max_ofs);
#line 661
      return (retflag8_ssa_1);
    }
  } else {
#line 665
    return (0);
  }
}
}
#line 670 "ftp_command.c"
int parse_number_cil_lr_1(int **__cil_ap_num , char const   **__cil_ap_s , int *__cil_ap_max_num ,
                          int *__cil_ap_tmp , char const   **__cil_ap___cil_ret8 ) 
{ 
  unsigned short const   **tmp___1_ssa_1 ;
  int cur_digit_ssa_1 ;
  int retflag8_ssa_1 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  char __cil_tmp15 ;
  unsigned short const   *__cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned short const   *__cil_tmp18 ;
  unsigned short __cil_tmp19 ;
  int __cil_tmp20 ;
  char const   *__cil_tmp21 ;
  char __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char const   *__cil_tmp31 ;

  {

#line 595
  return babel_wrapper_parse_number_cil_lr_1(__cil_ap_num, __cil_ap_s, __cil_ap_max_num,
                                             __cil_ap_tmp, __cil_ap___cil_ret8);
#line 595
  tmp___1_ssa_1 = __ctype_b_loc();
#line 595
  __cil_tmp14 = *__cil_ap_s;
#line 595
  __cil_tmp15 = (char )*__cil_tmp14;
#line 595
  __cil_tmp16 = *tmp___1_ssa_1;
#line 595
  __cil_tmp17 = (int )__cil_tmp15;
#line 595
  __cil_tmp18 = __cil_tmp16 + __cil_tmp17;
#line 595
  __cil_tmp19 = (unsigned short )*__cil_tmp18;
#line 595
  __cil_tmp20 = (int )((int const   )__cil_tmp19);
#line 595
  __cil_tmp12 = __cil_tmp20 & 2048;
#line 595
  if (__cil_tmp12 != 0) {
#line 596
    __cil_tmp21 = *__cil_ap_s;
#line 596
    __cil_tmp22 = (char )*__cil_tmp21;
#line 596
    __cil_tmp23 = (int )((int const   )__cil_tmp22);
#line 596
    __cil_tmp24 = __cil_tmp23 - 48;
#line 596
    cur_digit_ssa_1 = __cil_tmp24;
#line 599
    __cil_tmp25 = *__cil_ap_max_num;
#line 599
    __cil_tmp26 = *__cil_ap_tmp;
#line 599
    __cil_tmp27 = __cil_tmp25 - cur_digit_ssa_1;
#line 599
    __cil_tmp28 = __cil_tmp26 * 10;
#line 599
    __cil_tmp13 = __cil_tmp27 < __cil_tmp28;
#line 599
    if (__cil_tmp13 != 0) {
#line 600
      *__cil_ap___cil_ret8 = (char const   *)0;
#line 602
      return (1);
    } else {
#line 603
      __cil_tmp29 = *__cil_ap_tmp;
#line 603
      *__cil_ap_tmp = __cil_tmp29 * 10;
#line 604
      __cil_tmp30 = *__cil_ap_tmp;
#line 604
      *__cil_ap_tmp = __cil_tmp30 + cur_digit_ssa_1;
#line 605
      __cil_tmp31 = *__cil_ap_s;
#line 605
      *__cil_ap_s = __cil_tmp31 + 1;
#line 608
      retflag8_ssa_1 = parse_number_cil_lr_1(__cil_ap_num, __cil_ap_s, __cil_ap_max_num,
                                             __cil_ap_tmp, __cil_ap___cil_ret8);
#line 611
      return (retflag8_ssa_1);
    }
  } else {
#line 615
    return (0);
  }
}
}
#line 620 "ftp_command.c"
void copy_string_cil_lr_1(char **__cil_ap_dst , char const   **__cil_ap_src , int *__cil_ap_i ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char const   *__cil_tmp13 ;
  int __cil_tmp14 ;
  char const   *__cil_tmp15 ;
  char __cil_tmp16 ;
  int __cil_tmp17 ;
  char const   *__cil_tmp18 ;
  int __cil_tmp19 ;
  char const   *__cil_tmp20 ;
  char __cil_tmp21 ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  int __cil_tmp25 ;

  {

#line 310
  return babel_wrapper_copy_string_cil_lr_1(__cil_ap_dst, __cil_ap_src, __cil_ap_i);
#line 310
  __cil_tmp7 = *__cil_ap_i;
#line 310
  __cil_tmp4 = __cil_tmp7 <= 4096;
#line 310
  if (__cil_tmp4 != 0) {
#line 310
    __cil_tmp8 = *__cil_ap_src;
#line 310
    __cil_tmp9 = *__cil_ap_i;
#line 310
    __cil_tmp10 = __cil_tmp8 + __cil_tmp9;
#line 310
    __cil_tmp11 = (char )*__cil_tmp10;
#line 310
    __cil_tmp12 = (int )((int const   )__cil_tmp11);
#line 310
    __cil_tmp5 = __cil_tmp12 != 0;
#line 310
    if (__cil_tmp5 != 0) {
#line 310
      __cil_tmp13 = *__cil_ap_src;
#line 310
      __cil_tmp14 = *__cil_ap_i;
#line 310
      __cil_tmp15 = __cil_tmp13 + __cil_tmp14;
#line 310
      __cil_tmp16 = (char )*__cil_tmp15;
#line 310
      __cil_tmp17 = (int )((int const   )__cil_tmp16);
#line 310
      __cil_tmp6 = __cil_tmp17 != 10;
#line 310
      if (__cil_tmp6 != 0) {
#line 311
        __cil_tmp18 = *__cil_ap_src;
#line 311
        __cil_tmp19 = *__cil_ap_i;
#line 311
        __cil_tmp20 = __cil_tmp18 + __cil_tmp19;
#line 311
        __cil_tmp21 = (char )*__cil_tmp20;
#line 311
        __cil_tmp22 = *__cil_ap_dst;
#line 311
        __cil_tmp23 = *__cil_ap_i;
#line 311
        __cil_tmp24 = __cil_tmp22 + __cil_tmp23;
#line 311
        *__cil_tmp24 = __cil_tmp21;
#line 310
        __cil_tmp25 = *__cil_ap_i;
#line 310
        *__cil_ap_i = __cil_tmp25 + 1;
#line 313
        copy_string_cil_lr_1(__cil_ap_dst, __cil_ap_src, __cil_ap_i);
#line 315
        return;
      } else {
#line 317
        return;
      }
    } else {
#line 321
      return;
    }
  } else {
#line 325
    return;
  }
}
}
#include <gprolog.h>













































































































PlBool babel__implicit_copy_stringc_0(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_copy_stringc_1(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_copy_stringc_2(char ** arg_0, char const   ** arg_1, int * arg_2) 
{
copy_string_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_3(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_4(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_5(PlLong * babel_ret) 
{
*babel_ret = __ctype_b_loc();
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_6(int ** arg_0, char const   ** arg_1, int * arg_2, int * arg_3, char const   ** arg_4, PlLong * babel_ret) 
{
*babel_ret = parse_number_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_7(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_8(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_9(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_parse_numberc_10(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_parse_number_cil_lr_1c_11(PlLong * babel_ret) 
{
*babel_ret = __ctype_b_loc();
return PL_TRUE;
}
