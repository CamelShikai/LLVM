#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};

#line 216 "/usr/lib/gcc/x86_64-redhat-linux/5.1.1/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/bits/types.h"
typedef long __suseconds_t___0;
#line 153 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 40 "/usr/lib/gcc/x86_64-redhat-linux/5.1.1/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 30 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t___0 tv_usec ;
};
#line 34 "/usr/include/bits/time.h"
typedef long __suseconds_t___1;
#line 54 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 60 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
#line 168 "/usr/include/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 28 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 55 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 12 "telnet_session.h"
struct __anonstruct_telnet_session_t_47 {
   int in_fd ;
   int in_errno ;
   int in_eof ;
   int in_take ;
   int in_add ;
   char in_buf[2048] ;
   int in_buflen ;
   int in_status ;
   int out_fd ;
   int out_errno ;
   int out_eof ;
   int out_take ;
   int out_add ;
   char out_buf[2048] ;
   int out_buflen ;
};
#line 12 "telnet_session.h"
typedef struct __anonstruct_telnet_session_t_47 telnet_session_t;
#line 49 "af_portability.h"
typedef struct sockaddr_in sockaddr_storage_t;
#line 48 "ftp_command.h"
union __anonunion_arg_49 {
   char string[4097] ;
   sockaddr_storage_t host_port ;
   int num ;
   off_t offset ;
};
#line 48 "ftp_command.h"
struct __anonstruct_ftp_command_t_48 {
   char command[5] ;
   int num_arg ;
   union __anonunion_arg_49 arg[2] ;
};
#line 48 "ftp_command.h"
typedef struct __anonstruct_ftp_command_t_48 ftp_command_t;
#line 8 "error.h"
struct __anonstruct_error_t_50 {
   int error_code ;
   char desc[128] ;
};
#line 8 "error.h"
typedef struct __anonstruct_error_t_50 error_t;
#line 24 "watchdog.h"
struct watched {
   pthread_t watched_thread ;
   int in_list ;
   time_t alarm_time ;
   struct watched *older ;
   struct watched *newer ;
   void *watchdog ;
};
#line 24 "watchdog.h"
typedef struct watched watched_t;
#line 37 "ftp_session.h"
struct __anonstruct_ftp_session_t_52 {
   int session_active ;
   unsigned long command_number ;
   int data_type ;
   int file_structure ;
   off_t file_offset ;
   unsigned long file_offset_command_number ;
   int epsv_all_set ;
   sockaddr_storage_t client_addr ;
   char client_addr_str[58] ;
   sockaddr_storage_t server_addr ;
   struct sockaddr_in server_ipv4_addr ;
   telnet_session_t *telnet_session ;
   char dir[4097] ;
   int data_channel ;
   sockaddr_storage_t data_port ;
   int server_fd ;
   watched_t *watched ;
};
#line 37 "ftp_session.h"
typedef struct __anonstruct_ftp_session_t_52 ftp_session_t;
#line 92 "ftp_session.c"
struct __anonstruct_command_func_53 {
   char *name ;
   void (*func)(ftp_session_t *f , ftp_command_t const   *cmd ) ;
};
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
   int babel_wrapper_ftp_session_drop(ftp_session_t * f, char const   * reason)                           // function name insert
      {
        // wrapper for function ftp_session_drop        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("ftp_session_drop"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(reason);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      

      
   int babel_wrapper_do_user(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_user        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_user"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
      
   int babel_wrapper_do_cwd(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_cwd        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_cwd"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_do_quit(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_quit        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_quit"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_do_port(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_port        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_port"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_do_lprt(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_lprt        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_lprt"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_do_eprt(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_eprt        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_eprt"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_init_passive_port(struct timeval * __cil_pp_tv, unsigned short *seed)                           // function name insert
      {
        // wrapper for function init_passive_port        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("init_passive_port"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_tv);
      arg[1] = Pl_Mk_Integer(seed);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int  babel_wrapper_get_passive_port(pthread_once_t * __cil_pp_once_control, void (*__cil_pp_init_passive_port)(void) , pthread_mutex_t * __cil_pp_mutex)                           // function name insert
      {
        // wrapper for function get_passive_port        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("get_passive_port"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_once_control);
arg[1] = Pl_Mk_Integer(__cil_pp_init_passive_port);
arg[2] = Pl_Mk_Integer(__cil_pp_mutex);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_do_type(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_type        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_type"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      

      
   int babel_wrapper_do_mode(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_mode        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_mode"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_get_absolute_fname(char * fname, int  fname_len, char const   * dir, char const   * file)                           // function name insert
      {
        // wrapper for function get_absolute_fname        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("get_absolute_fname"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(fname);
arg[1] = Pl_Mk_Integer(fname_len);
arg[2] = Pl_Mk_Integer(dir);
arg[3] = Pl_Mk_Integer(file);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      

      
      
   int  babel_wrapper_convert_newlines(int * __cil_pp_dstlen, int * __cil_fp_dstlen, char * dst, char const   * src, int  srclen)                           // function name insert
      {
        // wrapper for function convert_newlines        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("convert_newlines"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_dstlen);
arg[1] = Pl_Mk_Integer(__cil_fp_dstlen);
arg[2] = Pl_Mk_Integer(dst);
arg[3] = Pl_Mk_Integer(src);
arg[4] = Pl_Mk_Integer(srclen);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int  babel_wrapper_write_fully(int * __cil_pp_amt_written, int * __cil_pp___cil_ret7, int * __cil_fp_amt_written, int * __cil_fp___cil_ret7, int  fd, char const   * buf, int  buflen)                           // function name insert
      {
        // wrapper for function write_fully        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_fully"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_amt_written);
arg[1] = Pl_Mk_Integer(__cil_pp___cil_ret7);
arg[2] = Pl_Mk_Integer(__cil_fp_amt_written);
arg[3] = Pl_Mk_Integer(__cil_fp___cil_ret7);
arg[4] = Pl_Mk_Integer(fd);
arg[5] = Pl_Mk_Integer(buf);
arg[6] = Pl_Mk_Integer(buflen);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      

      
   int  babel_wrapper_filespec_has_path_separator(char const   * filespec)                           // function name insert
      {
        // wrapper for function filespec_has_path_separator        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("filespec_has_path_separator"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(filespec);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int  babel_wrapper_filespec_is_legal(char const   * filespec)                           // function name insert
      {
        // wrapper for function filespec_is_legal        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("filespec_is_legal"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(filespec);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_do_syst(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_syst        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_syst"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      

      
   int babel_wrapper_do_rest(ftp_session_t * f, ftp_command_t const   * cmd)                           // function name insert
      {
        // wrapper for function do_rest        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_rest"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(f);
arg[1] = Pl_Mk_Integer(cmd);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_do_size(struct stat * __cil_pp_stat_buf, ftp_session_t * f, ftp_command_t const   * cmd, char* full_path)                           // function name insert
      {
        // wrapper for function do_size        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("do_size"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_stat_buf);
arg[1] = Pl_Mk_Integer(f);
arg[2] = Pl_Mk_Integer(cmd);
arg[3] = Pl_Mk_Integer(full_path);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int  babel_wrapper_write_fully_cil_lr_1(int * __cil_ap_amt_written, int * __cil_ap___cil_ret7, int  fd, char const   * buf, int  buflen)                           // function name insert
      {
        // wrapper for function write_fully_cil_lr_1        // function name insert
         int  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_fully_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_amt_written);
arg[1] = Pl_Mk_Integer(__cil_ap___cil_ret7);
arg[2] = Pl_Mk_Integer(fd);
arg[3] = Pl_Mk_Integer(buf);
arg[4] = Pl_Mk_Integer(buflen);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
#line 4 "ftp_session.c"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
#line 7
  tmp = __builtin_bswap32((int )__bsx);
#line 7
  return ((unsigned int )tmp);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 262
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 398
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 412
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 533
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 393 "/usr/include/bits/string2.h"
extern void *__rawmemchr(void const   *__s , int __c ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int snprintf(char * __restrict  __s , size_t __maxlen ,
                                                  char const   * __restrict  __format 
                                                  , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int vsnprintf(char * __restrict  __s , size_t __maxlen ,
                                                   char const   * __restrict  __format ,
                                                   __gnuc_va_list __arg ) ;
#line 208 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1,2),
__leaf__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 213
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(2),
__leaf__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 106 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 169 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 113 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 50 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 249
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   * __restrict  __timer ,
                                                                                      struct tm * __restrict  __tp ) ;
#line 496 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 190 "/usr/include/sys/syslog.h"
extern void syslog(int __pri , char const   *__fmt  , ...) ;
#line 393 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) lrand48)(void) ;
#line 404
extern  __attribute__((__nothrow__)) unsigned short *( __attribute__((__nonnull__(1),
__leaf__)) seed48)(unsigned short *__seed16v ) ;
#line 71 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 10 "daemon_assert.h"
extern void daemon_assert_fail(char const   *assertion , char const   *file , int line ,
                               char const   *function ) ;
#line 34 "telnet_session.h"
extern int telnet_session_print(telnet_session_t *t , char const   *s ) ;
#line 35
extern int telnet_session_println(telnet_session_t *t , char const   *s ) ;
#line 36
extern int telnet_session_readln(telnet_session_t *t , char *buf , int buflen ) ;
#line 60 "ftp_command.h"
extern int ftp_command_parse(char const   *input , ftp_command_t *cmd ) ;
#line 8 "file_list.h"
extern int file_nlst(int out , char const   *cur_dir , char const   *filespec ) ;
#line 9
extern int file_list(int out , char const   *cur_dir , char const   *filespec ) ;
#line 54 "watchdog.h"
extern void watchdog_defer_watched(watched_t *watched ) ;
#line 80 "ftp_session.h"
int ftp_session_init(ftp_session_t *f , sockaddr_storage_t const   *client_addr ,
                     sockaddr_storage_t const   *server_addr , telnet_session_t *t ,
                     char const   *dir , error_t *err ) ;
#line 86
void ftp_session_drop(ftp_session_t *f , char const   *reason ) ;
#line 87
void ftp_session_run(ftp_session_t *f , watched_t *watched ) ;
#line 88
void ftp_session_destroy(ftp_session_t *f ) ;
#line 47 "ftp_session.c"
static int invariant(ftp_session_t const   *f ) ;
#line 48
static void reply(ftp_session_t *f , int code , char const   *fmt  , ...) ;
#line 49
static void change_dir(ftp_session_t *f , char const   *new_dir ) ;
#line 50
static int open_connection(ftp_session_t *f ) ;
#line 51
static int write_fully(int fd , char const   *buf , int buflen ) ;
#line 52
static void init_passive_port(void) ;
#line 53
static int get_passive_port(void) ;
#line 54
static int convert_newlines(char *dst , char const   *src , int srclen ) ;
#line 55
static void get_addr_str(sockaddr_storage_t const   *s , char *buf , int bufsiz ) ;
#line 56
static void send_readme(ftp_session_t const   *f , int code ) ;
#line 57
static void netscape_hack(int fd ) ;
#line 58
static void set_port(ftp_session_t *f , sockaddr_storage_t const   *host_port ) ;
#line 59
static int set_pasv(ftp_session_t *f , sockaddr_storage_t *bind_addr ) ;
#line 60
static int ip_equal(sockaddr_storage_t const   *a , sockaddr_storage_t const   *b ) ;
#line 61
static void get_absolute_fname(char *fname , int fname_len , char const   *dir , char const   *file ) ;
#line 67
static void do_user(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 68
static void do_pass(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 69
static void do_cwd(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 70
static void do_cdup(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 71
static void do_quit(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 72
static void do_port(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 73
static void do_pasv(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 74
static void do_type(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 75
static void do_stru(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 76
static void do_mode(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 77
static void do_retr(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 78
static void do_stor(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 79
static void do_pwd(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 80
static void do_nlst(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 81
static void do_list(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 82
static void do_syst(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 83
static void do_noop(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 84
static void do_rest(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 85
static void do_lprt(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 86
static void do_lpsv(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 87
static void do_eprt(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 88
static void do_epsv(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 89
static void do_size(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 90
static void do_mdtm(ftp_session_t *f , ftp_command_t const   *cmd ) ;
#line 92 "ftp_session.c"
static struct __anonstruct_command_func_53 command_func[24]  = 
#line 92
  {      {(char *)"USER", & do_user}, 
        {(char *)"PASS", & do_pass}, 
        {(char *)"CWD", & do_cwd}, 
        {(char *)"CDUP", & do_cdup}, 
        {(char *)"QUIT", & do_quit}, 
        {(char *)"PORT", & do_port}, 
        {(char *)"PASV", & do_pasv}, 
        {(char *)"LPRT", & do_lprt}, 
        {(char *)"LPSV", & do_lpsv}, 
        {(char *)"EPRT", & do_eprt}, 
        {(char *)"EPSV", & do_epsv}, 
        {(char *)"TYPE", & do_type}, 
        {(char *)"STRU", & do_stru}, 
        {(char *)"MODE", & do_mode}, 
        {(char *)"RETR", & do_retr}, 
        {(char *)"STOR", & do_stor}, 
        {(char *)"PWD", & do_pwd}, 
        {(char *)"NLST", & do_nlst}, 
        {(char *)"LIST", & do_list}, 
        {(char *)"SYST", & do_syst}, 
        {(char *)"NOOP", & do_noop}, 
        {(char *)"REST", & do_rest}, 
        {(char *)"SIZE", & do_size}, 
        {(char *)"MDTM", & do_mdtm}};
#line 932 "ftp_session.c"
static pthread_once_t once_control  =    0;
#line 933 "ftp_session.c"
static pthread_mutex_t mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 1178
extern int sendfile() ;
#line 1179
int write_fully_cil_lr_1(int *__cil_ap_amt_written , int *__cil_ap___cil_ret7 , int fd ,
                         char const   *buf , int buflen ) ;
#line 1181
void convert_newlines_cil_lr_1(int *__cil_ap_dstlen , char *dst , char const   *src ,
                               int srclen , int i ) ;
#line 125 "ftp_session.c"
int ftp_session_init(ftp_session_t *f , sockaddr_storage_t const   *client_addr ,
                     sockaddr_storage_t const   *server_addr , telnet_session_t *t ,
                     char const   *dir , error_t *err ) 
{ 
  size_t tmp_ssa_1 ;
  size_t tmp___0_ssa_1 ;
  int tmp___1_ssa_1 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  sockaddr_storage_t __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  struct sockaddr_in *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  unsigned long *__cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  int *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  int *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  off_t *__cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  unsigned long *__cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  int *__cil_tmp35 ;
  sockaddr_storage_t __cil_tmp36 ;
  unsigned char *__cil_tmp37 ;
  sockaddr_storage_t *__cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  char (*__cil_tmp40)[58] ;
  char *__cil_tmp41 ;
  sockaddr_storage_t __cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  sockaddr_storage_t *__cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  telnet_session_t **__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  char (*__cil_tmp48)[4097] ;
  char *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  int *__cil_tmp51 ;
  sockaddr_storage_t __cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  sockaddr_storage_t *__cil_tmp54 ;
  unsigned char *__cil_tmp55 ;
  int *__cil_tmp56 ;
  int *mem_54 ;
  char (*mem_55)[58] ;
  char (*mem_56)[4097] ;

  {
#line 132
  __cil_tmp13 = (unsigned long )f != (unsigned long )((void *)0);
#line 132
  if (__cil_tmp13 == 0) {
#line 132
    daemon_assert_fail("f != ((void *)0)", "ftp_session.c", 132, "ftp_session_init");
  } else {

  }
#line 133
  __cil_tmp14 = (unsigned long )client_addr != (unsigned long )((void *)0);
#line 133
  if (__cil_tmp14 == 0) {
#line 133
    daemon_assert_fail("client_addr != ((void *)0)", "ftp_session.c", 133, "ftp_session_init");
  } else {

  }
#line 134
  __cil_tmp15 = (unsigned long )server_addr != (unsigned long )((void *)0);
#line 134
  if (__cil_tmp15 == 0) {
#line 134
    daemon_assert_fail("server_addr != ((void *)0)", "ftp_session.c", 134, "ftp_session_init");
  } else {

  }
#line 135
  __cil_tmp16 = (unsigned long )t != (unsigned long )((void *)0);
#line 135
  if (__cil_tmp16 == 0) {
#line 135
    daemon_assert_fail("t != ((void *)0)", "ftp_session.c", 135, "ftp_session_init");
  } else {

  }
#line 136
  __cil_tmp17 = (unsigned long )dir != (unsigned long )((void *)0);
#line 136
  if (__cil_tmp17 == 0) {
#line 136
    daemon_assert_fail("dir != ((void *)0)", "ftp_session.c", 136, "ftp_session_init");
  } else {

  }
#line 137
  tmp_ssa_1 = strlen(dir);
#line 137
  __cil_tmp18 = tmp_ssa_1 <= 4096UL;
#line 137
  if (__cil_tmp18 == 0) {
#line 137
    daemon_assert_fail("strlen(dir) <= 4096", "ftp_session.c", 137, "ftp_session_init");
  } else {

  }
#line 138
  __cil_tmp19 = (unsigned long )err != (unsigned long )((void *)0);
#line 138
  if (__cil_tmp19 == 0) {
#line 138
    daemon_assert_fail("err != ((void *)0)", "ftp_session.c", 138, "ftp_session_init");
  } else {

  }
#line 171
  __cil_tmp21 = (sockaddr_storage_t )*server_addr;
#line 171
  __cil_tmp22 = (unsigned char *)f + 136;
#line 171
  __cil_tmp23 = (struct sockaddr_in *)__cil_tmp22;
#line 171
  *__cil_tmp23 = __cil_tmp21;
#line 174
  mem_54 = (int *)f;
#line 174
  *mem_54 = 1;
#line 175
  __cil_tmp24 = (unsigned char *)f + 8;
#line 175
  __cil_tmp25 = (unsigned long *)__cil_tmp24;
#line 175
  *__cil_tmp25 = 0UL;
#line 177
  __cil_tmp26 = (unsigned char *)f + 16;
#line 177
  __cil_tmp27 = (int *)__cil_tmp26;
#line 177
  *__cil_tmp27 = 0;
#line 178
  __cil_tmp28 = (unsigned char *)f + 20;
#line 178
  __cil_tmp29 = (int *)__cil_tmp28;
#line 178
  *__cil_tmp29 = 0;
#line 180
  __cil_tmp30 = (unsigned char *)f + 24;
#line 180
  __cil_tmp31 = (off_t *)__cil_tmp30;
#line 180
  *__cil_tmp31 = (off_t )0;
#line 181
  __cil_tmp32 = (unsigned char *)f + 32;
#line 181
  __cil_tmp33 = (unsigned long *)__cil_tmp32;
#line 181
  *__cil_tmp33 = 0xffffffffffffffffUL;
#line 183
  __cil_tmp34 = (unsigned char *)f + 40;
#line 183
  __cil_tmp35 = (int *)__cil_tmp34;
#line 183
  *__cil_tmp35 = 0;
#line 185
  __cil_tmp36 = (sockaddr_storage_t )*client_addr;
#line 185
  __cil_tmp37 = (unsigned char *)f + 44;
#line 185
  __cil_tmp38 = (sockaddr_storage_t *)__cil_tmp37;
#line 185
  *__cil_tmp38 = __cil_tmp36;
#line 186
  __cil_tmp39 = (unsigned char *)f + 60;
#line 186
  __cil_tmp40 = (char (*)[58])__cil_tmp39;
#line 186
  __cil_tmp41 = *__cil_tmp40;
#line 186
  mem_55 = (char (*)[58])((unsigned char *)f + 60);
#line 186
  get_addr_str(client_addr, __cil_tmp41, (int )sizeof(*mem_55));
#line 188
  __cil_tmp42 = (sockaddr_storage_t )*server_addr;
#line 188
  __cil_tmp43 = (unsigned char *)f + 120;
#line 188
  __cil_tmp44 = (sockaddr_storage_t *)__cil_tmp43;
#line 188
  *__cil_tmp44 = __cil_tmp42;
#line 190
  __cil_tmp45 = (unsigned char *)f + 152;
#line 190
  __cil_tmp46 = (telnet_session_t **)__cil_tmp45;
#line 190
  *__cil_tmp46 = t;
#line 191
  tmp___0_ssa_1 = strlen(dir);
#line 191
  mem_56 = (char (*)[4097])((unsigned char *)f + 160);
#line 191
  __cil_tmp20 = tmp___0_ssa_1 < sizeof(*mem_56);
#line 191
  if (__cil_tmp20 == 0) {
#line 191
    daemon_assert_fail("strlen(dir) < sizeof(f->dir)", "ftp_session.c", 191, "ftp_session_init");
  } else {

  }
#line 192
  __cil_tmp47 = (unsigned char *)f + 160;
#line 192
  __cil_tmp48 = (char (*)[4097])__cil_tmp47;
#line 192
  __cil_tmp49 = *__cil_tmp48;
#line 192
  strcpy((char * __restrict  )__cil_tmp49, (char const   * __restrict  )dir);
#line 194
  __cil_tmp50 = (unsigned char *)f + 4260;
#line 194
  __cil_tmp51 = (int *)__cil_tmp50;
#line 194
  *__cil_tmp51 = 0;
#line 195
  __cil_tmp52 = (sockaddr_storage_t )*client_addr;
#line 195
  __cil_tmp53 = (unsigned char *)f + 4264;
#line 195
  __cil_tmp54 = (sockaddr_storage_t *)__cil_tmp53;
#line 195
  *__cil_tmp54 = __cil_tmp52;
#line 196
  __cil_tmp55 = (unsigned char *)f + 4280;
#line 196
  __cil_tmp56 = (int *)__cil_tmp55;
#line 196
  *__cil_tmp56 = -1;
#line 198
  tmp___1_ssa_1 = invariant((ftp_session_t const   *)f);
#line 198
  if (tmp___1_ssa_1 == 0) {
#line 198
    daemon_assert_fail("invariant(f)", "ftp_session.c", 198, "ftp_session_init");
  } else {

  }
#line 200
  return (1);
}
}
#line 203 "ftp_session.c"
void ftp_session_drop(ftp_session_t *f , char const   *reason ) 
{ 
  int tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp7 ;

  {

#line 205
  return babel_wrapper_ftp_session_drop(f, reason);
#line 205
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 205
  if (tmp_ssa_1 == 0) {
#line 205
    daemon_assert_fail("invariant(f)", "ftp_session.c", 205, "ftp_session_drop");
  } else {

  }
#line 206
  __cil_tmp7 = (unsigned long )reason != (unsigned long )((void *)0);
#line 206
  if (__cil_tmp7 == 0) {
#line 206
    daemon_assert_fail("reason != ((void *)0)", "ftp_session.c", 206, "ftp_session_drop");
  } else {

  }
#line 209
  reply(f, 421, "%s.", reason);
#line 211
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 211
  if (tmp___0_ssa_1 == 0) {
#line 211
    daemon_assert_fail("invariant(f)", "ftp_session.c", 211, "ftp_session_drop");
  } else {

  }
#line 212
  return;
}
}
#line 214 "ftp_session.c"
void ftp_session_run(ftp_session_t *f , watched_t *watched ) 
{ 
  char buf[2048] ;
  int len ;
  ftp_command_t cmd ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void (*mem_20)(ftp_session_t *f , ftp_command_t const   *cmd ) ;

  {
#line 221
  tmp = invariant((ftp_session_t const   *)f);
#line 221
  if (tmp == 0) {
#line 221
    daemon_assert_fail("invariant(f)", "ftp_session.c", 221, "ftp_session_run");
  } else {

  }
#line 222
  if ((unsigned long )watched == (unsigned long )((void *)0)) {
#line 222
    daemon_assert_fail("watched != ((void *)0)", "ftp_session.c", 222, "ftp_session_run");
  } else {

  }
#line 225
  f->watched = watched;
#line 228
  send_readme((ftp_session_t const   *)f, 220);
#line 229
  reply(f, 220, "Service ready for new user.");
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (f->session_active != 0) {
#line 232
      tmp___11 = telnet_session_readln(f->telnet_session, buf, (int )sizeof(buf));
#line 232
      if (tmp___11 == 0) {
#line 232
        goto while_break;
      } else {

      }
    } else {
#line 232
      goto while_break;
    }
#line 237
    watchdog_defer_watched(f->watched);
#line 240
    if (f->command_number == 0xffffffffffffffffUL) {
#line 241
      f->command_number = 0UL;
    } else {
#line 243
      (f->command_number) ++;
    }
#line 247
    tmp___0 = strlen((char const   *)(buf));
#line 247
    len = (int )tmp___0;
#line 248
    if ((int )buf[len - 1] != 10) {
#line 249
      reply(f, 500, "Command line too long.");
      {
#line 250
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 250
        tmp___2 = telnet_session_readln(f->telnet_session, buf, (int )sizeof(buf));
#line 250
        if (tmp___2 == 0) {
#line 250
          goto while_break___0;
        } else {

        }
#line 251
        tmp___1 = strlen((char const   *)(buf));
#line 251
        len = (int )tmp___1;
#line 252
        if ((int )buf[len - 1] == 10) {
#line 253
          goto while_break___0;
        } else {

        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 256
      goto next_command;
    } else {

    }
#line 259
    syslog(7, "%s %s", f->client_addr_str, buf);
#line 262
    tmp___3 = ftp_command_parse((char const   *)(buf), & cmd);
#line 262
    if (tmp___3 == 0) {
#line 263
      reply(f, 500, "Syntax error, command unrecognized.");
#line 264
      goto next_command;
    } else {

    }
#line 268
    i = 0;
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if ((unsigned long )i < sizeof(command_func) / sizeof(command_func[0])) {

      } else {
#line 268
        goto while_break___1;
      }
#line 269
      if (0 != 0) {
#line 269
        __s1_len = strlen((char const   *)(cmd.command));
#line 269
        __s2_len = strlen((char const   *)command_func[i].name);
#line 269
        if ((size_t )((void const   *)(cmd.command + 1)) - (size_t )((void const   *)(cmd.command)) != 1UL) {
#line 269
          goto _L___0;
        } else
#line 269
        if (__s1_len >= 4UL) {
          _L___0: 
#line 269
          if ((size_t )((void const   *)(command_func[i].name + 1)) - (size_t )((void const   *)command_func[i].name) != 1UL) {
#line 269
            tmp___10 = 1;
          } else
#line 269
          if (__s2_len >= 4UL) {
#line 269
            tmp___10 = 1;
          } else {
#line 269
            tmp___10 = 0;
          }
        } else {
#line 269
          tmp___10 = 0;
        }
#line 269
        if (tmp___10 != 0) {
#line 269
          tmp___5 = __builtin_strcmp((char const   *)(cmd.command), (char const   *)command_func[i].name);
#line 269
          tmp___9 = tmp___5;
        } else {
#line 269
          tmp___8 = __builtin_strcmp((char const   *)(cmd.command), (char const   *)command_func[i].name);
#line 269
          tmp___9 = tmp___8;
        }
      } else {
#line 269
        tmp___8 = __builtin_strcmp((char const   *)(cmd.command), (char const   *)command_func[i].name);
#line 269
        tmp___9 = tmp___8;
      }
#line 269
      if (tmp___9 == 0) {
#line 270
        mem_20 = command_func[i].func;
#line 270
        (*mem_20)(f, (ftp_command_t const   *)(& cmd));
#line 271
        goto next_command;
      } else {

      }
#line 268
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 276
    reply(f, 502, "Command not implemented.");
    next_command: ;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  tmp___12 = invariant((ftp_session_t const   *)f);
#line 281
  if (tmp___12 == 0) {
#line 281
    daemon_assert_fail("invariant(f)", "ftp_session.c", 281, "ftp_session_run");
  } else {

  }
#line 282
  return;
}
}
void ftp_session_destroy(ftp_session_t *f)
{
    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 286, __func__)));

    if (f->server_fd != -1) {
        close(f->server_fd);
 f->server_fd = -1;
    }
}

#line 295 "ftp_session.c"
static int invariant(ftp_session_t const   *f ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 299
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 300
    return (0);
  } else {

  }
#line 302
  if (f->session_active != 0) {
#line 302
    if (f->session_active != 1) {
#line 303
      return (0);
    } else {

    }
  } else {

  }
#line 305
  if (f->data_type != 0) {
#line 305
    if (f->data_type != 1) {
#line 306
      return (0);
    } else {

    }
  } else {

  }
#line 308
  if (f->file_structure != 0) {
#line 308
    if (f->file_structure != 1) {
#line 309
      return (0);
    } else {

    }
  } else {

  }
#line 311
  if (f->file_offset < 0L) {
#line 312
    return (0);
  } else {

  }
#line 314
  if (f->epsv_all_set != 0) {
#line 314
    if (f->epsv_all_set != 1) {
#line 315
      return (0);
    } else {

    }
  } else {

  }
#line 317
  tmp = strlen((char const   *)(f->client_addr_str));
#line 317
  len = (int )tmp;
#line 318
  if (len <= 0) {
#line 319
    return (0);
  } else
#line 318
  if (len >= 58) {
#line 319
    return (0);
  } else {

  }
#line 321
  if ((unsigned long )f->telnet_session == (unsigned long )((void *)0)) {
#line 322
    return (0);
  } else {

  }
  {
#line 325
  if (f->data_channel == 0) {
#line 325
    goto case_0;
  } else {

  }
#line 336
  if (f->data_channel == 1) {
#line 336
    goto case_1;
  } else {

  }
#line 341
  goto switch_default;
  case_0: /* CIL Label */ 
#line 329
  tmp___0 = ip_equal(& f->client_addr, & f->data_port);
#line 329
  if (tmp___0 == 0) {
#line 330
    return (0);
  } else {

  }
#line 332
  if (f->server_fd != -1) {
#line 333
    return (0);
  } else {

  }
#line 335
  goto switch_break;
  case_1: /* CIL Label */ 
#line 337
  if (f->server_fd < 0) {
#line 338
    return (0);
  } else {

  }
#line 340
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 342
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 344
  return (1);
}
}
#line 348 "ftp_session.c"
static void reply(ftp_session_t *f , int code , char const   *fmt  , ...) 
{ 
  char buf[256] ;
  va_list ap ;
  int tmp ;
  int tmp___0 ;

  {
#line 353
  tmp = invariant((ftp_session_t const   *)f);
#line 353
  if (tmp == 0) {
#line 353
    daemon_assert_fail("invariant(f)", "ftp_session.c", 353, "reply");
  } else {

  }
#line 354
  if (code < 100) {
#line 354
    daemon_assert_fail("code >= 100", "ftp_session.c", 354, "reply");
  } else {

  }
#line 355
  if (code > 559) {
#line 355
    daemon_assert_fail("code <= 559", "ftp_session.c", 355, "reply");
  } else {

  }
#line 356
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 356
    daemon_assert_fail("fmt != ((void *)0)", "ftp_session.c", 356, "reply");
  } else {

  }
#line 359
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", code);
#line 360
  buf[3] = (char )' ';
#line 363
  __builtin_va_start(ap, fmt);
#line 364
  vsnprintf((char * __restrict  )(buf + 4), sizeof(buf) - 4UL, (char const   * __restrict  )fmt,
            ap);
#line 365
  __builtin_va_end(ap);
#line 368
  syslog(7, "%s %s", f->client_addr_str, buf);
#line 371
  telnet_session_println(f->telnet_session, (char const   *)(buf));
#line 373
  tmp___0 = invariant((ftp_session_t const   *)f);
#line 373
  if (tmp___0 == 0) {
#line 373
    daemon_assert_fail("invariant(f)", "ftp_session.c", 373, "reply");
  } else {

  }
#line 374
  return;
}
}
#line 376 "ftp_session.c"
static void do_user(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  char const   *user_ssa_1 ;
  int tmp___0_ssa_1 ;
  int tmp___1_ssa_1 ;
  int tmp___2_ssa_1 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  int *__cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  union __anonunion_arg_49 (*__cil_tmp20)[2] ;
  union __anonunion_arg_49 *__cil_tmp21 ;
  union __anonunion_arg_49 *__cil_tmp22 ;
  char (*__cil_tmp23)[4097] ;
  char *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  char (*__cil_tmp26)[58] ;
  char *__cil_tmp27 ;

  {

#line 381
  return babel_wrapper_do_user(f, cmd);
#line 381
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 381
  if (tmp_ssa_1 == 0) {
#line 381
    daemon_assert_fail("invariant(f)", "ftp_session.c", 381, "do_user");
  } else {

  }
#line 382
  __cil_tmp14 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 382
  if (__cil_tmp14 == 0) {
#line 382
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 382, "do_user");
  } else {

  }
#line 383
  __cil_tmp16 = (unsigned char *)cmd + 8;
#line 383
  __cil_tmp17 = (int *)__cil_tmp16;
#line 383
  __cil_tmp18 = *__cil_tmp17;
#line 383
  __cil_tmp15 = __cil_tmp18 == 1;
#line 383
  if (__cil_tmp15 == 0) {
#line 383
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 383, "do_user");
  } else {

  }
#line 385
  __cil_tmp19 = (unsigned char *)cmd + 16;
#line 385
  __cil_tmp20 = (union __anonunion_arg_49 (*)[2])__cil_tmp19;
#line 385
  __cil_tmp21 = *__cil_tmp20;
#line 385
  __cil_tmp22 = __cil_tmp21;
#line 385
  __cil_tmp23 = (char (*)[4097])__cil_tmp22;
#line 385
  __cil_tmp24 = *__cil_tmp23;
#line 385
  user_ssa_1 = (char const   *)__cil_tmp24;
#line 386
  tmp___0_ssa_1 = strcasecmp(user_ssa_1, "ftp");
#line 386
  if (tmp___0_ssa_1 != 0) {
#line 386
    tmp___1_ssa_1 = strcasecmp(user_ssa_1, "anonymous");
#line 386
    if (tmp___1_ssa_1 != 0) {
#line 387
      __cil_tmp25 = (unsigned char *)f + 60;
#line 387
      __cil_tmp26 = (char (*)[58])__cil_tmp25;
#line 387
      __cil_tmp27 = *__cil_tmp26;
#line 387
      syslog(4, "%s attempted to log in as \"%s\"", __cil_tmp27, user_ssa_1);
#line 389
      reply(f, 530, "Only anonymous FTP supported.");
    } else {
#line 391
      reply(f, 331, "Send e-mail address as password.");
    }
  } else {
#line 391
    reply(f, 331, "Send e-mail address as password.");
  }
#line 393
  tmp___2_ssa_1 = invariant((ftp_session_t const   *)f);
#line 393
  if (tmp___2_ssa_1 == 0) {
#line 393
    daemon_assert_fail("invariant(f)", "ftp_session.c", 393, "do_user");
  } else {

  }
#line 394
  return;
}
}
static void do_pass(ftp_session_t *f, const ftp_command_t *cmd)
{
    const char *password;
    char addr_port[58];

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 402, __func__)));
    ((cmd != 
# 403 "ftp_session.c" 3 4
   ((void *)0)
# 403 "ftp_session.c"
   ) ? 0 : (daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 403, __func__)));
    ((cmd->num_arg == 1) ? 0 : (daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 404, __func__)));

    password = cmd->arg[0].string;
    syslog(
# 407 "ftp_session.c" 3 4
          6
# 407 "ftp_session.c"
                  , "%s reports e-mail address \"%s\"",
        f->client_addr_str, password);
    reply(f, 230, "User logged in, proceed.");

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 411, __func__)));
}

#line 439 "ftp_session.c"
static void get_addr_str(sockaddr_storage_t const   *s , char *buf , int bufsiz ) 
{ 
  unsigned int addr ;
  int port ;
  unsigned short __v ;
  unsigned short __x ;

  {
#line 444
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 444
    daemon_assert_fail("s != ((void *)0)", "ftp_session.c", 444, "get_addr_str");
  } else {

  }
#line 445
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 445
    daemon_assert_fail("buf != ((void *)0)", "ftp_session.c", 445, "get_addr_str");
  } else {

  }
#line 450
  if (bufsiz < 28) {
#line 450
    daemon_assert_fail("bufsiz >= (16 + 12)", "ftp_session.c", 450, "get_addr_str");
  } else {

  }
#line 452
  addr = __bswap_32((unsigned int )s->sin_addr.s_addr);
#line 453
  __x = (unsigned short )s->sin_port;
#line 453
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 453
  port = (int )__v;
#line 454
  snprintf((char * __restrict  )buf, (size_t )bufsiz, (char const   * __restrict  )"%d.%d.%d.%d port %d",
           (addr >> 24) & 255U, (addr >> 16) & 255U, (addr >> 8) & 255U, addr & 255U,
           port);
#line 460
  return;
}
}
#line 463 "ftp_session.c"
static void do_cwd(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  char const   *new_dir_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  union __anonunion_arg_49 (*__cil_tmp15)[2] ;
  union __anonunion_arg_49 *__cil_tmp16 ;
  union __anonunion_arg_49 *__cil_tmp17 ;
  char (*__cil_tmp18)[4097] ;
  char *__cil_tmp19 ;

  {

#line 467
  return babel_wrapper_do_cwd(f, cmd);
#line 467
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 467
  if (tmp_ssa_1 == 0) {
#line 467
    daemon_assert_fail("invariant(f)", "ftp_session.c", 467, "do_cwd");
  } else {

  }
#line 468
  __cil_tmp9 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 468
  if (__cil_tmp9 == 0) {
#line 468
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 468, "do_cwd");
  } else {

  }
#line 469
  __cil_tmp11 = (unsigned char *)cmd + 8;
#line 469
  __cil_tmp12 = (int *)__cil_tmp11;
#line 469
  __cil_tmp13 = *__cil_tmp12;
#line 469
  __cil_tmp10 = __cil_tmp13 == 1;
#line 469
  if (__cil_tmp10 == 0) {
#line 469
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 469, "do_cwd");
  } else {

  }
#line 471
  __cil_tmp14 = (unsigned char *)cmd + 16;
#line 471
  __cil_tmp15 = (union __anonunion_arg_49 (*)[2])__cil_tmp14;
#line 471
  __cil_tmp16 = *__cil_tmp15;
#line 471
  __cil_tmp17 = __cil_tmp16;
#line 471
  __cil_tmp18 = (char (*)[4097])__cil_tmp17;
#line 471
  __cil_tmp19 = *__cil_tmp18;
#line 471
  new_dir_ssa_1 = (char const   *)__cil_tmp19;
#line 472
  change_dir(f, new_dir_ssa_1);
#line 474
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 474
  if (tmp___0_ssa_1 == 0) {
#line 474
    daemon_assert_fail("invariant(f)", "ftp_session.c", 474, "do_cwd");
  } else {

  }
#line 475
  return;
}
}
static void do_cdup(ftp_session_t *f, const ftp_command_t *cmd)
{
    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 479, __func__)));
    ((cmd != 
# 480 "ftp_session.c" 3 4
   ((void *)0)
# 480 "ftp_session.c"
   ) ? 0 : (daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 480, __func__)));
    ((cmd->num_arg == 0) ? 0 : (daemon_assert_fail("cmd->num_arg == 0", "ftp_session.c", 481, __func__)));

    change_dir(f, "..");

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 485, __func__)));
}

#line 488 "ftp_session.c"
static void change_dir(ftp_session_t *f , char const   *new_dir ) 
{ 
  char target[4097] ;
  char const   *p ;
  char const   *n ;
  int len ;
  char *prev_dir ;
  char *target_end ;
  struct stat stat_buf ;
  int dir_okay ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  __uid_t tmp___12 ;
  __gid_t tmp___13 ;
  int __attribute__((__gnu_inline__))  tmp___14 ;
  size_t tmp___15 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char const   *mem_32 ;
  char const   *mem_33 ;
  char const   *mem_34 ;

  {
#line 499
  tmp = invariant((ftp_session_t const   *)f);
#line 499
  if (tmp == 0) {
#line 499
    daemon_assert_fail("invariant(f)", "ftp_session.c", 499, "change_dir");
  } else {

  }
#line 500
  if ((unsigned long )new_dir == (unsigned long )((void *)0)) {
#line 500
    daemon_assert_fail("new_dir != ((void *)0)", "ftp_session.c", 500, "change_dir");
  } else {

  }
#line 501
  tmp___0 = strlen(new_dir);
#line 501
  if (tmp___0 > 4096UL) {
#line 501
    daemon_assert_fail("strlen(new_dir) <= 4096", "ftp_session.c", 501, "change_dir");
  } else {

  }
#line 504
  p = new_dir;
#line 505
  if ((int const   )*p == 47) {
#line 507
    strcpy((char * __restrict  )(target), (char const   * __restrict  )"/");
    {
#line 508
    while (1) {
      while_continue: /* CIL Label */ ;
#line 509
      p ++;
#line 508
      if ((int const   )*p != 47) {
#line 508
        goto while_break;
      } else {

      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 513
    tmp___1 = strlen((char const   *)(f->dir));
#line 513
    if (tmp___1 >= sizeof(target)) {
#line 513
      daemon_assert_fail("strlen(f->dir) < sizeof(target)", "ftp_session.c", 513,
                         "change_dir");
    } else {

    }
#line 514
    strcpy((char * __restrict  )(target), (char const   * __restrict  )((char const   *)(f->dir)));
  }
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if ((int const   )*p != 0) {

    } else {
#line 518
      goto while_break___0;
    }
#line 521
    tmp___3 = __builtin_strchr((char *)p, '/');
#line 521
    n = (char const   *)tmp___3;
#line 522
    if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 523
      tmp___4 = __rawmemchr((void const   *)p, '\000');
#line 523
      n = (char const   *)((char *)tmp___4);
    } else {

    }
#line 525
    len = (int )(n - p);
#line 527
    if (len == 1) {
      {
#line 527
      mem_32 = p + 0;
#line 527
      if ((int const   )*mem_32 != 46) {
#line 527
        goto _L___1;
      } else {

      }
      }
    } else
    _L___1: 
#line 531
    if (len == 2) {
      {
#line 531
      mem_33 = p + 0;
#line 531
      if ((int const   )*mem_33 == 46) {
        {
#line 531
        mem_34 = p + 1;
#line 531
        if ((int const   )*mem_34 == 46) {
#line 534
          prev_dir = strrchr((char const   *)(target), '/');
#line 535
          if ((unsigned long )prev_dir == (unsigned long )((void *)0)) {
#line 535
            daemon_assert_fail("prev_dir != ((void *)0)", "ftp_session.c", 535, "change_dir");
          } else {

          }
#line 536
          *prev_dir = (char )'\000';
#line 537
          if ((unsigned long )prev_dir == (unsigned long )(target)) {
#line 538
            strcpy((char * __restrict  )(target), (char const   * __restrict  )"/");
          } else {

          }
        } else {
#line 531
          goto _L___0;
        }
        }
      } else {
#line 531
        goto _L___0;
      }
      }
    } else {
      _L___0: 
#line 544
      tmp___6 = strlen((char const   *)(target));
#line 544
      if ((tmp___6 + 1UL) + (size_t )len > 4096UL) {
#line 545
        reply(f, 550, "Error changing directory; path is too long.");
#line 546
        return;
      } else {

      }
#line 550
      tmp___7 = __rawmemchr((void const   *)(target), '\000');
#line 550
      target_end = (char *)tmp___7;
#line 551
      if ((unsigned long )target_end != (unsigned long )(target + 1)) {
#line 552
        tmp___9 = target_end;
#line 552
        target_end ++;
#line 552
        *tmp___9 = (char )'/';
      } else {

      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if ((unsigned long )p != (unsigned long )n) {

        } else {
#line 556
          goto while_break___1;
        }
#line 557
        tmp___10 = target_end;
#line 557
        target_end ++;
#line 557
        tmp___11 = p;
#line 557
        p ++;
#line 557
        *tmp___10 = (char )*tmp___11;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 559
      *target_end = (char )'\000';
    }
#line 564
    p = n;
    {
#line 567
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 567
      if ((int const   )*p == 47) {

      } else {
#line 567
        goto while_break___2;
      }
#line 568
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 573
  dir_okay = 0;
#line 574
  tmp___14 = stat((char const   * __restrict  )((char const   *)(target)), (struct stat * __restrict  )(& stat_buf));
#line 574
  if (tmp___14 == (int __attribute__((__gnu_inline__))  )0) {
#line 576
    if ((stat_buf.st_mode & 61440U) != 16384U) {
#line 580
      reply(f, 550, "Directory change failed; target is not a directory.");
    } else
#line 582
    if (((unsigned int )((64 >> 3) >> 3) & stat_buf.st_mode) != 0) {
#line 583
      dir_okay = 1;
    } else {
#line 584
      tmp___13 = getegid();
#line 584
      if (stat_buf.st_gid == tmp___13) {
#line 584
        if (((unsigned int )(64 >> 3) & stat_buf.st_mode) != 0) {
#line 587
          dir_okay = 1;
        } else {
#line 584
          goto _L___2;
        }
      } else {
        _L___2: 
#line 588
        tmp___12 = geteuid();
#line 588
        if (stat_buf.st_uid == tmp___12) {
#line 588
          if ((64U & stat_buf.st_mode) != 0) {
#line 591
            dir_okay = 1;
          } else {
#line 593
            reply(f, 550, "Directory change failed; permission denied.");
          }
        } else {
#line 593
          reply(f, 550, "Directory change failed; permission denied.");
        }
      }
    }
  } else {
#line 597
    reply(f, 550, "Directory change failed; directory does not exist.");
  }
#line 601
  if (dir_okay != 0) {
#line 602
    tmp___15 = strlen((char const   *)(target));
#line 602
    if (tmp___15 >= sizeof(f->dir)) {
#line 602
      daemon_assert_fail("strlen(target) < sizeof(f->dir)", "ftp_session.c", 602,
                         "change_dir");
    } else {

    }
#line 604
    if (0 != 0) {
#line 604
      __s1_len = strlen((char const   *)(f->dir));
#line 604
      __s2_len = strlen((char const   *)(target));
#line 604
      if ((size_t )((void const   *)(f->dir + 1)) - (size_t )((void const   *)(f->dir)) != 1UL) {
#line 604
        goto _L___4;
      } else
#line 604
      if (__s1_len >= 4UL) {
        _L___4: 
#line 604
        if ((size_t )((void const   *)(target + 1)) - (size_t )((void const   *)(target)) != 1UL) {
#line 604
          tmp___22 = 1;
        } else
#line 604
        if (__s2_len >= 4UL) {
#line 604
          tmp___22 = 1;
        } else {
#line 604
          tmp___22 = 0;
        }
      } else {
#line 604
        tmp___22 = 0;
      }
#line 604
      if (tmp___22 != 0) {
#line 604
        tmp___17 = __builtin_strcmp((char const   *)(f->dir), (char const   *)(target));
#line 604
        tmp___21 = tmp___17;
      } else {
#line 604
        tmp___20 = __builtin_strcmp((char const   *)(f->dir), (char const   *)(target));
#line 604
        tmp___21 = tmp___20;
      }
    } else {
#line 604
      tmp___20 = __builtin_strcmp((char const   *)(f->dir), (char const   *)(target));
#line 604
      tmp___21 = tmp___20;
    }
#line 604
    if (tmp___21 != 0) {
#line 605
      strcpy((char * __restrict  )(f->dir), (char const   * __restrict  )((char const   *)(target)));
#line 606
      send_readme((ftp_session_t const   *)f, 250);
    } else {
#line 608
      strcpy((char * __restrict  )(f->dir), (char const   * __restrict  )((char const   *)(target)));
    }
#line 610
    reply(f, 250, "Directory change successful.");
  } else {

  }
#line 613
  tmp___23 = invariant((ftp_session_t const   *)f);
#line 613
  if (tmp___23 == 0) {
#line 613
    daemon_assert_fail("invariant(f)", "ftp_session.c", 613, "change_dir");
  } else {

  }
#line 614
  return;
}
}
#line 616 "ftp_session.c"
static void do_quit(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  int *__cil_tmp10 ;
  int __cil_tmp11 ;
  int *mem_10 ;

  {

#line 618
  return babel_wrapper_do_quit(f, cmd);
#line 618
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 618
  if (tmp_ssa_1 == 0) {
#line 618
    daemon_assert_fail("invariant(f)", "ftp_session.c", 618, "do_quit");
  } else {

  }
#line 619
  __cil_tmp7 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 619
  if (__cil_tmp7 == 0) {
#line 619
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 619, "do_quit");
  } else {

  }
#line 620
  __cil_tmp9 = (unsigned char *)cmd + 8;
#line 620
  __cil_tmp10 = (int *)__cil_tmp9;
#line 620
  __cil_tmp11 = *__cil_tmp10;
#line 620
  __cil_tmp8 = __cil_tmp11 == 0;
#line 620
  if (__cil_tmp8 == 0) {
#line 620
    daemon_assert_fail("cmd->num_arg == 0", "ftp_session.c", 620, "do_quit");
  } else {

  }
#line 622
  reply(f, 221, "Service closing control connection.");
#line 623
  mem_10 = (int *)f;
#line 623
  *mem_10 = 0;
#line 625
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 625
  if (tmp___0_ssa_1 == 0) {
#line 625
    daemon_assert_fail("invariant(f)", "ftp_session.c", 625, "do_quit");
  } else {

  }
#line 626
  return;
}
}
#line 629 "ftp_session.c"
static void set_port(ftp_session_t *f , sockaddr_storage_t const   *host_port ) 
{ 
  int tmp ;
  unsigned short __v ;
  unsigned short __x ;
  int tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in *mem_8 ;

  {
#line 631
  tmp = invariant((ftp_session_t const   *)f);
#line 631
  if (tmp == 0) {
#line 631
    daemon_assert_fail("invariant(f)", "ftp_session.c", 631, "set_port");
  } else {

  }
#line 632
  if ((unsigned long )host_port == (unsigned long )((void *)0)) {
#line 632
    daemon_assert_fail("host_port != ((void *)0)", "ftp_session.c", 632, "set_port");
  } else {

  }
#line 634
  if (f->epsv_all_set != 0) {
#line 635
    reply(f, 500, "After EPSV ALL, only EPSV allowed.");
  } else {
#line 636
    tmp___0 = ip_equal((sockaddr_storage_t const   *)(& f->client_addr), host_port);
#line 636
    if (tmp___0 != 0) {
#line 638
      mem_8 = (struct sockaddr_in *)host_port;
#line 638
      __x = mem_8->sin_port;
#line 638
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 638
      if ((int )__v < 1024) {
#line 639
        reply(f, 500, "Port may not be less than 1024, which is reserved.");
      } else {
#line 642
        if (f->data_channel == 1) {
#line 643
          close(f->server_fd);
#line 644
          f->server_fd = -1;
        } else {

        }
#line 647
        f->data_channel = 0;
#line 648
        f->data_port = (sockaddr_storage_t )*host_port;
#line 649
        reply(f, 200, "Command okay.");
      }
    } else {
#line 637
      reply(f, 500, "Port must be on command channel IP.");
    }
  }
#line 652
  tmp___1 = invariant((ftp_session_t const   *)f);
#line 652
  if (tmp___1 == 0) {
#line 652
    daemon_assert_fail("invariant(f)", "ftp_session.c", 652, "set_port");
  } else {

  }
#line 653
  return;
}
}
#line 656 "ftp_session.c"
static void do_port(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  sockaddr_storage_t const   *host_port_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  int *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  union __anonunion_arg_49 (*__cil_tmp16)[2] ;
  union __anonunion_arg_49 *__cil_tmp17 ;
  union __anonunion_arg_49 *__cil_tmp18 ;
  sa_family_t __cil_tmp19 ;
  int __cil_tmp20 ;
  sa_family_t *mem_18 ;

  {

#line 660
  return babel_wrapper_do_port(f, cmd);
#line 660
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 660
  if (tmp_ssa_1 == 0) {
#line 660
    daemon_assert_fail("invariant(f)", "ftp_session.c", 660, "do_port");
  } else {

  }
#line 661
  __cil_tmp9 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 661
  if (__cil_tmp9 == 0) {
#line 661
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 661, "do_port");
  } else {

  }
#line 662
  __cil_tmp12 = (unsigned char *)cmd + 8;
#line 662
  __cil_tmp13 = (int *)__cil_tmp12;
#line 662
  __cil_tmp14 = *__cil_tmp13;
#line 662
  __cil_tmp10 = __cil_tmp14 == 1;
#line 662
  if (__cil_tmp10 == 0) {
#line 662
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 662, "do_port");
  } else {

  }
#line 664
  __cil_tmp15 = (unsigned char *)cmd + 16;
#line 664
  __cil_tmp16 = (union __anonunion_arg_49 (*)[2])__cil_tmp15;
#line 664
  __cil_tmp17 = *__cil_tmp16;
#line 664
  __cil_tmp18 = __cil_tmp17;
#line 664
  host_port_ssa_1 = (sockaddr_storage_t const   *)((sockaddr_storage_t *)__cil_tmp18);
#line 665
  mem_18 = (sa_family_t *)((struct sockaddr_storage *)host_port_ssa_1);
#line 665
  __cil_tmp19 = *mem_18;
#line 665
  __cil_tmp20 = (int )__cil_tmp19;
#line 665
  __cil_tmp11 = __cil_tmp20 == 2;
#line 665
  if (__cil_tmp11 == 0) {
#line 665
    daemon_assert_fail("(((struct sockaddr_storage *)(host_port))->ss_family) == 2",
                       "ftp_session.c", 665, "do_port");
  } else {

  }
#line 667
  set_port(f, host_port_ssa_1);
#line 669
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 669
  if (tmp___0_ssa_1 == 0) {
#line 669
    daemon_assert_fail("invariant(f)", "ftp_session.c", 669, "do_port");
  } else {

  }
#line 670
  return;
}
}
#line 673 "ftp_session.c"
static void do_lprt(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  sockaddr_storage_t const   *host_port_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  int *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  union __anonunion_arg_49 (*__cil_tmp16)[2] ;
  union __anonunion_arg_49 *__cil_tmp17 ;
  union __anonunion_arg_49 *__cil_tmp18 ;
  sa_family_t __cil_tmp19 ;
  int __cil_tmp20 ;
  sa_family_t *mem_18 ;

  {

#line 677
  return babel_wrapper_do_lprt(f, cmd);
#line 677
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 677
  if (tmp_ssa_1 == 0) {
#line 677
    daemon_assert_fail("invariant(f)", "ftp_session.c", 677, "do_lprt");
  } else {

  }
#line 678
  __cil_tmp9 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 678
  if (__cil_tmp9 == 0) {
#line 678
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 678, "do_lprt");
  } else {

  }
#line 679
  __cil_tmp12 = (unsigned char *)cmd + 8;
#line 679
  __cil_tmp13 = (int *)__cil_tmp12;
#line 679
  __cil_tmp14 = *__cil_tmp13;
#line 679
  __cil_tmp10 = __cil_tmp14 == 1;
#line 679
  if (__cil_tmp10 == 0) {
#line 679
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 679, "do_lprt");
  } else {

  }
#line 681
  __cil_tmp15 = (unsigned char *)cmd + 16;
#line 681
  __cil_tmp16 = (union __anonunion_arg_49 (*)[2])__cil_tmp15;
#line 681
  __cil_tmp17 = *__cil_tmp16;
#line 681
  __cil_tmp18 = __cil_tmp17;
#line 681
  host_port_ssa_1 = (sockaddr_storage_t const   *)((sockaddr_storage_t *)__cil_tmp18);
#line 688
  mem_18 = (sa_family_t *)((struct sockaddr_storage *)host_port_ssa_1);
#line 688
  __cil_tmp19 = *mem_18;
#line 688
  __cil_tmp20 = (int )__cil_tmp19;
#line 688
  __cil_tmp11 = __cil_tmp20 != 2;
#line 688
  if (__cil_tmp11 != 0) {
#line 689
    reply(f, 521, "Only IPv4 supported, address family (4)");
  } else {

  }
#line 693
  set_port(f, host_port_ssa_1);
#line 695
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 695
  if (tmp___0_ssa_1 == 0) {
#line 695
    daemon_assert_fail("invariant(f)", "ftp_session.c", 695, "do_lprt");
  } else {

  }
#line 696
  return;
}
}
#line 704 "ftp_session.c"
static void do_eprt(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  int *__cil_tmp11 ;
  int __cil_tmp12 ;

  {

#line 708
  return babel_wrapper_do_eprt(f, cmd);
#line 708
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 708
  if (tmp_ssa_1 == 0) {
#line 708
    daemon_assert_fail("invariant(f)", "ftp_session.c", 708, "do_eprt");
  } else {

  }
#line 709
  __cil_tmp8 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 709
  if (__cil_tmp8 == 0) {
#line 709
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 709, "do_eprt");
  } else {

  }
#line 710
  __cil_tmp10 = (unsigned char *)cmd + 8;
#line 710
  __cil_tmp11 = (int *)__cil_tmp10;
#line 710
  __cil_tmp12 = *__cil_tmp11;
#line 710
  __cil_tmp9 = __cil_tmp12 == 1;
#line 710
  if (__cil_tmp9 == 0) {
#line 710
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 710, "do_eprt");
  } else {

  }
#line 712
  reply(f, 500, "EPRT not supported, use EPSV.");
#line 714
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 714
  if (tmp___0_ssa_1 == 0) {
#line 714
    daemon_assert_fail("invariant(f)", "ftp_session.c", 714, "do_eprt");
  } else {

  }
#line 715
  return;
}
}
#line 720 "ftp_session.c"
static int set_pasv(ftp_session_t *f , sockaddr_storage_t *bind_addr ) 
{ 
  int socket_fd ;
  int port ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  unsigned short __v ;
  unsigned short __x ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  struct sockaddr_storage *mem_17 ;

  {
#line 725
  tmp = invariant((ftp_session_t const   *)f);
#line 725
  if (tmp == 0) {
#line 725
    daemon_assert_fail("invariant(f)", "ftp_session.c", 725, "set_pasv");
  } else {

  }
#line 726
  if ((unsigned long )bind_addr == (unsigned long )((void *)0)) {
#line 726
    daemon_assert_fail("bind_addr != ((void *)0)", "ftp_session.c", 726, "set_pasv");
  } else {

  }
#line 728
  mem_17 = (struct sockaddr_storage *)bind_addr;
#line 728
  socket_fd = socket((int )mem_17->ss_family, 1, 0);
#line 729
  if (socket_fd == -1) {
#line 730
    tmp___0 = __errno_location();
#line 730
    tmp___1 = strerror(*tmp___0);
#line 730
    reply(f, 500, "Error creating server socket; %s.", tmp___1);
#line 731
    return (-1);
  } else {

  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    port = get_passive_port();
#line 736
    __x = (unsigned short )port;
#line 736
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 736
    bind_addr->sin_port = __v;
#line 737
    tmp___2 = bind(socket_fd, (struct sockaddr  const  *)((struct sockaddr *)bind_addr),
                   (socklen_t )sizeof(struct sockaddr ));
#line 737
    if (tmp___2 == 0) {
#line 740
      goto while_break;
    } else {

    }
#line 742
    tmp___5 = __errno_location();
#line 742
    if (*tmp___5 != 98) {
#line 743
      tmp___3 = __errno_location();
#line 743
      tmp___4 = strerror(*tmp___3);
#line 743
      reply(f, 500, "Error binding server port; %s.", tmp___4);
#line 744
      close(socket_fd);
#line 745
      return (-1);
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  tmp___8 = listen(socket_fd, 1);
#line 749
  if (tmp___8 != 0) {
#line 750
    tmp___6 = __errno_location();
#line 750
    tmp___7 = strerror(*tmp___6);
#line 750
    reply(f, 500, "Error listening on server port; %s.", tmp___7);
#line 751
    close(socket_fd);
#line 752
    return (-1);
  } else {

  }
#line 755
  return (socket_fd);
}
}
#line 759 "ftp_session.c"
static void do_pasv(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int socket_fd ;
  unsigned int addr ;
  int port ;
  int tmp ;
  unsigned short __v ;
  unsigned short __x ;
  int tmp___0 ;

  {
#line 765
  tmp = invariant((ftp_session_t const   *)f);
#line 765
  if (tmp == 0) {
#line 765
    daemon_assert_fail("invariant(f)", "ftp_session.c", 765, "do_pasv");
  } else {

  }
#line 766
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 766
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 766, "do_pasv");
  } else {

  }
#line 767
  if (cmd->num_arg != 0) {
#line 767
    daemon_assert_fail("cmd->num_arg == 0", "ftp_session.c", 767, "do_pasv");
  } else {

  }
#line 769
  if (f->epsv_all_set != 0) {
#line 770
    reply(f, 500, "After EPSV ALL, only EPSV allowed.");
#line 771
    goto exit_pasv;
  } else {

  }
#line 774
  socket_fd = set_pasv(f, & f->server_ipv4_addr);
#line 775
  if (socket_fd == -1) {
#line 776
    goto exit_pasv;
  } else {

  }
#line 780
  addr = __bswap_32(f->server_ipv4_addr.sin_addr.s_addr);
#line 781
  __x = f->server_ipv4_addr.sin_port;
#line 781
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 781
  port = (int )__v;
#line 782
  reply(f, 227, "Entering Passive Mode (%d,%d,%d,%d,%d,%d).", addr >> 24, (addr >> 16) & 255U,
        (addr >> 8) & 255U, addr & 255U, port >> 8, port & 255);
#line 791
  if (f->data_channel == 1) {
#line 792
    close(f->server_fd);
  } else {

  }
#line 794
  f->data_channel = 1;
#line 795
  f->server_fd = socket_fd;
  exit_pasv: 
#line 798
  tmp___0 = invariant((ftp_session_t const   *)f);
#line 798
  if (tmp___0 == 0) {
#line 798
    daemon_assert_fail("invariant(f)", "ftp_session.c", 798, "do_pasv");
  } else {

  }
#line 799
  return;
}
}
#line 802 "ftp_session.c"
static void do_lpsv(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int socket_fd ;
  char addr[80] ;
  uint8_t *a ;
  uint8_t *p ;
  int tmp ;
  int tmp___0 ;
  uint8_t *mem_9 ;
  uint8_t *mem_10 ;
  uint8_t *mem_11 ;
  uint8_t *mem_12 ;
  uint8_t *mem_13 ;
  uint8_t *mem_14 ;

  {
#line 809
  tmp = invariant((ftp_session_t const   *)f);
#line 809
  if (tmp == 0) {
#line 809
    daemon_assert_fail("invariant(f)", "ftp_session.c", 809, "do_lpsv");
  } else {

  }
#line 810
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 810
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 810, "do_lpsv");
  } else {

  }
#line 811
  if (cmd->num_arg != 0) {
#line 811
    daemon_assert_fail("cmd->num_arg == 0", "ftp_session.c", 811, "do_lpsv");
  } else {

  }
#line 813
  if (f->epsv_all_set != 0) {
#line 814
    reply(f, 500, "After EPSV ALL, only EPSV allowed.");
#line 815
    goto exit_lpsv;
  } else {

  }
#line 818
  socket_fd = set_pasv(f, & f->server_addr);
#line 819
  if (socket_fd == -1) {
#line 820
    goto exit_lpsv;
  } else {

  }
#line 835
  a = (uint8_t *)(& f->server_addr.sin_addr);
#line 836
  p = (uint8_t *)(& f->server_addr.sin_port);
#line 837
  mem_9 = a + 0;
#line 837
  mem_10 = a + 1;
#line 837
  mem_11 = a + 2;
#line 837
  mem_12 = a + 3;
#line 837
  mem_13 = p + 0;
#line 837
  mem_14 = p + 1;
#line 837
  snprintf((char * __restrict  )(addr), sizeof(addr), (char const   * __restrict  )"(4,4,%d,%d,%d,%d,2,%d,%d)",
           (int )*mem_9, (int )*mem_10, (int )*mem_11, (int )*mem_12, (int )*mem_13,
           (int )*mem_14);
#line 841
  reply(f, 228, "Entering Long Passive Mode %s", addr);
#line 844
  if (f->data_channel == 1) {
#line 845
    close(f->server_fd);
  } else {

  }
#line 847
  f->data_channel = 1;
#line 848
  f->server_fd = socket_fd;
  exit_lpsv: 
#line 851
  tmp___0 = invariant((ftp_session_t const   *)f);
#line 851
  if (tmp___0 == 0) {
#line 851
    daemon_assert_fail("invariant(f)", "ftp_session.c", 851, "do_lpsv");
  } else {

  }
#line 852
  return;
}
}
#line 855 "ftp_session.c"
static void do_epsv(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int socket_fd ;
  sockaddr_storage_t *addr ;
  int tmp ;
  unsigned short __v ;
  unsigned short __x ;
  int tmp___0 ;

  {
#line 860
  tmp = invariant((ftp_session_t const   *)f);
#line 860
  if (tmp == 0) {
#line 860
    daemon_assert_fail("invariant(f)", "ftp_session.c", 860, "do_epsv");
  } else {

  }
#line 861
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 861
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 861, "do_epsv");
  } else {

  }
#line 862
  if (cmd->num_arg != 0) {
#line 862
    if (cmd->num_arg != 1) {
#line 862
      daemon_assert_fail("(cmd->num_arg == 0) || (cmd->num_arg == 1)", "ftp_session.c",
                         862, "do_epsv");
    } else {

    }
  } else {

  }
#line 865
  if (cmd->num_arg == 0) {
#line 866
    addr = & f->server_addr;
  } else {
    {
#line 869
    if (cmd->arg[0].num == -1) {
#line 869
      goto case_neg_1;
    } else {

    }
#line 877
    if (cmd->arg[0].num == 1) {
#line 877
      goto case_1;
    } else {

    }
#line 880
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 874
    f->epsv_all_set = 1;
#line 875
    reply(f, 200, "EPSV ALL command successful.");
#line 876
    goto exit_epsv;
    case_1: /* CIL Label */ 
#line 878
    addr = & f->server_ipv4_addr;
#line 879
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 889
    reply(f, 522, "Only IPv4 supported, use (1)");
#line 890
    goto exit_epsv;
    switch_break: /* CIL Label */ ;
    }
  }
#line 896
  socket_fd = set_pasv(f, addr);
#line 897
  if (socket_fd == -1) {
#line 898
    goto exit_epsv;
  } else {

  }
#line 903
  __x = f->server_addr.sin_port;
#line 903
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 903
  reply(f, 229, "Entering Extended Passive Mode (|||%d|)", (int )__v);
#line 906
  if (f->data_channel == 1) {
#line 907
    close(f->server_fd);
  } else {

  }
#line 909
  f->data_channel = 1;
#line 910
  f->server_fd = socket_fd;
  exit_epsv: 
#line 913
  tmp___0 = invariant((ftp_session_t const   *)f);
#line 913
  if (tmp___0 == 0) {
#line 913
    daemon_assert_fail("invariant(f)", "ftp_session.c", 913, "do_epsv");
  } else {

  }
#line 914
  return;
}
}
#line 917 "ftp_session.c"
static void init_passive_port(void) 
{ 
  struct timeval tv ;
  unsigned short seed[3] ;
  struct timeval *__cil_pp_tv ;
  __time_t __cil_tmp4 ;
  __time_t __cil_tmp5 ;
  long __cil_tmp6 ;
  __time_t __cil_tmp7 ;
  long __cil_tmp8 ;
  unsigned short *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  __suseconds_t___1 *__cil_tmp11 ;
  __suseconds_t___1 __cil_tmp12 ;
  long __cil_tmp13 ;
  unsigned short *__cil_tmp14 ;
  unsigned short *__cil_tmp15 ;
  __time_t *mem_16 ;
  __time_t *mem_17 ;

  {
#line 921
  __cil_pp_tv = & tv;
#line 921
  return babel_wrapper_init_passive_port(__cil_pp_tv, seed);
#line 921
  __cil_pp_tv = & tv;
#line 922
  gettimeofday((struct timeval * __restrict  )__cil_pp_tv, (__timezone_ptr_t )0);
#line 923
  mem_16 = (__time_t *)__cil_pp_tv;
#line 923
  __cil_tmp4 = *mem_16;
#line 923
  __cil_tmp5 = __cil_tmp4 >> 16;
#line 923
  __cil_tmp6 = __cil_tmp5 & 65535L;
#line 923
  seed[0] = (unsigned short )__cil_tmp6;
#line 924
  mem_17 = (__time_t *)__cil_pp_tv;
#line 924
  __cil_tmp7 = *mem_17;
#line 924
  __cil_tmp8 = __cil_tmp7 & 65535L;
#line 924
  __cil_tmp9 = seed + 1;
#line 924
  *__cil_tmp9 = (unsigned short )__cil_tmp8;
#line 925
  __cil_tmp10 = (unsigned char *)__cil_pp_tv + 8;
#line 925
  __cil_tmp11 = (__suseconds_t___1 *)__cil_tmp10;
#line 925
  __cil_tmp12 = *__cil_tmp11;
#line 925
  __cil_tmp13 = __cil_tmp12 & 65535L;
#line 925
  __cil_tmp14 = seed + 2;
#line 925
  *__cil_tmp14 = (unsigned short )__cil_tmp13;
#line 926
  __cil_tmp15 = seed;
#line 926
  seed48(__cil_tmp15);
#line 927
  return;
}
}
#line 930 "ftp_session.c"
static int get_passive_port(void) 
{ 
  pthread_once_t *__cil_pp_once_control ;
  void (*__cil_pp_init_passive_port)(void) ;
  pthread_mutex_t *__cil_pp_mutex ;
  long tmp_ssa_1 ;
  int port_ssa_1 ;
  long __cil_tmp8 ;
  long __cil_tmp9 ;

  {
#line 932
  __cil_pp_mutex = & mutex;
#line 932
  __cil_pp_init_passive_port = & init_passive_port;
#line 932
  __cil_pp_once_control = & once_control;
#line 932
  return babel_wrapper_get_passive_port(__cil_pp_once_control, __cil_pp_init_passive_port,
                                        __cil_pp_mutex);
#line 932
  __cil_pp_once_control = & once_control;
#line 933
  __cil_pp_init_passive_port = & init_passive_port;
#line 934
  __cil_pp_mutex = & mutex;
#line 937
  pthread_once(__cil_pp_once_control, __cil_pp_init_passive_port);
#line 940
  pthread_mutex_lock(__cil_pp_mutex);
#line 941
  tmp_ssa_1 = lrand48();
#line 941
  __cil_tmp8 = tmp_ssa_1 % 64512L;
#line 941
  __cil_tmp9 = __cil_tmp8 + 1024L;
#line 941
  port_ssa_1 = (int )__cil_tmp9;
#line 942
  pthread_mutex_unlock(__cil_pp_mutex);
#line 944
  return (port_ssa_1);
}
}
#line 947 "ftp_session.c"
static void do_type(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  char type_ssa_1 ;
  char form_ssa_1 ;
  int cmd_okay_ssa_1 ;
  int cmd_okay_ssa_2 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  int *__cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  int *__cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  union __anonunion_arg_49 (*__cil_tmp30)[2] ;
  union __anonunion_arg_49 *__cil_tmp31 ;
  union __anonunion_arg_49 *__cil_tmp32 ;
  char (*__cil_tmp33)[4097] ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  union __anonunion_arg_49 (*__cil_tmp40)[2] ;
  union __anonunion_arg_49 *__cil_tmp41 ;
  union __anonunion_arg_49 *__cil_tmp42 ;
  char (*__cil_tmp43)[4097] ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  int *__cil_tmp47 ;
  int __cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  int *__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  int *__cil_tmp52 ;
  int __cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  int *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  int *__cil_tmp57 ;

  {

#line 953
  return babel_wrapper_do_type(f, cmd);
#line 953
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 953
  if (tmp_ssa_1 == 0) {
#line 953
    daemon_assert_fail("invariant(f)", "ftp_session.c", 953, "do_type");
  } else {

  }
#line 954
  __cil_tmp14 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 954
  if (__cil_tmp14 == 0) {
#line 954
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 954, "do_type");
  } else {

  }
#line 955
  __cil_tmp23 = (unsigned char *)cmd + 8;
#line 955
  __cil_tmp24 = (int *)__cil_tmp23;
#line 955
  __cil_tmp25 = *__cil_tmp24;
#line 955
  __cil_tmp15 = __cil_tmp25 >= 1;
#line 955
  if (__cil_tmp15 == 0) {
#line 955
    daemon_assert_fail("cmd->num_arg >= 1", "ftp_session.c", 955, "do_type");
  } else {

  }
#line 956
  __cil_tmp26 = (unsigned char *)cmd + 8;
#line 956
  __cil_tmp27 = (int *)__cil_tmp26;
#line 956
  __cil_tmp28 = *__cil_tmp27;
#line 956
  __cil_tmp16 = __cil_tmp28 <= 2;
#line 956
  if (__cil_tmp16 == 0) {
#line 956
    daemon_assert_fail("cmd->num_arg <= 2", "ftp_session.c", 956, "do_type");
  } else {

  }
#line 958
  __cil_tmp29 = (unsigned char *)cmd + 16;
#line 958
  __cil_tmp30 = (union __anonunion_arg_49 (*)[2])__cil_tmp29;
#line 958
  __cil_tmp31 = *__cil_tmp30;
#line 958
  __cil_tmp32 = __cil_tmp31;
#line 958
  __cil_tmp33 = (char (*)[4097])__cil_tmp32;
#line 958
  __cil_tmp34 = *__cil_tmp33;
#line 958
  __cil_tmp35 = __cil_tmp34;
#line 958
  type_ssa_1 = *__cil_tmp35;
#line 959
  __cil_tmp36 = (unsigned char *)cmd + 8;
#line 959
  __cil_tmp37 = (int *)__cil_tmp36;
#line 959
  __cil_tmp38 = *__cil_tmp37;
#line 959
  __cil_tmp17 = __cil_tmp38 == 2;
#line 959
  if (__cil_tmp17 != 0) {
#line 960
    __cil_tmp39 = (unsigned char *)cmd + 16;
#line 960
    __cil_tmp40 = (union __anonunion_arg_49 (*)[2])__cil_tmp39;
#line 960
    __cil_tmp41 = *__cil_tmp40;
#line 960
    __cil_tmp42 = __cil_tmp41 + 1;
#line 960
    __cil_tmp43 = (char (*)[4097])__cil_tmp42;
#line 960
    __cil_tmp44 = *__cil_tmp43;
#line 960
    __cil_tmp45 = __cil_tmp44;
#line 960
    form_ssa_1 = *__cil_tmp45;
  } else {
#line 962
    form_ssa_1 = (char)0;
  }
#line 965
  cmd_okay_ssa_1 = 0;
#line 966
  __cil_tmp18 = (int )type_ssa_1 == 65;
#line 966
  if (__cil_tmp18 != 0) {
#line 967
    __cil_tmp46 = (unsigned char *)cmd + 8;
#line 967
    __cil_tmp47 = (int *)__cil_tmp46;
#line 967
    __cil_tmp48 = *__cil_tmp47;
#line 967
    __cil_tmp19 = __cil_tmp48 == 1;
#line 967
    if (__cil_tmp19 != 0) {
#line 968
      __cil_tmp49 = (unsigned char *)f + 16;
#line 968
      __cil_tmp50 = (int *)__cil_tmp49;
#line 968
      *__cil_tmp50 = 0;
#line 969
      cmd_okay_ssa_2 = 1;
    } else {
#line 967
      __cil_tmp51 = (unsigned char *)cmd + 8;
#line 967
      __cil_tmp52 = (int *)__cil_tmp51;
#line 967
      __cil_tmp53 = *__cil_tmp52;
#line 967
      __cil_tmp20 = __cil_tmp53 == 2;
#line 967
      if (__cil_tmp20 != 0) {
#line 967
        __cil_tmp21 = (int )form_ssa_1 == 78;
#line 967
        if (__cil_tmp21 != 0) {
#line 968
          __cil_tmp54 = (unsigned char *)f + 16;
#line 968
          __cil_tmp55 = (int *)__cil_tmp54;
#line 968
          *__cil_tmp55 = 0;
#line 969
          cmd_okay_ssa_2 = 1;
        } else {
#line 972
          cmd_okay_ssa_2 = cmd_okay_ssa_1;
        }
      } else {
#line 976
        cmd_okay_ssa_2 = cmd_okay_ssa_1;
      }
    }
  } else {
#line 971
    __cil_tmp22 = (int )type_ssa_1 == 73;
#line 971
    if (__cil_tmp22 != 0) {
#line 972
      __cil_tmp56 = (unsigned char *)f + 16;
#line 972
      __cil_tmp57 = (int *)__cil_tmp56;
#line 972
      *__cil_tmp57 = 1;
#line 973
      cmd_okay_ssa_2 = 1;
    } else {
#line 976
      cmd_okay_ssa_2 = cmd_okay_ssa_1;
    }
  }
#line 976
  if (cmd_okay_ssa_2 != 0) {
#line 977
    reply(f, 200, "Command okay.");
  } else {
#line 979
    reply(f, 504, "Command not implemented for that parameter.");
  }
#line 982
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 982
  if (tmp___0_ssa_1 == 0) {
#line 982
    daemon_assert_fail("invariant(f)", "ftp_session.c", 982, "do_type");
  } else {

  }
#line 983
  return;
}
}
static void do_stru(ftp_session_t *f, const ftp_command_t *cmd)
{
    char structure;
    int cmd_okay;

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 990, __func__)));
    ((cmd != 
# 991 "ftp_session.c" 3 4
   ((void *)0)
# 991 "ftp_session.c"
   ) ? 0 : (daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 991, __func__)));
    ((cmd->num_arg == 1) ? 0 : (daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 992, __func__)));

    structure = cmd->arg[0].string[0];
    cmd_okay = 0;
    if (structure == 'F') {
        f->file_structure = 0;
        cmd_okay = 1;
    } else if (structure == 'R') {
        f->file_structure = 1;
        cmd_okay = 1;
    }

    if (cmd_okay) {
        reply(f, 200, "Command okay.");
    } else {
        reply(f, 504, "Command not implemented for that parameter.");
    }

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 1010, __func__)));
}


#line 1013 "ftp_session.c"
static void do_mode(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  char mode_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  int *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  union __anonunion_arg_49 (*__cil_tmp16)[2] ;
  union __anonunion_arg_49 *__cil_tmp17 ;
  union __anonunion_arg_49 *__cil_tmp18 ;
  char (*__cil_tmp19)[4097] ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {

#line 1017
  return babel_wrapper_do_mode(f, cmd);
#line 1017
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1017
  if (tmp_ssa_1 == 0) {
#line 1017
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1017, "do_mode");
  } else {

  }
#line 1018
  __cil_tmp9 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 1018
  if (__cil_tmp9 == 0) {
#line 1018
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1018, "do_mode");
  } else {

  }
#line 1019
  __cil_tmp12 = (unsigned char *)cmd + 8;
#line 1019
  __cil_tmp13 = (int *)__cil_tmp12;
#line 1019
  __cil_tmp14 = *__cil_tmp13;
#line 1019
  __cil_tmp10 = __cil_tmp14 == 1;
#line 1019
  if (__cil_tmp10 == 0) {
#line 1019
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1019, "do_mode");
  } else {

  }
#line 1021
  __cil_tmp15 = (unsigned char *)cmd + 16;
#line 1021
  __cil_tmp16 = (union __anonunion_arg_49 (*)[2])__cil_tmp15;
#line 1021
  __cil_tmp17 = *__cil_tmp16;
#line 1021
  __cil_tmp18 = __cil_tmp17;
#line 1021
  __cil_tmp19 = (char (*)[4097])__cil_tmp18;
#line 1021
  __cil_tmp20 = *__cil_tmp19;
#line 1021
  __cil_tmp21 = __cil_tmp20;
#line 1021
  mode_ssa_1 = *__cil_tmp21;
#line 1022
  __cil_tmp11 = (int )mode_ssa_1 == 83;
#line 1022
  if (__cil_tmp11 != 0) {
#line 1023
    reply(f, 200, "Command okay.");
  } else {
#line 1025
    reply(f, 504, "Command not implemented for that parameter.");
  }
#line 1028
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1028
  if (tmp___0_ssa_1 == 0) {
#line 1028
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1028, "do_mode");
  } else {

  }
#line 1029
  return;
}
}
#line 1032 "ftp_session.c"
static void get_absolute_fname(char *fname , int fname_len , char const   *dir , char const   *file ) 
{ 
  size_t tmp_ssa_1 ;
  size_t tmp___0_ssa_1 ;
  size_t tmp___1_ssa_1 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char __cil_tmp18 ;
  int __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp21 ;
  char *__cil_tmp22 ;
  char __cil_tmp23 ;
  int __cil_tmp24 ;

  {

#line 1037
  return babel_wrapper_get_absolute_fname(fname, fname_len, dir, file);
#line 1037
  __cil_tmp11 = (unsigned long )fname != (unsigned long )((void *)0);
#line 1037
  if (__cil_tmp11 == 0) {
#line 1037
    daemon_assert_fail("fname != ((void *)0)", "ftp_session.c", 1037, "get_absolute_fname");
  } else {

  }
#line 1038
  __cil_tmp12 = (unsigned long )dir != (unsigned long )((void *)0);
#line 1038
  if (__cil_tmp12 == 0) {
#line 1038
    daemon_assert_fail("dir != ((void *)0)", "ftp_session.c", 1038, "get_absolute_fname");
  } else {

  }
#line 1039
  __cil_tmp13 = (unsigned long )file != (unsigned long )((void *)0);
#line 1039
  if (__cil_tmp13 == 0) {
#line 1039
    daemon_assert_fail("file != ((void *)0)", "ftp_session.c", 1039, "get_absolute_fname");
  } else {

  }
#line 1041
  __cil_tmp18 = (char )*file;
#line 1041
  __cil_tmp19 = (int )((int const   )__cil_tmp18);
#line 1041
  __cil_tmp14 = __cil_tmp19 == 47;
#line 1041
  if (__cil_tmp14 != 0) {
#line 1044
    tmp_ssa_1 = strlen(file);
#line 1044
    __cil_tmp15 = tmp_ssa_1 < (size_t )fname_len;
#line 1044
    if (__cil_tmp15 == 0) {
#line 1044
      daemon_assert_fail("strlen(file) < fname_len", "ftp_session.c", 1044, "get_absolute_fname");
    } else {

    }
#line 1045
    strcpy((char * __restrict  )fname, (char const   * __restrict  )file);
  } else {
#line 1050
    tmp___0_ssa_1 = strlen(dir);
#line 1050
    tmp___1_ssa_1 = strlen(file);
#line 1050
    __cil_tmp20 = tmp___0_ssa_1 + 1UL;
#line 1050
    __cil_tmp21 = __cil_tmp20 + tmp___1_ssa_1;
#line 1050
    __cil_tmp16 = __cil_tmp21 < (size_t )fname_len;
#line 1050
    if (__cil_tmp16 == 0) {
#line 1050
      daemon_assert_fail("strlen(dir) + 1 + strlen(file) < fname_len", "ftp_session.c",
                         1050, "get_absolute_fname");
    } else {

    }
#line 1051
    strcpy((char * __restrict  )fname, (char const   * __restrict  )dir);
#line 1054
    __cil_tmp22 = fname + 1;
#line 1054
    __cil_tmp23 = *__cil_tmp22;
#line 1054
    __cil_tmp24 = (int )__cil_tmp23;
#line 1054
    __cil_tmp17 = __cil_tmp24 != 0;
#line 1054
    if (__cil_tmp17 != 0) {
#line 1055
      strcat((char * __restrict  )fname, (char const   * __restrict  )"/");
    } else {

    }
#line 1059
    strcat((char * __restrict  )fname, (char const   * __restrict  )file);
  }
#line 1062
  return;
}
}
#line 1064 "ftp_session.c"
static void do_retr(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  char const   *file_name ;
  char full_path[8193] ;
  int file_fd ;
  struct stat stat_buf ;
  int socket_fd ;
  int read_ret ;
  char buf[4096] ;
  char converted_buf[8192] ;
  int converted_buflen ;
  struct timeval start_timestamp ;
  struct timeval end_timestamp ;
  struct timeval transfer_time ;
  off_t file_size ;
  off_t offset ;
  off_t amt_to_send ;
  int sendfile_ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int __attribute__((__gnu_inline__))  tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __off_t tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;

  {
#line 1085
  tmp = invariant((ftp_session_t const   *)f);
#line 1085
  if (tmp == 0) {
#line 1085
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1085, "do_retr");
  } else {

  }
#line 1086
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 1086
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1086, "do_retr");
  } else {

  }
#line 1087
  if (cmd->num_arg != 1) {
#line 1087
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1087, "do_retr");
  } else {

  }
#line 1091
  socket_fd = -1;
#line 1094
  file_name = (char const   *)(cmd->arg[0].string);
#line 1095
  get_absolute_fname(full_path, (int )sizeof(full_path), (char const   *)(f->dir),
                     file_name);
#line 1098
  file_fd = open((char const   *)(full_path), 0);
#line 1099
  if (file_fd == -1) {
#line 1100
    tmp___0 = __errno_location();
#line 1100
    tmp___1 = strerror(*tmp___0);
#line 1100
    reply(f, 550, "Error opening file; %s.", tmp___1);
#line 1101
    goto exit_retr;
  } else {

  }
#line 1103
  tmp___4 = fstat(file_fd, & stat_buf);
#line 1103
  if (tmp___4 != (int __attribute__((__gnu_inline__))  )0) {
#line 1104
    tmp___2 = __errno_location();
#line 1104
    tmp___3 = strerror(*tmp___2);
#line 1104
    reply(f, 550, "Error getting file information; %s.", tmp___3);
#line 1105
    goto exit_retr;
  } else {

  }
#line 1108
  if ((stat_buf.st_mode & 61440U) == 16384U) {
#line 1112
    reply(f, 550, "Error, file is a directory.");
#line 1113
    goto exit_retr;
  } else {

  }
#line 1118
  if (f->file_offset_command_number == f->command_number - 1UL) {
#line 1118
    if (f->file_offset > 0L) {
#line 1121
      tmp___7 = lseek(file_fd, f->file_offset, 0);
#line 1121
      if (tmp___7 == -1L) {
#line 1122
        tmp___5 = __errno_location();
#line 1122
        tmp___6 = strerror(*tmp___5);
#line 1122
        reply(f, 550, "Error seeking to restart position; %s.", tmp___6);
#line 1124
        goto exit_retr;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1129
  reply(f, 150, "About to open data connection.");
#line 1132
  gettimeofday((struct timeval * __restrict  )(& start_timestamp), (__timezone_ptr_t )((void *)0));
#line 1135
  socket_fd = open_connection(f);
#line 1136
  if (socket_fd == -1) {
#line 1137
    goto exit_retr;
  } else {

  }
#line 1141
  file_size = (off_t )0;
#line 1142
  if (f->data_type == 0) {
    {
#line 1143
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1144
      tmp___8 = read(file_fd, (void *)(buf), sizeof(buf));
#line 1144
      read_ret = (int )tmp___8;
#line 1145
      if (read_ret == -1) {
#line 1146
        tmp___9 = __errno_location();
#line 1146
        tmp___10 = strerror(*tmp___9);
#line 1146
        reply(f, 550, "Error reading from file; %s.", tmp___10);
#line 1147
        goto exit_retr;
      } else {

      }
#line 1149
      if (read_ret == 0) {
#line 1150
        goto while_break;
      } else {

      }
#line 1152
      converted_buflen = convert_newlines(converted_buf, (char const   *)(buf), read_ret);
#line 1154
      tmp___13 = write_fully(socket_fd, (char const   *)(converted_buf), converted_buflen);
#line 1154
      if (tmp___13 == -1) {
#line 1155
        tmp___11 = __errno_location();
#line 1155
        tmp___12 = strerror(*tmp___11);
#line 1155
        reply(f, 550, "Error writing to data connection; %s.", tmp___12);
#line 1157
        goto exit_retr;
      } else {

      }
#line 1160
      file_size += (off_t )converted_buflen;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1163
    if (f->data_type != 1) {
#line 1163
      daemon_assert_fail("f->data_type == 1", "ftp_session.c", 1163, "do_retr");
    } else {

    }
#line 1169
    offset = f->file_offset;
#line 1170
    file_size = stat_buf.st_size - offset;
    {
#line 1171
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1171
      if (offset < stat_buf.st_size) {

      } else {
#line 1171
        goto while_break___0;
      }
#line 1173
      amt_to_send = stat_buf.st_size - offset;
#line 1174
      if (amt_to_send > 65536L) {
#line 1175
        amt_to_send = (off_t )65536;
      } else {

      }
#line 1178
      sendfile_ret = sendfile(socket_fd, file_fd, & offset, amt_to_send);
#line 1182
      if ((off_t )sendfile_ret != amt_to_send) {
#line 1183
        tmp___14 = __errno_location();
#line 1183
        tmp___15 = strerror(*tmp___14);
#line 1183
        reply(f, 550, "Error sending file; %s.", tmp___15);
#line 1184
        goto exit_retr;
      } else {

      }
#line 1201
      watchdog_defer_watched(f->watched);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1226
  close(socket_fd);
#line 1227
  socket_fd = -1;
#line 1230
  reply(f, 226, "File transfer complete.");
#line 1233
  gettimeofday((struct timeval * __restrict  )(& end_timestamp), (__timezone_ptr_t )((void *)0));
#line 1236
  transfer_time.tv_sec = end_timestamp.tv_sec - start_timestamp.tv_sec;
#line 1237
  transfer_time.tv_usec = end_timestamp.tv_usec - start_timestamp.tv_usec;
  {
#line 1238
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1238
    if (transfer_time.tv_usec >= 1000000L) {

    } else {
#line 1238
      goto while_break___1;
    }
#line 1239
    (transfer_time.tv_sec) ++;
#line 1240
    transfer_time.tv_usec -= 1000000L;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1242
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1242
    if (transfer_time.tv_usec < 0L) {

    } else {
#line 1242
      goto while_break___2;
    }
#line 1243
    (transfer_time.tv_sec) --;
#line 1244
    transfer_time.tv_usec += 1000000L;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1248
  syslog(6, "%s retrieved \"%s\", %ld bytes in %d.%06d seconds", f->client_addr_str,
         full_path, file_size, transfer_time.tv_sec, transfer_time.tv_usec);
  exit_retr: 
#line 1257
  f->file_offset = (off_t )0;
#line 1258
  if (socket_fd != -1) {
#line 1259
    close(socket_fd);
  } else {

  }
#line 1261
  if (file_fd != -1) {
#line 1262
    close(file_fd);
  } else {

  }
#line 1264
  tmp___16 = invariant((ftp_session_t const   *)f);
#line 1264
  if (tmp___16 == 0) {
#line 1264
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1264, "do_retr");
  } else {

  }
#line 1265
  return;
}
}
#line 1267 "ftp_session.c"
static void do_stor(ftp_session_t *f, const ftp_command_t *cmd)
{
    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 1269, __func__)));
    ((cmd != 
# 1270 "ftp_session.c" 3 4
   ((void *)0)
# 1270 "ftp_session.c"
   ) ? 0 : (daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1270, __func__)));
    ((cmd->num_arg == 1) ? 0 : (daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1271, __func__)));

    reply(f, 553, "Server will not store files.");

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 1275, __func__)));
}

static int open_connection(ftp_session_t *f)
{
    int socket_fd;
    struct sockaddr_in addr;
    unsigned addr_len;

    (((f->data_channel == 0) || (f->data_channel == 1)) ? 0 : (daemon_assert_fail("(f->data_channel == 0) || (f->data_channel == 1)",
                                                   "ftp_session.c"
# 1284 "ftp_session.c"
    ,
                                                   1285
# 1284 "ftp_session.c"
    , __func__)))
                                                    ;

    if (f->data_channel == 0) {
        socket_fd = socket((((struct sockaddr_storage *)(&f->data_port))->ss_family), 
# 1288 "ftp_session.c" 3 4
                                                SOCK_STREAM
# 1288 "ftp_session.c"
                                                           , 0);
 if (socket_fd == -1) {
     reply(f, 425, "Error creating socket; %s.", strerror(
# 1290 "ftp_session.c" 3 4
                                                         (*__errno_location ())
# 1290 "ftp_session.c"
                                                              ));
     return -1;
 }
 if (connect(socket_fd, (struct sockaddr *)&f->data_port,
     sizeof(sockaddr_storage_t)) != 0)
 {
     reply(f, 425, "Error connecting; %s.", strerror(
# 1296 "ftp_session.c" 3 4
                                                    (*__errno_location ())
# 1296 "ftp_session.c"
                                                         ));
     close(socket_fd);
     return -1;
 }
    } else {
        ((f->data_channel == 1) ? 0 : (daemon_assert_fail("f->data_channel == 1", "ftp_session.c", 1301, __func__)));

        addr_len = sizeof(struct sockaddr_in);
        socket_fd = accept(f->server_fd, (struct sockaddr *)&addr, &addr_len);
 if (socket_fd == -1) {
     reply(f, 425, "Error accepting connection; %s.", strerror(
# 1306 "ftp_session.c" 3 4
                                                              (*__errno_location ())
# 1306 "ftp_session.c"
                                                                   ));
     return -1;
 }
# 1324 "ftp_session.c"
 if (memcmp(&f->client_addr.sin_addr,
     &addr.sin_addr, sizeof(struct in_addr)))
 {
     reply(f, 425,
       "Error accepting connection; connection from invalid IP.");
     close(socket_fd);
     return -1;
 }

    }

    return socket_fd;
}

#line 1340 "ftp_session.c"
static int convert_newlines(char *dst , char const   *src , int srclen ) 
{ 
  int dstlen ;
  int *__cil_pp_dstlen ;
  int *__cil_fp_dstlen ;
  int dstlen_ssa_1 ;
  int i_ssa_1 ;
  int dstlen_ssa_2 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 1343
  __cil_fp_dstlen = & dstlen;
#line 1343
  __cil_pp_dstlen = & dstlen;
#line 1343
  return babel_wrapper_convert_newlines(__cil_pp_dstlen, __cil_fp_dstlen, dst, src,
                                        srclen);
#line 1343
  __cil_pp_dstlen = & dstlen;
#line 1344
  __cil_fp_dstlen = & dstlen;
#line 1345
  __cil_tmp13 = (unsigned long )dst != (unsigned long )((void *)0);
#line 1345
  if (__cil_tmp13 == 0) {
#line 1345
    daemon_assert_fail("dst != ((void *)0)", "ftp_session.c", 1345, "convert_newlines");
  } else {

  }
#line 1346
  __cil_tmp14 = (unsigned long )src != (unsigned long )((void *)0);
#line 1346
  if (__cil_tmp14 == 0) {
#line 1346
    daemon_assert_fail("src != ((void *)0)", "ftp_session.c", 1346, "convert_newlines");
  } else {

  }
#line 1348
  dstlen_ssa_1 = 0;
#line 1349
  i_ssa_1 = 0;
#line 1352
  *__cil_fp_dstlen = dstlen_ssa_1;
#line 1349
  convert_newlines_cil_lr_1(__cil_pp_dstlen, dst, src, srclen, i_ssa_1);
#line 1350
  dstlen_ssa_2 = *__cil_fp_dstlen;
#line 1355
  return (dstlen_ssa_2);
}
}
#line 1358 "ftp_session.c"
static int write_fully(int fd , char const   *buf , int buflen ) 
{ 
  int amt_written ;
  int __cil_ret7 ;
  int *__cil_pp_amt_written ;
  int *__cil_pp___cil_ret7 ;
  int *__cil_fp_amt_written ;
  int *__cil_fp___cil_ret7 ;
  int amt_written_ssa_1 ;
  int retflag8_ssa_1 ;
  int amt_written_ssa_2 ;
  int __cil_ret7_ssa_1 ;

  {
#line 1362
  __cil_fp___cil_ret7 = & __cil_ret7;
#line 1362
  __cil_fp_amt_written = & amt_written;
#line 1362
  __cil_pp___cil_ret7 = & __cil_ret7;
#line 1362
  __cil_pp_amt_written = & amt_written;
#line 1362
  return babel_wrapper_write_fully(__cil_pp_amt_written, __cil_pp___cil_ret7, __cil_fp_amt_written,
                                   __cil_fp___cil_ret7, fd, buf, buflen);
#line 1362
  __cil_pp_amt_written = & amt_written;
#line 1363
  __cil_pp___cil_ret7 = & __cil_ret7;
#line 1364
  __cil_fp_amt_written = & amt_written;
#line 1365
  __cil_fp___cil_ret7 = & __cil_ret7;
#line 1363
  amt_written_ssa_1 = 0;
#line 1367
  *__cil_fp_amt_written = amt_written_ssa_1;
#line 1368
  *__cil_fp___cil_ret7 = __cil_ret7;
#line 1364
  retflag8_ssa_1 = write_fully_cil_lr_1(__cil_pp_amt_written, __cil_pp___cil_ret7,
                                        fd, buf, buflen);
#line 1366
  amt_written_ssa_2 = *__cil_fp_amt_written;
#line 1367
  __cil_ret7_ssa_1 = *__cil_fp___cil_ret7;
#line 1364
  if (retflag8_ssa_1 != 0) {
#line 1364
    return (__cil_ret7_ssa_1);
  } else {
#line 1371
    return (amt_written_ssa_2);
  }
}
}
static void do_pwd(ftp_session_t *f, const ftp_command_t *cmd)
{
    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 1376, __func__)));
    ((cmd != 
# 1377 "ftp_session.c" 3 4
   ((void *)0)
# 1377 "ftp_session.c"
   ) ? 0 : (daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1377, __func__)));
    ((cmd->num_arg == 0) ? 0 : (daemon_assert_fail("cmd->num_arg == 0", "ftp_session.c", 1378, __func__)));

    reply(f, 257, "\"%s\" is current directory.", f->dir);

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 1382, __func__)));
}

#line 1398 "ftp_session.c"
static int filespec_has_wildcard(char const   *filespec ) 
{ 
  char const   *mem_2 ;

  {
#line 1400
  if ((unsigned long )filespec == (unsigned long )((void *)0)) {
#line 1400
    daemon_assert_fail("filespec != ((void *)0)", "ftp_session.c", 1400, "filespec_has_wildcard");
  } else {

  }
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1403
    if ((int const   )*filespec != 0) {

    } else {
#line 1403
      goto while_break;
    }
    {
#line 1407
    if ((int const   )*filespec == 42) {
#line 1407
      goto case_42;
    } else {

    }
#line 1406
    if ((int const   )*filespec == 63) {
#line 1406
      goto case_42;
    } else {

    }
#line 1405
    if ((int const   )*filespec == 91) {
#line 1405
      goto case_42;
    } else {

    }
#line 1410
    if ((int const   )*filespec == 92) {
#line 1410
      goto case_92;
    } else {

    }
#line 1404
    goto switch_break;
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_91: /* CIL Label */ 
#line 1409
    return (1);
    case_92: /* CIL Label */ 
    {
#line 1413
    mem_2 = filespec + 1;
#line 1413
    if ((int const   )*mem_2 != 0) {
#line 1414
      filespec ++;
    } else {

    }
    }
#line 1416
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1418
    filespec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1421
  return (0);
}
}
#line 1425 "ftp_session.c"
static int filespec_has_path_separator(char const   *filespec ) 
{ 
  char *tmp___0_ssa_1 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {

#line 1427
  return babel_wrapper_filespec_has_path_separator(filespec);
#line 1427
  __cil_tmp5 = (unsigned long )filespec != (unsigned long )((void *)0);
#line 1427
  if (__cil_tmp5 == 0) {
#line 1427
    daemon_assert_fail("filespec != ((void *)0)", "ftp_session.c", 1427, "filespec_has_path_separator");
  } else {

  }
#line 1430
  tmp___0_ssa_1 = __builtin_strchr((char *)filespec, '/');
#line 1430
  __cil_tmp6 = (unsigned long )tmp___0_ssa_1 != (unsigned long )((void *)0);
#line 1430
  if (__cil_tmp6 != 0) {
#line 1431
    return (1);
  } else {
#line 1433
    return (0);
  }
}
}
#line 1438 "ftp_session.c"
static int filespec_is_legal(char const   *filespec ) 
{ 
  int tmp___0_ssa_1 ;
  int tmp_ssa_1 ;
  int __cil_tmp6 ;

  {

#line 1440
  return babel_wrapper_filespec_is_legal(filespec);
#line 1440
  __cil_tmp6 = (unsigned long )filespec != (unsigned long )((void *)0);
#line 1440
  if (__cil_tmp6 == 0) {
#line 1440
    daemon_assert_fail("filespec != ((void *)0)", "ftp_session.c", 1440, "filespec_is_legal");
  } else {

  }
#line 1442
  tmp___0_ssa_1 = filespec_has_wildcard(filespec);
#line 1442
  if (tmp___0_ssa_1 != 0) {
#line 1443
    tmp_ssa_1 = filespec_has_path_separator(filespec);
#line 1443
    if (tmp_ssa_1 != 0) {
#line 1444
      return (0);
    } else {
#line 1447
      return (1);
    }
  } else {
#line 1447
    return (1);
  }
}
}
#line 1450 "ftp_session.c"
static void do_nlst(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int fd ;
  char const   *param ;
  int send_ok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1456
  tmp = invariant((ftp_session_t const   *)f);
#line 1456
  if (tmp == 0) {
#line 1456
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1456, "do_nlst");
  } else {

  }
#line 1457
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 1457
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1457, "do_nlst");
  } else {

  }
#line 1458
  if (cmd->num_arg != 0) {
#line 1458
    if (cmd->num_arg != 1) {
#line 1458
      daemon_assert_fail("(cmd->num_arg == 0) || (cmd->num_arg == 1)", "ftp_session.c",
                         1458, "do_nlst");
    } else {

    }
  } else {

  }
#line 1461
  fd = -1;
#line 1464
  if (cmd->num_arg == 0) {
#line 1465
    param = "*";
  } else {
#line 1467
    if (cmd->num_arg != 1) {
#line 1467
      daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1467, "do_nlst");
    } else {

    }
#line 1470
    if ((int )cmd->arg[0].string[0] == 45) {
#line 1471
      param = "*";
    } else {
#line 1473
      param = (char const   *)(cmd->arg[0].string);
    }
  }
#line 1478
  tmp___0 = filespec_is_legal(param);
#line 1478
  if (tmp___0 == 0) {
#line 1479
    reply(f, 550, "Illegal filename passed.");
#line 1480
    goto exit_nlst;
  } else {

  }
#line 1484
  reply(f, 150, "About to send name list.");
#line 1487
  fd = open_connection(f);
#line 1488
  if (fd == -1) {
#line 1489
    goto exit_nlst;
  } else {

  }
#line 1493
  send_ok = file_nlst(fd, (char const   *)(f->dir), param);
#line 1496
  netscape_hack(fd);
#line 1498
  if (send_ok != 0) {
#line 1499
    reply(f, 226, "Transfer complete.");
  } else {
#line 1501
    reply(f, 451, "Error sending name list.");
  }
  exit_nlst: 
#line 1506
  if (fd != -1) {
#line 1507
    close(fd);
  } else {

  }
#line 1509
  tmp___1 = invariant((ftp_session_t const   *)f);
#line 1509
  if (tmp___1 == 0) {
#line 1509
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1509, "do_nlst");
  } else {

  }
#line 1510
  return;
}
}
#line 1512 "ftp_session.c"
static void do_list(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int fd ;
  char const   *param ;
  int send_ok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1518
  tmp = invariant((ftp_session_t const   *)f);
#line 1518
  if (tmp == 0) {
#line 1518
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1518, "do_list");
  } else {

  }
#line 1519
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 1519
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1519, "do_list");
  } else {

  }
#line 1520
  if (cmd->num_arg != 0) {
#line 1520
    if (cmd->num_arg != 1) {
#line 1520
      daemon_assert_fail("(cmd->num_arg == 0) || (cmd->num_arg == 1)", "ftp_session.c",
                         1520, "do_list");
    } else {

    }
  } else {

  }
#line 1523
  fd = -1;
#line 1526
  if (cmd->num_arg == 0) {
#line 1527
    param = "*";
  } else {
#line 1529
    if (cmd->num_arg != 1) {
#line 1529
      daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1529, "do_list");
    } else {

    }
#line 1532
    if ((int )cmd->arg[0].string[0] == 45) {
#line 1533
      param = "*";
    } else {
#line 1535
      param = (char const   *)(cmd->arg[0].string);
    }
  }
#line 1540
  tmp___0 = filespec_is_legal(param);
#line 1540
  if (tmp___0 == 0) {
#line 1541
    reply(f, 550, "Illegal filename passed.");
#line 1542
    goto exit_list;
  } else {

  }
#line 1546
  reply(f, 150, "About to send file list.");
#line 1549
  fd = open_connection(f);
#line 1550
  if (fd == -1) {
#line 1551
    goto exit_list;
  } else {

  }
#line 1555
  send_ok = file_list(fd, (char const   *)(f->dir), param);
#line 1558
  netscape_hack(fd);
#line 1560
  if (send_ok != 0) {
#line 1561
    reply(f, 226, "Transfer complete.");
  } else {
#line 1563
    reply(f, 451, "Error sending file list.");
  }
  exit_list: 
#line 1568
  if (fd != -1) {
#line 1569
    close(fd);
  } else {

  }
#line 1571
  tmp___1 = invariant((ftp_session_t const   *)f);
#line 1571
  if (tmp___1 == 0) {
#line 1571
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1571, "do_list");
  } else {

  }
#line 1572
  return;
}
}
#line 1574 "ftp_session.c"
static void do_syst(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  int *__cil_tmp10 ;
  int __cil_tmp11 ;

  {

#line 1576
  return babel_wrapper_do_syst(f, cmd);
#line 1576
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1576
  if (tmp_ssa_1 == 0) {
#line 1576
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1576, "do_syst");
  } else {

  }
#line 1577
  __cil_tmp7 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 1577
  if (__cil_tmp7 == 0) {
#line 1577
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1577, "do_syst");
  } else {

  }
#line 1578
  __cil_tmp9 = (unsigned char *)cmd + 8;
#line 1578
  __cil_tmp10 = (int *)__cil_tmp9;
#line 1578
  __cil_tmp11 = *__cil_tmp10;
#line 1578
  __cil_tmp8 = __cil_tmp11 == 0;
#line 1578
  if (__cil_tmp8 == 0) {
#line 1578
    daemon_assert_fail("cmd->num_arg == 0", "ftp_session.c", 1578, "do_syst");
  } else {

  }
#line 1580
  reply(f, 215, "UNIX");
#line 1582
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1582
  if (tmp___0_ssa_1 == 0) {
#line 1582
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1582, "do_syst");
  } else {

  }
#line 1583
  return;
}
}
static void do_noop(ftp_session_t *f, const ftp_command_t *cmd)
{
    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 1588, __func__)));
    ((cmd != 
# 1589 "ftp_session.c" 3 4
   ((void *)0)
# 1589 "ftp_session.c"
   ) ? 0 : (daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1589, __func__)));
    ((cmd->num_arg == 0) ? 0 : (daemon_assert_fail("cmd->num_arg == 0", "ftp_session.c", 1590, __func__)));

    reply(f, 200, "Command okay.");

    ((invariant(f)) ? 0 : (daemon_assert_fail("invariant(f)", "ftp_session.c", 1594, __func__)));
}


#line 1597 "ftp_session.c"
static void do_rest(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  int tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  int *__cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  union __anonunion_arg_49 (*__cil_tmp21)[2] ;
  union __anonunion_arg_49 *__cil_tmp22 ;
  union __anonunion_arg_49 *__cil_tmp23 ;
  off_t *__cil_tmp24 ;
  off_t __cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  off_t *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  unsigned long *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  unsigned long *__cil_tmp31 ;

  {

#line 1599
  return babel_wrapper_do_rest(f, cmd);
#line 1599
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1599
  if (tmp_ssa_1 == 0) {
#line 1599
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1599, "do_rest");
  } else {

  }
#line 1600
  __cil_tmp7 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 1600
  if (__cil_tmp7 == 0) {
#line 1600
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1600, "do_rest");
  } else {

  }
#line 1601
  __cil_tmp11 = (unsigned char *)cmd + 8;
#line 1601
  __cil_tmp12 = (int *)__cil_tmp11;
#line 1601
  __cil_tmp13 = *__cil_tmp12;
#line 1601
  __cil_tmp8 = __cil_tmp13 == 1;
#line 1601
  if (__cil_tmp8 == 0) {
#line 1601
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1601, "do_rest");
  } else {

  }
#line 1603
  __cil_tmp14 = (unsigned char *)f + 16;
#line 1603
  __cil_tmp15 = (int *)__cil_tmp14;
#line 1603
  __cil_tmp16 = *__cil_tmp15;
#line 1603
  __cil_tmp9 = __cil_tmp16 != 1;
#line 1603
  if (__cil_tmp9 != 0) {
#line 1604
    reply(f, 555, "Restart not possible in ASCII mode.");
  } else {
#line 1605
    __cil_tmp17 = (unsigned char *)f + 20;
#line 1605
    __cil_tmp18 = (int *)__cil_tmp17;
#line 1605
    __cil_tmp19 = *__cil_tmp18;
#line 1605
    __cil_tmp10 = __cil_tmp19 != 0;
#line 1605
    if (__cil_tmp10 != 0) {
#line 1606
      reply(f, 555, "Restart only possible with FILE structure.");
    } else {
#line 1608
      __cil_tmp20 = (unsigned char *)cmd + 16;
#line 1608
      __cil_tmp21 = (union __anonunion_arg_49 (*)[2])__cil_tmp20;
#line 1608
      __cil_tmp22 = *__cil_tmp21;
#line 1608
      __cil_tmp23 = __cil_tmp22;
#line 1608
      __cil_tmp24 = (off_t *)__cil_tmp23;
#line 1608
      __cil_tmp25 = *__cil_tmp24;
#line 1608
      __cil_tmp26 = (unsigned char *)f + 24;
#line 1608
      __cil_tmp27 = (off_t *)__cil_tmp26;
#line 1608
      *__cil_tmp27 = __cil_tmp25;
#line 1609
      __cil_tmp28 = (unsigned char *)f + 8;
#line 1609
      __cil_tmp29 = (unsigned long *)__cil_tmp28;
#line 1609
      __cil_tmp30 = (unsigned char *)f + 32;
#line 1609
      __cil_tmp31 = (unsigned long *)__cil_tmp30;
#line 1609
      *__cil_tmp31 = *__cil_tmp29;
#line 1610
      reply(f, 350, "Restart okay, awaiting file retrieval request.");
    }
  }
#line 1613
  tmp___0_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1613
  if (tmp___0_ssa_1 == 0) {
#line 1613
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1613, "do_rest");
  } else {

  }
#line 1614
  return;
}
}
#line 1616 "ftp_session.c"
static void do_size(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  char full_path[8193] ;
  struct stat stat_buf ;
  struct stat *__cil_pp_stat_buf ;
  int tmp_ssa_1 ;
  char const   *file_name_ssa_1 ;
  int __attribute__((__gnu_inline__))  tmp___2_ssa_1 ;
  int *tmp___0_ssa_1 ;
  char *tmp___1_ssa_1 ;
  int tmp___3_ssa_1 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  int *__cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  int *__cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  int *__cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  union __anonunion_arg_49 (*__cil_tmp35)[2] ;
  union __anonunion_arg_49 *__cil_tmp36 ;
  union __anonunion_arg_49 *__cil_tmp37 ;
  char (*__cil_tmp38)[4097] ;
  char *__cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  char (*__cil_tmp41)[4097] ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  int __cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  __mode_t *__cil_tmp47 ;
  __mode_t __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  __off_t *__cil_tmp51 ;
  __off_t __cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  __off_t *__cil_tmp54 ;
  __off_t __cil_tmp55 ;

  {
#line 1620
  __cil_pp_stat_buf = & stat_buf;
#line 1620
  return babel_wrapper_do_size(__cil_pp_stat_buf, f, cmd, full_path);
#line 1620
  __cil_pp_stat_buf = & stat_buf;
#line 1622
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1622
  if (tmp_ssa_1 == 0) {
#line 1622
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1622, "do_size");
  } else {

  }
#line 1623
  __cil_tmp18 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 1623
  if (__cil_tmp18 == 0) {
#line 1623
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1623, "do_size");
  } else {

  }
#line 1624
  __cil_tmp25 = (unsigned char *)cmd + 8;
#line 1624
  __cil_tmp26 = (int *)__cil_tmp25;
#line 1624
  __cil_tmp27 = *__cil_tmp26;
#line 1624
  __cil_tmp19 = __cil_tmp27 == 1;
#line 1624
  if (__cil_tmp19 == 0) {
#line 1624
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1624, "do_size");
  } else {

  }
#line 1626
  __cil_tmp28 = (unsigned char *)f + 16;
#line 1626
  __cil_tmp29 = (int *)__cil_tmp28;
#line 1626
  __cil_tmp30 = *__cil_tmp29;
#line 1626
  __cil_tmp20 = __cil_tmp30 != 1;
#line 1626
  if (__cil_tmp20 != 0) {
#line 1627
    reply(f, 550, "Size cannot be determined in ASCII mode.");
  } else {
#line 1628
    __cil_tmp31 = (unsigned char *)f + 20;
#line 1628
    __cil_tmp32 = (int *)__cil_tmp31;
#line 1628
    __cil_tmp33 = *__cil_tmp32;
#line 1628
    __cil_tmp21 = __cil_tmp33 != 0;
#line 1628
    if (__cil_tmp21 != 0) {
#line 1629
      reply(f, 550, "Size cannot be determined with FILE structure.");
    } else {
#line 1633
      __cil_tmp34 = (unsigned char *)cmd + 16;
#line 1633
      __cil_tmp35 = (union __anonunion_arg_49 (*)[2])__cil_tmp34;
#line 1633
      __cil_tmp36 = *__cil_tmp35;
#line 1633
      __cil_tmp37 = __cil_tmp36;
#line 1633
      __cil_tmp38 = (char (*)[4097])__cil_tmp37;
#line 1633
      __cil_tmp39 = *__cil_tmp38;
#line 1633
      file_name_ssa_1 = (char const   *)__cil_tmp39;
#line 1634
      __cil_tmp40 = (unsigned char *)f + 160;
#line 1634
      __cil_tmp41 = (char (*)[4097])__cil_tmp40;
#line 1634
      __cil_tmp42 = *__cil_tmp41;
#line 1634
      __cil_tmp43 = full_path;
#line 1634
      get_absolute_fname(__cil_tmp43, (int )sizeof(full_path), (char const   *)__cil_tmp42,
                         file_name_ssa_1);
#line 1637
      __cil_tmp44 = full_path;
#line 1637
      tmp___2_ssa_1 = stat((char const   * __restrict  )((char const   *)__cil_tmp44),
                           (struct stat * __restrict  )__cil_pp_stat_buf);
#line 1637
      __cil_tmp22 = tmp___2_ssa_1 != (int __attribute__((__gnu_inline__))  )0;
#line 1637
      if (__cil_tmp22 != 0) {
#line 1638
        tmp___0_ssa_1 = __errno_location();
#line 1638
        __cil_tmp45 = *tmp___0_ssa_1;
#line 1638
        tmp___1_ssa_1 = strerror(__cil_tmp45);
#line 1638
        reply(f, 550, "Error getting file status; %s.", tmp___1_ssa_1);
      } else {
#line 1642
        __cil_tmp46 = (unsigned char *)__cil_pp_stat_buf + 24;
#line 1642
        __cil_tmp47 = (__mode_t *)__cil_tmp46;
#line 1642
        __cil_tmp48 = *__cil_tmp47;
#line 1642
        __cil_tmp49 = __cil_tmp48 & 61440U;
#line 1642
        __cil_tmp23 = __cil_tmp49 == 16384U;
#line 1642
        if (__cil_tmp23 != 0) {
#line 1643
          reply(f, 550, "File is a directory, SIZE command not valid.");
        } else {
#line 1647
          __cil_tmp24 = sizeof(off_t ) == 8UL;
#line 1647
          if (__cil_tmp24 != 0) {
#line 1648
            __cil_tmp50 = (unsigned char *)__cil_pp_stat_buf + 48;
#line 1648
            __cil_tmp51 = (__off_t *)__cil_tmp50;
#line 1648
            __cil_tmp52 = *__cil_tmp51;
#line 1648
            reply(f, 213, "%llu", __cil_tmp52);
          } else {
#line 1650
            __cil_tmp53 = (unsigned char *)__cil_pp_stat_buf + 48;
#line 1650
            __cil_tmp54 = (__off_t *)__cil_tmp53;
#line 1650
            __cil_tmp55 = *__cil_tmp54;
#line 1650
            reply(f, 213, "%lu", __cil_tmp55);
          }
        }
      }
    }
  }
#line 1658
  tmp___3_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1658
  if (tmp___3_ssa_1 == 0) {
#line 1658
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1658, "do_size");
  } else {

  }
#line 1659
  return;
}
}
#line 1674 "ftp_session.c"
static void do_mdtm(ftp_session_t *f , ftp_command_t const   *cmd ) 
{ 
  char full_path[8193] ;
  struct stat stat_buf ;
  struct tm mtime ;
  char time_buf[16] ;
  struct stat *__cil_pp_stat_buf ;
  struct tm *__cil_pp_mtime ;
  int tmp_ssa_1 ;
  char const   *file_name_ssa_1 ;
  int __attribute__((__gnu_inline__))  tmp___2_ssa_1 ;
  int *tmp___0_ssa_1 ;
  char *tmp___1_ssa_1 ;
  int tmp___3_ssa_1 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  int *__cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  union __anonunion_arg_49 (*__cil_tmp28)[2] ;
  union __anonunion_arg_49 *__cil_tmp29 ;
  union __anonunion_arg_49 *__cil_tmp30 ;
  char (*__cil_tmp31)[4097] ;
  char *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  char (*__cil_tmp34)[4097] ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 1680
  __cil_pp_stat_buf = & stat_buf;
#line 1681
  __cil_pp_mtime = & mtime;
#line 1682
  tmp_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1682
  if (tmp_ssa_1 == 0) {
#line 1682
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1682, "do_mdtm");
  } else {

  }
#line 1683
  __cil_tmp21 = (unsigned long )cmd != (unsigned long )((void *)0);
#line 1683
  if (__cil_tmp21 == 0) {
#line 1683
    daemon_assert_fail("cmd != ((void *)0)", "ftp_session.c", 1683, "do_mdtm");
  } else {

  }
#line 1684
  __cil_tmp24 = (unsigned char *)cmd + 8;
#line 1684
  __cil_tmp25 = (int *)__cil_tmp24;
#line 1684
  __cil_tmp26 = *__cil_tmp25;
#line 1684
  __cil_tmp22 = __cil_tmp26 == 1;
#line 1684
  if (__cil_tmp22 == 0) {
#line 1684
    daemon_assert_fail("cmd->num_arg == 1", "ftp_session.c", 1684, "do_mdtm");
  } else {

  }
#line 1687
  __cil_tmp27 = (unsigned char *)cmd + 16;
#line 1687
  __cil_tmp28 = (union __anonunion_arg_49 (*)[2])__cil_tmp27;
#line 1687
  __cil_tmp29 = *__cil_tmp28;
#line 1687
  __cil_tmp30 = __cil_tmp29;
#line 1687
  __cil_tmp31 = (char (*)[4097])__cil_tmp30;
#line 1687
  __cil_tmp32 = *__cil_tmp31;
#line 1687
  file_name_ssa_1 = (char const   *)__cil_tmp32;
#line 1688
  __cil_tmp33 = (unsigned char *)f + 160;
#line 1688
  __cil_tmp34 = (char (*)[4097])__cil_tmp33;
#line 1688
  __cil_tmp35 = *__cil_tmp34;
#line 1688
  __cil_tmp36 = full_path;
#line 1688
  get_absolute_fname(__cil_tmp36, (int )sizeof(full_path), (char const   *)__cil_tmp35,
                     file_name_ssa_1);
#line 1691
  __cil_tmp37 = full_path;
#line 1691
  tmp___2_ssa_1 = stat((char const   * __restrict  )((char const   *)__cil_tmp37),
                       (struct stat * __restrict  )__cil_pp_stat_buf);
#line 1691
  __cil_tmp23 = tmp___2_ssa_1 != (int __attribute__((__gnu_inline__))  )0;
#line 1691
  if (__cil_tmp23 != 0) {
#line 1692
    tmp___0_ssa_1 = __errno_location();
#line 1692
    __cil_tmp38 = *tmp___0_ssa_1;
#line 1692
    tmp___1_ssa_1 = strerror(__cil_tmp38);
#line 1692
    reply(f, 550, "Error getting file status; %s.", tmp___1_ssa_1);
  } else {
#line 1694
    __cil_tmp39 = (unsigned char *)__cil_pp_stat_buf + 88;
#line 1694
    gmtime_r((time_t const   * __restrict  )((time_t const   *)__cil_tmp39), (struct tm * __restrict  )__cil_pp_mtime);
#line 1695
    __cil_tmp40 = time_buf;
#line 1695
    strftime((char * __restrict  )__cil_tmp40, sizeof(time_buf), (char const   * __restrict  )"%Y%m%d%H%M%S",
             (struct tm  const  * __restrict  )((struct tm  const  *)__cil_pp_mtime));
#line 1696
    __cil_tmp41 = time_buf;
#line 1696
    reply(f, 213, (char const   *)__cil_tmp41);
  }
#line 1699
  tmp___3_ssa_1 = invariant((ftp_session_t const   *)f);
#line 1699
  if (tmp___3_ssa_1 == 0) {
#line 1699
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1699, "do_mdtm");
  } else {

  }
#line 1700
  return;
}
}
#line 1703 "ftp_session.c"
static void send_readme(ftp_session_t const   *f , int code ) 
{ 
  char file_name[4097] ;
  int dir_len ;
  struct stat stat_buf ;
  int fd ;
  int read_ret ;
  char buf[4096] ;
  char code_str[8] ;
  char *p ;
  int len ;
  char *nl ;
  int line_len ;
  int tmp ;
  size_t tmp___0 ;
  int __attribute__((__gnu_inline__))  tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
#line 1717
  tmp = invariant(f);
#line 1717
  if (tmp == 0) {
#line 1717
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1717, "send_readme");
  } else {

  }
#line 1718
  if (code < 100) {
#line 1718
    daemon_assert_fail("code >= 100", "ftp_session.c", 1718, "send_readme");
  } else {

  }
#line 1719
  if (code > 559) {
#line 1719
    daemon_assert_fail("code <= 559", "ftp_session.c", 1719, "send_readme");
  } else {

  }
#line 1722
  fd = -1;
#line 1725
  tmp___0 = strlen((char const   *)(f->dir));
#line 1725
  dir_len = (int )tmp___0;
#line 1726
  if ((unsigned long )(dir_len + 1) + sizeof("README") > sizeof(file_name)) {
#line 1727
    goto exit_send_readme;
  } else {

  }
#line 1731
  strcpy((char * __restrict  )(file_name), (char const   * __restrict  )((char const   *)(f->dir)));
#line 1732
  strcat((char * __restrict  )(file_name), (char const   * __restrict  )"/");
#line 1733
  strcat((char * __restrict  )(file_name), (char const   * __restrict  )"README");
#line 1736
  fd = open((char const   *)(file_name), 0);
#line 1737
  if (fd == -1) {
#line 1738
    goto exit_send_readme;
  } else {

  }
#line 1742
  tmp___1 = fstat(fd, & stat_buf);
#line 1742
  if (tmp___1 != (int __attribute__((__gnu_inline__))  )0) {
#line 1743
    goto exit_send_readme;
  } else {

  }
#line 1746
  if ((stat_buf.st_mode & 61440U) == 16384U) {
#line 1750
    goto exit_send_readme;
  } else {

  }
#line 1754
  if (code < 100) {
#line 1754
    daemon_assert_fail("code >= 100", "ftp_session.c", 1754, "send_readme");
  } else {

  }
#line 1755
  if (code > 999) {
#line 1755
    daemon_assert_fail("code <= 999", "ftp_session.c", 1755, "send_readme");
  } else {

  }
#line 1756
  sprintf((char * __restrict  )(code_str), (char const   * __restrict  )"%03d-", code);
#line 1759
  tmp___2 = read(fd, (void *)(buf), sizeof(buf));
#line 1759
  read_ret = (int )tmp___2;
#line 1760
  if (read_ret > 0) {
#line 1761
    telnet_session_print((telnet_session_t *)f->telnet_session, (char const   *)(code_str));
    {
#line 1762
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1762
      if (read_ret > 0) {

      } else {
#line 1762
        goto while_break;
      }
#line 1763
      p = buf;
#line 1764
      len = read_ret;
#line 1765
      tmp___3 = memchr((void const   *)p, '\n', (size_t )len);
#line 1765
      nl = (char *)tmp___3;
      {
#line 1766
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1766
        if (len > 0) {
#line 1766
          if ((unsigned long )nl == (unsigned long )((void *)0)) {
#line 1766
            goto while_break___0;
          } else {

          }
        } else {
#line 1766
          goto while_break___0;
        }
#line 1767
        *nl = (char )'\000';
#line 1768
        telnet_session_println((telnet_session_t *)f->telnet_session, (char const   *)p);
#line 1769
        line_len = (int )(nl - p);
#line 1770
        len -= line_len + 1;
#line 1771
        if (len > 0) {
#line 1772
          telnet_session_print((telnet_session_t *)f->telnet_session, (char const   *)(code_str));
        } else {

        }
#line 1774
        p = nl + 1;
#line 1775
        tmp___4 = memchr((void const   *)p, '\n', (size_t )len);
#line 1775
        nl = (char *)tmp___4;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1777
      if (len > 0) {
#line 1778
        telnet_session_print((telnet_session_t *)f->telnet_session, (char const   *)p);
      } else {

      }
#line 1781
      tmp___5 = read(fd, (void *)(buf), sizeof(buf));
#line 1781
      read_ret = (int )tmp___5;
    }
    while_break: /* CIL Label */ ;
    }
  } else {

  }
  exit_send_readme: 
#line 1787
  if (fd != -1) {
#line 1788
    close(fd);
  } else {

  }
#line 1790
  tmp___6 = invariant(f);
#line 1790
  if (tmp___6 == 0) {
#line 1790
    daemon_assert_fail("invariant(f)", "ftp_session.c", 1790, "send_readme");
  } else {

  }
#line 1791
  return;
}
}
#line 1794 "ftp_session.c"
static void netscape_hack(int fd ) 
{ 
  fd_set readfds ;
  struct timeval timeout ;
  int select_ret ;
  char c ;
  int __d0 ;
  int __d1 ;

  {
#line 1801
  if (fd < 0) {
#line 1801
    daemon_assert_fail("fd >= 0", "ftp_session.c", 1801, "netscape_hack");
  } else {

  }
#line 1803
  shutdown(fd, 1);
  {
#line 1804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1804
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 1804
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1805
  readfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
#line 1806
  timeout.tv_sec = (__time_t )15;
#line 1807
  timeout.tv_usec = (__suseconds_t___1 )0;
#line 1808
  select_ret = select(fd + 1, (fd_set * __restrict  )(& readfds), (fd_set * __restrict  )((fd_set *)((void *)0)),
                      (fd_set * __restrict  )((fd_set *)((void *)0)), (struct timeval * __restrict  )(& timeout));
#line 1809
  if (select_ret > 0) {
#line 1810
    read(fd, (void *)(& c), (size_t )1);
  } else {

  }
#line 1812
  return;
}
}
#line 1815 "ftp_session.c"
static int ip_equal(sockaddr_storage_t const   *a , sockaddr_storage_t const   *b ) 
{ 
  int tmp_ssa_1 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  sa_family_t __cil_tmp13 ;
  int __cil_tmp14 ;
  sa_family_t __cil_tmp15 ;
  int __cil_tmp16 ;
  sa_family_t __cil_tmp17 ;
  int __cil_tmp18 ;
  sa_family_t __cil_tmp19 ;
  int __cil_tmp20 ;
  sa_family_t __cil_tmp21 ;
  sa_family_t __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  sa_family_t *mem_26 ;
  sa_family_t *mem_27 ;
  sa_family_t *mem_28 ;
  sa_family_t *mem_29 ;
  sa_family_t *mem_30 ;
  sa_family_t *mem_31 ;
  struct in_addr *mem_32 ;

  {
#line 1817
  __cil_tmp5 = (unsigned long )a != (unsigned long )((void *)0);
#line 1817
  if (__cil_tmp5 == 0) {
#line 1817
    daemon_assert_fail("a != ((void *)0)", "ftp_session.c", 1817, "ip_equal");
  } else {

  }
#line 1818
  __cil_tmp6 = (unsigned long )b != (unsigned long )((void *)0);
#line 1818
  if (__cil_tmp6 == 0) {
#line 1818
    daemon_assert_fail("b != ((void *)0)", "ftp_session.c", 1818, "ip_equal");
  } else {

  }
#line 1819
  mem_26 = (sa_family_t *)((struct sockaddr_storage *)a);
#line 1819
  __cil_tmp13 = *mem_26;
#line 1819
  __cil_tmp14 = (int )__cil_tmp13;
#line 1819
  __cil_tmp7 = __cil_tmp14 == 2;
#line 1819
  if (__cil_tmp7 == 0) {
#line 1819
    mem_27 = (sa_family_t *)((struct sockaddr_storage *)a);
#line 1819
    __cil_tmp15 = *mem_27;
#line 1819
    __cil_tmp16 = (int )__cil_tmp15;
#line 1819
    __cil_tmp8 = __cil_tmp16 == 10;
#line 1819
    if (__cil_tmp8 == 0) {
#line 1819
      daemon_assert_fail("((((struct sockaddr_storage *)(a))->ss_family) == 2) || ((((struct sockaddr_storage *)(a))->ss_family) == 10)",
                         "ftp_session.c", 1819, "ip_equal");
    } else {

    }
  } else {

  }
#line 1820
  mem_28 = (sa_family_t *)((struct sockaddr_storage *)b);
#line 1820
  __cil_tmp17 = *mem_28;
#line 1820
  __cil_tmp18 = (int )__cil_tmp17;
#line 1820
  __cil_tmp9 = __cil_tmp18 == 2;
#line 1820
  if (__cil_tmp9 == 0) {
#line 1820
    mem_29 = (sa_family_t *)((struct sockaddr_storage *)b);
#line 1820
    __cil_tmp19 = *mem_29;
#line 1820
    __cil_tmp20 = (int )__cil_tmp19;
#line 1820
    __cil_tmp10 = __cil_tmp20 == 10;
#line 1820
    if (__cil_tmp10 == 0) {
#line 1820
      daemon_assert_fail("((((struct sockaddr_storage *)(b))->ss_family) == 2) || ((((struct sockaddr_storage *)(b))->ss_family) == 10)",
                         "ftp_session.c", 1820, "ip_equal");
    } else {

    }
  } else {

  }
#line 1822
  mem_30 = (sa_family_t *)((struct sockaddr_storage *)a);
#line 1822
  __cil_tmp21 = *mem_30;
#line 1822
  mem_31 = (sa_family_t *)((struct sockaddr_storage *)b);
#line 1822
  __cil_tmp22 = *mem_31;
#line 1822
  __cil_tmp23 = (int )__cil_tmp21;
#line 1822
  __cil_tmp24 = (int )__cil_tmp22;
#line 1822
  __cil_tmp11 = __cil_tmp23 != __cil_tmp24;
#line 1822
  if (__cil_tmp11 != 0) {
#line 1823
    return (0);
  } else {
#line 1825
    __cil_tmp25 = (unsigned char *)a + 4;
#line 1825
    __cil_tmp26 = (unsigned char *)b + 4;
#line 1825
    mem_32 = (struct in_addr *)((unsigned char *)a + 4);
#line 1825
    tmp_ssa_1 = memcmp((void const   *)__cil_tmp25, (void const   *)__cil_tmp26, sizeof(*mem_32));
#line 1825
    __cil_tmp12 = tmp_ssa_1 != 0;
#line 1825
    if (__cil_tmp12 != 0) {
#line 1826
      return (0);
    } else {
#line 1828
      return (1);
    }
  }
}
}
#line 1835 "ftp_session.c"
int write_fully_cil_lr_1(int *__cil_ap_amt_written , int *__cil_ap___cil_ret7 , int fd ,
                         char const   *buf , int buflen ) 
{ 
  ssize_t tmp_ssa_1 ;
  int write_ret_ssa_1 ;
  int retflag8_ssa_1 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {

#line 1364
  return babel_wrapper_write_fully_cil_lr_1(__cil_ap_amt_written, __cil_ap___cil_ret7,
                                            fd, buf, buflen);
#line 1364
  __cil_tmp14 = *__cil_ap_amt_written;
#line 1364
  __cil_tmp12 = __cil_tmp14 < buflen;
#line 1364
  if (__cil_tmp12 != 0) {
#line 1365
    __cil_tmp15 = *__cil_ap_amt_written;
#line 1365
    __cil_tmp16 = buf + __cil_tmp15;
#line 1365
    __cil_tmp17 = *__cil_ap_amt_written;
#line 1365
    __cil_tmp18 = buflen - __cil_tmp17;
#line 1365
    tmp_ssa_1 = write(fd, (void const   *)__cil_tmp16, (size_t )__cil_tmp18);
#line 1365
    write_ret_ssa_1 = (int )tmp_ssa_1;
#line 1366
    __cil_tmp13 = write_ret_ssa_1 <= 0;
#line 1366
    if (__cil_tmp13 != 0) {
#line 1367
      *__cil_ap___cil_ret7 = -1;
#line 1369
      return (1);
    } else {
#line 1369
      __cil_tmp19 = *__cil_ap_amt_written;
#line 1369
      *__cil_ap_amt_written = __cil_tmp19 + write_ret_ssa_1;
#line 1372
      retflag8_ssa_1 = write_fully_cil_lr_1(__cil_ap_amt_written, __cil_ap___cil_ret7,
                                            fd, buf, buflen);
#line 1375
      return (retflag8_ssa_1);
    }
  } else {
#line 1379
    return (0);
  }
}
}
#line 1384 "ftp_session.c"
void convert_newlines_cil_lr_1(int *__cil_ap_dstlen , char *dst , char const   *src ,
                               int srclen , int i ) 
{ 
  int tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  int i_ssa_1 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  char const   *__cil_tmp13 ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char const   *__cil_tmp19 ;
  char __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char const   *__cil_tmp23 ;
  char __cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1349
  __cil_tmp11 = i < srclen;
#line 1349
  if (__cil_tmp11 != 0) {
#line 1350
    __cil_tmp13 = src + i;
#line 1350
    __cil_tmp14 = (char )*__cil_tmp13;
#line 1350
    __cil_tmp15 = (int )((int const   )__cil_tmp14);
#line 1350
    __cil_tmp12 = __cil_tmp15 == 10;
#line 1350
    if (__cil_tmp12 != 0) {
#line 1351
      tmp_ssa_1 = *__cil_ap_dstlen;
#line 1351
      __cil_tmp16 = *__cil_ap_dstlen;
#line 1351
      *__cil_ap_dstlen = __cil_tmp16 + 1;
#line 1351
      __cil_tmp17 = dst + tmp_ssa_1;
#line 1351
      *__cil_tmp17 = (char )'\r';
    } else {

    }
#line 1353
    tmp___0_ssa_1 = *__cil_ap_dstlen;
#line 1353
    __cil_tmp18 = *__cil_ap_dstlen;
#line 1353
    *__cil_ap_dstlen = __cil_tmp18 + 1;
#line 1353
    __cil_tmp19 = src + i;
#line 1353
    __cil_tmp20 = (char )*__cil_tmp19;
#line 1353
    __cil_tmp21 = dst + tmp___0_ssa_1;
#line 1353
    *__cil_tmp21 = __cil_tmp20;
#line 1349
    i_ssa_1 = i + 1;
#line 1352
    convert_newlines_cil_lr_1(__cil_ap_dstlen, dst, src, srclen, i_ssa_1);
#line 1354
    return;
  } else {
#line 1356
    return;
  }
#line 1353
  tmp___0_ssa_1 = *__cil_ap_dstlen;
#line 1353
  __cil_tmp22 = *__cil_ap_dstlen;
#line 1353
  *__cil_ap_dstlen = __cil_tmp22 + 1;
#line 1353
  __cil_tmp23 = src + i;
#line 1353
  __cil_tmp24 = (char )*__cil_tmp23;
#line 1353
  __cil_tmp25 = dst + tmp___0_ssa_1;
#line 1353
  *__cil_tmp25 = __cil_tmp24;
#line 1349
  i_ssa_1 = i + 1;
#line 1352
  convert_newlines_cil_lr_1(__cil_ap_dstlen, dst, src, srclen, i_ssa_1);
#line 1354
  return;
}
}
#include <gprolog.h>
PlBool babel_ptrR(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

		return PL_TRUE;
}

PlBool babel_ptrR_byte(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

	return PL_TRUE;
}

PlBool babel_ptrE(PlLong* p,  PlLong e, PlLong len)
{
	if (p == 0)
	    return PL_FALSE;

	switch(len)
		{
		    case 1:
		    	*(unsigned char*)p = (unsigned char)e;
		    	break;
		    case 2:
		    	*(short*) p = (short)e;
		    	break;
		    case 4:
		    	*(int*)p = (int)e;
		    	break;
		    case 8:
		    	*(long long*)p = (long long)e;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrL\n");
		}

        return PL_TRUE;
}

PlBool babel_ptrFR(double* fp, PlLong ptr, PlLong len)
{
  if(len == 2)
  *(double *)fp = *(double *)ptr;
   else if (len == 1)
  *(float *)fp = *(float *)ptr;
  else
  return PL_FALSE;

  return PL_TRUE;
}

PlBool babel_ptrFW(PlLong ptr, double f, PlLong len)
{
  if (len == 2)
  *(double *)ptr = f;
   else if (len == 1)
  *(float *)ptr = f;
  else
  return PL_FALSE;
  
  return PL_TRUE;
}






PlBool babel__implicit_ftp_session_dropc_0(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_ftp_session_dropc_1(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_ftp_session_dropc_2(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_ftp_session_dropc_3(ftp_session_t * arg_0, int arg_1, char* arg_2, char const   * arg_3) 
{
reply(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_ftp_session_dropc_4(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_ftp_session_dropc_5(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}

PlBool babel__implicit_do_userc_9(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_10(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_11(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_12(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_13(char const   * arg_0, char* arg_1, PlLong * babel_ret) 
{
*babel_ret = strcasecmp(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_14(char const   * arg_0, char* arg_1, PlLong * babel_ret) 
{
*babel_ret = strcasecmp(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_15(int arg_0, char* arg_1, char * arg_2, char const   * arg_3) 
{
syslog(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_16(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_17(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_18(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_19(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_userc_20(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}

PlBool babel__implicit_do_cwdc_29(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_cwdc_30(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_cwdc_31(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_cwdc_32(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_cwdc_33(ftp_session_t * arg_0, char const   * arg_1) 
{
change_dir(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_do_cwdc_34(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_cwdc_35(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}

PlBool babel__implicit_do_quitc_43(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_quitc_44(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_quitc_45(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_quitc_46(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_quitc_47(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_quitc_48(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_quitc_49(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_50(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_51(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_52(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_53(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_54(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_55(ftp_session_t * arg_0, sockaddr_storage_t const   * arg_1) 
{
set_port(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_56(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_portc_57(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_58(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_59(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_60(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_61(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_62(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_63(ftp_session_t * arg_0, sockaddr_storage_t const   * arg_1) 
{
set_port(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_64(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_lprtc_65(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_eprtc_66(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_eprtc_67(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_eprtc_68(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_eprtc_69(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_eprtc_70(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_eprtc_71(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_eprtc_72(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_init_passive_portc_73(struct timeval * __restrict   arg_0, __timezone_ptr_t  arg_1) 
{
gettimeofday(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_init_passive_portc_74(unsigned short * arg_0) 
{
seed48(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_get_passive_portc_75(pthread_once_t * arg_0, void (*arg_1)(void) ) 
{
pthread_once(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_get_passive_portc_76(pthread_mutex_t * arg_0) 
{
pthread_mutex_lock(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_get_passive_portc_77(PlLong * babel_ret) 
{
*babel_ret = lrand48();
return PL_TRUE;
}
PlBool babel__implicit_get_passive_portc_78(pthread_mutex_t * arg_0) 
{
pthread_mutex_unlock(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_79(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_80(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_81(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_82(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_83(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_84(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_85(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_86(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_typec_87(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}

PlBool babel__implicit_do_modec_96(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_modec_97(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_modec_98(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_modec_99(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_modec_100(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_modec_101(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_modec_102(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_modec_103(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_104(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_105(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_106(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_107(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_108(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_109(char * __restrict   arg_0, char const   * __restrict   arg_1) 
{
strcpy(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_110(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_111(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = strlen(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_112(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_113(char * __restrict   arg_0, char const   * __restrict   arg_1) 
{
strcpy(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_114(char * __restrict   arg_0, char const   * __restrict   arg_1) 
{
strcat(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_get_absolute_fnamec_115(char * __restrict   arg_0, char const   * __restrict   arg_1) 
{
strcat(arg_0, arg_1);
return PL_TRUE;
}

PlBool babel__implicit_convert_newlinesc_141(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_convert_newlinesc_142(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_convert_newlinesc_143(int * arg_0, char * arg_1, char const   * arg_2, int  arg_3, int  arg_4) 
{
convert_newlines_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_write_fullyc_144(int * arg_0, int * arg_1, int  arg_2, char const   * arg_3, int  arg_4, PlLong * babel_ret) 
{
*babel_ret = write_fully_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}

PlBool babel__implicit_filespec_has_path_separatorc_152(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_filespec_has_path_separatorc_153(char * arg_0, char arg_1, PlLong * babel_ret) 
{
*babel_ret = __builtin_strchr(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_filespec_is_legalc_154(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_filespec_is_legalc_155(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = filespec_has_wildcard(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_filespec_is_legalc_156(char const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = filespec_has_path_separator(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_systc_157(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_systc_158(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_systc_159(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_systc_160(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_systc_161(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_systc_162(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_systc_163(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}

PlBool babel__implicit_do_restc_171(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_172(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_173(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_174(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_175(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_176(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_177(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_178(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_restc_179(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_180(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_181(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_182(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_183(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_184(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_185(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_186(char * arg_0, int  arg_1, char const   * arg_2, char const   * arg_3) 
{
get_absolute_fname(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_187(char const   * __restrict   arg_0, struct stat * __restrict   arg_1, PlLong * babel_ret) 
{
*babel_ret = stat(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_188(PlLong * babel_ret) 
{
*babel_ret = __errno_location();
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_189(int  arg_0, PlLong * babel_ret) 
{
*babel_ret = strerror(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_190(ftp_session_t * arg_0, int arg_1, char* arg_2, char * arg_3) 
{
reply(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_191(ftp_session_t * arg_0, int arg_1, char* arg_2) 
{
reply(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_192(ftp_session_t * arg_0, int arg_1, char* arg_2, __off_t  arg_3) 
{
reply(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_193(ftp_session_t * arg_0, int arg_1, char* arg_2, __off_t  arg_3) 
{
reply(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_194(ftp_session_t const   * arg_0, PlLong * babel_ret) 
{
*babel_ret = invariant(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_do_sizec_195(char* arg_0, char* arg_1, int arg_2, char* arg_3) 
{
daemon_assert_fail(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_write_fully_cil_lr_1c_196(int  arg_0, void const   * arg_1, size_t  arg_2, PlLong * babel_ret) 
{
*babel_ret = write(arg_0, arg_1, arg_2);
return PL_TRUE;
}
