#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 68 "defines.h"
typedef long flow_t;
#line 69 "defines.h"
typedef long cost_t;
#line 99
struct node;
#line 99
struct node;
#line 99 "defines.h"
typedef struct node node_t;
#line 100 "defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 102
struct arc;
#line 102 "defines.h"
typedef struct arc arc_t;
#line 103 "defines.h"
typedef struct arc *arc_p;
#line 107 "defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 138 "defines.h"
struct network {
   char inputfile[200] ;
   char clustfile[200] ;
   long n ;
   long n_trips ;
   long max_m ;
   long m ;
   long m_org ;
   long m_impl ;
   long max_residual_new_m ;
   long max_new_m ;
   long primal_unbounded ;
   long dual_unbounded ;
   long perturbed ;
   long feasible ;
   long eps ;
   long opt_tol ;
   long feas_tol ;
   long pert_val ;
   long bigM ;
   double optcost ;
   cost_t ignore_impl ;
   node_p nodes ;
   node_p stop_nodes ;
   arc_p arcs ;
   arc_p stop_arcs ;
   arc_p dummy_arcs ;
   arc_p stop_dummy ;
   long iterations ;
   long bound_exchanges ;
   long checksum ;
};
#line 138 "defines.h"
typedef struct network network_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 30 "mcfutil.h"
void refresh_neighbour_lists(network_t *net ) ;
#line 31
long refresh_potential(network_t *net ) ;
#line 32
double flow_cost(network_t *net ) ;
#line 33
double flow_org_cost(network_t *net ) ;
#line 34
long primal_feasible(network_t *net ) ;
#line 35
long dual_feasible(network_t *net ) ;
#line 36
long getfree(network_t *net ) ;
#line 37
void refresh_neighbour_lists_cil_lr_1(network_t **__cil_ap_net , node_t *node , void *stop ) ;
#line 60
void refresh_neighbour_lists_cil_lr_2(arc_t *arc , void *stop ) ;
   int babel_wrapper_refresh_neighbour_lists(network_t ** __cil_pp_net, network_t ** __cil_fp_net, network_t * net)                           // function name insert
      {
        // wrapper for function refresh_neighbour_lists        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_neighbour_lists"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_net);
arg[1] = Pl_Mk_Integer(__cil_fp_net);
arg[2] = Pl_Mk_Integer(net);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      

      
      
//   long  babel_wrapper_getfree(network_t * net)                           // function name insert
//      {
//        // wrapper for function getfree        // function name insert
//         long  return_value; //  return value type (how about array type)
//
//        //rountine code
//        int func;
//        PlTerm arg[2];    //  function variable + return value insert
//        PlBool res;
//
//        func = Pl_Find_Atom("getfree"); // function name insert
//
//      //routine code
//        Pl_Query_Begin(PL_FALSE);
//
//      //prepare parameters
//      //partial routine code, pass in parameter  // we need to init arguments and return value
//      arg[0] = Pl_Mk_Integer(net);
//
//      //routine code, reserve a place for return value
//      arg[1] = Pl_Mk_Variable();
//
//      //partial routine code, 2 is not routine. (number of arguments) + 1
//        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)
//
//      //get return value, partial routine code, 1 is not routine
//        return_value = Pl_Rd_Integer(arg[1]);        // insert ()
//
//      //routine code
//        Pl_Query_End(PL_KEEP_FOR_PROLOG);
//
//      //routine code
//        return return_value;
//        }
      
      
   int babel_wrapper_refresh_neighbour_lists_cil_lr_1(network_t ** __cil_ap_net, node_t * node, void * stop)                           // function name insert
      {
        // wrapper for function refresh_neighbour_lists_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_neighbour_lists_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_net);
arg[1] = Pl_Mk_Integer(node);
arg[2] = Pl_Mk_Integer(stop);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_refresh_neighbour_lists_cil_lr_2(arc_t * arc, void * stop)                           // function name insert
      {
        // wrapper for function refresh_neighbour_lists_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_neighbour_lists_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(arc);
arg[1] = Pl_Mk_Integer(stop);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 28 "mcfutil.c"
void refresh_neighbour_lists(network_t *net ) 
{ 
  network_t **__cil_pp_net ;
  network_t **__cil_fp_net ;
  node_t *node_ssa_1 ;
  void *stop_ssa_1 ;
  network_t *net_ssa_1 ;
  arc_t *arc_ssa_1 ;
  void *stop_ssa_2 ;
  unsigned char *__cil_tmp12 ;
  node_p *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  node_p *__cil_tmp15 ;
  node_p __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  arc_p *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  arc_p *__cil_tmp20 ;
  arc_p __cil_tmp21 ;

  {
#line 30
  __cil_fp_net = & net;
#line 30
  __cil_pp_net = & net;
#line 30
  return babel_wrapper_refresh_neighbour_lists(__cil_pp_net, __cil_fp_net, net);
#line 30
  __cil_pp_net = & net;
#line 31
  __cil_fp_net = & net;
#line 39
  __cil_tmp12 = (unsigned char *)net + 552;
#line 39
  __cil_tmp13 = (node_p *)__cil_tmp12;
#line 39
  node_ssa_1 = *__cil_tmp13;
#line 40
  __cil_tmp14 = (unsigned char *)net + 560;
#line 40
  __cil_tmp15 = (node_p *)__cil_tmp14;
#line 40
  __cil_tmp16 = *__cil_tmp15;
#line 40
  stop_ssa_1 = (void *)__cil_tmp16;
#line 43
  *__cil_fp_net = net;
#line 40
  refresh_neighbour_lists_cil_lr_1(__cil_pp_net, node_ssa_1, stop_ssa_1);
#line 41
  net_ssa_1 = *__cil_fp_net;
#line 46
  __cil_tmp17 = (unsigned char *)net_ssa_1 + 568;
#line 46
  __cil_tmp18 = (arc_p *)__cil_tmp17;
#line 46
  arc_ssa_1 = *__cil_tmp18;
#line 47
  __cil_tmp19 = (unsigned char *)net_ssa_1 + 576;
#line 47
  __cil_tmp20 = (arc_p *)__cil_tmp19;
#line 47
  __cil_tmp21 = *__cil_tmp20;
#line 47
  stop_ssa_2 = (void *)__cil_tmp21;
#line 47
  refresh_neighbour_lists_cil_lr_2(arc_ssa_1, stop_ssa_2);
#line 55
  return;
}
}
#line 68 "mcfutil.c"
long refresh_potential( network_t *net )
{
    node_t *node, *tmp;
    node_t *root = net->nodes;
    long checksum = 0;


    root->potential = (cost_t) -(long)(100000000L);
    tmp = node = root->child;
    while( node != root )
    {
        while( node )
        {
            if( node->orientation == 1 )
                node->potential = node->basic_arc->cost + node->pred->potential;
            else
            {
                node->potential = node->pred->potential - node->basic_arc->cost;
                checksum++;
            }

            tmp = node;
            node = node->child;
        }

        node = tmp;

        while( node->pred )
        {
            tmp = node->sibling;
            if( tmp )
            {
                node = tmp;
                break;
            }
            else
                node = node->pred;
        }
    }

    return checksum;
}

#line 122 "mcfutil.c"
double flow_cost( network_t *net )
{
    arc_t *arc;
    node_t *node;
    void *stop;

    long fleet = 0;
    cost_t operational_cost = 0;
    int cond;

    stop = (void *)net->stop_arcs;
    for( arc = net->arcs; arc != (arc_t *)stop; arc++ )
    {
        if( arc->ident == 2 )
            arc->flow = (flow_t)1;
        else
            arc->flow = (flow_t)0;
    }

    stop = (void *)net->stop_nodes;
    for( node = net->nodes, node++; node != (node_t *)stop; node++ )
        node->basic_arc->flow = node->flow;

    stop = (void *)net->stop_arcs;
    for( arc = net->arcs; arc != (arc_t *)stop; arc++ )
    {
        if( arc->flow )
        {
          cond = !(arc->tail->number < 0 && arc->head->number > 0);
          
            if( cond )
            {
                if( !arc->tail->number )
                {
                    operational_cost += (arc->cost - net->bigM);
                    fleet++;
                }
                else
                    operational_cost += arc->cost;
            }
        }

    }

    return (double)fleet * (double)net->bigM + (double)operational_cost;
}

double flow_org_cost( network_t *net )




{
    arc_t *arc;
    node_t *node;
    void *stop;

    long fleet = 0;
    cost_t operational_cost = 0;


    stop = (void *)net->stop_arcs;
    for( arc = net->arcs; arc != (arc_t *)stop; arc++ )
    {
        if( arc->ident == 2 )
            arc->flow = (flow_t)1;
        else
            arc->flow = (flow_t)0;
    }

    stop = (void *)net->stop_nodes;
    for( node = net->nodes, node++; node != (node_t *)stop; node++ )
        node->basic_arc->flow = node->flow;

    stop = (void *)net->stop_arcs;
    for( arc = net->arcs; arc != (arc_t *)stop; arc++ )
    {
        if( arc->flow )
        {
          if( (arc->tail->number >= 0))
            {
                if( !arc->tail->number )
                {
                    operational_cost += (arc->org_cost - net->bigM);
                    fleet++;
                }
                else
                    operational_cost += arc->org_cost;
            } else {
            if ( arc->head->number <= 0 )
                if( !arc->tail->number )
                {
                    operational_cost += (arc->org_cost - net->bigM);
                    fleet++;
                }
                else
                    operational_cost += arc->org_cost;
          }
        }
    }

    return (double)fleet * (double)net->bigM + (double)operational_cost;
}

long primal_feasible( network_t *net )




{
    void *stop;
    node_t *node;
    arc_t *dummy = net->dummy_arcs;
    arc_t *stop_dummy = net->stop_dummy;
    arc_t *arc;
    flow_t flow;
    int cond;

    node = net->nodes;
    stop = (void *)net->stop_nodes;
    cond = 0;
    
    for( node++; node < (node_t *)stop; node++ )
    {
        arc = node->basic_arc;
        flow = node->flow;
        cond = arc >= dummy && arc < stop_dummy;
        if( cond )
        {
            if( ( ((flow) >= 0) ? ( flow ) : -( flow ) ) > (flow_t)net->feas_tol )
            {
                printf( "PRIMAL NETWORK SIMPLEX: " );
                printf( "artificial arc with nonzero flow, node %d (%ld)\n",
                        node->number, flow );
            }
        }
        else
        {
          cond =  flow < (flow_t)(-net->feas_tol)
            || flow - (flow_t)1 > (flow_t)net->feas_tol ;
          
          if( cond )
            {
                printf( "PRIMAL NETWORK SIMPLEX: " );
                printf( "basis primal infeasible (%ld)\n", flow );
                net->feasible = 0;
                return 1;
            }
        }
    }

    net->feasible = 1;

    return 0;
}
# 297 "mcfutil.c"
long dual_feasible( network_t *net )




{
    arc_t *arc;
    arc_t *stop = net->stop_arcs;
    cost_t red_cost;

    int cond = 0;

    for( arc = net->arcs; arc < stop; arc++ )
    {
        red_cost = arc->cost - arc->tail->potential
            + arc->head->potential;
        if (arc->ident == 0) {
            if( red_cost < (cost_t)-net->feas_tol )
              cond = 1;
        } else if (arc->ident == 1){
            if( red_cost < (cost_t)-net->feas_tol )
              cond = 1;
        } else if (arc->ident == 2){
            if( red_cost > (cost_t)net->feas_tol )
              cond = 1;
        } else {
        }
        if (cond == 1)
          break;
    }
    if (cond == 1) {
      fprintf( stderr, "DUAL NETWORK SIMPLEX: " );
      fprintf( stderr, "basis dual infeasible\n" );
      return 1;
    }
    else
      return 0;
}

#line 369 "mcfutil.c"
long getfree(network_t *net ) 
{ 
  node_p tmp_ssa_1 ;
  arc_p tmp___0_ssa_1 ;
  arc_p tmp___1_ssa_1 ;
  node_p __cil_tmp8 ;
  arc_p __cil_tmp9 ;
  arc_p __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  node_p *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  node_p __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  arc_p *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  arc_p *__cil_tmp19 ;
  arc_p __cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  arc_p *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  arc_p *__cil_tmp24 ;
  arc_p __cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  node_p *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  node_p *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  arc_p *__cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  arc_p *__cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  arc_p *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  arc_p *__cil_tmp37 ;

  {

#line 377
  //return babel_wrapper_getfree(net);
#line 377
  __cil_tmp11 = (unsigned char *)net + 552;
#line 377
  __cil_tmp12 = (node_p *)__cil_tmp11;
#line 377
  __cil_tmp8 = *__cil_tmp12;
#line 377
  if (__cil_tmp8 != 0) {
#line 377
    __cil_tmp13 = (unsigned char *)net + 552;
#line 377
    __cil_tmp14 = (node_p *)__cil_tmp13;
#line 377
    __cil_tmp15 = *__cil_tmp14;
#line 377
    free((void *)__cil_tmp15);
  } else {

  }
#line 378
  __cil_tmp16 = (unsigned char *)net + 568;
#line 378
  __cil_tmp17 = (arc_p *)__cil_tmp16;
#line 378
  __cil_tmp9 = *__cil_tmp17;
#line 378
  if (__cil_tmp9 != 0) {
#line 378
    __cil_tmp18 = (unsigned char *)net + 568;
#line 378
    __cil_tmp19 = (arc_p *)__cil_tmp18;
#line 378
    __cil_tmp20 = *__cil_tmp19;
#line 378
    free((void *)__cil_tmp20);
  } else {

  }
#line 379
  __cil_tmp21 = (unsigned char *)net + 584;
#line 379
  __cil_tmp22 = (arc_p *)__cil_tmp21;
#line 379
  __cil_tmp10 = *__cil_tmp22;
#line 379
  if (__cil_tmp10 != 0) {
#line 379
    __cil_tmp23 = (unsigned char *)net + 584;
#line 379
    __cil_tmp24 = (arc_p *)__cil_tmp23;
#line 379
    __cil_tmp25 = *__cil_tmp24;
#line 379
    free((void *)__cil_tmp25);
  } else {

  }
#line 380
  tmp_ssa_1 = (node_p )0;
#line 380
  __cil_tmp26 = (unsigned char *)net + 560;
#line 380
  __cil_tmp27 = (node_p *)__cil_tmp26;
#line 380
  *__cil_tmp27 = tmp_ssa_1;
#line 380
  __cil_tmp28 = (unsigned char *)net + 552;
#line 380
  __cil_tmp29 = (node_p *)__cil_tmp28;
#line 380
  *__cil_tmp29 = tmp_ssa_1;
#line 381
  tmp___0_ssa_1 = (arc_p )0;
#line 381
  __cil_tmp30 = (unsigned char *)net + 576;
#line 381
  __cil_tmp31 = (arc_p *)__cil_tmp30;
#line 381
  *__cil_tmp31 = tmp___0_ssa_1;
#line 381
  __cil_tmp32 = (unsigned char *)net + 568;
#line 381
  __cil_tmp33 = (arc_p *)__cil_tmp32;
#line 381
  *__cil_tmp33 = tmp___0_ssa_1;
#line 382
  tmp___1_ssa_1 = (arc_p )0;
#line 382
  __cil_tmp34 = (unsigned char *)net + 592;
#line 382
  __cil_tmp35 = (arc_p *)__cil_tmp34;
#line 382
  *__cil_tmp35 = tmp___1_ssa_1;
#line 382
  __cil_tmp36 = (unsigned char *)net + 584;
#line 382
  __cil_tmp37 = (arc_p *)__cil_tmp36;
#line 382
  *__cil_tmp37 = tmp___1_ssa_1;
#line 384
  return (0L);
}
}
#line 114 "mcfutil.c"
void refresh_neighbour_lists_cil_lr_1(network_t **__cil_ap_net , node_t *node , void *stop ) 
{ 
  node_t *node_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  arc_p *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  arc_p *__cil_tmp9 ;

  {

#line 40
  return babel_wrapper_refresh_neighbour_lists_cil_lr_1(__cil_ap_net, node, stop);
#line 40
  __cil_tmp5 = (unsigned long )node < (unsigned long )((node_t *)stop);
#line 40
  if (__cil_tmp5 != 0) {
#line 42
    __cil_tmp6 = (unsigned char *)node + 64;
#line 42
    __cil_tmp7 = (arc_p *)__cil_tmp6;
#line 42
    *__cil_tmp7 = (arc_t *)0;
#line 43
    __cil_tmp8 = (unsigned char *)node + 56;
#line 43
    __cil_tmp9 = (arc_p *)__cil_tmp8;
#line 43
    *__cil_tmp9 = (arc_t *)0;
#line 40
    node_ssa_1 = node + 1;
#line 43
    refresh_neighbour_lists_cil_lr_1(__cil_ap_net, node_ssa_1, stop);
#line 45
    return;
  } else {
#line 47
    return;
  }
}
}
#line 52 "mcfutil.c"
void refresh_neighbour_lists_cil_lr_2(arc_t *arc , void *stop ) 
{ 
  arc_t *arc_ssa_1 ;
  int __cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  node_p *__cil_tmp6 ;
  node_p __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  arc_p *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  arc_p *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  node_p __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  arc_p *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  node_p *__cil_tmp20 ;
  node_p __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  arc_p *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  arc_p *__cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  node_p *__cil_tmp28 ;
  node_p __cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  arc_p *__cil_tmp32 ;

  {

#line 47
  return babel_wrapper_refresh_neighbour_lists_cil_lr_2(arc, stop);
#line 47
  __cil_tmp4 = (unsigned long )arc < (unsigned long )((arc_t *)stop);
#line 47
  if (__cil_tmp4 != 0) {
#line 49
    __cil_tmp5 = (unsigned char *)arc + 8;
#line 49
    __cil_tmp6 = (node_p *)__cil_tmp5;
#line 49
    __cil_tmp7 = *__cil_tmp6;
#line 49
    __cil_tmp8 = (unsigned char *)__cil_tmp7;
#line 49
    __cil_tmp9 = __cil_tmp8 + 56;
#line 49
    __cil_tmp10 = (arc_p *)__cil_tmp9;
#line 49
    __cil_tmp11 = (unsigned char *)arc + 32;
#line 49
    __cil_tmp12 = (arc_p *)__cil_tmp11;
#line 49
    *__cil_tmp12 = *__cil_tmp10;
#line 50
    __cil_tmp13 = (unsigned char *)arc + 8;
#line 50
    __cil_tmp14 = (node_p *)__cil_tmp13;
#line 50
    __cil_tmp15 = *__cil_tmp14;
#line 50
    __cil_tmp16 = (unsigned char *)__cil_tmp15;
#line 50
    __cil_tmp17 = __cil_tmp16 + 56;
#line 50
    __cil_tmp18 = (arc_p *)__cil_tmp17;
#line 50
    *__cil_tmp18 = arc;
#line 51
    __cil_tmp19 = (unsigned char *)arc + 16;
#line 51
    __cil_tmp20 = (node_p *)__cil_tmp19;
#line 51
    __cil_tmp21 = *__cil_tmp20;
#line 51
    __cil_tmp22 = (unsigned char *)__cil_tmp21;
#line 51
    __cil_tmp23 = __cil_tmp22 + 64;
#line 51
    __cil_tmp24 = (arc_p *)__cil_tmp23;
#line 51
    __cil_tmp25 = (unsigned char *)arc + 40;
#line 51
    __cil_tmp26 = (arc_p *)__cil_tmp25;
#line 51
    *__cil_tmp26 = *__cil_tmp24;
#line 52
    __cil_tmp27 = (unsigned char *)arc + 16;
#line 52
    __cil_tmp28 = (node_p *)__cil_tmp27;
#line 52
    __cil_tmp29 = *__cil_tmp28;
#line 52
    __cil_tmp30 = (unsigned char *)__cil_tmp29;
#line 52
    __cil_tmp31 = __cil_tmp30 + 64;
#line 52
    __cil_tmp32 = (arc_p *)__cil_tmp31;
#line 52
    *__cil_tmp32 = arc;
#line 47
    arc_ssa_1 = arc + 1;
#line 50
    refresh_neighbour_lists_cil_lr_2(arc_ssa_1, stop);
#line 52
    return;
  } else {
#line 54
    return;
  }
}
}
#include <gprolog.h>

PlBool babel_ptrR(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

		return PL_TRUE;
}

PlBool babel_ptrR_byte(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

	return PL_TRUE;
}

PlBool babel_ptrE(PlLong* p,  PlLong e, PlLong len)
{
	if (p == 0)
	    return PL_FALSE;

	switch(len)
		{
		    case 1:
		    	*(unsigned char*)p = (unsigned char)e;
		    	break;
		    case 2:
		    	*(short*) p = (short)e;
		    	break;
		    case 4:
		    	*(int*)p = (int)e;
		    	break;
		    case 8:
		    	*(long long*)p = (long long)e;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrL\n");
		}

        return PL_TRUE;
}

PlBool babel_ptrFR(double* fp, PlLong ptr, PlLong len)
{
  if(len == 2)
  *(double *)fp = *(double *)ptr;
   else if (len == 1)
  *(float *)fp = *(float *)ptr;
  else
  return PL_FALSE;

  return PL_TRUE;
}

PlBool babel_ptrFW(PlLong ptr, double f, PlLong len)
{
  if (len == 2)
  *(double *)ptr = f;
   else if (len == 1)
  *(float *)ptr = f;
  else
  return PL_FALSE;
  
  return PL_TRUE;
}

PlBool babel__implicit_refresh_neighbour_listsc_0(network_t ** arg_0, node_t * arg_1, void * arg_2) 
{
refresh_neighbour_lists_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_refresh_neighbour_listsc_1(arc_t * arg_0, void * arg_1) 
{
refresh_neighbour_lists_cil_lr_2(arg_0, arg_1);
return PL_TRUE;
}


