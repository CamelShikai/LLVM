/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 68 "defines.h"
typedef long flow_t;
#line 69 "defines.h"
typedef long cost_t;
#line 99
struct node;
#line 99 "defines.h"
typedef struct node node_t;
#line 100 "defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 102 "defines.h"
typedef struct arc arc_t;
#line 103 "defines.h"
typedef struct arc *arc_p;
#line 107 "defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 30 "treeup.h"
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) ;
#line 29 "treeup.c"
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) 
{ 
  arc_t *basic_arc_temp ;
  arc_t *new_basic_arc ;
  node_t *father ;
  node_t *temp ;
  node_t *new_pred ;
  long orientation_temp ;
  long depth_temp ;
  long depth_iminus ;
  long new_depth ;
  flow_t flow_temp ;
  cost_t tmp ;

  {
#line 71
  if ((unsigned long )bea->tail == (unsigned long )jplus) {
#line 71
    if (sigma < 0L) {
#line 71
      goto _L;
    } else {
#line 71
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 71
  if ((unsigned long )bea->tail == (unsigned long )iplus) {
#line 71
    if (sigma > 0L) {
      _L: /* CIL Label */ 
#line 73
      if (sigma >= 0L) {

      } else {
#line 73
        sigma = - sigma;
      }
    } else {
#line 71
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 75
    if (sigma >= 0L) {
#line 75
      tmp = sigma;
    } else {
#line 75
      tmp = - sigma;
    }
#line 75
    sigma = - tmp;
  }
#line 77
  father = iminus;
#line 78
  father->potential += sigma;
  RECURSION: 
#line 80
  temp = father->child;
#line 81
  if (temp) {
    ITERATION: 
#line 84
    temp->potential += sigma;
#line 85
    father = temp;
#line 86
    goto RECURSION;
  }
  TEST: 
#line 89
  if ((unsigned long )father == (unsigned long )iminus) {
#line 90
    goto CONTINUE;
  }
#line 91
  temp = father->sibling;
#line 92
  if (temp) {
#line 93
    goto ITERATION;
  }
#line 94
  father = father->pred;
#line 95
  goto TEST;
  CONTINUE: 
#line 101
  temp = iplus;
#line 102
  father = temp->pred;
#line 103
  depth_iminus = iminus->depth;
#line 103
  new_depth = depth_iminus;
#line 104
  new_pred = jplus;
#line 105
  new_basic_arc = bea;
#line 106
  while ((unsigned long )temp != (unsigned long )jminus) {
#line 108
    if (temp->sibling) {
#line 109
      (temp->sibling)->sibling_prev = temp->sibling_prev;
    }
#line 110
    if (temp->sibling_prev) {
#line 111
      (temp->sibling_prev)->sibling = temp->sibling;
    } else {
#line 112
      father->child = temp->sibling;
    }
#line 115
    temp->pred = new_pred;
#line 116
    temp->sibling = new_pred->child;
#line 117
    if (temp->sibling) {
#line 118
      (temp->sibling)->sibling_prev = temp;
    }
#line 119
    new_pred->child = temp;
#line 120
    temp->sibling_prev = (node_p )0;
#line 122
    orientation_temp = (long )(! temp->orientation);
#line 123
    if (orientation_temp == cycle_ori) {
#line 124
      flow_temp = temp->flow + delta;
    } else {
#line 126
      flow_temp = temp->flow - delta;
    }
#line 127
    basic_arc_temp = temp->basic_arc;
#line 128
    depth_temp = temp->depth;
#line 130
    temp->orientation = (int )new_orientation;
#line 131
    temp->flow = new_flow;
#line 132
    temp->basic_arc = new_basic_arc;
#line 133
    temp->depth = new_depth;
#line 135
    new_pred = temp;
#line 136
    new_orientation = orientation_temp;
#line 137
    new_flow = flow_temp;
#line 138
    new_basic_arc = basic_arc_temp;
#line 139
    new_depth = depth_iminus - depth_temp;
#line 140
    temp = father;
#line 141
    father = temp->pred;
  }
#line 144
  if (delta > feas_tol) {
#line 146
    temp = jminus;
#line 146
    while ((unsigned long )temp != (unsigned long )w) {
#line 148
      temp->depth -= depth_iminus;
#line 149
      if ((long )temp->orientation != cycle_ori) {
#line 150
        temp->flow += delta;
      } else {
#line 152
        temp->flow -= delta;
      }
#line 146
      temp = temp->pred;
    }
#line 154
    temp = jplus;
#line 154
    while ((unsigned long )temp != (unsigned long )w) {
#line 156
      temp->depth += depth_iminus;
#line 157
      if ((long )temp->orientation == cycle_ori) {
#line 158
        temp->flow += delta;
      } else {
#line 160
        temp->flow -= delta;
      }
#line 154
      temp = temp->pred;
    }
  } else {
#line 165
    temp = jminus;
#line 165
    while ((unsigned long )temp != (unsigned long )w) {
#line 166
      temp->depth -= depth_iminus;
#line 165
      temp = temp->pred;
    }
#line 167
    temp = jplus;
#line 167
    while ((unsigned long )temp != (unsigned long )w) {
#line 168
      temp->depth += depth_iminus;
#line 167
      temp = temp->pred;
    }
  }
#line 171
  return;
}
}
