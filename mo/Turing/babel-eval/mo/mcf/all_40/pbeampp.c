/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 68 "defines.h"
typedef long flow_t;
#line 69 "defines.h"
typedef long cost_t;
#line 99
struct node;
#line 100 "defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 102 "defines.h"
typedef struct arc arc_t;
#line 103 "defines.h"
typedef struct arc *arc_p;
#line 107 "defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 51 "pbeampp.c"
struct basket {
   arc_t *a ;
   cost_t cost ;
   cost_t abs_cost ;
};
#line 51 "pbeampp.c"
typedef struct basket BASKET;
#line 30 "pbeampp.h"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) ;
#line 58 "pbeampp.c"
static long basket_size  ;
#line 59 "pbeampp.c"
static BASKET basket[351]  ;
#line 60 "pbeampp.c"
static BASKET *perm[351]  ;
#line 111 "pbeampp.c"
static long nr_group  ;
#line 112 "pbeampp.c"
static long group_pos  ;
#line 115 "pbeampp.c"
static long initialize  =    1L;
void sort_basket_cil_lr_1_cil_lr_1(cost_t *__cil_ap_cut , long *__cil_ap_l ) ;
void sort_basket_cil_lr_1_cil_lr_2(cost_t *__cil_ap_cut , long *__cil_ap_r ) ;
void sort_basket_cil_lr_1(long *__cil_ap_min , long *__cil_ap_max , long *__cil_ap_l ,
                          long *__cil_ap_r , cost_t cut ) ;
#line 34 "pbeampp.c"
int bea_is_dual_infeasible(arc_t *arc , cost_t red_cost ) 
{ 
  int tmp ;

  {
#line 41
  if (red_cost < 0L) {
#line 41
    if (arc->ident == 1) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if (red_cost > 0L) {
#line 41
    if (arc->ident == 2) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return (tmp);
}
}
#line 65 "pbeampp.c"
void sort_basket(long min , long max ) 
{ 
  long l ;
  long r ;
  long *__cil_pp_min  = & min;
  long *__cil_pp_max  = & max;
  long *__cil_pp_l  = & l;
  long *__cil_pp_r  = & r;
  long *__cil_fp_min  = & min;
  long *__cil_fp_max  = & max;
  long *__cil_fp_l  = & l;
  long *__cil_fp_r  = & r;
  long l_ssa_1 ;
  long r_ssa_1 ;
  cost_t cut_ssa_1 ;
  long min_ssa_1 ;
  long max_ssa_1 ;
  long l_ssa_2 ;
  long r_ssa_2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  long __cil_tmp26 ;
  BASKET **__cil_tmp27 ;
  BASKET *__cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  cost_t *__cil_tmp31 ;

  {
  {
#line 75
  l_ssa_1 = min;
#line 75
  r_ssa_1 = max;
#line 77
  __cil_tmp25 = l_ssa_1 + r_ssa_1;
#line 77
  __cil_tmp26 = __cil_tmp25 / 2L;
#line 77
  __cil_tmp27 = perm + __cil_tmp26;
#line 77
  __cil_tmp28 = *__cil_tmp27;
#line 77
  __cil_tmp29 = (unsigned char *)__cil_tmp28;
#line 77
  __cil_tmp30 = __cil_tmp29 + 16;
#line 77
  __cil_tmp31 = (cost_t *)__cil_tmp30;
#line 77
  cut_ssa_1 = *__cil_tmp31;
  }
  {
  *__cil_fp_min = min;
  *__cil_fp_max = max;
  *__cil_fp_l = l_ssa_1;
  *__cil_fp_r = r_ssa_1;
#line 79
  sort_basket_cil_lr_1(__cil_pp_min, __cil_pp_max, __cil_pp_l, __cil_pp_r, cut_ssa_1);
  min_ssa_1 = *__cil_fp_min;
  max_ssa_1 = *__cil_fp_max;
  l_ssa_2 = *__cil_fp_l;
  r_ssa_2 = *__cil_fp_r;
  }
  {
#line 100
  __cil_tmp22 = min_ssa_1 < r_ssa_2;
#line 100
  if (__cil_tmp22) {
    {
#line 101
    sort_basket(min_ssa_1, r_ssa_2);
    }
  } else {

  }
  }
  {
#line 102
  __cil_tmp23 = l_ssa_2 < max_ssa_1;
#line 102
  if (__cil_tmp23) {
    {
#line 102
    __cil_tmp24 = l_ssa_2 <= 50L;
#line 102
    if (__cil_tmp24) {
      {
#line 103
      sort_basket(l_ssa_2, max_ssa_1);
      }
    } else {

    }
    }
  } else {

  }
  }
#line 104
  return;
}
}
#line 119 "pbeampp.c"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) 
{ 
  long i ;
  long next ;
  long old_group_pos ;
  arc_t *arc ;
  cost_t red_cost ;
  int tmp ;

  {
#line 133
  if (initialize) {
#line 135
    i = 1L;
#line 135
    while (i < 351L) {
#line 136
      perm[i] = & basket[i];
#line 135
      i ++;
    }
#line 137
    nr_group = (m - 1L) / 300L + 1L;
#line 138
    group_pos = 0L;
#line 139
    basket_size = 0L;
#line 140
    initialize = 0L;
  } else {
#line 144
    i = 2L;
#line 144
    next = 0L;
#line 144
    while (1) {
#line 144
      if (i <= 50L) {
#line 144
        if (! (i <= basket_size)) {
#line 144
          break;
        }
      } else {
#line 144
        break;
      }
#line 146
      arc = (perm[i])->a;
#line 147
      red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
#line 148
      if (red_cost < 0L) {
#line 148
        if (arc->ident == 1) {
#line 148
          goto _L;
        } else {
#line 148
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 148
      if (red_cost > 0L) {
#line 148
        if (arc->ident == 2) {
          _L: /* CIL Label */ 
#line 151
          next ++;
#line 152
          (perm[next])->a = arc;
#line 153
          (perm[next])->cost = red_cost;
#line 154
          if (red_cost >= 0L) {
#line 154
            (perm[next])->abs_cost = red_cost;
          } else {
#line 154
            (perm[next])->abs_cost = - red_cost;
          }
        }
      }
#line 144
      i ++;
    }
#line 157
    basket_size = next;
  }
#line 160
  old_group_pos = group_pos;
#line 162
  while (1) {
#line 165
    arc = arcs + group_pos;
#line 166
    while ((unsigned long )arc < (unsigned long )stop_arcs) {
#line 168
      if (arc->ident > 0) {
#line 171
        red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
#line 172
        tmp = bea_is_dual_infeasible(arc, red_cost);
#line 172
        if (tmp) {
#line 174
          basket_size ++;
#line 175
          (perm[basket_size])->a = arc;
#line 176
          (perm[basket_size])->cost = red_cost;
#line 177
          if (red_cost >= 0L) {
#line 177
            (perm[basket_size])->abs_cost = red_cost;
          } else {
#line 177
            (perm[basket_size])->abs_cost = - red_cost;
          }
        }
      }
#line 166
      arc += nr_group;
    }
#line 183
    group_pos ++;
#line 183
    if (group_pos == nr_group) {
#line 184
      group_pos = 0L;
    }
#line 162
    if (basket_size < 50L) {
#line 162
      if (! (group_pos != old_group_pos)) {
#line 162
        break;
      }
    } else {
#line 162
      break;
    }
  }
#line 188
  if (basket_size == 0L) {
#line 190
    initialize = 1L;
#line 191
    *red_cost_of_bea = (cost_t )0;
#line 192
    return ((arc_t *)((void *)0));
  } else {
#line 194
    sort_basket(1L, basket_size);
#line 195
    *red_cost_of_bea = (perm[1])->cost;
#line 196
    return ((perm[1])->a);
  }
}
}
void sort_basket_cil_lr_1_cil_lr_1(cost_t *__cil_ap_cut , long *__cil_ap_l ) 
{ 
  int __cil_tmp3 ;
  long __cil_tmp4 ;
  BASKET **__cil_tmp5 ;
  BASKET *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  cost_t *__cil_tmp9 ;
  cost_t __cil_tmp10 ;
  cost_t __cil_tmp11 ;
  long __cil_tmp12 ;

  {
  {
#line 81
  __cil_tmp4 = *__cil_ap_l;
#line 81
  __cil_tmp5 = perm + __cil_tmp4;
#line 81
  __cil_tmp6 = *__cil_tmp5;
#line 81
  __cil_tmp7 = (unsigned char *)__cil_tmp6;
#line 81
  __cil_tmp8 = __cil_tmp7 + 16;
#line 81
  __cil_tmp9 = (cost_t *)__cil_tmp8;
#line 81
  __cil_tmp10 = *__cil_tmp9;
#line 81
  __cil_tmp11 = *__cil_ap_cut;
#line 81
  __cil_tmp3 = __cil_tmp10 > __cil_tmp11;
#line 81
  if (__cil_tmp3) {
    {
#line 82
    __cil_tmp12 = *__cil_ap_l;
#line 82
    *__cil_ap_l = __cil_tmp12 + 1L;
    }
    {
    sort_basket_cil_lr_1_cil_lr_1(__cil_ap_cut, __cil_ap_l);
    }
    return;
  } else {
    return;
  }
  }
}
}
void sort_basket_cil_lr_1_cil_lr_2(cost_t *__cil_ap_cut , long *__cil_ap_r ) 
{ 
  int __cil_tmp3 ;
  long __cil_tmp4 ;
  BASKET **__cil_tmp5 ;
  BASKET *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  cost_t *__cil_tmp9 ;
  cost_t __cil_tmp10 ;
  cost_t __cil_tmp11 ;
  long __cil_tmp12 ;

  {
  {
#line 83
  __cil_tmp4 = *__cil_ap_r;
#line 83
  __cil_tmp5 = perm + __cil_tmp4;
#line 83
  __cil_tmp6 = *__cil_tmp5;
#line 83
  __cil_tmp7 = (unsigned char *)__cil_tmp6;
#line 83
  __cil_tmp8 = __cil_tmp7 + 16;
#line 83
  __cil_tmp9 = (cost_t *)__cil_tmp8;
#line 83
  __cil_tmp10 = *__cil_ap_cut;
#line 83
  __cil_tmp11 = *__cil_tmp9;
#line 83
  __cil_tmp3 = __cil_tmp10 > __cil_tmp11;
#line 83
  if (__cil_tmp3) {
    {
#line 84
    __cil_tmp12 = *__cil_ap_r;
#line 84
    *__cil_ap_r = __cil_tmp12 - 1L;
    }
    {
    sort_basket_cil_lr_1_cil_lr_2(__cil_ap_cut, __cil_ap_r);
    }
    return;
  } else {
    return;
  }
  }
}
}
void sort_basket_cil_lr_1(long *__cil_ap_min , long *__cil_ap_max , long *__cil_ap_l ,
                          long *__cil_ap_r , cost_t cut ) 
{ 
  cost_t *__cil_pp_cut  = & cut;
  cost_t *__cil_fp_cut  = & cut;
  cost_t cut_ssa_1 ;
  cost_t cut_ssa_2 ;
  BASKET *xchange_ssa_1 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  long __cil_tmp16 ;
  long __cil_tmp17 ;
  BASKET **__cil_tmp18 ;
  long __cil_tmp19 ;
  BASKET **__cil_tmp20 ;
  long __cil_tmp21 ;
  BASKET **__cil_tmp22 ;
  long __cil_tmp23 ;
  BASKET **__cil_tmp24 ;
  long __cil_tmp25 ;
  long __cil_tmp26 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  long __cil_tmp29 ;
  long __cil_tmp30 ;

  {
  {
  *__cil_fp_cut = cut;
#line 81
  sort_basket_cil_lr_1_cil_lr_1(__cil_pp_cut, __cil_ap_l);
  cut_ssa_1 = *__cil_fp_cut;
  }
  {
  *__cil_fp_cut = cut_ssa_1;
#line 83
  sort_basket_cil_lr_1_cil_lr_2(__cil_pp_cut, __cil_ap_r);
  cut_ssa_2 = *__cil_fp_cut;
  }
  {
#line 86
  __cil_tmp15 = *__cil_ap_l;
#line 86
  __cil_tmp16 = *__cil_ap_r;
#line 86
  __cil_tmp12 = __cil_tmp15 < __cil_tmp16;
#line 86
  if (__cil_tmp12) {
    {
#line 88
    __cil_tmp17 = *__cil_ap_l;
#line 88
    __cil_tmp18 = perm + __cil_tmp17;
#line 88
    xchange_ssa_1 = *__cil_tmp18;
#line 89
    __cil_tmp19 = *__cil_ap_r;
#line 89
    __cil_tmp20 = perm + __cil_tmp19;
#line 89
    __cil_tmp21 = *__cil_ap_l;
#line 89
    __cil_tmp22 = perm + __cil_tmp21;
#line 89
    *__cil_tmp22 = *__cil_tmp20;
#line 90
    __cil_tmp23 = *__cil_ap_r;
#line 90
    __cil_tmp24 = perm + __cil_tmp23;
#line 90
    *__cil_tmp24 = xchange_ssa_1;
    }
  } else {

  }
  }
  {
#line 92
  __cil_tmp25 = *__cil_ap_l;
#line 92
  __cil_tmp26 = *__cil_ap_r;
#line 92
  __cil_tmp13 = __cil_tmp25 <= __cil_tmp26;
#line 92
  if (__cil_tmp13) {
    {
#line 94
    __cil_tmp27 = *__cil_ap_l;
#line 94
    *__cil_ap_l = __cil_tmp27 + 1L;
#line 94
    __cil_tmp28 = *__cil_ap_r;
#line 94
    *__cil_ap_r = __cil_tmp28 - 1L;
    }
  } else {

  }
  }
  {
#line 79
  __cil_tmp29 = *__cil_ap_l;
#line 79
  __cil_tmp30 = *__cil_ap_r;
#line 79
  __cil_tmp14 = __cil_tmp29 <= __cil_tmp30;
#line 79
  if (__cil_tmp14) {
    {
    sort_basket_cil_lr_1(__cil_ap_min, __cil_ap_max, __cil_ap_l, __cil_ap_r, cut_ssa_2);
    }
    return;
  } else {
    return;
  }
  }
}
}
