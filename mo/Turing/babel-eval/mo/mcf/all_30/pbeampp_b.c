#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 68 "defines.h"
typedef long flow_t;
#line 69 "defines.h"
typedef long cost_t;
#line 99
struct node;
#line 99
struct node;
#line 100 "defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 102
struct arc;
#line 102 "defines.h"
typedef struct arc arc_t;
#line 103 "defines.h"
typedef struct arc *arc_p;
#line 107 "defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 51 "pbeampp.c"
struct basket {
   arc_t *a ;
   cost_t cost ;
   cost_t abs_cost ;
};
#line 51 "pbeampp.c"
typedef struct basket BASKET;
#line 30 "pbeampp.h"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) ;
#line 58 "pbeampp.c"
static long basket_size  ;
#line 59 "pbeampp.c"
static BASKET basket[351]  ;
#line 60 "pbeampp.c"
static BASKET *perm[351]  ;
#line 111 "pbeampp.c"
static long nr_group  ;
#line 112 "pbeampp.c"
static long group_pos  ;
#line 115 "pbeampp.c"
static long initialize  =    1L;
#line 116
void primal_bea_mpp_cil_lr_3_cil_lr_1(long *__cil_ap_basket_size , long *__cil_ap_nr_group ,
                                      long *__cil_ap_group_pos , arc_t **__cil_ap_arcs ,
                                      arc_t **__cil_ap_stop_arcs , long *__cil_ap_old_group_pos ,
                                      arc_t *arc ) ;
#line 120
void sort_basket_cil_lr_1_cil_lr_1(cost_t *__cil_ap_cut , long *__cil_ap_l ) ;
#line 121
void sort_basket_cil_lr_1_cil_lr_2(cost_t *__cil_ap_cut , long *__cil_ap_r ) ;
#line 122
void primal_bea_mpp_cil_lr_1(long *__cil_ap_m , arc_t **__cil_ap_arcs , arc_t **__cil_ap_stop_arcs ,
                             cost_t **__cil_ap_red_cost_of_bea , long i ) ;
#line 124
void primal_bea_mpp_cil_lr_2(long *__cil_ap_nr_group , long *__cil_ap_group_pos ,
                             arc_t **__cil_ap_arcs , arc_t **__cil_ap_stop_arcs ,
                             cost_t **__cil_ap_red_cost_of_bea , long *__cil_ap_next ,
                             long i , int cond ) ;
#line 128
void primal_bea_mpp_cil_lr_3(long *__cil_ap_basket_size , cost_t **__cil_ap_red_cost_of_bea ,
                             arc_t *arcs , arc_t *stop_arcs , long old_group_pos ) ;
#line 130
void sort_basket_cil_lr_1(long *__cil_ap_min , long *__cil_ap_max , long *__cil_ap_l ,
                          long *__cil_ap_r , cost_t cut ) ;
   int babel_wrapper_sort_basket(long * __cil_pp_min, long * __cil_pp_max, long * __cil_pp_l, long * __cil_pp_r, long * __cil_fp_min, long * __cil_fp_max, long * __cil_fp_l, long * __cil_fp_r, long  min, long  max)                           // function name insert
      {
        // wrapper for function sort_basket        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[12];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sort_basket"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_min);
arg[1] = Pl_Mk_Integer(__cil_pp_max);
arg[2] = Pl_Mk_Integer(__cil_pp_l);
arg[3] = Pl_Mk_Integer(__cil_pp_r);
arg[4] = Pl_Mk_Integer(__cil_fp_min);
arg[5] = Pl_Mk_Integer(__cil_fp_max);
arg[6] = Pl_Mk_Integer(__cil_fp_l);
arg[7] = Pl_Mk_Integer(__cil_fp_r);
arg[8] = Pl_Mk_Integer(min);
arg[9] = Pl_Mk_Integer(max);
arg[10] = Pl_Mk_Integer(perm);

      //routine code, reserve a place for return value
      arg[11] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 12, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[11]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
//   arc_t * babel_wrapper_primal_bea_mpp(long * __cil_pp_m, arc_t ** __cil_pp_arcs, arc_t ** __cil_pp_stop_arcs, cost_t ** __cil_pp_red_cost_of_bea, long * __cil_pp_nr_group, long * __cil_pp_group_pos, long * __cil_pp_next, long * __cil_pp_basket_size, long * __cil_gp_initialize, long * __cil_gp_nr_group, long * __cil_gp_group_pos, long * __cil_gp_basket_size, long * __cil_fp_m, arc_t ** __cil_fp_arcs, arc_t ** __cil_fp_stop_arcs, cost_t ** __cil_fp_red_cost_of_bea, long * __cil_fp_next, long  m, arc_t * arcs, arc_t * stop_arcs, cost_t * red_cost_of_bea)                           // function name insert
//      {
//        // wrapper for function primal_bea_mpp        // function name insert
//         arc_t * return_value; //  return value type (how about array type)
//
//        //rountine code
//        int func;
//        PlTerm arg[23];    //  function variable + return value insert
//        PlBool res;
//
//        func = Pl_Find_Atom("primal_bea_mpp"); // function name insert
//
//      //routine code
//        Pl_Query_Begin(PL_FALSE);
//
//      //prepare parameters
//      //partial routine code, pass in parameter  // we need to init arguments and return value
//      arg[0] = Pl_Mk_Integer(__cil_pp_m);
//arg[1] = Pl_Mk_Integer(__cil_pp_arcs);
//arg[2] = Pl_Mk_Integer(__cil_pp_stop_arcs);
//arg[3] = Pl_Mk_Integer(__cil_pp_red_cost_of_bea);
//arg[4] = Pl_Mk_Integer(__cil_pp_nr_group);
//arg[5] = Pl_Mk_Integer(__cil_pp_group_pos);
//arg[6] = Pl_Mk_Integer(__cil_pp_next);
//arg[7] = Pl_Mk_Integer(__cil_pp_basket_size);
//arg[8] = Pl_Mk_Integer(__cil_gp_initialize);
//arg[9] = Pl_Mk_Integer(__cil_gp_nr_group);
//arg[10] = Pl_Mk_Integer(__cil_gp_group_pos);
//arg[11] = Pl_Mk_Integer(__cil_gp_basket_size);
//arg[12] = Pl_Mk_Integer(__cil_fp_m);
//arg[13] = Pl_Mk_Integer(__cil_fp_arcs);
//arg[14] = Pl_Mk_Integer(__cil_fp_stop_arcs);
//arg[15] = Pl_Mk_Integer(__cil_fp_red_cost_of_bea);
//arg[16] = Pl_Mk_Integer(__cil_fp_next);
//arg[17] = Pl_Mk_Integer(m);
//arg[18] = Pl_Mk_Integer(arcs);
//arg[19] = Pl_Mk_Integer(stop_arcs);
//arg[20] = Pl_Mk_Integer(red_cost_of_bea);
//arg[21] = Pl_Mk_Integer(perm);
//
//      //routine code, reserve a place for return value
//      arg[22] = Pl_Mk_Variable();
//
//      //partial routine code, 2 is not routine. (number of arguments) + 1
//        res = Pl_Query_Call(func, 23, arg);          // insert (variable+return value)
//
//      //get return value, partial routine code, 1 is not routine
//        return_value = Pl_Rd_Integer(arg[22]);        // insert ()
//
//      //routine code
//        Pl_Query_End(PL_KEEP_FOR_PROLOG);
//
//      //routine code
//        return return_value;
//        }
//      
//   int babel_wrapper_primal_bea_mpp_cil_lr_3_cil_lr_1(long * __cil_gp_basket_size, long * __cil_gp_nr_group, long * __cil_ap_basket_size, long * __cil_ap_nr_group, long * __cil_ap_group_pos, arc_t ** __cil_ap_arcs, arc_t ** __cil_ap_stop_arcs, long * __cil_ap_old_group_pos, arc_t * arc)                           // function name insert
//      {
//        // wrapper for function primal_bea_mpp_cil_lr_3_cil_lr_1        // function name insert
//         int return_value; //  return value type (how about array type)
//
//        //rountine code
//        int func;
//        PlTerm arg[11];    //  function variable + return value insert
//        PlBool res;
//
//        func = Pl_Find_Atom("primal_bea_mpp_cil_lr_3_cil_lr_1"); // function name insert
//
//      //routine code
//        Pl_Query_Begin(PL_FALSE);
//
//      //prepare parameters
//      //partial routine code, pass in parameter  // we need to init arguments and return value
//      arg[0] = Pl_Mk_Integer(__cil_gp_basket_size);
//arg[1] = Pl_Mk_Integer(__cil_gp_nr_group);
//arg[2] = Pl_Mk_Integer(__cil_ap_basket_size);
//arg[3] = Pl_Mk_Integer(__cil_ap_nr_group);
//arg[4] = Pl_Mk_Integer(__cil_ap_group_pos);
//arg[5] = Pl_Mk_Integer(__cil_ap_arcs);
//arg[6] = Pl_Mk_Integer(__cil_ap_stop_arcs);
//arg[7] = Pl_Mk_Integer(__cil_ap_old_group_pos);
//arg[8] = Pl_Mk_Integer(arc);
//arg[9] = Pl_Mk_Integer(perm);
//
//      //routine code, reserve a place for return value
//      arg[10] = Pl_Mk_Variable();
//
//      //partial routine code, 2 is not routine. (number of arguments) + 1
//        res = Pl_Query_Call(func, 11, arg);          // insert (variable+return value)
//
//      //get return value, partial routine code, 1 is not routine
//        return_value = Pl_Rd_Integer(arg[10]);        // insert ()
//
//      //routine code
//        Pl_Query_End(PL_KEEP_FOR_PROLOG);
//
//      //routine code
//        return 0;
//        }
      
   int babel_wrapper_sort_basket_cil_lr_1_cil_lr_1(cost_t * __cil_ap_cut, long * __cil_ap_l)                           // function name insert
      {
        // wrapper for function sort_basket_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sort_basket_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_cut);
arg[1] = Pl_Mk_Integer(__cil_ap_l);
arg[2] = Pl_Mk_Integer(perm);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sort_basket_cil_lr_1_cil_lr_2(cost_t * __cil_ap_cut, long * __cil_ap_r)                           // function name insert
      {
        // wrapper for function sort_basket_cil_lr_1_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sort_basket_cil_lr_1_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_cut);
arg[1] = Pl_Mk_Integer(__cil_ap_r);
arg[2] = Pl_Mk_Integer(perm);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_primal_bea_mpp_cil_lr_1(long * __cil_ap_m, arc_t ** __cil_ap_arcs, arc_t ** __cil_ap_stop_arcs, cost_t ** __cil_ap_red_cost_of_bea, long  i)                           // function name insert
      {
        // wrapper for function primal_bea_mpp_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("primal_bea_mpp_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_m);
arg[1] = Pl_Mk_Integer(__cil_ap_arcs);
arg[2] = Pl_Mk_Integer(__cil_ap_stop_arcs);
arg[3] = Pl_Mk_Integer(__cil_ap_red_cost_of_bea);
arg[4] = Pl_Mk_Integer(i);
arg[5] = Pl_Mk_Integer(perm);
arg[6] = Pl_Mk_Integer(basket);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_primal_bea_mpp_cil_lr_2(long * __cil_gp_basket_size, long * __cil_ap_nr_group, long * __cil_ap_group_pos, arc_t ** __cil_ap_arcs, arc_t ** __cil_ap_stop_arcs, cost_t ** __cil_ap_red_cost_of_bea, long * __cil_ap_next, long  i, int  cond)                           // function name insert
      {
        // wrapper for function primal_bea_mpp_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[11];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("primal_bea_mpp_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_gp_basket_size);
arg[1] = Pl_Mk_Integer(__cil_ap_nr_group);
arg[2] = Pl_Mk_Integer(__cil_ap_group_pos);
arg[3] = Pl_Mk_Integer(__cil_ap_arcs);
arg[4] = Pl_Mk_Integer(__cil_ap_stop_arcs);
arg[5] = Pl_Mk_Integer(__cil_ap_red_cost_of_bea);
arg[6] = Pl_Mk_Integer(__cil_ap_next);
arg[7] = Pl_Mk_Integer(i);
arg[8] = Pl_Mk_Integer(cond);
arg[9] = Pl_Mk_Integer(perm);

      //routine code, reserve a place for return value
      arg[10] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 11, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[10]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_primal_bea_mpp_cil_lr_3(long * __cil_pp_basket_size, long * __cil_pp_nr_group, long * __cil_pp_group_pos, arc_t ** __cil_pp_arcs, arc_t ** __cil_pp_stop_arcs, long * __cil_pp_old_group_pos, long * __cil_gp_group_pos, long * __cil_gp_nr_group, long * __cil_gp_basket_size, arc_t ** __cil_fp_arcs, arc_t ** __cil_fp_stop_arcs, long * __cil_fp_old_group_pos, long * __cil_ap_basket_size, cost_t ** __cil_ap_red_cost_of_bea, arc_t * arcs, arc_t * stop_arcs, long  old_group_pos)                           // function name insert
      {
        // wrapper for function primal_bea_mpp_cil_lr_3        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[18];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("primal_bea_mpp_cil_lr_3"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_basket_size);
arg[1] = Pl_Mk_Integer(__cil_pp_nr_group);
arg[2] = Pl_Mk_Integer(__cil_pp_group_pos);
arg[3] = Pl_Mk_Integer(__cil_pp_arcs);
arg[4] = Pl_Mk_Integer(__cil_pp_stop_arcs);
arg[5] = Pl_Mk_Integer(__cil_pp_old_group_pos);
arg[6] = Pl_Mk_Integer(__cil_gp_group_pos);
arg[7] = Pl_Mk_Integer(__cil_gp_nr_group);
arg[8] = Pl_Mk_Integer(__cil_gp_basket_size);
arg[9] = Pl_Mk_Integer(__cil_fp_arcs);
arg[10] = Pl_Mk_Integer(__cil_fp_stop_arcs);
arg[11] = Pl_Mk_Integer(__cil_fp_old_group_pos);
arg[12] = Pl_Mk_Integer(__cil_ap_basket_size);
arg[13] = Pl_Mk_Integer(__cil_ap_red_cost_of_bea);
arg[14] = Pl_Mk_Integer(arcs);
arg[15] = Pl_Mk_Integer(stop_arcs);
arg[16] = Pl_Mk_Integer(old_group_pos);

      //routine code, reserve a place for return value
      arg[17] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 18, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[17]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sort_basket_cil_lr_1(cost_t * __cil_pp_cut, cost_t * __cil_fp_cut, long * __cil_ap_min, long * __cil_ap_max, long * __cil_ap_l, long * __cil_ap_r, cost_t  cut)                           // function name insert
      {
        // wrapper for function sort_basket_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[9];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sort_basket_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_cut);
arg[1] = Pl_Mk_Integer(__cil_fp_cut);
arg[2] = Pl_Mk_Integer(__cil_ap_min);
arg[3] = Pl_Mk_Integer(__cil_ap_max);
arg[4] = Pl_Mk_Integer(__cil_ap_l);
arg[5] = Pl_Mk_Integer(__cil_ap_r);
arg[6] = Pl_Mk_Integer(cut);
arg[7] = Pl_Mk_Integer(perm);

      //routine code, reserve a place for return value
      arg[8] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 9, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[8]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 34 "pbeampp.c"
int bea_is_dual_infeasible(arc_t *arc , cost_t red_cost ) 
{ 
  int tmp ;

  {
#line 41
  if (red_cost < 0L) {
#line 41
    if (arc->ident == 1) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: 
#line 41
  if (red_cost > 0L) {
#line 41
    if (arc->ident == 2) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return (tmp);
}
}
#line 65 "pbeampp.c"
void sort_basket(long min , long max ) 
{ 
  long l ;
  long r ;
  long *__cil_pp_min ;
  long *__cil_pp_max ;
  long *__cil_pp_l ;
  long *__cil_pp_r ;
  long *__cil_fp_min ;
  long *__cil_fp_max ;
  long *__cil_fp_l ;
  long *__cil_fp_r ;
  long l_ssa_1 ;
  long r_ssa_1 ;
  cost_t cut_ssa_1 ;
  long min_ssa_1 ;
  long max_ssa_1 ;
  long l_ssa_2 ;
  long r_ssa_2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long __cil_tmp25 ;
  long __cil_tmp26 ;
  BASKET **__cil_tmp27 ;
  BASKET *__cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  cost_t *__cil_tmp31 ;

  {
#line 69
  __cil_fp_r = & r;
#line 69
  __cil_fp_l = & l;
#line 69
  __cil_fp_max = & max;
#line 69
  __cil_fp_min = & min;
#line 69
  __cil_pp_r = & r;
#line 69
  __cil_pp_l = & l;
#line 69
  __cil_pp_max = & max;
#line 69
  __cil_pp_min = & min;
#line 69
  return babel_wrapper_sort_basket(__cil_pp_min, __cil_pp_max, __cil_pp_l, __cil_pp_r,
                                   __cil_fp_min, __cil_fp_max, __cil_fp_l, __cil_fp_r,
                                   min, max);
#line 69
  __cil_pp_min = & min;
#line 70
  __cil_pp_max = & max;
#line 71
  __cil_pp_l = & l;
#line 72
  __cil_pp_r = & r;
#line 73
  __cil_fp_min = & min;
#line 74
  __cil_fp_max = & max;
#line 75
  __cil_fp_l = & l;
#line 76
  __cil_fp_r = & r;
#line 75
  l_ssa_1 = min;
#line 75
  r_ssa_1 = max;
#line 77
  __cil_tmp25 = l_ssa_1 + r_ssa_1;
#line 77
  __cil_tmp26 = __cil_tmp25 / 2L;
#line 77
  __cil_tmp27 = perm + __cil_tmp26;
#line 77
  __cil_tmp28 = *__cil_tmp27;
#line 77
  __cil_tmp29 = (unsigned char *)__cil_tmp28;
#line 77
  __cil_tmp30 = __cil_tmp29 + 16;
#line 77
  __cil_tmp31 = (cost_t *)__cil_tmp30;
#line 77
  cut_ssa_1 = *__cil_tmp31;
#line 80
  *__cil_fp_min = min;
#line 81
  *__cil_fp_max = max;
#line 82
  *__cil_fp_l = l_ssa_1;
#line 83
  *__cil_fp_r = r_ssa_1;
#line 79
  sort_basket_cil_lr_1(__cil_pp_min, __cil_pp_max, __cil_pp_l, __cil_pp_r, cut_ssa_1);
#line 80
  min_ssa_1 = *__cil_fp_min;
#line 81
  max_ssa_1 = *__cil_fp_max;
#line 82
  l_ssa_2 = *__cil_fp_l;
#line 83
  r_ssa_2 = *__cil_fp_r;
#line 100
  __cil_tmp22 = min_ssa_1 < r_ssa_2;
#line 100
  if (__cil_tmp22 != 0) {
#line 101
    sort_basket(min_ssa_1, r_ssa_2);
  } else {

  }
#line 102
  __cil_tmp23 = l_ssa_2 < max_ssa_1;
#line 102
  if (__cil_tmp23 != 0) {
#line 102
    __cil_tmp24 = l_ssa_2 <= 50L;
#line 102
    if (__cil_tmp24 != 0) {
#line 103
      sort_basket(l_ssa_2, max_ssa_1);
    } else {

    }
  } else {

  }
#line 104
  return;
}
}
#line 119 "pbeampp.c"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) 
{ 
  long next ;
  long *__cil_pp_m ;
  arc_t **__cil_pp_arcs ;
  arc_t **__cil_pp_stop_arcs ;
  cost_t **__cil_pp_red_cost_of_bea ;
  long *__cil_pp_nr_group ;
  long *__cil_pp_group_pos ;
  long *__cil_pp_next ;
  long *__cil_pp_basket_size ;
  long *__cil_gp_initialize ;
  long *__cil_gp_nr_group ;
  long *__cil_gp_group_pos ;
  long *__cil_gp_basket_size ;
  long *__cil_fp_m ;
  arc_t **__cil_fp_arcs ;
  arc_t **__cil_fp_stop_arcs ;
  cost_t **__cil_fp_red_cost_of_bea ;
  long *__cil_fp_next ;
  int cond_ssa_1 ;
  long i_ssa_1 ;
  long m_ssa_1 ;
  arc_t *arcs_ssa_1 ;
  arc_t *stop_arcs_ssa_1 ;
  cost_t *red_cost_of_bea_ssa_1 ;
  int tmp_ssa_1 ;
  int cond_ssa_2 ;
  long next_ssa_1 ;
  long next_ssa_2 ;
  long old_group_pos_ssa_1 ;
  cost_t *red_cost_of_bea_ssa_2 ;
  long __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  arc_t *__cil_tmp48 ;
  long __cil_tmp49 ;
  long __cil_tmp50 ;
  long __cil_tmp51 ;
  long __cil_tmp52 ;
  long __cil_tmp53 ;
  BASKET **__cil_tmp54 ;
  BASKET *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  unsigned char *__cil_tmp57 ;
  cost_t *__cil_tmp58 ;
  BASKET **__cil_tmp59 ;
  BASKET *__cil_tmp60 ;
  arc_t **__cil_tmp61 ;

  {
#line 122
  __cil_fp_next = & next;
#line 122
  __cil_fp_red_cost_of_bea = & red_cost_of_bea;
#line 122
  __cil_fp_stop_arcs = & stop_arcs;
#line 122
  __cil_fp_arcs = & arcs;
#line 122
  __cil_fp_m = & m;
#line 122
  __cil_gp_basket_size = & basket_size;
#line 122
  __cil_gp_group_pos = & group_pos;
#line 122
  __cil_gp_nr_group = & nr_group;
#line 122
  __cil_gp_initialize = & initialize;
#line 122
  __cil_pp_basket_size = & basket_size;
#line 122
  __cil_pp_next = & next;
#line 122
  __cil_pp_group_pos = & group_pos;
#line 122
  __cil_pp_nr_group = & nr_group;
#line 122
  __cil_pp_red_cost_of_bea = & red_cost_of_bea;
#line 122
  __cil_pp_stop_arcs = & stop_arcs;
#line 122
  __cil_pp_arcs = & arcs;
#line 122
  __cil_pp_m = & m;
#line 122
 // return babel_wrapper_primal_bea_mpp(__cil_pp_m, __cil_pp_arcs, __cil_pp_stop_arcs,
 //                                     __cil_pp_red_cost_of_bea, __cil_pp_nr_group,
 //                                     __cil_pp_group_pos, __cil_pp_next, __cil_pp_basket_size,
 //                                     __cil_gp_initialize, __cil_gp_nr_group, __cil_gp_group_pos,
 //                                     __cil_gp_basket_size, __cil_fp_m, __cil_fp_arcs,
 //                                     __cil_fp_stop_arcs, __cil_fp_red_cost_of_bea,
 //                                     __cil_fp_next, m, arcs, stop_arcs, red_cost_of_bea);
#line 122
  __cil_pp_m = & m;
#line 123
  __cil_pp_arcs = & arcs;
#line 124
  __cil_pp_stop_arcs = & stop_arcs;
#line 125
  __cil_pp_red_cost_of_bea = & red_cost_of_bea;
#line 126
  __cil_pp_nr_group = & nr_group;
#line 127
  __cil_pp_group_pos = & group_pos;
#line 128
  __cil_pp_next = & next;
#line 129
  __cil_pp_basket_size = & basket_size;
#line 130
  __cil_gp_initialize = & initialize;
#line 131
  __cil_gp_nr_group = & nr_group;
#line 132
  __cil_gp_group_pos = & group_pos;
#line 133
  __cil_gp_basket_size = & basket_size;
#line 134
  __cil_fp_m = & m;
#line 135
  __cil_fp_arcs = & arcs;
#line 136
  __cil_fp_stop_arcs = & stop_arcs;
#line 137
  __cil_fp_red_cost_of_bea = & red_cost_of_bea;
#line 138
  __cil_fp_next = & next;
#line 125
  cond_ssa_1 = 0;
#line 127
  __cil_tmp44 = *__cil_gp_initialize;
#line 127
  if (__cil_tmp44 != 0) {
#line 129
    i_ssa_1 = 1L;
#line 132
    *__cil_fp_m = m;
#line 133
    *__cil_fp_arcs = arcs;
#line 134
    *__cil_fp_stop_arcs = stop_arcs;
#line 135
    *__cil_fp_red_cost_of_bea = red_cost_of_bea;
#line 129
    primal_bea_mpp_cil_lr_1(__cil_pp_m, __cil_pp_arcs, __cil_pp_stop_arcs, __cil_pp_red_cost_of_bea,
                            i_ssa_1);
#line 131
    m_ssa_1 = *__cil_fp_m;
#line 132
    arcs_ssa_1 = *__cil_fp_arcs;
#line 133
    stop_arcs_ssa_1 = *__cil_fp_stop_arcs;
#line 134
    red_cost_of_bea_ssa_1 = *__cil_fp_red_cost_of_bea;
#line 131
    __cil_tmp49 = m_ssa_1 - 1L;
#line 131
    __cil_tmp50 = __cil_tmp49 / 300L;
#line 131
    *__cil_gp_nr_group = __cil_tmp50 + 1L;
#line 132
    *__cil_gp_group_pos = 0L;
#line 133
    *__cil_gp_basket_size = 0L;
#line 134
    *__cil_gp_initialize = 0L;
  } else {
#line 138
    i_ssa_1 = 2L;
#line 139
    __cil_tmp45 = i_ssa_1 <= 50L;
#line 139
    if (__cil_tmp45 != 0) {
#line 139
      __cil_tmp51 = *__cil_gp_basket_size;
#line 139
      __cil_tmp46 = i_ssa_1 <= __cil_tmp51;
#line 139
      if (__cil_tmp46 != 0) {
#line 139
        tmp_ssa_1 = 1;
      } else {
#line 139
        tmp_ssa_1 = 0;
      }
    } else {
#line 139
      tmp_ssa_1 = 0;
    }
#line 139
    cond_ssa_2 = tmp_ssa_1;
#line 140
    next_ssa_1 = 0L;
#line 143
    *__cil_fp_arcs = arcs;
#line 144
    *__cil_fp_stop_arcs = stop_arcs;
#line 145
    *__cil_fp_red_cost_of_bea = red_cost_of_bea;
#line 146
    *__cil_fp_next = next_ssa_1;
#line 140
    primal_bea_mpp_cil_lr_2(__cil_pp_nr_group, __cil_pp_group_pos, __cil_pp_arcs,
                            __cil_pp_stop_arcs, __cil_pp_red_cost_of_bea, __cil_pp_next,
                            i_ssa_1, cond_ssa_2);
#line 143
    arcs_ssa_1 = *__cil_fp_arcs;
#line 144
    stop_arcs_ssa_1 = *__cil_fp_stop_arcs;
#line 145
    red_cost_of_bea_ssa_1 = *__cil_fp_red_cost_of_bea;
#line 146
    next_ssa_2 = *__cil_fp_next;
#line 181
    *__cil_gp_basket_size = next_ssa_2;
  }
#line 184
  old_group_pos_ssa_1 = *__cil_gp_group_pos;
#line 187
  *__cil_fp_red_cost_of_bea = red_cost_of_bea_ssa_1;
#line 186
  primal_bea_mpp_cil_lr_3(__cil_pp_basket_size, __cil_pp_red_cost_of_bea, arcs_ssa_1,
                          stop_arcs_ssa_1, old_group_pos_ssa_1);
#line 188
  red_cost_of_bea_ssa_2 = *__cil_fp_red_cost_of_bea;
#line 213
  __cil_tmp52 = *__cil_gp_basket_size;
#line 213
  __cil_tmp47 = __cil_tmp52 == 0L;
#line 213
  if (__cil_tmp47 != 0) {
#line 215
    *__cil_gp_initialize = 1L;
#line 216
    *red_cost_of_bea_ssa_2 = (cost_t )0;
#line 217
    return ((arc_t *)0);
  } else {
#line 219
    __cil_tmp53 = *__cil_gp_basket_size;
#line 219
    sort_basket(1L, __cil_tmp53);
#line 220
    __cil_tmp54 = perm + 1;
#line 220
    __cil_tmp55 = *__cil_tmp54;
#line 220
    __cil_tmp56 = (unsigned char *)__cil_tmp55;
#line 220
    __cil_tmp57 = __cil_tmp56 + 8;
#line 220
    __cil_tmp58 = (cost_t *)__cil_tmp57;
#line 220
    *red_cost_of_bea_ssa_2 = *__cil_tmp58;
#line 221
    __cil_tmp59 = perm + 1;
#line 221
    __cil_tmp60 = *__cil_tmp59;
#line 221
    __cil_tmp61 = (arc_t **)__cil_tmp60;
#line 221
    __cil_tmp48 = *__cil_tmp61;
#line 221
    return (__cil_tmp48);
  }
}
}
#line 227 "pbeampp.c"
void primal_bea_mpp_cil_lr_3_cil_lr_1(long *__cil_ap_basket_size , long *__cil_ap_nr_group ,
                                      long *__cil_ap_group_pos , arc_t **__cil_ap_arcs ,
                                      arc_t **__cil_ap_stop_arcs , long *__cil_ap_old_group_pos ,
                                      arc_t *arc ) 
{ 
  long *__cil_gp_basket_size ;
  long *__cil_gp_nr_group ;
  cost_t red_cost_ssa_1 ;
  int tmp___1_ssa_1 ;
  arc_t *arc_ssa_1 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  arc_t *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int *__cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  node_p *__cil_tmp24 ;
  node_p __cil_tmp25 ;
  cost_t *__cil_tmp26 ;
  cost_t __cil_tmp27 ;
  cost_t __cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  node_p *__cil_tmp30 ;
  node_p __cil_tmp31 ;
  cost_t *__cil_tmp32 ;
  cost_t __cil_tmp33 ;
  cost_t __cil_tmp34 ;
  long __cil_tmp35 ;
  long __cil_tmp36 ;
  BASKET **__cil_tmp37 ;
  BASKET *__cil_tmp38 ;
  arc_t **__cil_tmp39 ;
  long __cil_tmp40 ;
  BASKET **__cil_tmp41 ;
  BASKET *__cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  cost_t *__cil_tmp45 ;
  long __cil_tmp46 ;
  BASKET **__cil_tmp47 ;
  BASKET *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  cost_t *__cil_tmp51 ;
  long __cil_tmp52 ;
  BASKET **__cil_tmp53 ;
  BASKET *__cil_tmp54 ;
  unsigned char *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  cost_t *__cil_tmp57 ;
  long __cil_tmp58 ;
  cost_t *mem_58 ;

  {
#line 232
  __cil_gp_nr_group = & nr_group;
#line 232
  __cil_gp_basket_size = & basket_size;
#line 232
 // return babel_wrapper_primal_bea_mpp_cil_lr_3_cil_lr_1(__cil_gp_basket_size, __cil_gp_nr_group,
 //                                                       __cil_ap_basket_size, __cil_ap_nr_group,
 //                                                       __cil_ap_group_pos, __cil_ap_arcs,
 //                                                       __cil_ap_stop_arcs, __cil_ap_old_group_pos,
 //                                                       arc);
#line 232
  __cil_gp_basket_size = & basket_size;
#line 233
  __cil_gp_nr_group = & nr_group;
#line 190
  __cil_tmp18 = *__cil_ap_stop_arcs;
#line 190
  __cil_tmp19 = (unsigned long )__cil_tmp18;
#line 190
  __cil_tmp15 = (unsigned long )arc < __cil_tmp19;
#line 190
  if (__cil_tmp15 != 0) {
#line 192
    __cil_tmp20 = (unsigned char *)arc + 24;
#line 192
    __cil_tmp21 = (int *)__cil_tmp20;
#line 192
    __cil_tmp22 = *__cil_tmp21;
#line 192
    __cil_tmp16 = __cil_tmp22 > 0;
#line 192
    if (__cil_tmp16 != 0) {
#line 195
      __cil_tmp23 = (unsigned char *)arc + 8;
#line 195
      __cil_tmp24 = (node_p *)__cil_tmp23;
#line 195
      __cil_tmp25 = *__cil_tmp24;
#line 195
      __cil_tmp26 = (cost_t *)__cil_tmp25;
#line 195
      mem_58 = (cost_t *)arc;
#line 195
      __cil_tmp27 = *mem_58;
#line 195
      __cil_tmp28 = *__cil_tmp26;
#line 195
      __cil_tmp29 = (unsigned char *)arc + 16;
#line 195
      __cil_tmp30 = (node_p *)__cil_tmp29;
#line 195
      __cil_tmp31 = *__cil_tmp30;
#line 195
      __cil_tmp32 = (cost_t *)__cil_tmp31;
#line 195
      __cil_tmp33 = __cil_tmp27 - __cil_tmp28;
#line 195
      __cil_tmp34 = *__cil_tmp32;
#line 195
      red_cost_ssa_1 = __cil_tmp33 + __cil_tmp34;
#line 196
      tmp___1_ssa_1 = bea_is_dual_infeasible(arc, red_cost_ssa_1);
#line 196
      if (tmp___1_ssa_1 != 0) {
#line 198
        __cil_tmp35 = *__cil_gp_basket_size;
#line 198
        *__cil_gp_basket_size = __cil_tmp35 + 1L;
#line 199
        __cil_tmp36 = *__cil_gp_basket_size;
#line 199
        __cil_tmp37 = perm + __cil_tmp36;
#line 199
        __cil_tmp38 = *__cil_tmp37;
#line 199
        __cil_tmp39 = (arc_t **)__cil_tmp38;
#line 199
        *__cil_tmp39 = arc;
#line 200
        __cil_tmp40 = *__cil_gp_basket_size;
#line 200
        __cil_tmp41 = perm + __cil_tmp40;
#line 200
        __cil_tmp42 = *__cil_tmp41;
#line 200
        __cil_tmp43 = (unsigned char *)__cil_tmp42;
#line 200
        __cil_tmp44 = __cil_tmp43 + 8;
#line 200
        __cil_tmp45 = (cost_t *)__cil_tmp44;
#line 200
        *__cil_tmp45 = red_cost_ssa_1;
#line 201
        __cil_tmp17 = red_cost_ssa_1 >= 0L;
#line 201
        if (__cil_tmp17 != 0) {
#line 201
          __cil_tmp46 = *__cil_gp_basket_size;
#line 201
          __cil_tmp47 = perm + __cil_tmp46;
#line 201
          __cil_tmp48 = *__cil_tmp47;
#line 201
          __cil_tmp49 = (unsigned char *)__cil_tmp48;
#line 201
          __cil_tmp50 = __cil_tmp49 + 16;
#line 201
          __cil_tmp51 = (cost_t *)__cil_tmp50;
#line 201
          *__cil_tmp51 = red_cost_ssa_1;
        } else {
#line 201
          __cil_tmp52 = *__cil_gp_basket_size;
#line 201
          __cil_tmp53 = perm + __cil_tmp52;
#line 201
          __cil_tmp54 = *__cil_tmp53;
#line 201
          __cil_tmp55 = (unsigned char *)__cil_tmp54;
#line 201
          __cil_tmp56 = __cil_tmp55 + 16;
#line 201
          __cil_tmp57 = (cost_t *)__cil_tmp56;
#line 201
          *__cil_tmp57 = - red_cost_ssa_1;
        }
      } else {

      }
    } else {

    }
#line 190
    __cil_tmp58 = *__cil_gp_nr_group;
#line 190
    arc_ssa_1 = arc + __cil_tmp58;
#line 193
    primal_bea_mpp_cil_lr_3_cil_lr_1(__cil_ap_basket_size, __cil_ap_nr_group, __cil_ap_group_pos,
                                     __cil_ap_arcs, __cil_ap_stop_arcs, __cil_ap_old_group_pos,
                                     arc_ssa_1);
#line 197
    return;
  } else {
#line 199
    return;
  }
}
}
#line 204 "pbeampp.c"
void sort_basket_cil_lr_1_cil_lr_1(cost_t *__cil_ap_cut , long *__cil_ap_l ) 
{ 
  int __cil_tmp3 ;
  long __cil_tmp4 ;
  BASKET **__cil_tmp5 ;
  BASKET *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  cost_t *__cil_tmp9 ;
  cost_t __cil_tmp10 ;
  cost_t __cil_tmp11 ;
  long __cil_tmp12 ;

  {

#line 81
  return babel_wrapper_sort_basket_cil_lr_1_cil_lr_1(__cil_ap_cut, __cil_ap_l);
#line 81
  __cil_tmp4 = *__cil_ap_l;
#line 81
  __cil_tmp5 = perm + __cil_tmp4;
#line 81
  __cil_tmp6 = *__cil_tmp5;
#line 81
  __cil_tmp7 = (unsigned char *)__cil_tmp6;
#line 81
  __cil_tmp8 = __cil_tmp7 + 16;
#line 81
  __cil_tmp9 = (cost_t *)__cil_tmp8;
#line 81
  __cil_tmp10 = *__cil_tmp9;
#line 81
  __cil_tmp11 = *__cil_ap_cut;
#line 81
  __cil_tmp3 = __cil_tmp10 > __cil_tmp11;
#line 81
  if (__cil_tmp3 != 0) {
#line 82
    __cil_tmp12 = *__cil_ap_l;
#line 82
    *__cil_ap_l = __cil_tmp12 + 1L;
#line 85
    sort_basket_cil_lr_1_cil_lr_1(__cil_ap_cut, __cil_ap_l);
#line 87
    return;
  } else {
#line 89
    return;
  }
}
}
#line 94 "pbeampp.c"
void sort_basket_cil_lr_1_cil_lr_2(cost_t *__cil_ap_cut , long *__cil_ap_r ) 
{ 
  int __cil_tmp3 ;
  long __cil_tmp4 ;
  BASKET **__cil_tmp5 ;
  BASKET *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  cost_t *__cil_tmp9 ;
  cost_t __cil_tmp10 ;
  cost_t __cil_tmp11 ;
  long __cil_tmp12 ;

  {

#line 83
  return babel_wrapper_sort_basket_cil_lr_1_cil_lr_2(__cil_ap_cut, __cil_ap_r);
#line 83
  __cil_tmp4 = *__cil_ap_r;
#line 83
  __cil_tmp5 = perm + __cil_tmp4;
#line 83
  __cil_tmp6 = *__cil_tmp5;
#line 83
  __cil_tmp7 = (unsigned char *)__cil_tmp6;
#line 83
  __cil_tmp8 = __cil_tmp7 + 16;
#line 83
  __cil_tmp9 = (cost_t *)__cil_tmp8;
#line 83
  __cil_tmp10 = *__cil_ap_cut;
#line 83
  __cil_tmp11 = *__cil_tmp9;
#line 83
  __cil_tmp3 = __cil_tmp10 > __cil_tmp11;
#line 83
  if (__cil_tmp3 != 0) {
#line 84
    __cil_tmp12 = *__cil_ap_r;
#line 84
    *__cil_ap_r = __cil_tmp12 - 1L;
#line 87
    sort_basket_cil_lr_1_cil_lr_2(__cil_ap_cut, __cil_ap_r);
#line 89
    return;
  } else {
#line 91
    return;
  }
}
}
#line 96 "pbeampp.c"
void primal_bea_mpp_cil_lr_1(long *__cil_ap_m , arc_t **__cil_ap_arcs , arc_t **__cil_ap_stop_arcs ,
                             cost_t **__cil_ap_red_cost_of_bea , long i ) 
{ 
  long i_ssa_1 ;
  int __cil_tmp7 ;
  BASKET **__cil_tmp8 ;

  {

#line 129
 // return babel_wrapper_primal_bea_mpp_cil_lr_1(__cil_ap_m, __cil_ap_arcs, __cil_ap_stop_arcs,
 //                                              __cil_ap_red_cost_of_bea, i);
#line 129
  __cil_tmp7 = i < 351L;
#line 129
  if (__cil_tmp7 != 0) {
#line 130
    __cil_tmp8 = perm + i;
#line 130
    *__cil_tmp8 = basket + i;
#line 129
    i_ssa_1 = i + 1L;
#line 132
    primal_bea_mpp_cil_lr_1(__cil_ap_m, __cil_ap_arcs, __cil_ap_stop_arcs, __cil_ap_red_cost_of_bea,
                            i_ssa_1);
#line 135
    return;
  } else {
#line 137
    return;
  }
}
}
#line 142 "pbeampp.c"
void primal_bea_mpp_cil_lr_2(long *__cil_ap_nr_group , long *__cil_ap_group_pos ,
                             arc_t **__cil_ap_arcs , arc_t **__cil_ap_stop_arcs ,
                             cost_t **__cil_ap_red_cost_of_bea , long *__cil_ap_next ,
                             long i , int cond ) 
{ 
  long *__cil_gp_basket_size ;
  arc_t *arc_ssa_1 ;
  cost_t red_cost_ssa_1 ;
  long i_ssa_1 ;
  int tmp___0_ssa_1 ;
  int cond_ssa_1 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  BASKET **__cil_tmp31 ;
  BASKET *__cil_tmp32 ;
  arc_t **__cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  node_p *__cil_tmp35 ;
  node_p __cil_tmp36 ;
  cost_t *__cil_tmp37 ;
  cost_t __cil_tmp38 ;
  cost_t __cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  node_p *__cil_tmp41 ;
  node_p __cil_tmp42 ;
  cost_t *__cil_tmp43 ;
  cost_t __cil_tmp44 ;
  cost_t __cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  int *__cil_tmp47 ;
  int __cil_tmp48 ;
  long __cil_tmp49 ;
  long __cil_tmp50 ;
  BASKET **__cil_tmp51 ;
  BASKET *__cil_tmp52 ;
  arc_t **__cil_tmp53 ;
  long __cil_tmp54 ;
  BASKET **__cil_tmp55 ;
  BASKET *__cil_tmp56 ;
  unsigned char *__cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  cost_t *__cil_tmp59 ;
  long __cil_tmp60 ;
  BASKET **__cil_tmp61 ;
  BASKET *__cil_tmp62 ;
  unsigned char *__cil_tmp63 ;
  unsigned char *__cil_tmp64 ;
  cost_t *__cil_tmp65 ;
  long __cil_tmp66 ;
  BASKET **__cil_tmp67 ;
  BASKET *__cil_tmp68 ;
  unsigned char *__cil_tmp69 ;
  unsigned char *__cil_tmp70 ;
  cost_t *__cil_tmp71 ;
  unsigned char *__cil_tmp72 ;
  int *__cil_tmp73 ;
  int __cil_tmp74 ;
  long __cil_tmp75 ;
  long __cil_tmp76 ;
  BASKET **__cil_tmp77 ;
  BASKET *__cil_tmp78 ;
  arc_t **__cil_tmp79 ;
  long __cil_tmp80 ;
  BASKET **__cil_tmp81 ;
  BASKET *__cil_tmp82 ;
  unsigned char *__cil_tmp83 ;
  unsigned char *__cil_tmp84 ;
  cost_t *__cil_tmp85 ;
  long __cil_tmp86 ;
  BASKET **__cil_tmp87 ;
  BASKET *__cil_tmp88 ;
  unsigned char *__cil_tmp89 ;
  unsigned char *__cil_tmp90 ;
  cost_t *__cil_tmp91 ;
  long __cil_tmp92 ;
  BASKET **__cil_tmp93 ;
  BASKET *__cil_tmp94 ;
  unsigned char *__cil_tmp95 ;
  unsigned char *__cil_tmp96 ;
  cost_t *__cil_tmp97 ;
  unsigned char *__cil_tmp98 ;
  int *__cil_tmp99 ;
  int __cil_tmp100 ;
  long __cil_tmp101 ;
  long __cil_tmp102 ;
  BASKET **__cil_tmp103 ;
  BASKET *__cil_tmp104 ;
  arc_t **__cil_tmp105 ;
  long __cil_tmp106 ;
  BASKET **__cil_tmp107 ;
  BASKET *__cil_tmp108 ;
  unsigned char *__cil_tmp109 ;
  unsigned char *__cil_tmp110 ;
  cost_t *__cil_tmp111 ;
  long __cil_tmp112 ;
  BASKET **__cil_tmp113 ;
  BASKET *__cil_tmp114 ;
  unsigned char *__cil_tmp115 ;
  unsigned char *__cil_tmp116 ;
  cost_t *__cil_tmp117 ;
  long __cil_tmp118 ;
  BASKET **__cil_tmp119 ;
  BASKET *__cil_tmp120 ;
  unsigned char *__cil_tmp121 ;
  unsigned char *__cil_tmp122 ;
  cost_t *__cil_tmp123 ;
  long __cil_tmp124 ;
  cost_t *mem_123 ;

  {
#line 147
  __cil_gp_basket_size = & basket_size;
#line 147
 // return babel_wrapper_primal_bea_mpp_cil_lr_2(__cil_gp_basket_size, __cil_ap_nr_group,
 //                                              __cil_ap_group_pos, __cil_ap_arcs,
 //                                              __cil_ap_stop_arcs, __cil_ap_red_cost_of_bea,
 //                                              __cil_ap_next, i, cond);
#line 147
  __cil_gp_basket_size = & basket_size;
#line 140
  if (cond != 0) {
#line 142
    __cil_tmp31 = perm + i;
#line 142
    __cil_tmp32 = *__cil_tmp31;
#line 142
    __cil_tmp33 = (arc_t **)__cil_tmp32;
#line 142
    arc_ssa_1 = *__cil_tmp33;
#line 143
    __cil_tmp34 = (unsigned char *)arc_ssa_1 + 8;
#line 143
    __cil_tmp35 = (node_p *)__cil_tmp34;
#line 143
    __cil_tmp36 = *__cil_tmp35;
#line 143
    __cil_tmp37 = (cost_t *)__cil_tmp36;
#line 143
    mem_123 = (cost_t *)arc_ssa_1;
#line 143
    __cil_tmp38 = *mem_123;
#line 143
    __cil_tmp39 = *__cil_tmp37;
#line 143
    __cil_tmp40 = (unsigned char *)arc_ssa_1 + 16;
#line 143
    __cil_tmp41 = (node_p *)__cil_tmp40;
#line 143
    __cil_tmp42 = *__cil_tmp41;
#line 143
    __cil_tmp43 = (cost_t *)__cil_tmp42;
#line 143
    __cil_tmp44 = __cil_tmp38 - __cil_tmp39;
#line 143
    __cil_tmp45 = *__cil_tmp43;
#line 143
    red_cost_ssa_1 = __cil_tmp44 + __cil_tmp45;
#line 144
    __cil_tmp18 = red_cost_ssa_1 < 0L;
#line 144
    if (__cil_tmp18 != 0) {
#line 146
      __cil_tmp46 = (unsigned char *)arc_ssa_1 + 24;
#line 146
      __cil_tmp47 = (int *)__cil_tmp46;
#line 146
      __cil_tmp48 = *__cil_tmp47;
#line 146
      __cil_tmp19 = __cil_tmp48 == 1;
#line 146
      if (__cil_tmp19 != 0) {
#line 148
        __cil_tmp49 = *__cil_ap_next;
#line 148
        *__cil_ap_next = __cil_tmp49 + 1L;
#line 149
        __cil_tmp50 = *__cil_ap_next;
#line 149
        __cil_tmp51 = perm + __cil_tmp50;
#line 149
        __cil_tmp52 = *__cil_tmp51;
#line 149
        __cil_tmp53 = (arc_t **)__cil_tmp52;
#line 149
        *__cil_tmp53 = arc_ssa_1;
#line 150
        __cil_tmp54 = *__cil_ap_next;
#line 150
        __cil_tmp55 = perm + __cil_tmp54;
#line 150
        __cil_tmp56 = *__cil_tmp55;
#line 150
        __cil_tmp57 = (unsigned char *)__cil_tmp56;
#line 150
        __cil_tmp58 = __cil_tmp57 + 8;
#line 150
        __cil_tmp59 = (cost_t *)__cil_tmp58;
#line 150
        *__cil_tmp59 = red_cost_ssa_1;
#line 151
        __cil_tmp20 = red_cost_ssa_1 >= 0L;
#line 151
        if (__cil_tmp20 != 0) {
#line 151
          __cil_tmp60 = *__cil_ap_next;
#line 151
          __cil_tmp61 = perm + __cil_tmp60;
#line 151
          __cil_tmp62 = *__cil_tmp61;
#line 151
          __cil_tmp63 = (unsigned char *)__cil_tmp62;
#line 151
          __cil_tmp64 = __cil_tmp63 + 16;
#line 151
          __cil_tmp65 = (cost_t *)__cil_tmp64;
#line 151
          *__cil_tmp65 = red_cost_ssa_1;
        } else {
#line 151
          __cil_tmp66 = *__cil_ap_next;
#line 151
          __cil_tmp67 = perm + __cil_tmp66;
#line 151
          __cil_tmp68 = *__cil_tmp67;
#line 151
          __cil_tmp69 = (unsigned char *)__cil_tmp68;
#line 151
          __cil_tmp70 = __cil_tmp69 + 16;
#line 151
          __cil_tmp71 = (cost_t *)__cil_tmp70;
#line 151
          *__cil_tmp71 = - red_cost_ssa_1;
        }
      } else {
#line 155
        __cil_tmp21 = red_cost_ssa_1 > 0L;
#line 155
        if (__cil_tmp21 != 0) {
#line 157
          __cil_tmp72 = (unsigned char *)arc_ssa_1 + 24;
#line 157
          __cil_tmp73 = (int *)__cil_tmp72;
#line 157
          __cil_tmp74 = *__cil_tmp73;
#line 157
          __cil_tmp22 = __cil_tmp74 == 2;
#line 157
          if (__cil_tmp22 != 0) {
#line 158
            __cil_tmp75 = *__cil_ap_next;
#line 158
            *__cil_ap_next = __cil_tmp75 + 1L;
#line 159
            __cil_tmp76 = *__cil_ap_next;
#line 159
            __cil_tmp77 = perm + __cil_tmp76;
#line 159
            __cil_tmp78 = *__cil_tmp77;
#line 159
            __cil_tmp79 = (arc_t **)__cil_tmp78;
#line 159
            *__cil_tmp79 = arc_ssa_1;
#line 160
            __cil_tmp80 = *__cil_ap_next;
#line 160
            __cil_tmp81 = perm + __cil_tmp80;
#line 160
            __cil_tmp82 = *__cil_tmp81;
#line 160
            __cil_tmp83 = (unsigned char *)__cil_tmp82;
#line 160
            __cil_tmp84 = __cil_tmp83 + 8;
#line 160
            __cil_tmp85 = (cost_t *)__cil_tmp84;
#line 160
            *__cil_tmp85 = red_cost_ssa_1;
#line 161
            __cil_tmp23 = red_cost_ssa_1 >= 0L;
#line 161
            if (__cil_tmp23 != 0) {
#line 161
              __cil_tmp86 = *__cil_ap_next;
#line 161
              __cil_tmp87 = perm + __cil_tmp86;
#line 161
              __cil_tmp88 = *__cil_tmp87;
#line 161
              __cil_tmp89 = (unsigned char *)__cil_tmp88;
#line 161
              __cil_tmp90 = __cil_tmp89 + 16;
#line 161
              __cil_tmp91 = (cost_t *)__cil_tmp90;
#line 161
              *__cil_tmp91 = red_cost_ssa_1;
            } else {
#line 161
              __cil_tmp92 = *__cil_ap_next;
#line 161
              __cil_tmp93 = perm + __cil_tmp92;
#line 161
              __cil_tmp94 = *__cil_tmp93;
#line 161
              __cil_tmp95 = (unsigned char *)__cil_tmp94;
#line 161
              __cil_tmp96 = __cil_tmp95 + 16;
#line 161
              __cil_tmp97 = (cost_t *)__cil_tmp96;
#line 161
              *__cil_tmp97 = - red_cost_ssa_1;
            }
          } else {

          }
        } else {

        }
      }
    } else {
#line 168
      __cil_tmp24 = red_cost_ssa_1 > 0L;
#line 168
      if (__cil_tmp24 != 0) {
#line 170
        __cil_tmp98 = (unsigned char *)arc_ssa_1 + 24;
#line 170
        __cil_tmp99 = (int *)__cil_tmp98;
#line 170
        __cil_tmp100 = *__cil_tmp99;
#line 170
        __cil_tmp25 = __cil_tmp100 == 2;
#line 170
        if (__cil_tmp25 != 0) {
#line 171
          __cil_tmp101 = *__cil_ap_next;
#line 171
          *__cil_ap_next = __cil_tmp101 + 1L;
#line 172
          __cil_tmp102 = *__cil_ap_next;
#line 172
          __cil_tmp103 = perm + __cil_tmp102;
#line 172
          __cil_tmp104 = *__cil_tmp103;
#line 172
          __cil_tmp105 = (arc_t **)__cil_tmp104;
#line 172
          *__cil_tmp105 = arc_ssa_1;
#line 173
          __cil_tmp106 = *__cil_ap_next;
#line 173
          __cil_tmp107 = perm + __cil_tmp106;
#line 173
          __cil_tmp108 = *__cil_tmp107;
#line 173
          __cil_tmp109 = (unsigned char *)__cil_tmp108;
#line 173
          __cil_tmp110 = __cil_tmp109 + 8;
#line 173
          __cil_tmp111 = (cost_t *)__cil_tmp110;
#line 173
          *__cil_tmp111 = red_cost_ssa_1;
#line 174
          __cil_tmp26 = red_cost_ssa_1 >= 0L;
#line 174
          if (__cil_tmp26 != 0) {
#line 174
            __cil_tmp112 = *__cil_ap_next;
#line 174
            __cil_tmp113 = perm + __cil_tmp112;
#line 174
            __cil_tmp114 = *__cil_tmp113;
#line 174
            __cil_tmp115 = (unsigned char *)__cil_tmp114;
#line 174
            __cil_tmp116 = __cil_tmp115 + 16;
#line 174
            __cil_tmp117 = (cost_t *)__cil_tmp116;
#line 174
            *__cil_tmp117 = red_cost_ssa_1;
          } else {
#line 174
            __cil_tmp118 = *__cil_ap_next;
#line 174
            __cil_tmp119 = perm + __cil_tmp118;
#line 174
            __cil_tmp120 = *__cil_tmp119;
#line 174
            __cil_tmp121 = (unsigned char *)__cil_tmp120;
#line 174
            __cil_tmp122 = __cil_tmp121 + 16;
#line 174
            __cil_tmp123 = (cost_t *)__cil_tmp122;
#line 174
            *__cil_tmp123 = - red_cost_ssa_1;
          }
        } else {

        }
      } else {

      }
    }
#line 178
    i_ssa_1 = i + 1L;
#line 179
    __cil_tmp27 = i_ssa_1 <= 50L;
#line 179
    if (__cil_tmp27 != 0) {
#line 179
      __cil_tmp124 = *__cil_gp_basket_size;
#line 179
      __cil_tmp28 = i_ssa_1 <= __cil_tmp124;
#line 179
      if (__cil_tmp28 != 0) {
#line 179
        tmp___0_ssa_1 = 1;
      } else {
#line 179
        tmp___0_ssa_1 = 0;
      }
    } else {
#line 179
      tmp___0_ssa_1 = 0;
    }
#line 179
    cond_ssa_1 = tmp___0_ssa_1;
#line 182
    primal_bea_mpp_cil_lr_2(__cil_ap_nr_group, __cil_ap_group_pos, __cil_ap_arcs,
                            __cil_ap_stop_arcs, __cil_ap_red_cost_of_bea, __cil_ap_next,
                            i_ssa_1, cond_ssa_1);
#line 186
    return;
  } else {
#line 188
    return;
  }
}
}
#line 192 "pbeampp.c"
void primal_bea_mpp_cil_lr_3(long *__cil_ap_basket_size , cost_t **__cil_ap_red_cost_of_bea ,
                             arc_t *arcs , arc_t *stop_arcs , long old_group_pos ) 
{ 
  long *__cil_pp_basket_size ;
  long *__cil_pp_nr_group ;
  long *__cil_pp_group_pos ;
  arc_t **__cil_pp_arcs ;
  arc_t **__cil_pp_stop_arcs ;
  long *__cil_pp_old_group_pos ;
  long *__cil_gp_group_pos ;
  long *__cil_gp_nr_group ;
  long *__cil_gp_basket_size ;
  arc_t **__cil_fp_arcs ;
  arc_t **__cil_fp_stop_arcs ;
  long *__cil_fp_old_group_pos ;
  arc_t *arc_ssa_1 ;
  arc_t *arcs_ssa_1 ;
  arc_t *stop_arcs_ssa_1 ;
  long old_group_pos_ssa_1 ;
  int tmp___2_ssa_1 ;
  int cond_ssa_1 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  long __cil_tmp32 ;
  long __cil_tmp33 ;
  long __cil_tmp34 ;
  long __cil_tmp35 ;
  long __cil_tmp36 ;
  long __cil_tmp37 ;

  {
#line 195
  __cil_fp_old_group_pos = & old_group_pos;
#line 195
  __cil_fp_stop_arcs = & stop_arcs;
#line 195
  __cil_fp_arcs = & arcs;
#line 195
  __cil_gp_basket_size = & basket_size;
#line 195
  __cil_gp_nr_group = & nr_group;
#line 195
  __cil_gp_group_pos = & group_pos;
#line 195
  __cil_pp_old_group_pos = & old_group_pos;
#line 195
  __cil_pp_stop_arcs = & stop_arcs;
#line 195
  __cil_pp_arcs = & arcs;
#line 195
  __cil_pp_group_pos = & group_pos;
#line 195
  __cil_pp_nr_group = & nr_group;
#line 195
  __cil_pp_basket_size = & basket_size;
#line 195
 // return babel_wrapper_primal_bea_mpp_cil_lr_3(__cil_pp_basket_size, __cil_pp_nr_group,
 //                                              __cil_pp_group_pos, __cil_pp_arcs,
 //                                              __cil_pp_stop_arcs, __cil_pp_old_group_pos,
 //                                              __cil_gp_group_pos, __cil_gp_nr_group,
 //                                              __cil_gp_basket_size, __cil_fp_arcs,
 //                                              __cil_fp_stop_arcs, __cil_fp_old_group_pos,
 //                                              __cil_ap_basket_size, __cil_ap_red_cost_of_bea,
 //                                              arcs, stop_arcs, old_group_pos);
#line 195
  __cil_pp_basket_size = & basket_size;
#line 196
  __cil_pp_nr_group = & nr_group;
#line 197
  __cil_pp_group_pos = & group_pos;
#line 198
  __cil_pp_arcs = & arcs;
#line 199
  __cil_pp_stop_arcs = & stop_arcs;
#line 200
  __cil_pp_old_group_pos = & old_group_pos;
#line 201
  __cil_gp_group_pos = & group_pos;
#line 202
  __cil_gp_nr_group = & nr_group;
#line 203
  __cil_gp_basket_size = & basket_size;
#line 204
  __cil_fp_arcs = & arcs;
#line 205
  __cil_fp_stop_arcs = & stop_arcs;
#line 206
  __cil_fp_old_group_pos = & old_group_pos;
#line 189
  __cil_tmp32 = *__cil_gp_group_pos;
#line 189
  arc_ssa_1 = arcs + __cil_tmp32;
#line 192
  *__cil_fp_arcs = arcs;
#line 193
  *__cil_fp_stop_arcs = stop_arcs;
#line 194
  *__cil_fp_old_group_pos = old_group_pos;
#line 190
  primal_bea_mpp_cil_lr_3_cil_lr_1(__cil_pp_basket_size, __cil_pp_nr_group, __cil_pp_group_pos,
                                   __cil_pp_arcs, __cil_pp_stop_arcs, __cil_pp_old_group_pos,
                                   arc_ssa_1);
#line 193
  arcs_ssa_1 = *__cil_fp_arcs;
#line 194
  stop_arcs_ssa_1 = *__cil_fp_stop_arcs;
#line 195
  old_group_pos_ssa_1 = *__cil_fp_old_group_pos;
#line 207
  __cil_tmp33 = *__cil_gp_group_pos;
#line 207
  *__cil_gp_group_pos = __cil_tmp33 + 1L;
#line 207
  __cil_tmp34 = *__cil_gp_group_pos;
#line 207
  __cil_tmp35 = *__cil_gp_nr_group;
#line 207
  __cil_tmp29 = __cil_tmp34 == __cil_tmp35;
#line 207
  if (__cil_tmp29 != 0) {
#line 208
    *__cil_gp_group_pos = 0L;
  } else {

  }
#line 209
  __cil_tmp36 = *__cil_gp_basket_size;
#line 209
  __cil_tmp30 = __cil_tmp36 < 50L;
#line 209
  if (__cil_tmp30 != 0) {
#line 209
    __cil_tmp37 = *__cil_gp_group_pos;
#line 209
    __cil_tmp31 = __cil_tmp37 != old_group_pos_ssa_1;
#line 209
    if (__cil_tmp31 != 0) {
#line 209
      tmp___2_ssa_1 = 1;
    } else {
#line 209
      tmp___2_ssa_1 = 0;
    }
  } else {
#line 209
    tmp___2_ssa_1 = 0;
  }
#line 209
  cond_ssa_1 = tmp___2_ssa_1;
#line 186
  if (cond_ssa_1 != 0) {
#line 188
    primal_bea_mpp_cil_lr_3(__cil_ap_basket_size, __cil_ap_red_cost_of_bea, arcs_ssa_1,
                            stop_arcs_ssa_1, old_group_pos_ssa_1);
#line 191
    return;
  } else {
#line 193
    return;
  }
}
}
#line 197 "pbeampp.c"
void sort_basket_cil_lr_1(long *__cil_ap_min , long *__cil_ap_max , long *__cil_ap_l ,
                          long *__cil_ap_r , cost_t cut ) 
{ 
  cost_t *__cil_pp_cut ;
  cost_t *__cil_fp_cut ;
  cost_t cut_ssa_1 ;
  cost_t cut_ssa_2 ;
  BASKET *xchange_ssa_1 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  long __cil_tmp16 ;
  long __cil_tmp17 ;
  BASKET **__cil_tmp18 ;
  long __cil_tmp19 ;
  BASKET **__cil_tmp20 ;
  long __cil_tmp21 ;
  BASKET **__cil_tmp22 ;
  long __cil_tmp23 ;
  BASKET **__cil_tmp24 ;
  long __cil_tmp25 ;
  long __cil_tmp26 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  long __cil_tmp29 ;
  long __cil_tmp30 ;

  {
#line 200
  __cil_fp_cut = & cut;
#line 200
  __cil_pp_cut = & cut;
#line 200
  return babel_wrapper_sort_basket_cil_lr_1(__cil_pp_cut, __cil_fp_cut, __cil_ap_min,
                                            __cil_ap_max, __cil_ap_l, __cil_ap_r,
                                            cut);
#line 200
  __cil_pp_cut = & cut;
#line 201
  __cil_fp_cut = & cut;
#line 227
  *__cil_fp_cut = cut;
#line 81
  sort_basket_cil_lr_1_cil_lr_1(__cil_pp_cut, __cil_ap_l);
#line 82
  cut_ssa_1 = *__cil_fp_cut;
#line 85
  *__cil_fp_cut = cut_ssa_1;
#line 83
  sort_basket_cil_lr_1_cil_lr_2(__cil_pp_cut, __cil_ap_r);
#line 84
  cut_ssa_2 = *__cil_fp_cut;
#line 86
  __cil_tmp15 = *__cil_ap_l;
#line 86
  __cil_tmp16 = *__cil_ap_r;
#line 86
  __cil_tmp12 = __cil_tmp15 < __cil_tmp16;
#line 86
  if (__cil_tmp12 != 0) {
#line 88
    __cil_tmp17 = *__cil_ap_l;
#line 88
    __cil_tmp18 = perm + __cil_tmp17;
#line 88
    xchange_ssa_1 = *__cil_tmp18;
#line 89
    __cil_tmp19 = *__cil_ap_r;
#line 89
    __cil_tmp20 = perm + __cil_tmp19;
#line 89
    __cil_tmp21 = *__cil_ap_l;
#line 89
    __cil_tmp22 = perm + __cil_tmp21;
#line 89
    *__cil_tmp22 = *__cil_tmp20;
#line 90
    __cil_tmp23 = *__cil_ap_r;
#line 90
    __cil_tmp24 = perm + __cil_tmp23;
#line 90
    *__cil_tmp24 = xchange_ssa_1;
  } else {

  }
#line 92
  __cil_tmp25 = *__cil_ap_l;
#line 92
  __cil_tmp26 = *__cil_ap_r;
#line 92
  __cil_tmp13 = __cil_tmp25 <= __cil_tmp26;
#line 92
  if (__cil_tmp13 != 0) {
#line 94
    __cil_tmp27 = *__cil_ap_l;
#line 94
    *__cil_ap_l = __cil_tmp27 + 1L;
#line 94
    __cil_tmp28 = *__cil_ap_r;
#line 94
    *__cil_ap_r = __cil_tmp28 - 1L;
  } else {

  }
#line 79
  __cil_tmp29 = *__cil_ap_l;
#line 79
  __cil_tmp30 = *__cil_ap_r;
#line 79
  __cil_tmp14 = __cil_tmp29 <= __cil_tmp30;
#line 79
  if (__cil_tmp14 != 0) {
#line 81
    sort_basket_cil_lr_1(__cil_ap_min, __cil_ap_max, __cil_ap_l, __cil_ap_r, cut_ssa_2);
#line 83
    return;
  } else {
#line 85
    return;
  }
}
}
#include <gprolog.h>


PlBool babel__implicit_sort_basketc_0(long * arg_0, long * arg_1, long * arg_2, long * arg_3, cost_t  arg_4) 
{
sort_basket_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_sort_basketc_1(long  arg_0, long  arg_1) 
{
sort_basket(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_sort_basketc_2(long  arg_0, long  arg_1) 
{
sort_basket(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mppc_3(long * arg_0, arc_t ** arg_1, arc_t ** arg_2, cost_t ** arg_3, long  arg_4) 
{
primal_bea_mpp_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mppc_4(long * arg_0, long * arg_1, arc_t ** arg_2, arc_t ** arg_3, cost_t ** arg_4, long * arg_5, long  arg_6, int  arg_7) 
{
primal_bea_mpp_cil_lr_2(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mppc_5(long * arg_0, cost_t ** arg_1, arc_t * arg_2, arc_t * arg_3, long  arg_4) 
{
primal_bea_mpp_cil_lr_3(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mppc_6(int arg_0, long  arg_1) 
{
sort_basket(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mpp_cil_lr_3_cil_lr_1c_7(arc_t * arg_0, cost_t  arg_1, PlLong * babel_ret) 
{
*babel_ret = bea_is_dual_infeasible(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mpp_cil_lr_3_cil_lr_1c_8(long * arg_0, long * arg_1, long * arg_2, arc_t ** arg_3, arc_t ** arg_4, long * arg_5, arc_t * arg_6) 
{
primal_bea_mpp_cil_lr_3_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mpp_cil_lr_2c_12(long * arg_0, long * arg_1, arc_t ** arg_2, arc_t ** arg_3, cost_t ** arg_4, long * arg_5, long  arg_6, int  arg_7) 
{
primal_bea_mpp_cil_lr_2(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mpp_cil_lr_3c_13(long * arg_0, long * arg_1, long * arg_2, arc_t ** arg_3, arc_t ** arg_4, long * arg_5, arc_t * arg_6) 
{
primal_bea_mpp_cil_lr_3_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6);
return PL_TRUE;
}
PlBool babel__implicit_primal_bea_mpp_cil_lr_3c_14(long * arg_0, cost_t ** arg_1, arc_t * arg_2, arc_t * arg_3, long  arg_4) 
{
primal_bea_mpp_cil_lr_3(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_sort_basket_cil_lr_1c_15(cost_t * arg_0, long * arg_1) 
{
sort_basket_cil_lr_1_cil_lr_1(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_sort_basket_cil_lr_1c_16(cost_t * arg_0, long * arg_1) 
{
sort_basket_cil_lr_1_cil_lr_2(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_sort_basket_cil_lr_1c_17(long * arg_0, long * arg_1, long * arg_2, long * arg_3, cost_t  arg_4) 
{
sort_basket_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
