/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 68 "defines.h"
typedef long flow_t;
#line 69 "defines.h"
typedef long cost_t;
#line 99
struct node;
#line 99 "defines.h"
typedef struct node node_t;
#line 100 "defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 102 "defines.h"
typedef struct arc arc_t;
#line 103 "defines.h"
typedef struct arc *arc_p;
#line 107 "defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 138 "defines.h"
struct network {
   char inputfile[200] ;
   char clustfile[200] ;
   long n ;
   long n_trips ;
   long max_m ;
   long m ;
   long m_org ;
   long m_impl ;
   long max_residual_new_m ;
   long max_new_m ;
   long primal_unbounded ;
   long dual_unbounded ;
   long perturbed ;
   long feasible ;
   long eps ;
   long opt_tol ;
   long feas_tol ;
   long pert_val ;
   long bigM ;
   double optcost ;
   cost_t ignore_impl ;
   node_p nodes ;
   node_p stop_nodes ;
   arc_p arcs ;
   arc_p stop_arcs ;
   arc_p dummy_arcs ;
   arc_p stop_dummy ;
   long iterations ;
   long bound_exchanges ;
   long checksum ;
};
#line 138 "defines.h"
typedef struct network network_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 30 "mcfutil.h"
void refresh_neighbour_lists(network_t *net ) ;
#line 31
long refresh_potential(network_t *net ) ;
#line 32
double flow_cost(network_t *net ) ;
#line 33
double flow_org_cost(network_t *net ) ;
#line 34
long primal_feasible(network_t *net ) ;
#line 35
long dual_feasible(network_t *net ) ;
#line 36
long getfree(network_t *net ) ;
void refresh_potential_cil_lr_1_cil_lr_1(node_t **__cil_ap_tmp , node_t **__cil_ap_root ,
                                         long *__cil_ap_checksum , node_t *node ) ;
void refresh_potential_cil_lr_1_cil_lr_2(node_t **__cil_ap_node , node_t **__cil_ap_tmp ,
                                         node_t **__cil_ap_root ) ;
void refresh_potential_cil_lr_1(long *__cil_ap_checksum , node_t *node , node_t *tmp ,
                                node_t *root ) ;
void refresh_neighbour_lists_cil_lr_1(network_t **__cil_ap_net , node_t *node , void *stop ) ;
void refresh_neighbour_lists_cil_lr_2(arc_t *arc , void *stop ) ;
#line 28 "mcfutil.c"
void refresh_neighbour_lists(network_t *net ) 
{ 
  network_t **__cil_pp_net  = & net;
  network_t **__cil_fp_net  = & net;
  node_t *node_ssa_1 ;
  void *stop_ssa_1 ;
  network_t *net_ssa_1 ;
  arc_t *arc_ssa_1 ;
  void *stop_ssa_2 ;
  unsigned char *__cil_tmp12 ;
  node_p *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  node_p *__cil_tmp15 ;
  node_p __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  arc_p *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  arc_p *__cil_tmp20 ;
  arc_p __cil_tmp21 ;

  {
  {
#line 39
  __cil_tmp12 = (unsigned char *)net + 552;
#line 39
  __cil_tmp13 = (node_p *)__cil_tmp12;
#line 39
  node_ssa_1 = *__cil_tmp13;
#line 40
  __cil_tmp14 = (unsigned char *)net + 560;
#line 40
  __cil_tmp15 = (node_p *)__cil_tmp14;
#line 40
  __cil_tmp16 = *__cil_tmp15;
#line 40
  stop_ssa_1 = (void *)__cil_tmp16;
  }
  {
  *__cil_fp_net = net;
#line 40
  refresh_neighbour_lists_cil_lr_1(__cil_pp_net, node_ssa_1, stop_ssa_1);
  net_ssa_1 = *__cil_fp_net;
  }
  {
#line 46
  __cil_tmp17 = (unsigned char *)net_ssa_1 + 568;
#line 46
  __cil_tmp18 = (arc_p *)__cil_tmp17;
#line 46
  arc_ssa_1 = *__cil_tmp18;
#line 47
  __cil_tmp19 = (unsigned char *)net_ssa_1 + 576;
#line 47
  __cil_tmp20 = (arc_p *)__cil_tmp19;
#line 47
  __cil_tmp21 = *__cil_tmp20;
#line 47
  stop_ssa_2 = (void *)__cil_tmp21;
  }
  {
#line 47
  refresh_neighbour_lists_cil_lr_2(arc_ssa_1, stop_ssa_2);
  }
#line 55
  return;
}
}
#line 68 "mcfutil.c"
long refresh_potential(network_t *net ) 
{ 
  long checksum ;
  long *__cil_pp_checksum  = & checksum;
  long *__cil_fp_checksum  = & checksum;
  node_t *root_ssa_1 ;
  long checksum_ssa_1 ;
  node_t *node_ssa_1 ;
  node_t *tmp_ssa_1 ;
  long checksum_ssa_2 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  node_p *__cil_tmp16 ;

  {
  {
#line 75
  __cil_tmp13 = (unsigned char *)net + 552;
#line 75
  __cil_tmp14 = (node_p *)__cil_tmp13;
#line 75
  root_ssa_1 = *__cil_tmp14;
#line 76
  checksum_ssa_1 = 0L;
#line 79
  *((cost_t *)root_ssa_1) = -100000000L;
#line 80
  __cil_tmp15 = (unsigned char *)root_ssa_1 + 16;
#line 80
  __cil_tmp16 = (node_p *)__cil_tmp15;
#line 80
  node_ssa_1 = *__cil_tmp16;
#line 80
  tmp_ssa_1 = node_ssa_1;
  }
  {
  *__cil_fp_checksum = checksum_ssa_1;
#line 81
  refresh_potential_cil_lr_1(__cil_pp_checksum, node_ssa_1, tmp_ssa_1, root_ssa_1);
  checksum_ssa_2 = *__cil_fp_checksum;
  }
#line 112
  return (checksum_ssa_2);
}
}
#line 122 "mcfutil.c"
double flow_cost(network_t *net ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
#line 132
  fleet = 0L;
#line 133
  operational_cost = (cost_t )0;
#line 136
  stop = (void *)net->stop_arcs;
#line 137
  arc = net->arcs;
#line 137
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 139
    if (arc->ident == 2) {
#line 140
      arc->flow = (flow_t )1;
    } else {
#line 142
      arc->flow = (flow_t )0;
    }
#line 137
    arc ++;
  }
#line 145
  stop = (void *)net->stop_nodes;
#line 146
  node = net->nodes;
#line 146
  node ++;
#line 146
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
#line 147
    (node->basic_arc)->flow = node->flow;
#line 146
    node ++;
  }
#line 149
  stop = (void *)net->stop_arcs;
#line 150
  arc = net->arcs;
#line 150
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 152
    if (arc->flow) {
#line 154
      if ((arc->tail)->number < 0) {
#line 154
        if (! ((arc->head)->number > 0)) {
#line 154
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 156
      if (! (arc->tail)->number) {
#line 158
        operational_cost += arc->cost - net->bigM;
#line 159
        fleet ++;
      } else {
#line 162
        operational_cost += arc->cost;
      }
    }
#line 150
    arc ++;
  }
#line 168
  return ((double )fleet * (double )net->bigM + (double )operational_cost);
}
}
#line 181 "mcfutil.c"
double flow_org_cost(network_t *net ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
#line 191
  fleet = 0L;
#line 192
  operational_cost = (cost_t )0;
#line 195
  stop = (void *)net->stop_arcs;
#line 196
  arc = net->arcs;
#line 196
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 198
    if (arc->ident == 2) {
#line 199
      arc->flow = (flow_t )1;
    } else {
#line 201
      arc->flow = (flow_t )0;
    }
#line 196
    arc ++;
  }
#line 204
  stop = (void *)net->stop_nodes;
#line 205
  node = net->nodes;
#line 205
  node ++;
#line 205
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
#line 206
    (node->basic_arc)->flow = node->flow;
#line 205
    node ++;
  }
#line 208
  stop = (void *)net->stop_arcs;
#line 209
  arc = net->arcs;
#line 209
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 211
    if (arc->flow) {
#line 213
      if ((arc->tail)->number < 0) {
#line 213
        if (! ((arc->head)->number > 0)) {
#line 213
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 215
      if (! (arc->tail)->number) {
#line 217
        operational_cost += arc->org_cost - net->bigM;
#line 218
        fleet ++;
      } else {
#line 221
        operational_cost += arc->org_cost;
      }
    }
#line 209
    arc ++;
  }
#line 226
  return ((double )fleet * (double )net->bigM + (double )operational_cost);
}
}
#line 239 "mcfutil.c"
long primal_feasible(network_t *net ) 
{ 
  void *stop ;
  node_t *node ;
  arc_t *dummy ;
  arc_t *stop_dummy ;
  arc_t *arc ;
  flow_t flow ;
  flow_t tmp ;

  {
#line 247
  dummy = net->dummy_arcs;
#line 248
  stop_dummy = net->stop_dummy;
#line 253
  node = net->nodes;
#line 254
  stop = (void *)net->stop_nodes;
#line 256
  node ++;
#line 256
  while ((unsigned long )node < (unsigned long )((node_t *)stop)) {
#line 258
    arc = node->basic_arc;
#line 259
    flow = node->flow;
#line 260
    if ((unsigned long )arc >= (unsigned long )dummy) {
#line 260
      if ((unsigned long )arc < (unsigned long )stop_dummy) {
#line 262
        if (flow >= 0L) {
#line 262
          tmp = flow;
        } else {
#line 262
          tmp = - flow;
        }
#line 262
        if (tmp > net->feas_tol) {
#line 264
          printf((char const   */* __restrict  */)"PRIMAL NETWORK SIMPLEX: ");
#line 265
          printf((char const   */* __restrict  */)"artificial arc with nonzero flow, node %d (%ld)\n",
                 node->number, flow);
        }
      } else {
#line 260
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 271
    if (flow < - net->feas_tol) {
#line 274
      printf((char const   */* __restrict  */)"PRIMAL NETWORK SIMPLEX: ");
#line 275
      printf((char const   */* __restrict  */)"basis primal infeasible (%ld)\n", flow);
#line 276
      net->feasible = 0L;
#line 277
      return (1L);
    } else
#line 271
    if (flow - 1L > net->feas_tol) {
#line 274
      printf((char const   */* __restrict  */)"PRIMAL NETWORK SIMPLEX: ");
#line 275
      printf((char const   */* __restrict  */)"basis primal infeasible (%ld)\n", flow);
#line 276
      net->feasible = 0L;
#line 277
      return (1L);
    }
#line 256
    node ++;
  }
#line 282
  net->feasible = 1L;
#line 284
  return (0L);
}
}
#line 297 "mcfutil.c"
long dual_feasible(network_t *net ) 
{ 
  arc_t *arc ;
  arc_t *stop ;
  cost_t red_cost ;

  {
#line 304
  stop = net->stop_arcs;
#line 309
  arc = net->arcs;
#line 309
  while ((unsigned long )arc < (unsigned long )stop) {
#line 311
    red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
#line 313
    switch (arc->ident) {
    case 1: 
    case 0: 
#line 329
    if (red_cost < - net->feas_tol) {
#line 334
      goto DUAL_INFEAS;
    }
#line 337
    break;
    case 2: 
#line 339
    if (red_cost > net->feas_tol) {
#line 344
      goto DUAL_INFEAS;
    }
#line 347
    break;
    default: 
#line 350
    break;
    }
#line 309
    arc ++;
  }
#line 354
  return (0L);
  DUAL_INFEAS: 
#line 357
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DUAL NETWORK SIMPLEX: ");
#line 358
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"basis dual infeasible\n");
#line 359
  return (1L);
}
}
#line 369 "mcfutil.c"
long getfree(network_t *net ) 
{ 
  node_p tmp_ssa_1 ;
  arc_p tmp___0_ssa_1 ;
  arc_p tmp___1_ssa_1 ;
  node_p __cil_tmp8 ;
  arc_p __cil_tmp9 ;
  arc_p __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  node_p *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  node_p __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  arc_p *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  arc_p *__cil_tmp19 ;
  arc_p __cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  arc_p *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  arc_p *__cil_tmp24 ;
  arc_p __cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  node_p *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  node_p *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  arc_p *__cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  arc_p *__cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  arc_p *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  arc_p *__cil_tmp37 ;

  {
  {
#line 377
  __cil_tmp11 = (unsigned char *)net + 552;
#line 377
  __cil_tmp12 = (node_p *)__cil_tmp11;
#line 377
  __cil_tmp8 = *__cil_tmp12;
#line 377
  if (__cil_tmp8) {
    {
#line 377
    __cil_tmp13 = (unsigned char *)net + 552;
#line 377
    __cil_tmp14 = (node_p *)__cil_tmp13;
#line 377
    __cil_tmp15 = *__cil_tmp14;
#line 377
    free((void *)__cil_tmp15);
    }
  } else {

  }
  }
  {
#line 378
  __cil_tmp16 = (unsigned char *)net + 568;
#line 378
  __cil_tmp17 = (arc_p *)__cil_tmp16;
#line 378
  __cil_tmp9 = *__cil_tmp17;
#line 378
  if (__cil_tmp9) {
    {
#line 378
    __cil_tmp18 = (unsigned char *)net + 568;
#line 378
    __cil_tmp19 = (arc_p *)__cil_tmp18;
#line 378
    __cil_tmp20 = *__cil_tmp19;
#line 378
    free((void *)__cil_tmp20);
    }
  } else {

  }
  }
  {
#line 379
  __cil_tmp21 = (unsigned char *)net + 584;
#line 379
  __cil_tmp22 = (arc_p *)__cil_tmp21;
#line 379
  __cil_tmp10 = *__cil_tmp22;
#line 379
  if (__cil_tmp10) {
    {
#line 379
    __cil_tmp23 = (unsigned char *)net + 584;
#line 379
    __cil_tmp24 = (arc_p *)__cil_tmp23;
#line 379
    __cil_tmp25 = *__cil_tmp24;
#line 379
    free((void *)__cil_tmp25);
    }
  } else {

  }
  }
  {
#line 380
  tmp_ssa_1 = (node_p )0;
#line 380
  __cil_tmp26 = (unsigned char *)net + 560;
#line 380
  __cil_tmp27 = (node_p *)__cil_tmp26;
#line 380
  *__cil_tmp27 = tmp_ssa_1;
#line 380
  __cil_tmp28 = (unsigned char *)net + 552;
#line 380
  __cil_tmp29 = (node_p *)__cil_tmp28;
#line 380
  *__cil_tmp29 = tmp_ssa_1;
#line 381
  tmp___0_ssa_1 = (arc_p )0;
#line 381
  __cil_tmp30 = (unsigned char *)net + 576;
#line 381
  __cil_tmp31 = (arc_p *)__cil_tmp30;
#line 381
  *__cil_tmp31 = tmp___0_ssa_1;
#line 381
  __cil_tmp32 = (unsigned char *)net + 568;
#line 381
  __cil_tmp33 = (arc_p *)__cil_tmp32;
#line 381
  *__cil_tmp33 = tmp___0_ssa_1;
#line 382
  tmp___1_ssa_1 = (arc_p )0;
#line 382
  __cil_tmp34 = (unsigned char *)net + 592;
#line 382
  __cil_tmp35 = (arc_p *)__cil_tmp34;
#line 382
  *__cil_tmp35 = tmp___1_ssa_1;
#line 382
  __cil_tmp36 = (unsigned char *)net + 584;
#line 382
  __cil_tmp37 = (arc_p *)__cil_tmp36;
#line 382
  *__cil_tmp37 = tmp___1_ssa_1;
  }
#line 384
  return (0L);
}
}
void refresh_potential_cil_lr_1_cil_lr_1(node_t **__cil_ap_tmp , node_t **__cil_ap_root ,
                                         long *__cil_ap_checksum , node_t *node ) 
{ 
  node_t *node_ssa_1 ;
  int __cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  int *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  arc_p *__cil_tmp11 ;
  arc_p __cil_tmp12 ;
  cost_t *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  node_p *__cil_tmp15 ;
  node_p __cil_tmp16 ;
  cost_t *__cil_tmp17 ;
  cost_t __cil_tmp18 ;
  cost_t __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  node_p *__cil_tmp21 ;
  node_p __cil_tmp22 ;
  cost_t *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  arc_p *__cil_tmp25 ;
  arc_p __cil_tmp26 ;
  cost_t *__cil_tmp27 ;
  cost_t __cil_tmp28 ;
  cost_t __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  node_p *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  node_p *__cil_tmp34 ;

  {
#line 83
  if (node) {
    {
#line 85
    __cil_tmp7 = (unsigned char *)node + 8;
#line 85
    __cil_tmp8 = (int *)__cil_tmp7;
#line 85
    __cil_tmp9 = *__cil_tmp8;
#line 85
    __cil_tmp6 = __cil_tmp9 == 1;
#line 85
    if (__cil_tmp6) {
      {
#line 86
      __cil_tmp10 = (unsigned char *)node + 48;
#line 86
      __cil_tmp11 = (arc_p *)__cil_tmp10;
#line 86
      __cil_tmp12 = *__cil_tmp11;
#line 86
      __cil_tmp13 = (cost_t *)__cil_tmp12;
#line 86
      __cil_tmp14 = (unsigned char *)node + 24;
#line 86
      __cil_tmp15 = (node_p *)__cil_tmp14;
#line 86
      __cil_tmp16 = *__cil_tmp15;
#line 86
      __cil_tmp17 = (cost_t *)__cil_tmp16;
#line 86
      __cil_tmp18 = *__cil_tmp13;
#line 86
      __cil_tmp19 = *__cil_tmp17;
#line 86
      *((cost_t *)node) = __cil_tmp18 + __cil_tmp19;
      }
    } else {
      {
#line 89
      __cil_tmp20 = (unsigned char *)node + 24;
#line 89
      __cil_tmp21 = (node_p *)__cil_tmp20;
#line 89
      __cil_tmp22 = *__cil_tmp21;
#line 89
      __cil_tmp23 = (cost_t *)__cil_tmp22;
#line 89
      __cil_tmp24 = (unsigned char *)node + 48;
#line 89
      __cil_tmp25 = (arc_p *)__cil_tmp24;
#line 89
      __cil_tmp26 = *__cil_tmp25;
#line 89
      __cil_tmp27 = (cost_t *)__cil_tmp26;
#line 89
      __cil_tmp28 = *__cil_tmp23;
#line 89
      __cil_tmp29 = *__cil_tmp27;
#line 89
      *((cost_t *)node) = __cil_tmp28 - __cil_tmp29;
#line 90
      __cil_tmp30 = *__cil_ap_checksum;
#line 90
      *__cil_ap_checksum = __cil_tmp30 + 1L;
      }
    }
    }
    {
#line 93
    *__cil_ap_tmp = node;
#line 94
    __cil_tmp31 = (unsigned char *)node + 16;
#line 94
    __cil_tmp32 = (node_p *)__cil_tmp31;
#line 94
    node_ssa_1 = *__cil_tmp32;
    }
    {
    refresh_potential_cil_lr_1_cil_lr_1(__cil_ap_tmp, __cil_ap_root, __cil_ap_checksum,
                                        node_ssa_1);
    }
    return;
  } else {
    return;
  }
  {
#line 93
  *__cil_ap_tmp = node;
#line 94
  __cil_tmp33 = (unsigned char *)node + 16;
#line 94
  __cil_tmp34 = (node_p *)__cil_tmp33;
#line 94
  node_ssa_1 = *__cil_tmp34;
  }
  {
  refresh_potential_cil_lr_1_cil_lr_1(__cil_ap_tmp, __cil_ap_root, __cil_ap_checksum,
                                      node_ssa_1);
  }
  return;
}
}
void refresh_potential_cil_lr_1_cil_lr_2(node_t **__cil_ap_node , node_t **__cil_ap_tmp ,
                                         node_t **__cil_ap_root ) 
{ 
  node_p __cil_tmp4 ;
  node_t *__cil_tmp5 ;
  node_t *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  node_p *__cil_tmp9 ;
  node_t *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  node_p *__cil_tmp13 ;
  node_t *__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  node_p *__cil_tmp17 ;

  {
  {
#line 99
  __cil_tmp6 = *__cil_ap_node;
#line 99
  __cil_tmp7 = (unsigned char *)__cil_tmp6;
#line 99
  __cil_tmp8 = __cil_tmp7 + 24;
#line 99
  __cil_tmp9 = (node_p *)__cil_tmp8;
#line 99
  __cil_tmp4 = *__cil_tmp9;
#line 99
  if (__cil_tmp4) {
    {
#line 101
    __cil_tmp10 = *__cil_ap_node;
#line 101
    __cil_tmp11 = (unsigned char *)__cil_tmp10;
#line 101
    __cil_tmp12 = __cil_tmp11 + 32;
#line 101
    __cil_tmp13 = (node_p *)__cil_tmp12;
#line 101
    *__cil_ap_tmp = *__cil_tmp13;
    }
    {
#line 102
    __cil_tmp5 = *__cil_ap_tmp;
#line 102
    if (__cil_tmp5) {
      {
#line 104
      *__cil_ap_node = *__cil_ap_tmp;
      }
      return;
    } else {
      {
#line 108
      __cil_tmp14 = *__cil_ap_node;
#line 108
      __cil_tmp15 = (unsigned char *)__cil_tmp14;
#line 108
      __cil_tmp16 = __cil_tmp15 + 24;
#line 108
      __cil_tmp17 = (node_p *)__cil_tmp16;
#line 108
      *__cil_ap_node = *__cil_tmp17;
      }
      {
      refresh_potential_cil_lr_1_cil_lr_2(__cil_ap_node, __cil_ap_tmp, __cil_ap_root);
      }
      return;
    }
    }
  } else {
    return;
  }
  }
}
}
void refresh_potential_cil_lr_1(long *__cil_ap_checksum , node_t *node , node_t *tmp ,
                                node_t *root ) 
{ 
  node_t **__cil_pp_tmp  = & tmp;
  node_t **__cil_pp_root  = & root;
  node_t **__cil_pp_node  = & node;
  node_t **__cil_fp_tmp  = & tmp;
  node_t **__cil_fp_root  = & root;
  node_t **__cil_fp_node  = & node;
  node_t *tmp_ssa_1 ;
  node_t *root_ssa_1 ;
  node_t *node_ssa_1 ;
  node_t *node_ssa_2 ;
  node_t *tmp_ssa_2 ;
  node_t *root_ssa_2 ;
  int __cil_tmp17 ;

  {
  {
#line 81
  __cil_tmp17 = (unsigned long )node != (unsigned long )root;
#line 81
  if (__cil_tmp17) {
    {
    *__cil_fp_tmp = tmp;
    *__cil_fp_root = root;
#line 83
    refresh_potential_cil_lr_1_cil_lr_1(__cil_pp_tmp, __cil_pp_root, __cil_ap_checksum,
                                        node);
    tmp_ssa_1 = *__cil_fp_tmp;
    root_ssa_1 = *__cil_fp_root;
    }
    {
#line 97
    node_ssa_1 = tmp_ssa_1;
    }
    {
    *__cil_fp_node = node_ssa_1;
    *__cil_fp_tmp = tmp_ssa_1;
    *__cil_fp_root = root_ssa_1;
#line 99
    refresh_potential_cil_lr_1_cil_lr_2(__cil_pp_node, __cil_pp_tmp, __cil_pp_root);
    node_ssa_2 = *__cil_fp_node;
    tmp_ssa_2 = *__cil_fp_tmp;
    root_ssa_2 = *__cil_fp_root;
    }
    {
    refresh_potential_cil_lr_1(__cil_ap_checksum, node_ssa_2, tmp_ssa_2, root_ssa_2);
    }
    return;
  } else {
    return;
  }
  }
}
}
void refresh_neighbour_lists_cil_lr_1(network_t **__cil_ap_net , node_t *node , void *stop ) 
{ 
  node_t *node_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  arc_p *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  arc_p *__cil_tmp9 ;

  {
  {
#line 40
  __cil_tmp5 = (unsigned long )node < (unsigned long )((node_t *)stop);
#line 40
  if (__cil_tmp5) {
    {
#line 42
    __cil_tmp6 = (unsigned char *)node + 64;
#line 42
    __cil_tmp7 = (arc_p *)__cil_tmp6;
#line 42
    *__cil_tmp7 = (arc_t *)0;
#line 43
    __cil_tmp8 = (unsigned char *)node + 56;
#line 43
    __cil_tmp9 = (arc_p *)__cil_tmp8;
#line 43
    *__cil_tmp9 = (arc_t *)0;
#line 40
    node_ssa_1 = node + 1;
    }
    {
    refresh_neighbour_lists_cil_lr_1(__cil_ap_net, node_ssa_1, stop);
    }
    return;
  } else {
    return;
  }
  }
}
}
void refresh_neighbour_lists_cil_lr_2(arc_t *arc , void *stop ) 
{ 
  arc_t *arc_ssa_1 ;
  int __cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  node_p *__cil_tmp6 ;
  node_p __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  arc_p *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  arc_p *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  node_p __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  arc_p *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  node_p *__cil_tmp20 ;
  node_p __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  arc_p *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  arc_p *__cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  node_p *__cil_tmp28 ;
  node_p __cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  arc_p *__cil_tmp32 ;

  {
  {
#line 47
  __cil_tmp4 = (unsigned long )arc < (unsigned long )((arc_t *)stop);
#line 47
  if (__cil_tmp4) {
    {
#line 49
    __cil_tmp5 = (unsigned char *)arc + 8;
#line 49
    __cil_tmp6 = (node_p *)__cil_tmp5;
#line 49
    __cil_tmp7 = *__cil_tmp6;
#line 49
    __cil_tmp8 = (unsigned char *)__cil_tmp7;
#line 49
    __cil_tmp9 = __cil_tmp8 + 56;
#line 49
    __cil_tmp10 = (arc_p *)__cil_tmp9;
#line 49
    __cil_tmp11 = (unsigned char *)arc + 32;
#line 49
    __cil_tmp12 = (arc_p *)__cil_tmp11;
#line 49
    *__cil_tmp12 = *__cil_tmp10;
#line 50
    __cil_tmp13 = (unsigned char *)arc + 8;
#line 50
    __cil_tmp14 = (node_p *)__cil_tmp13;
#line 50
    __cil_tmp15 = *__cil_tmp14;
#line 50
    __cil_tmp16 = (unsigned char *)__cil_tmp15;
#line 50
    __cil_tmp17 = __cil_tmp16 + 56;
#line 50
    __cil_tmp18 = (arc_p *)__cil_tmp17;
#line 50
    *__cil_tmp18 = arc;
#line 51
    __cil_tmp19 = (unsigned char *)arc + 16;
#line 51
    __cil_tmp20 = (node_p *)__cil_tmp19;
#line 51
    __cil_tmp21 = *__cil_tmp20;
#line 51
    __cil_tmp22 = (unsigned char *)__cil_tmp21;
#line 51
    __cil_tmp23 = __cil_tmp22 + 64;
#line 51
    __cil_tmp24 = (arc_p *)__cil_tmp23;
#line 51
    __cil_tmp25 = (unsigned char *)arc + 40;
#line 51
    __cil_tmp26 = (arc_p *)__cil_tmp25;
#line 51
    *__cil_tmp26 = *__cil_tmp24;
#line 52
    __cil_tmp27 = (unsigned char *)arc + 16;
#line 52
    __cil_tmp28 = (node_p *)__cil_tmp27;
#line 52
    __cil_tmp29 = *__cil_tmp28;
#line 52
    __cil_tmp30 = (unsigned char *)__cil_tmp29;
#line 52
    __cil_tmp31 = __cil_tmp30 + 64;
#line 52
    __cil_tmp32 = (arc_p *)__cil_tmp31;
#line 52
    *__cil_tmp32 = arc;
#line 47
    arc_ssa_1 = arc + 1;
    }
    {
    refresh_neighbour_lists_cil_lr_2(arc_ssa_1, stop);
    }
    return;
  } else {
    return;
  }
  }
}
}
