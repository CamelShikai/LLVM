#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 68 "defines.h"
typedef long flow_t;
#line 69 "defines.h"
typedef long cost_t;
#line 99
struct node;
#line 99
struct node;
#line 99 "defines.h"
typedef struct node node_t;
#line 100 "defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 102
struct arc;
#line 102 "defines.h"
typedef struct arc arc_t;
#line 103 "defines.h"
typedef struct arc *arc_p;
#line 107 "defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 138 "defines.h"
struct network {
   char inputfile[200] ;
   char clustfile[200] ;
   long n ;
   long n_trips ;
   long max_m ;
   long m ;
   long m_org ;
   long m_impl ;
   long max_residual_new_m ;
   long max_new_m ;
   long primal_unbounded ;
   long dual_unbounded ;
   long perturbed ;
   long feasible ;
   long eps ;
   long opt_tol ;
   long feas_tol ;
   long pert_val ;
   long bigM ;
   double optcost ;
   cost_t ignore_impl ;
   node_p nodes ;
   node_p stop_nodes ;
   arc_p arcs ;
   arc_p stop_arcs ;
   arc_p dummy_arcs ;
   arc_p stop_dummy ;
   long iterations ;
   long bound_exchanges ;
   long checksum ;
};
#line 138 "defines.h"
typedef struct network network_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 30 "mcfutil.h"
void refresh_neighbour_lists(network_t *net ) ;
#line 31
long refresh_potential(network_t *net ) ;
#line 32
double flow_cost(network_t *net ) ;
#line 33
double flow_org_cost(network_t *net ) ;
#line 34
long primal_feasible(network_t *net ) ;
#line 35
long dual_feasible(network_t *net ) ;
#line 36
long getfree(network_t *net ) ;
#line 37
void refresh_potential_cil_lr_1_cil_lr_1(node_t **__cil_ap_tmp , node_t **__cil_ap_root ,
                                         long *__cil_ap_checksum , node_t *node ) ;
#line 39
void refresh_potential_cil_lr_1_cil_lr_2(node_t **__cil_ap_node , node_t **__cil_ap_tmp ,
                                         node_t **__cil_ap_root ) ;
#line 41
void dual_feasible_cil_lr_1(struct _IO_FILE **__cil_ap_stderr , int *__cil_ap_cond ,
                            network_t *net , arc_t *arc , arc_t *stop ) ;
#line 43
int primal_feasible_cil_lr_1(network_t **__cil_ap_net , long *__cil_ap___cil_ret12 ,
                             void *stop , node_t *node , arc_t *dummy , arc_t *stop_dummy ) ;
#line 45
void flow_org_cost_cil_lr_1(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                            arc_t *arc , void *stop ) ;
#line 47
void flow_org_cost_cil_lr_2(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                            node_t *node , void *stop ) ;
#line 49
void flow_org_cost_cil_lr_3(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                            arc_t *arc , void *stop ) ;
#line 51
void flow_cost_cil_lr_1(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                        arc_t *arc , void *stop ) ;
#line 53
void flow_cost_cil_lr_2(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                        node_t *node , void *stop ) ;
#line 55
void flow_cost_cil_lr_3(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                        arc_t *arc , void *stop ) ;
#line 57
void refresh_potential_cil_lr_1(long *__cil_ap_checksum , node_t *node , node_t *tmp ,
                                node_t *root ) ;
#line 59
void refresh_neighbour_lists_cil_lr_1(network_t **__cil_ap_net , node_t *node , void *stop ) ;
#line 60
void refresh_neighbour_lists_cil_lr_2(arc_t *arc , void *stop ) ;
   int babel_wrapper_refresh_neighbour_lists(network_t ** __cil_pp_net, network_t ** __cil_fp_net, network_t * net)                           // function name insert
      {
        // wrapper for function refresh_neighbour_lists        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_neighbour_lists"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_net);
arg[1] = Pl_Mk_Integer(__cil_fp_net);
arg[2] = Pl_Mk_Integer(net);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   long  babel_wrapper_refresh_potential(long * __cil_pp_checksum, long * __cil_fp_checksum, network_t * net)                           // function name insert
      {
        // wrapper for function refresh_potential        // function name insert
         long  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_potential"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_checksum);
arg[1] = Pl_Mk_Integer(__cil_fp_checksum);
arg[2] = Pl_Mk_Integer(net);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   double  babel_wrapper_flow_org_cost(network_t ** __cil_pp_net, long * __cil_pp_fleet, cost_t * __cil_pp_operational_cost, network_t ** __cil_fp_net, long * __cil_fp_fleet, cost_t * __cil_fp_operational_cost, network_t * net)                           // function name insert
      {
        // wrapper for function flow_org_cost        // function name insert
         double  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("flow_org_cost"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_net);
arg[1] = Pl_Mk_Integer(__cil_pp_fleet);
arg[2] = Pl_Mk_Integer(__cil_pp_operational_cost);
arg[3] = Pl_Mk_Integer(__cil_fp_net);
arg[4] = Pl_Mk_Integer(__cil_fp_fleet);
arg[5] = Pl_Mk_Integer(__cil_fp_operational_cost);
arg[6] = Pl_Mk_Integer(net);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Float(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   long  babel_wrapper_primal_feasible(network_t ** __cil_pp_net, long * __cil_pp___cil_ret12, network_t ** __cil_fp_net, long * __cil_fp___cil_ret12, network_t * net)                           // function name insert
      {
        // wrapper for function primal_feasible        // function name insert
         long  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("primal_feasible"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_net);
arg[1] = Pl_Mk_Integer(__cil_pp___cil_ret12);
arg[2] = Pl_Mk_Integer(__cil_fp_net);
arg[3] = Pl_Mk_Integer(__cil_fp___cil_ret12);
arg[4] = Pl_Mk_Integer(net);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   long  babel_wrapper_dual_feasible(struct _IO_FILE ** __cil_pp_stderr, int * __cil_pp_cond, struct _IO_FILE ** __cil_gp_stderr, int * __cil_fp_cond, network_t * net)                           // function name insert
      {
        // wrapper for function dual_feasible        // function name insert
         long  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("dual_feasible"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_stderr);
arg[1] = Pl_Mk_Integer(__cil_pp_cond);
arg[2] = Pl_Mk_Integer(__cil_gp_stderr);
arg[3] = Pl_Mk_Integer(__cil_fp_cond);
arg[4] = Pl_Mk_Integer(net);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   long  babel_wrapper_getfree(network_t * net)                           // function name insert
      {
        // wrapper for function getfree        // function name insert
         long  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("getfree"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(net);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_refresh_potential_cil_lr_1_cil_lr_1(node_t ** __cil_ap_tmp, node_t ** __cil_ap_root, long * __cil_ap_checksum, node_t * node)                           // function name insert
      {
        // wrapper for function refresh_potential_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_potential_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_tmp);
arg[1] = Pl_Mk_Integer(__cil_ap_root);
arg[2] = Pl_Mk_Integer(__cil_ap_checksum);
arg[3] = Pl_Mk_Integer(node);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_refresh_potential_cil_lr_1_cil_lr_2(node_t ** __cil_ap_node, node_t ** __cil_ap_tmp, node_t ** __cil_ap_root)                           // function name insert
      {
        // wrapper for function refresh_potential_cil_lr_1_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_potential_cil_lr_1_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_node);
arg[1] = Pl_Mk_Integer(__cil_ap_tmp);
arg[2] = Pl_Mk_Integer(__cil_ap_root);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_flow_org_cost_cil_lr_1(network_t ** __cil_ap_net, long * __cil_ap_fleet, cost_t * __cil_ap_operational_cost, arc_t * arc, void * stop)                           // function name insert
      {
        // wrapper for function flow_org_cost_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("flow_org_cost_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_net);
arg[1] = Pl_Mk_Integer(__cil_ap_fleet);
arg[2] = Pl_Mk_Integer(__cil_ap_operational_cost);
arg[3] = Pl_Mk_Integer(arc);
arg[4] = Pl_Mk_Integer(stop);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_flow_org_cost_cil_lr_2(network_t ** __cil_ap_net, long * __cil_ap_fleet, cost_t * __cil_ap_operational_cost, node_t * node, void * stop)                           // function name insert
      {
        // wrapper for function flow_org_cost_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("flow_org_cost_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_net);
arg[1] = Pl_Mk_Integer(__cil_ap_fleet);
arg[2] = Pl_Mk_Integer(__cil_ap_operational_cost);
arg[3] = Pl_Mk_Integer(node);
arg[4] = Pl_Mk_Integer(stop);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_flow_org_cost_cil_lr_3(network_t ** __cil_ap_net, long * __cil_ap_fleet, cost_t * __cil_ap_operational_cost, arc_t * arc, void * stop)                           // function name insert
      {
        // wrapper for function flow_org_cost_cil_lr_3        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("flow_org_cost_cil_lr_3"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_net);
arg[1] = Pl_Mk_Integer(__cil_ap_fleet);
arg[2] = Pl_Mk_Integer(__cil_ap_operational_cost);
arg[3] = Pl_Mk_Integer(arc);
arg[4] = Pl_Mk_Integer(stop);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_refresh_potential_cil_lr_1(node_t ** __cil_pp_tmp, node_t ** __cil_pp_root, node_t ** __cil_pp_node, node_t ** __cil_fp_tmp, node_t ** __cil_fp_root, node_t ** __cil_fp_node, long * __cil_ap_checksum, node_t * node, node_t * tmp, node_t * root)                           // function name insert
      {
        // wrapper for function refresh_potential_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[11];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_potential_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_tmp);
arg[1] = Pl_Mk_Integer(__cil_pp_root);
arg[2] = Pl_Mk_Integer(__cil_pp_node);
arg[3] = Pl_Mk_Integer(__cil_fp_tmp);
arg[4] = Pl_Mk_Integer(__cil_fp_root);
arg[5] = Pl_Mk_Integer(__cil_fp_node);
arg[6] = Pl_Mk_Integer(__cil_ap_checksum);
arg[7] = Pl_Mk_Integer(node);
arg[8] = Pl_Mk_Integer(tmp);
arg[9] = Pl_Mk_Integer(root);

      //routine code, reserve a place for return value
      arg[10] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 11, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[10]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_refresh_neighbour_lists_cil_lr_1(network_t ** __cil_ap_net, node_t * node, void * stop)                           // function name insert
      {
        // wrapper for function refresh_neighbour_lists_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_neighbour_lists_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_net);
arg[1] = Pl_Mk_Integer(node);
arg[2] = Pl_Mk_Integer(stop);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_refresh_neighbour_lists_cil_lr_2(arc_t * arc, void * stop)                           // function name insert
      {
        // wrapper for function refresh_neighbour_lists_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("refresh_neighbour_lists_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(arc);
arg[1] = Pl_Mk_Integer(stop);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 28 "mcfutil.c"
void refresh_neighbour_lists(network_t *net ) 
{ 
  network_t **__cil_pp_net ;
  network_t **__cil_fp_net ;
  node_t *node_ssa_1 ;
  void *stop_ssa_1 ;
  network_t *net_ssa_1 ;
  arc_t *arc_ssa_1 ;
  void *stop_ssa_2 ;
  unsigned char *__cil_tmp12 ;
  node_p *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  node_p *__cil_tmp15 ;
  node_p __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  arc_p *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  arc_p *__cil_tmp20 ;
  arc_p __cil_tmp21 ;

  {
#line 30
  __cil_fp_net = & net;
#line 30
  __cil_pp_net = & net;
#line 30
  return babel_wrapper_refresh_neighbour_lists(__cil_pp_net, __cil_fp_net, net);
#line 30
  __cil_pp_net = & net;
#line 31
  __cil_fp_net = & net;
#line 39
  __cil_tmp12 = (unsigned char *)net + 552;
#line 39
  __cil_tmp13 = (node_p *)__cil_tmp12;
#line 39
  node_ssa_1 = *__cil_tmp13;
#line 40
  __cil_tmp14 = (unsigned char *)net + 560;
#line 40
  __cil_tmp15 = (node_p *)__cil_tmp14;
#line 40
  __cil_tmp16 = *__cil_tmp15;
#line 40
  stop_ssa_1 = (void *)__cil_tmp16;
#line 43
  *__cil_fp_net = net;
#line 40
  refresh_neighbour_lists_cil_lr_1(__cil_pp_net, node_ssa_1, stop_ssa_1);
#line 41
  net_ssa_1 = *__cil_fp_net;
#line 46
  __cil_tmp17 = (unsigned char *)net_ssa_1 + 568;
#line 46
  __cil_tmp18 = (arc_p *)__cil_tmp17;
#line 46
  arc_ssa_1 = *__cil_tmp18;
#line 47
  __cil_tmp19 = (unsigned char *)net_ssa_1 + 576;
#line 47
  __cil_tmp20 = (arc_p *)__cil_tmp19;
#line 47
  __cil_tmp21 = *__cil_tmp20;
#line 47
  stop_ssa_2 = (void *)__cil_tmp21;
#line 47
  refresh_neighbour_lists_cil_lr_2(arc_ssa_1, stop_ssa_2);
#line 55
  return;
}
}
#line 68 "mcfutil.c"
long refresh_potential(network_t *net ) 
{ 
  long checksum ;
  long *__cil_pp_checksum ;
  long *__cil_fp_checksum ;
  node_t *root_ssa_1 ;
  long checksum_ssa_1 ;
  node_t *node_ssa_1 ;
  node_t *tmp_ssa_1 ;
  long checksum_ssa_2 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  node_p *__cil_tmp16 ;
  cost_t *mem_14 ;

  {
#line 71
  __cil_fp_checksum = & checksum;
#line 71
  __cil_pp_checksum = & checksum;
#line 71
  return babel_wrapper_refresh_potential(__cil_pp_checksum, __cil_fp_checksum, net);
#line 71
  __cil_pp_checksum = & checksum;
#line 72
  __cil_fp_checksum = & checksum;
#line 75
  __cil_tmp13 = (unsigned char *)net + 552;
#line 75
  __cil_tmp14 = (node_p *)__cil_tmp13;
#line 75
  root_ssa_1 = *__cil_tmp14;
#line 76
  checksum_ssa_1 = 0L;
#line 79
  mem_14 = (cost_t *)root_ssa_1;
#line 79
  *mem_14 = -100000000L;
#line 80
  __cil_tmp15 = (unsigned char *)root_ssa_1 + 16;
#line 80
  __cil_tmp16 = (node_p *)__cil_tmp15;
#line 80
  node_ssa_1 = *__cil_tmp16;
#line 80
  tmp_ssa_1 = node_ssa_1;
#line 83
  *__cil_fp_checksum = checksum_ssa_1;
#line 81
  refresh_potential_cil_lr_1(__cil_pp_checksum, node_ssa_1, tmp_ssa_1, root_ssa_1);
#line 82
  checksum_ssa_2 = *__cil_fp_checksum;
#line 112
  return (checksum_ssa_2);
}
}
#line 122 "mcfutil.c"
double flow_cost(network_t *net ) 
{ 
  long fleet ;
  cost_t operational_cost ;
  network_t **__cil_pp_net ;
  long *__cil_pp_fleet ;
  cost_t *__cil_pp_operational_cost ;
  network_t **__cil_fp_net ;
  long *__cil_fp_fleet ;
  cost_t *__cil_fp_operational_cost ;
  long fleet_ssa_1 ;
  cost_t operational_cost_ssa_1 ;
  void *stop_ssa_1 ;
  arc_t *arc_ssa_1 ;
  network_t *net_ssa_1 ;
  long fleet_ssa_2 ;
  cost_t operational_cost_ssa_2 ;
  void *stop_ssa_2 ;
  node_t *node_ssa_1 ;
  node_t *node_ssa_2 ;
  network_t *net_ssa_2 ;
  long fleet_ssa_3 ;
  cost_t operational_cost_ssa_3 ;
  void *stop_ssa_3 ;
  arc_t *arc_ssa_2 ;
  network_t *net_ssa_3 ;
  long fleet_ssa_4 ;
  cost_t operational_cost_ssa_4 ;
  double __cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  arc_p *__cil_tmp35 ;
  arc_p __cil_tmp36 ;
  unsigned char *__cil_tmp37 ;
  arc_p *__cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  node_p *__cil_tmp40 ;
  node_p __cil_tmp41 ;
  unsigned char *__cil_tmp42 ;
  node_p *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  arc_p *__cil_tmp45 ;
  arc_p __cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  arc_p *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  long *__cil_tmp50 ;
  long __cil_tmp51 ;
  double __cil_tmp52 ;
  double __cil_tmp53 ;

  {
#line 126
  __cil_pp_net = & net;
#line 127
  __cil_pp_fleet = & fleet;
#line 128
  __cil_pp_operational_cost = & operational_cost;
#line 129
  __cil_fp_net = & net;
#line 130
  __cil_fp_fleet = & fleet;
#line 131
  __cil_fp_operational_cost = & operational_cost;
#line 132
  fleet_ssa_1 = 0L;
#line 133
  operational_cost_ssa_1 = (cost_t )0;
#line 136
  __cil_tmp34 = (unsigned char *)net + 576;
#line 136
  __cil_tmp35 = (arc_p *)__cil_tmp34;
#line 136
  __cil_tmp36 = *__cil_tmp35;
#line 136
  stop_ssa_1 = (void *)__cil_tmp36;
#line 137
  __cil_tmp37 = (unsigned char *)net + 568;
#line 137
  __cil_tmp38 = (arc_p *)__cil_tmp37;
#line 137
  arc_ssa_1 = *__cil_tmp38;
#line 140
  *__cil_fp_net = net;
#line 141
  *__cil_fp_fleet = fleet_ssa_1;
#line 142
  *__cil_fp_operational_cost = operational_cost_ssa_1;
#line 137
  flow_cost_cil_lr_1(__cil_pp_net, __cil_pp_fleet, __cil_pp_operational_cost, arc_ssa_1,
                     stop_ssa_1);
#line 139
  net_ssa_1 = *__cil_fp_net;
#line 140
  fleet_ssa_2 = *__cil_fp_fleet;
#line 141
  operational_cost_ssa_2 = *__cil_fp_operational_cost;
#line 145
  __cil_tmp39 = (unsigned char *)net_ssa_1 + 560;
#line 145
  __cil_tmp40 = (node_p *)__cil_tmp39;
#line 145
  __cil_tmp41 = *__cil_tmp40;
#line 145
  stop_ssa_2 = (void *)__cil_tmp41;
#line 146
  __cil_tmp42 = (unsigned char *)net_ssa_1 + 552;
#line 146
  __cil_tmp43 = (node_p *)__cil_tmp42;
#line 146
  node_ssa_1 = *__cil_tmp43;
#line 146
  node_ssa_2 = node_ssa_1 + 1;
#line 149
  *__cil_fp_net = net_ssa_1;
#line 150
  *__cil_fp_fleet = fleet_ssa_2;
#line 151
  *__cil_fp_operational_cost = operational_cost_ssa_2;
#line 146
  flow_cost_cil_lr_2(__cil_pp_net, __cil_pp_fleet, __cil_pp_operational_cost, node_ssa_2,
                     stop_ssa_2);
#line 148
  net_ssa_2 = *__cil_fp_net;
#line 149
  fleet_ssa_3 = *__cil_fp_fleet;
#line 150
  operational_cost_ssa_3 = *__cil_fp_operational_cost;
#line 149
  __cil_tmp44 = (unsigned char *)net_ssa_2 + 576;
#line 149
  __cil_tmp45 = (arc_p *)__cil_tmp44;
#line 149
  __cil_tmp46 = *__cil_tmp45;
#line 149
  stop_ssa_3 = (void *)__cil_tmp46;
#line 150
  __cil_tmp47 = (unsigned char *)net_ssa_2 + 568;
#line 150
  __cil_tmp48 = (arc_p *)__cil_tmp47;
#line 150
  arc_ssa_2 = *__cil_tmp48;
#line 153
  *__cil_fp_net = net_ssa_2;
#line 154
  *__cil_fp_fleet = fleet_ssa_3;
#line 155
  *__cil_fp_operational_cost = operational_cost_ssa_3;
#line 150
  flow_cost_cil_lr_3(__cil_pp_net, __cil_pp_fleet, __cil_pp_operational_cost, arc_ssa_2,
                     stop_ssa_3);
#line 152
  net_ssa_3 = *__cil_fp_net;
#line 153
  fleet_ssa_4 = *__cil_fp_fleet;
#line 154
  operational_cost_ssa_4 = *__cil_fp_operational_cost;
#line 170
  __cil_tmp49 = (unsigned char *)net_ssa_3 + 528;
#line 170
  __cil_tmp50 = (long *)__cil_tmp49;
#line 170
  __cil_tmp51 = *__cil_tmp50;
#line 170
  __cil_tmp52 = (double )__cil_tmp51;
#line 170
  __cil_tmp53 = (double )fleet_ssa_4 * __cil_tmp52;
#line 170
  __cil_tmp33 = __cil_tmp53 + (double )operational_cost_ssa_4;
#line 170
  return (__cil_tmp33);
}
}
#line 181 "mcfutil.c"
double flow_org_cost(network_t *net ) 
{ 
  long fleet ;
  cost_t operational_cost ;
  network_t **__cil_pp_net ;
  long *__cil_pp_fleet ;
  cost_t *__cil_pp_operational_cost ;
  network_t **__cil_fp_net ;
  long *__cil_fp_fleet ;
  cost_t *__cil_fp_operational_cost ;
  long fleet_ssa_1 ;
  cost_t operational_cost_ssa_1 ;
  void *stop_ssa_1 ;
  arc_t *arc_ssa_1 ;
  network_t *net_ssa_1 ;
  long fleet_ssa_2 ;
  cost_t operational_cost_ssa_2 ;
  void *stop_ssa_2 ;
  node_t *node_ssa_1 ;
  node_t *node_ssa_2 ;
  network_t *net_ssa_2 ;
  long fleet_ssa_3 ;
  cost_t operational_cost_ssa_3 ;
  void *stop_ssa_3 ;
  arc_t *arc_ssa_2 ;
  network_t *net_ssa_3 ;
  long fleet_ssa_4 ;
  cost_t operational_cost_ssa_4 ;
  double __cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  arc_p *__cil_tmp33 ;
  arc_p __cil_tmp34 ;
  unsigned char *__cil_tmp35 ;
  arc_p *__cil_tmp36 ;
  unsigned char *__cil_tmp37 ;
  node_p *__cil_tmp38 ;
  node_p __cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  node_p *__cil_tmp41 ;
  unsigned char *__cil_tmp42 ;
  arc_p *__cil_tmp43 ;
  arc_p __cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  arc_p *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  long *__cil_tmp48 ;
  long __cil_tmp49 ;
  double __cil_tmp50 ;
  double __cil_tmp51 ;

  {
#line 185
  __cil_fp_operational_cost = & operational_cost;
#line 185
  __cil_fp_fleet = & fleet;
#line 185
  __cil_fp_net = & net;
#line 185
  __cil_pp_operational_cost = & operational_cost;
#line 185
  __cil_pp_fleet = & fleet;
#line 185
  __cil_pp_net = & net;
#line 185
  return babel_wrapper_flow_org_cost(__cil_pp_net, __cil_pp_fleet, __cil_pp_operational_cost,
                                     __cil_fp_net, __cil_fp_fleet, __cil_fp_operational_cost,
                                     net);
#line 185
  __cil_pp_net = & net;
#line 186
  __cil_pp_fleet = & fleet;
#line 187
  __cil_pp_operational_cost = & operational_cost;
#line 188
  __cil_fp_net = & net;
#line 189
  __cil_fp_fleet = & fleet;
#line 190
  __cil_fp_operational_cost = & operational_cost;
#line 191
  fleet_ssa_1 = 0L;
#line 192
  operational_cost_ssa_1 = (cost_t )0;
#line 195
  __cil_tmp32 = (unsigned char *)net + 576;
#line 195
  __cil_tmp33 = (arc_p *)__cil_tmp32;
#line 195
  __cil_tmp34 = *__cil_tmp33;
#line 195
  stop_ssa_1 = (void *)__cil_tmp34;
#line 196
  __cil_tmp35 = (unsigned char *)net + 568;
#line 196
  __cil_tmp36 = (arc_p *)__cil_tmp35;
#line 196
  arc_ssa_1 = *__cil_tmp36;
#line 199
  *__cil_fp_net = net;
#line 200
  *__cil_fp_fleet = fleet_ssa_1;
#line 201
  *__cil_fp_operational_cost = operational_cost_ssa_1;
#line 196
  flow_org_cost_cil_lr_1(__cil_pp_net, __cil_pp_fleet, __cil_pp_operational_cost,
                         arc_ssa_1, stop_ssa_1);
#line 198
  net_ssa_1 = *__cil_fp_net;
#line 199
  fleet_ssa_2 = *__cil_fp_fleet;
#line 200
  operational_cost_ssa_2 = *__cil_fp_operational_cost;
#line 204
  __cil_tmp37 = (unsigned char *)net_ssa_1 + 560;
#line 204
  __cil_tmp38 = (node_p *)__cil_tmp37;
#line 204
  __cil_tmp39 = *__cil_tmp38;
#line 204
  stop_ssa_2 = (void *)__cil_tmp39;
#line 205
  __cil_tmp40 = (unsigned char *)net_ssa_1 + 552;
#line 205
  __cil_tmp41 = (node_p *)__cil_tmp40;
#line 205
  node_ssa_1 = *__cil_tmp41;
#line 205
  node_ssa_2 = node_ssa_1 + 1;
#line 208
  *__cil_fp_net = net_ssa_1;
#line 209
  *__cil_fp_fleet = fleet_ssa_2;
#line 210
  *__cil_fp_operational_cost = operational_cost_ssa_2;
#line 205
  flow_org_cost_cil_lr_2(__cil_pp_net, __cil_pp_fleet, __cil_pp_operational_cost,
                         node_ssa_2, stop_ssa_2);
#line 207
  net_ssa_2 = *__cil_fp_net;
#line 208
  fleet_ssa_3 = *__cil_fp_fleet;
#line 209
  operational_cost_ssa_3 = *__cil_fp_operational_cost;
#line 208
  __cil_tmp42 = (unsigned char *)net_ssa_2 + 576;
#line 208
  __cil_tmp43 = (arc_p *)__cil_tmp42;
#line 208
  __cil_tmp44 = *__cil_tmp43;
#line 208
  stop_ssa_3 = (void *)__cil_tmp44;
#line 209
  __cil_tmp45 = (unsigned char *)net_ssa_2 + 568;
#line 209
  __cil_tmp46 = (arc_p *)__cil_tmp45;
#line 209
  arc_ssa_2 = *__cil_tmp46;
#line 212
  *__cil_fp_net = net_ssa_2;
#line 213
  *__cil_fp_fleet = fleet_ssa_3;
#line 214
  *__cil_fp_operational_cost = operational_cost_ssa_3;
#line 209
  flow_org_cost_cil_lr_3(__cil_pp_net, __cil_pp_fleet, __cil_pp_operational_cost,
                         arc_ssa_2, stop_ssa_3);
#line 211
  net_ssa_3 = *__cil_fp_net;
#line 212
  fleet_ssa_4 = *__cil_fp_fleet;
#line 213
  operational_cost_ssa_4 = *__cil_fp_operational_cost;
#line 235
  __cil_tmp47 = (unsigned char *)net_ssa_3 + 528;
#line 235
  __cil_tmp48 = (long *)__cil_tmp47;
#line 235
  __cil_tmp49 = *__cil_tmp48;
#line 235
  __cil_tmp50 = (double )__cil_tmp49;
#line 235
  __cil_tmp51 = (double )fleet_ssa_4 * __cil_tmp50;
#line 235
  __cil_tmp31 = __cil_tmp51 + (double )operational_cost_ssa_4;
#line 235
  return (__cil_tmp31);
}
}
#line 239 "mcfutil.c"
long primal_feasible(network_t *net ) 
{ 
  long __cil_ret12 ;
  network_t **__cil_pp_net ;
  long *__cil_pp___cil_ret12 ;
  network_t **__cil_fp_net ;
  long *__cil_fp___cil_ret12 ;
  arc_t *dummy_ssa_1 ;
  arc_t *stop_dummy_ssa_1 ;
  node_t *node_ssa_1 ;
  void *stop_ssa_1 ;
  node_t *node_ssa_2 ;
  int retflag13_ssa_1 ;
  network_t *net_ssa_1 ;
  long __cil_ret12_ssa_1 ;
  unsigned char *__cil_tmp27 ;
  arc_p *__cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  arc_p *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  node_p *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  node_p *__cil_tmp34 ;
  node_p __cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  long *__cil_tmp37 ;

  {
#line 242
  __cil_fp___cil_ret12 = & __cil_ret12;
#line 242
  __cil_fp_net = & net;
#line 242
  __cil_pp___cil_ret12 = & __cil_ret12;
#line 242
  __cil_pp_net = & net;
#line 242
  return babel_wrapper_primal_feasible(__cil_pp_net, __cil_pp___cil_ret12, __cil_fp_net,
                                       __cil_fp___cil_ret12, net);
#line 242
  __cil_pp_net = & net;
#line 243
  __cil_pp___cil_ret12 = & __cil_ret12;
#line 244
  __cil_fp_net = & net;
#line 245
  __cil_fp___cil_ret12 = & __cil_ret12;
#line 247
  __cil_tmp27 = (unsigned char *)net + 584;
#line 247
  __cil_tmp28 = (arc_p *)__cil_tmp27;
#line 247
  dummy_ssa_1 = *__cil_tmp28;
#line 248
  __cil_tmp29 = (unsigned char *)net + 592;
#line 248
  __cil_tmp30 = (arc_p *)__cil_tmp29;
#line 248
  stop_dummy_ssa_1 = *__cil_tmp30;
#line 253
  __cil_tmp31 = (unsigned char *)net + 552;
#line 253
  __cil_tmp32 = (node_p *)__cil_tmp31;
#line 253
  node_ssa_1 = *__cil_tmp32;
#line 254
  __cil_tmp33 = (unsigned char *)net + 560;
#line 254
  __cil_tmp34 = (node_p *)__cil_tmp33;
#line 254
  __cil_tmp35 = *__cil_tmp34;
#line 254
  stop_ssa_1 = (void *)__cil_tmp35;
#line 257
  node_ssa_2 = node_ssa_1 + 1;
#line 261
  *__cil_fp_net = net;
#line 262
  *__cil_fp___cil_ret12 = __cil_ret12;
#line 257
  retflag13_ssa_1 = primal_feasible_cil_lr_1(__cil_pp_net, __cil_pp___cil_ret12, stop_ssa_1,
                                             node_ssa_2, dummy_ssa_1, stop_dummy_ssa_1);
#line 259
  net_ssa_1 = *__cil_fp_net;
#line 260
  __cil_ret12_ssa_1 = *__cil_fp___cil_ret12;
#line 257
  if (retflag13_ssa_1 != 0) {
#line 257
    return (__cil_ret12_ssa_1);
  } else {
#line 286
    __cil_tmp36 = (unsigned char *)net_ssa_1 + 488;
#line 286
    __cil_tmp37 = (long *)__cil_tmp36;
#line 286
    *__cil_tmp37 = 1L;
#line 288
    return (0L);
  }
}
}
#line 297 "mcfutil.c"
long dual_feasible(network_t *net ) 
{ 
  int cond ;
  struct _IO_FILE **__cil_pp_stderr ;
  int *__cil_pp_cond ;
  struct _IO_FILE **__cil_gp_stderr ;
  int *__cil_fp_cond ;
  arc_t *stop_ssa_1 ;
  int cond_ssa_1 ;
  arc_t *arc_ssa_1 ;
  int cond_ssa_2 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  arc_p *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  arc_p *__cil_tmp18 ;
  struct _IO_FILE *__cil_tmp19 ;
  struct _IO_FILE *__cil_tmp20 ;

  {
#line 300
  __cil_fp_cond = & cond;
#line 300
  __cil_gp_stderr = & stderr;
#line 300
  __cil_pp_cond = & cond;
#line 300
  __cil_pp_stderr = & stderr;
#line 300
  return babel_wrapper_dual_feasible(__cil_pp_stderr, __cil_pp_cond, __cil_gp_stderr,
                                     __cil_fp_cond, net);
#line 300
  __cil_pp_stderr = & stderr;
#line 301
  __cil_pp_cond = & cond;
#line 302
  __cil_gp_stderr = & stderr;
#line 303
  __cil_fp_cond = & cond;
#line 304
  __cil_tmp15 = (unsigned char *)net + 576;
#line 304
  __cil_tmp16 = (arc_p *)__cil_tmp15;
#line 304
  stop_ssa_1 = *__cil_tmp16;
#line 307
  cond_ssa_1 = 0;
#line 309
  __cil_tmp17 = (unsigned char *)net + 568;
#line 309
  __cil_tmp18 = (arc_p *)__cil_tmp17;
#line 309
  arc_ssa_1 = *__cil_tmp18;
#line 312
  *__cil_fp_cond = cond_ssa_1;
#line 309
  dual_feasible_cil_lr_1(__cil_pp_stderr, __cil_pp_cond, net, arc_ssa_1, stop_ssa_1);
#line 310
  cond_ssa_2 = *__cil_fp_cond;
#line 327
  __cil_tmp14 = cond_ssa_2 == 1;
#line 327
  if (__cil_tmp14 != 0) {
#line 328
    __cil_tmp19 = *__cil_gp_stderr;
#line 328
    fprintf((FILE * __restrict  )__cil_tmp19, (char const   * __restrict  )"DUAL NETWORK SIMPLEX: ");
#line 329
    __cil_tmp20 = *__cil_gp_stderr;
#line 329
    fprintf((FILE * __restrict  )__cil_tmp20, (char const   * __restrict  )"basis dual infeasible\n");
#line 330
    return (1L);
  } else {
#line 333
    return (0L);
  }
}
}
#line 369 "mcfutil.c"
long getfree(network_t *net ) 
{ 
  node_p tmp_ssa_1 ;
  arc_p tmp___0_ssa_1 ;
  arc_p tmp___1_ssa_1 ;
  node_p __cil_tmp8 ;
  arc_p __cil_tmp9 ;
  arc_p __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  node_p *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  node_p __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  arc_p *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  arc_p *__cil_tmp19 ;
  arc_p __cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  arc_p *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  arc_p *__cil_tmp24 ;
  arc_p __cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  node_p *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  node_p *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  arc_p *__cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  arc_p *__cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  arc_p *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  arc_p *__cil_tmp37 ;

  {

#line 377
  return babel_wrapper_getfree(net);
#line 377
  __cil_tmp11 = (unsigned char *)net + 552;
#line 377
  __cil_tmp12 = (node_p *)__cil_tmp11;
#line 377
  __cil_tmp8 = *__cil_tmp12;
#line 377
  if (__cil_tmp8 != 0) {
#line 377
    __cil_tmp13 = (unsigned char *)net + 552;
#line 377
    __cil_tmp14 = (node_p *)__cil_tmp13;
#line 377
    __cil_tmp15 = *__cil_tmp14;
#line 377
    free((void *)__cil_tmp15);
  } else {

  }
#line 378
  __cil_tmp16 = (unsigned char *)net + 568;
#line 378
  __cil_tmp17 = (arc_p *)__cil_tmp16;
#line 378
  __cil_tmp9 = *__cil_tmp17;
#line 378
  if (__cil_tmp9 != 0) {
#line 378
    __cil_tmp18 = (unsigned char *)net + 568;
#line 378
    __cil_tmp19 = (arc_p *)__cil_tmp18;
#line 378
    __cil_tmp20 = *__cil_tmp19;
#line 378
    free((void *)__cil_tmp20);
  } else {

  }
#line 379
  __cil_tmp21 = (unsigned char *)net + 584;
#line 379
  __cil_tmp22 = (arc_p *)__cil_tmp21;
#line 379
  __cil_tmp10 = *__cil_tmp22;
#line 379
  if (__cil_tmp10 != 0) {
#line 379
    __cil_tmp23 = (unsigned char *)net + 584;
#line 379
    __cil_tmp24 = (arc_p *)__cil_tmp23;
#line 379
    __cil_tmp25 = *__cil_tmp24;
#line 379
    free((void *)__cil_tmp25);
  } else {

  }
#line 380
  tmp_ssa_1 = (node_p )0;
#line 380
  __cil_tmp26 = (unsigned char *)net + 560;
#line 380
  __cil_tmp27 = (node_p *)__cil_tmp26;
#line 380
  *__cil_tmp27 = tmp_ssa_1;
#line 380
  __cil_tmp28 = (unsigned char *)net + 552;
#line 380
  __cil_tmp29 = (node_p *)__cil_tmp28;
#line 380
  *__cil_tmp29 = tmp_ssa_1;
#line 381
  tmp___0_ssa_1 = (arc_p )0;
#line 381
  __cil_tmp30 = (unsigned char *)net + 576;
#line 381
  __cil_tmp31 = (arc_p *)__cil_tmp30;
#line 381
  *__cil_tmp31 = tmp___0_ssa_1;
#line 381
  __cil_tmp32 = (unsigned char *)net + 568;
#line 381
  __cil_tmp33 = (arc_p *)__cil_tmp32;
#line 381
  *__cil_tmp33 = tmp___0_ssa_1;
#line 382
  tmp___1_ssa_1 = (arc_p )0;
#line 382
  __cil_tmp34 = (unsigned char *)net + 592;
#line 382
  __cil_tmp35 = (arc_p *)__cil_tmp34;
#line 382
  *__cil_tmp35 = tmp___1_ssa_1;
#line 382
  __cil_tmp36 = (unsigned char *)net + 584;
#line 382
  __cil_tmp37 = (arc_p *)__cil_tmp36;
#line 382
  *__cil_tmp37 = tmp___1_ssa_1;
#line 384
  return (0L);
}
}
#line 387 "mcfutil.c"
void refresh_potential_cil_lr_1_cil_lr_1(node_t **__cil_ap_tmp , node_t **__cil_ap_root ,
                                         long *__cil_ap_checksum , node_t *node ) 
{ 
  node_t *node_ssa_1 ;
  int __cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  int *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  arc_p *__cil_tmp11 ;
  arc_p __cil_tmp12 ;
  cost_t *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  node_p *__cil_tmp15 ;
  node_p __cil_tmp16 ;
  cost_t *__cil_tmp17 ;
  cost_t __cil_tmp18 ;
  cost_t __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  node_p *__cil_tmp21 ;
  node_p __cil_tmp22 ;
  cost_t *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  arc_p *__cil_tmp25 ;
  arc_p __cil_tmp26 ;
  cost_t *__cil_tmp27 ;
  cost_t __cil_tmp28 ;
  cost_t __cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  node_p *__cil_tmp32 ;
  cost_t *mem_35 ;
  cost_t *mem_36 ;

  {

#line 83
  return babel_wrapper_refresh_potential_cil_lr_1_cil_lr_1(__cil_ap_tmp, __cil_ap_root,
                                                           __cil_ap_checksum, node);
#line 83
  if (node != 0) {
#line 85
    __cil_tmp7 = (unsigned char *)node + 8;
#line 85
    __cil_tmp8 = (int *)__cil_tmp7;
#line 85
    __cil_tmp9 = *__cil_tmp8;
#line 85
    __cil_tmp6 = __cil_tmp9 == 1;
#line 85
    if (__cil_tmp6 != 0) {
#line 86
      __cil_tmp10 = (unsigned char *)node + 48;
#line 86
      __cil_tmp11 = (arc_p *)__cil_tmp10;
#line 86
      __cil_tmp12 = *__cil_tmp11;
#line 86
      __cil_tmp13 = (cost_t *)__cil_tmp12;
#line 86
      __cil_tmp14 = (unsigned char *)node + 24;
#line 86
      __cil_tmp15 = (node_p *)__cil_tmp14;
#line 86
      __cil_tmp16 = *__cil_tmp15;
#line 86
      __cil_tmp17 = (cost_t *)__cil_tmp16;
#line 86
      __cil_tmp18 = *__cil_tmp13;
#line 86
      __cil_tmp19 = *__cil_tmp17;
#line 86
      mem_35 = (cost_t *)node;
#line 86
      *mem_35 = __cil_tmp18 + __cil_tmp19;
    } else {
#line 89
      __cil_tmp20 = (unsigned char *)node + 24;
#line 89
      __cil_tmp21 = (node_p *)__cil_tmp20;
#line 89
      __cil_tmp22 = *__cil_tmp21;
#line 89
      __cil_tmp23 = (cost_t *)__cil_tmp22;
#line 89
      __cil_tmp24 = (unsigned char *)node + 48;
#line 89
      __cil_tmp25 = (arc_p *)__cil_tmp24;
#line 89
      __cil_tmp26 = *__cil_tmp25;
#line 89
      __cil_tmp27 = (cost_t *)__cil_tmp26;
#line 89
      __cil_tmp28 = *__cil_tmp23;
#line 89
      __cil_tmp29 = *__cil_tmp27;
#line 89
      mem_36 = (cost_t *)node;
#line 89
      *mem_36 = __cil_tmp28 - __cil_tmp29;
#line 90
      __cil_tmp30 = *__cil_ap_checksum;
#line 90
      *__cil_ap_checksum = __cil_tmp30 + 1L;
    }
#line 93
    *__cil_ap_tmp = node;
#line 94
    __cil_tmp31 = (unsigned char *)node + 16;
#line 94
    __cil_tmp32 = (node_p *)__cil_tmp31;
#line 94
    node_ssa_1 = *__cil_tmp32;
#line 97
    refresh_potential_cil_lr_1_cil_lr_1(__cil_ap_tmp, __cil_ap_root, __cil_ap_checksum,
                                        node_ssa_1);
#line 100
    return;
  } else {
#line 102
    return;
  }
}
}
#line 106 "mcfutil.c"
void refresh_potential_cil_lr_1_cil_lr_2(node_t **__cil_ap_node , node_t **__cil_ap_tmp ,
                                         node_t **__cil_ap_root ) 
{ 
  node_p __cil_tmp4 ;
  node_t *__cil_tmp5 ;
  node_t *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  node_p *__cil_tmp9 ;
  node_t *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  node_p *__cil_tmp13 ;
  node_t *__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  node_p *__cil_tmp17 ;

  {

#line 99
  return babel_wrapper_refresh_potential_cil_lr_1_cil_lr_2(__cil_ap_node, __cil_ap_tmp,
                                                           __cil_ap_root);
#line 99
  __cil_tmp6 = *__cil_ap_node;
#line 99
  __cil_tmp7 = (unsigned char *)__cil_tmp6;
#line 99
  __cil_tmp8 = __cil_tmp7 + 24;
#line 99
  __cil_tmp9 = (node_p *)__cil_tmp8;
#line 99
  __cil_tmp4 = *__cil_tmp9;
#line 99
  if (__cil_tmp4 != 0) {
#line 101
    __cil_tmp10 = *__cil_ap_node;
#line 101
    __cil_tmp11 = (unsigned char *)__cil_tmp10;
#line 101
    __cil_tmp12 = __cil_tmp11 + 32;
#line 101
    __cil_tmp13 = (node_p *)__cil_tmp12;
#line 101
    *__cil_ap_tmp = *__cil_tmp13;
#line 102
    __cil_tmp5 = *__cil_ap_tmp;
#line 102
    if (__cil_tmp5 != 0) {
#line 104
      *__cil_ap_node = *__cil_ap_tmp;
#line 106
      return;
    } else {
#line 108
      __cil_tmp14 = *__cil_ap_node;
#line 108
      __cil_tmp15 = (unsigned char *)__cil_tmp14;
#line 108
      __cil_tmp16 = __cil_tmp15 + 24;
#line 108
      __cil_tmp17 = (node_p *)__cil_tmp16;
#line 108
      *__cil_ap_node = *__cil_tmp17;
#line 111
      refresh_potential_cil_lr_1_cil_lr_2(__cil_ap_node, __cil_ap_tmp, __cil_ap_root);
#line 113
      return;
    }
  } else {
#line 117
    return;
  }
}
}
#line 122 "mcfutil.c"
void dual_feasible_cil_lr_1(struct _IO_FILE **__cil_ap_stderr , int *__cil_ap_cond ,
                            network_t *net , arc_t *arc , arc_t *stop ) 
{ 
  cost_t red_cost_ssa_1 ;
  arc_t *arc_ssa_1 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  node_p *__cil_tmp19 ;
  node_p __cil_tmp20 ;
  cost_t *__cil_tmp21 ;
  cost_t __cil_tmp22 ;
  cost_t __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  node_p *__cil_tmp25 ;
  node_p __cil_tmp26 ;
  cost_t *__cil_tmp27 ;
  cost_t __cil_tmp28 ;
  cost_t __cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  int *__cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  long *__cil_tmp34 ;
  long __cil_tmp35 ;
  long __cil_tmp36 ;
  unsigned char *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  long *__cil_tmp41 ;
  long __cil_tmp42 ;
  long __cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  int *__cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  long *__cil_tmp48 ;
  long __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  cost_t *mem_51 ;

  {
#line 309
  __cil_tmp9 = (unsigned long )arc < (unsigned long )stop;
#line 309
  if (__cil_tmp9 != 0) {
#line 311
    __cil_tmp18 = (unsigned char *)arc + 8;
#line 311
    __cil_tmp19 = (node_p *)__cil_tmp18;
#line 311
    __cil_tmp20 = *__cil_tmp19;
#line 311
    __cil_tmp21 = (cost_t *)__cil_tmp20;
#line 311
    mem_51 = (cost_t *)arc;
#line 311
    __cil_tmp22 = *mem_51;
#line 311
    __cil_tmp23 = *__cil_tmp21;
#line 311
    __cil_tmp24 = (unsigned char *)arc + 16;
#line 311
    __cil_tmp25 = (node_p *)__cil_tmp24;
#line 311
    __cil_tmp26 = *__cil_tmp25;
#line 311
    __cil_tmp27 = (cost_t *)__cil_tmp26;
#line 311
    __cil_tmp28 = __cil_tmp22 - __cil_tmp23;
#line 311
    __cil_tmp29 = *__cil_tmp27;
#line 311
    red_cost_ssa_1 = __cil_tmp28 + __cil_tmp29;
#line 313
    __cil_tmp30 = (unsigned char *)arc + 24;
#line 313
    __cil_tmp31 = (int *)__cil_tmp30;
#line 313
    __cil_tmp32 = *__cil_tmp31;
#line 313
    __cil_tmp10 = __cil_tmp32 == 0;
#line 313
    if (__cil_tmp10 != 0) {
#line 314
      __cil_tmp33 = (unsigned char *)net + 512;
#line 314
      __cil_tmp34 = (long *)__cil_tmp33;
#line 314
      __cil_tmp35 = *__cil_tmp34;
#line 314
      __cil_tmp36 = - __cil_tmp35;
#line 314
      __cil_tmp11 = red_cost_ssa_1 < __cil_tmp36;
#line 314
      if (__cil_tmp11 != 0) {
#line 315
        *__cil_ap_cond = 1;
      } else {

      }
    } else {
#line 316
      __cil_tmp37 = (unsigned char *)arc + 24;
#line 316
      __cil_tmp38 = (int *)__cil_tmp37;
#line 316
      __cil_tmp39 = *__cil_tmp38;
#line 316
      __cil_tmp12 = __cil_tmp39 == 1;
#line 316
      if (__cil_tmp12 != 0) {
#line 317
        __cil_tmp40 = (unsigned char *)net + 512;
#line 317
        __cil_tmp41 = (long *)__cil_tmp40;
#line 317
        __cil_tmp42 = *__cil_tmp41;
#line 317
        __cil_tmp43 = - __cil_tmp42;
#line 317
        __cil_tmp13 = red_cost_ssa_1 < __cil_tmp43;
#line 317
        if (__cil_tmp13 != 0) {
#line 318
          *__cil_ap_cond = 1;
        } else {

        }
      } else {
#line 319
        __cil_tmp44 = (unsigned char *)arc + 24;
#line 319
        __cil_tmp45 = (int *)__cil_tmp44;
#line 319
        __cil_tmp46 = *__cil_tmp45;
#line 319
        __cil_tmp14 = __cil_tmp46 == 2;
#line 319
        if (__cil_tmp14 != 0) {
#line 320
          __cil_tmp47 = (unsigned char *)net + 512;
#line 320
          __cil_tmp48 = (long *)__cil_tmp47;
#line 320
          __cil_tmp49 = *__cil_tmp48;
#line 320
          __cil_tmp15 = red_cost_ssa_1 > __cil_tmp49;
#line 320
          if (__cil_tmp15 != 0) {
#line 321
            *__cil_ap_cond = 1;
          } else {

          }
        } else {

        }
      }
    }
#line 324
    __cil_tmp50 = *__cil_ap_cond;
#line 324
    __cil_tmp16 = __cil_tmp50 == 1;
#line 324
    if (__cil_tmp16 != 0) {
#line 325
      return;
    } else {
#line 309
      arc_ssa_1 = arc + 1;
#line 312
      dual_feasible_cil_lr_1(__cil_ap_stderr, __cil_ap_cond, net, arc_ssa_1, stop);
#line 314
      return;
    }
  } else {
#line 318
    return;
  }
#line 324
  __cil_tmp51 = *__cil_ap_cond;
#line 324
  __cil_tmp17 = __cil_tmp51 == 1;
#line 324
  if (__cil_tmp17 != 0) {
#line 325
    return;
  } else {
#line 309
    arc_ssa_1 = arc + 1;
#line 312
    dual_feasible_cil_lr_1(__cil_ap_stderr, __cil_ap_cond, net, arc_ssa_1, stop);
#line 314
    return;
  }
}
}
#line 319 "mcfutil.c"
int primal_feasible_cil_lr_1(network_t **__cil_ap_net , long *__cil_ap___cil_ret12 ,
                             void *stop , node_t *node , arc_t *dummy , arc_t *stop_dummy ) 
{ 
  flow_t flow ;
  int tmp ;
  arc_t *arc_ssa_1 ;
  flow_t flow_ssa_1 ;
  int tmp_ssa_1 ;
  int cond_ssa_1 ;
  flow_t tmp___0_ssa_1 ;
  node_t *node_ssa_1 ;
  int retflag13_ssa_1 ;
  int tmp___1_ssa_1 ;
  int cond_ssa_2 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  arc_p *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  flow_t *__cil_tmp37 ;
  network_t *__cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  long *__cil_tmp41 ;
  long __cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  int *__cil_tmp44 ;
  int __cil_tmp45 ;
  network_t *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  unsigned char *__cil_tmp48 ;
  long *__cil_tmp49 ;
  long __cil_tmp50 ;
  long __cil_tmp51 ;
  network_t *__cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  long *__cil_tmp55 ;
  flow_t __cil_tmp56 ;
  long __cil_tmp57 ;
  network_t *__cil_tmp58 ;
  unsigned char *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  long *__cil_tmp61 ;
  network_t *__cil_tmp62 ;
  unsigned char *__cil_tmp63 ;
  unsigned char *__cil_tmp64 ;
  long *__cil_tmp65 ;
  long __cil_tmp66 ;
  unsigned char *__cil_tmp67 ;
  int *__cil_tmp68 ;
  int __cil_tmp69 ;
  network_t *__cil_tmp70 ;
  unsigned char *__cil_tmp71 ;
  unsigned char *__cil_tmp72 ;
  long *__cil_tmp73 ;
  long __cil_tmp74 ;
  long __cil_tmp75 ;
  network_t *__cil_tmp76 ;
  unsigned char *__cil_tmp77 ;
  unsigned char *__cil_tmp78 ;
  long *__cil_tmp79 ;
  flow_t __cil_tmp80 ;
  long __cil_tmp81 ;
  network_t *__cil_tmp82 ;
  unsigned char *__cil_tmp83 ;
  unsigned char *__cil_tmp84 ;
  long *__cil_tmp85 ;

  {
#line 257
  __cil_tmp23 = (unsigned long )node < (unsigned long )((node_t *)stop);
#line 257
  if (__cil_tmp23 != 0) {
#line 259
    __cil_tmp34 = (unsigned char *)node + 48;
#line 259
    __cil_tmp35 = (arc_p *)__cil_tmp34;
#line 259
    arc_ssa_1 = *__cil_tmp35;
#line 260
    __cil_tmp36 = (unsigned char *)node + 80;
#line 260
    __cil_tmp37 = (flow_t *)__cil_tmp36;
#line 260
    flow_ssa_1 = *__cil_tmp37;
#line 261
    __cil_tmp24 = (unsigned long )arc_ssa_1 >= (unsigned long )dummy;
#line 261
    if (__cil_tmp24 != 0) {
#line 261
      __cil_tmp25 = (unsigned long )arc_ssa_1 < (unsigned long )stop_dummy;
#line 261
      if (__cil_tmp25 != 0) {
#line 261
        tmp_ssa_1 = 1;
      } else {
#line 261
        tmp_ssa_1 = 0;
      }
    } else {
#line 261
      tmp_ssa_1 = 0;
    }
#line 261
    cond_ssa_1 = tmp_ssa_1;
#line 262
    if (cond_ssa_1 != 0) {
#line 264
      __cil_tmp26 = flow_ssa_1 >= 0L;
#line 264
      if (__cil_tmp26 != 0) {
#line 264
        tmp___0_ssa_1 = flow_ssa_1;
      } else {
#line 264
        tmp___0_ssa_1 = - flow_ssa_1;
      }
#line 264
      __cil_tmp38 = *__cil_ap_net;
#line 264
      __cil_tmp39 = (unsigned char *)__cil_tmp38;
#line 264
      __cil_tmp40 = __cil_tmp39 + 512;
#line 264
      __cil_tmp41 = (long *)__cil_tmp40;
#line 264
      __cil_tmp42 = *__cil_tmp41;
#line 264
      __cil_tmp27 = tmp___0_ssa_1 > __cil_tmp42;
#line 264
      if (__cil_tmp27 != 0) {
#line 266
        printf((char const   * __restrict  )"PRIMAL NETWORK SIMPLEX: ");
#line 267
        __cil_tmp43 = (unsigned char *)node + 96;
#line 267
        __cil_tmp44 = (int *)__cil_tmp43;
#line 267
        __cil_tmp45 = *__cil_tmp44;
#line 267
        printf((char const   * __restrict  )"artificial arc with nonzero flow, node %d (%ld)\n",
               __cil_tmp45, flow_ssa_1);
      } else {

      }
#line 257
      node_ssa_1 = node + 1;
#line 260
      retflag13_ssa_1 = primal_feasible_cil_lr_1(__cil_ap_net, __cil_ap___cil_ret12,
                                                 stop, node_ssa_1, dummy, stop_dummy);
#line 263
      return (retflag13_ssa_1);
    } else {
#line 273
      __cil_tmp46 = *__cil_ap_net;
#line 273
      __cil_tmp47 = (unsigned char *)__cil_tmp46;
#line 273
      __cil_tmp48 = __cil_tmp47 + 512;
#line 273
      __cil_tmp49 = (long *)__cil_tmp48;
#line 273
      __cil_tmp50 = *__cil_tmp49;
#line 273
      __cil_tmp51 = - __cil_tmp50;
#line 273
      __cil_tmp28 = flow_ssa_1 < __cil_tmp51;
#line 273
      if (__cil_tmp28 != 0) {
#line 273
        tmp___1_ssa_1 = 1;
      } else {
#line 273
        __cil_tmp52 = *__cil_ap_net;
#line 273
        __cil_tmp53 = (unsigned char *)__cil_tmp52;
#line 273
        __cil_tmp54 = __cil_tmp53 + 512;
#line 273
        __cil_tmp55 = (long *)__cil_tmp54;
#line 273
        __cil_tmp56 = flow_ssa_1 - 1L;
#line 273
        __cil_tmp57 = *__cil_tmp55;
#line 273
        __cil_tmp29 = __cil_tmp56 > __cil_tmp57;
#line 273
        if (__cil_tmp29 != 0) {
#line 273
          tmp___1_ssa_1 = 1;
        } else {
#line 273
          tmp___1_ssa_1 = 0;
        }
      }
#line 273
      cond_ssa_2 = tmp___1_ssa_1;
#line 276
      if (cond_ssa_2 != 0) {
#line 278
        printf((char const   * __restrict  )"PRIMAL NETWORK SIMPLEX: ");
#line 279
        printf((char const   * __restrict  )"basis primal infeasible (%ld)\n", flow_ssa_1);
#line 280
        __cil_tmp58 = *__cil_ap_net;
#line 280
        __cil_tmp59 = (unsigned char *)__cil_tmp58;
#line 280
        __cil_tmp60 = __cil_tmp59 + 488;
#line 280
        __cil_tmp61 = (long *)__cil_tmp60;
#line 280
        *__cil_tmp61 = 0L;
#line 281
        *__cil_ap___cil_ret12 = 1L;
#line 283
        return (1);
      } else {
#line 257
        node_ssa_1 = node + 1;
#line 260
        retflag13_ssa_1 = primal_feasible_cil_lr_1(__cil_ap_net, __cil_ap___cil_ret12,
                                                   stop, node_ssa_1, dummy, stop_dummy);
#line 263
        return (retflag13_ssa_1);
      }
    }
  } else {
#line 267
    return (0);
  }
#line 261
  cond_ssa_1 = tmp;
#line 262
  if (cond_ssa_1 != 0) {
#line 264
    __cil_tmp30 = flow >= 0L;
#line 264
    if (__cil_tmp30 != 0) {
#line 264
      tmp___0_ssa_1 = flow;
    } else {
#line 264
      tmp___0_ssa_1 = - flow;
    }
#line 264
    __cil_tmp62 = *__cil_ap_net;
#line 264
    __cil_tmp63 = (unsigned char *)__cil_tmp62;
#line 264
    __cil_tmp64 = __cil_tmp63 + 512;
#line 264
    __cil_tmp65 = (long *)__cil_tmp64;
#line 264
    __cil_tmp66 = *__cil_tmp65;
#line 264
    __cil_tmp31 = tmp___0_ssa_1 > __cil_tmp66;
#line 264
    if (__cil_tmp31 != 0) {
#line 266
      printf((char const   * __restrict  )"PRIMAL NETWORK SIMPLEX: ");
#line 267
      __cil_tmp67 = (unsigned char *)node + 96;
#line 267
      __cil_tmp68 = (int *)__cil_tmp67;
#line 267
      __cil_tmp69 = *__cil_tmp68;
#line 267
      printf((char const   * __restrict  )"artificial arc with nonzero flow, node %d (%ld)\n",
             __cil_tmp69, flow);
    } else {

    }
#line 257
    node_ssa_1 = node + 1;
#line 260
    retflag13_ssa_1 = primal_feasible_cil_lr_1(__cil_ap_net, __cil_ap___cil_ret12,
                                               stop, node_ssa_1, dummy, stop_dummy);
#line 263
    return (retflag13_ssa_1);
  } else {
#line 273
    __cil_tmp70 = *__cil_ap_net;
#line 273
    __cil_tmp71 = (unsigned char *)__cil_tmp70;
#line 273
    __cil_tmp72 = __cil_tmp71 + 512;
#line 273
    __cil_tmp73 = (long *)__cil_tmp72;
#line 273
    __cil_tmp74 = *__cil_tmp73;
#line 273
    __cil_tmp75 = - __cil_tmp74;
#line 273
    __cil_tmp32 = flow < __cil_tmp75;
#line 273
    if (__cil_tmp32 != 0) {
#line 273
      tmp___1_ssa_1 = 1;
    } else {
#line 273
      __cil_tmp76 = *__cil_ap_net;
#line 273
      __cil_tmp77 = (unsigned char *)__cil_tmp76;
#line 273
      __cil_tmp78 = __cil_tmp77 + 512;
#line 273
      __cil_tmp79 = (long *)__cil_tmp78;
#line 273
      __cil_tmp80 = flow - 1L;
#line 273
      __cil_tmp81 = *__cil_tmp79;
#line 273
      __cil_tmp33 = __cil_tmp80 > __cil_tmp81;
#line 273
      if (__cil_tmp33 != 0) {
#line 273
        tmp___1_ssa_1 = 1;
      } else {
#line 273
        tmp___1_ssa_1 = 0;
      }
    }
#line 273
    cond_ssa_2 = tmp___1_ssa_1;
#line 276
    if (cond_ssa_2 != 0) {
#line 278
      printf((char const   * __restrict  )"PRIMAL NETWORK SIMPLEX: ");
#line 279
      printf((char const   * __restrict  )"basis primal infeasible (%ld)\n", flow);
#line 280
      __cil_tmp82 = *__cil_ap_net;
#line 280
      __cil_tmp83 = (unsigned char *)__cil_tmp82;
#line 280
      __cil_tmp84 = __cil_tmp83 + 488;
#line 280
      __cil_tmp85 = (long *)__cil_tmp84;
#line 280
      *__cil_tmp85 = 0L;
#line 281
      *__cil_ap___cil_ret12 = 1L;
#line 283
      return (1);
    } else {
#line 257
      node_ssa_1 = node + 1;
#line 260
      retflag13_ssa_1 = primal_feasible_cil_lr_1(__cil_ap_net, __cil_ap___cil_ret12,
                                                 stop, node_ssa_1, dummy, stop_dummy);
#line 263
      return (retflag13_ssa_1);
    }
  }
}
}
#line 268 "mcfutil.c"
void flow_org_cost_cil_lr_1(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                            arc_t *arc , void *stop ) 
{ 
  arc_t *arc_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  int *__cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  flow_t *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  flow_t *__cil_tmp15 ;

  {

#line 196
  return babel_wrapper_flow_org_cost_cil_lr_1(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                                              arc, stop);
#line 196
  __cil_tmp7 = (unsigned long )arc != (unsigned long )((arc_t *)stop);
#line 196
  if (__cil_tmp7 != 0) {
#line 198
    __cil_tmp9 = (unsigned char *)arc + 24;
#line 198
    __cil_tmp10 = (int *)__cil_tmp9;
#line 198
    __cil_tmp11 = *__cil_tmp10;
#line 198
    __cil_tmp8 = __cil_tmp11 == 2;
#line 198
    if (__cil_tmp8 != 0) {
#line 199
      __cil_tmp12 = (unsigned char *)arc + 48;
#line 199
      __cil_tmp13 = (flow_t *)__cil_tmp12;
#line 199
      *__cil_tmp13 = (flow_t )1;
    } else {
#line 201
      __cil_tmp14 = (unsigned char *)arc + 48;
#line 201
      __cil_tmp15 = (flow_t *)__cil_tmp14;
#line 201
      *__cil_tmp15 = (flow_t )0;
    }
#line 196
    arc_ssa_1 = arc + 1;
#line 199
    flow_org_cost_cil_lr_1(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                           arc_ssa_1, stop);
#line 202
    return;
  } else {
#line 204
    return;
  }
#line 196
  arc_ssa_1 = arc + 1;
#line 199
  flow_org_cost_cil_lr_1(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                         arc_ssa_1, stop);
#line 202
  return;
}
}
#line 205 "mcfutil.c"
void flow_org_cost_cil_lr_2(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                            node_t *node , void *stop ) 
{ 
  node_t *node_ssa_1 ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  flow_t *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  arc_p *__cil_tmp11 ;
  arc_p __cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  flow_t *__cil_tmp15 ;

  {

#line 205
  return babel_wrapper_flow_org_cost_cil_lr_2(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                                              node, stop);
#line 205
  __cil_tmp7 = (unsigned long )node != (unsigned long )((node_t *)stop);
#line 205
  if (__cil_tmp7 != 0) {
#line 206
    __cil_tmp8 = (unsigned char *)node + 80;
#line 206
    __cil_tmp9 = (flow_t *)__cil_tmp8;
#line 206
    __cil_tmp10 = (unsigned char *)node + 48;
#line 206
    __cil_tmp11 = (arc_p *)__cil_tmp10;
#line 206
    __cil_tmp12 = *__cil_tmp11;
#line 206
    __cil_tmp13 = (unsigned char *)__cil_tmp12;
#line 206
    __cil_tmp14 = __cil_tmp13 + 48;
#line 206
    __cil_tmp15 = (flow_t *)__cil_tmp14;
#line 206
    *__cil_tmp15 = *__cil_tmp9;
#line 205
    node_ssa_1 = node + 1;
#line 208
    flow_org_cost_cil_lr_2(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                           node_ssa_1, stop);
#line 211
    return;
  } else {
#line 213
    return;
  }
}
}
#line 218 "mcfutil.c"
void flow_org_cost_cil_lr_3(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                            arc_t *arc , void *stop ) 
{ 
  arc_t *arc_ssa_1 ;
  int __cil_tmp7 ;
  flow_t __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  flow_t *__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  node_p *__cil_tmp16 ;
  node_p __cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  int *__cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  node_p *__cil_tmp23 ;
  node_p __cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  unsigned char *__cil_tmp26 ;
  int *__cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  cost_t *__cil_tmp30 ;
  network_t *__cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  long *__cil_tmp34 ;
  cost_t __cil_tmp35 ;
  long __cil_tmp36 ;
  cost_t __cil_tmp37 ;
  cost_t __cil_tmp38 ;
  long __cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  cost_t *__cil_tmp41 ;
  cost_t __cil_tmp42 ;
  cost_t __cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  node_p *__cil_tmp45 ;
  node_p __cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  unsigned char *__cil_tmp48 ;
  int *__cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  node_p *__cil_tmp52 ;
  node_p __cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  unsigned char *__cil_tmp55 ;
  int *__cil_tmp56 ;
  int __cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  cost_t *__cil_tmp59 ;
  network_t *__cil_tmp60 ;
  unsigned char *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;
  long *__cil_tmp63 ;
  cost_t __cil_tmp64 ;
  long __cil_tmp65 ;
  cost_t __cil_tmp66 ;
  cost_t __cil_tmp67 ;
  long __cil_tmp68 ;
  unsigned char *__cil_tmp69 ;
  cost_t *__cil_tmp70 ;
  cost_t __cil_tmp71 ;
  cost_t __cil_tmp72 ;

  {

#line 209
  return babel_wrapper_flow_org_cost_cil_lr_3(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                                              arc, stop);
#line 209
  __cil_tmp7 = (unsigned long )arc != (unsigned long )((arc_t *)stop);
#line 209
  if (__cil_tmp7 != 0) {
#line 211
    __cil_tmp13 = (unsigned char *)arc + 48;
#line 211
    __cil_tmp14 = (flow_t *)__cil_tmp13;
#line 211
    __cil_tmp8 = *__cil_tmp14;
#line 211
    if (__cil_tmp8 != 0) {
#line 213
      __cil_tmp15 = (unsigned char *)arc + 8;
#line 213
      __cil_tmp16 = (node_p *)__cil_tmp15;
#line 213
      __cil_tmp17 = *__cil_tmp16;
#line 213
      __cil_tmp18 = (unsigned char *)__cil_tmp17;
#line 213
      __cil_tmp19 = __cil_tmp18 + 96;
#line 213
      __cil_tmp20 = (int *)__cil_tmp19;
#line 213
      __cil_tmp21 = *__cil_tmp20;
#line 213
      __cil_tmp9 = __cil_tmp21 >= 0;
#line 213
      if (__cil_tmp9 != 0) {
#line 215
        __cil_tmp22 = (unsigned char *)arc + 8;
#line 215
        __cil_tmp23 = (node_p *)__cil_tmp22;
#line 215
        __cil_tmp24 = *__cil_tmp23;
#line 215
        __cil_tmp25 = (unsigned char *)__cil_tmp24;
#line 215
        __cil_tmp26 = __cil_tmp25 + 96;
#line 215
        __cil_tmp27 = (int *)__cil_tmp26;
#line 215
        __cil_tmp28 = *__cil_tmp27;
#line 215
        __cil_tmp10 = ! __cil_tmp28;
#line 215
        if (__cil_tmp10 != 0) {
#line 217
          __cil_tmp29 = (unsigned char *)arc + 56;
#line 217
          __cil_tmp30 = (cost_t *)__cil_tmp29;
#line 217
          __cil_tmp31 = *__cil_ap_net;
#line 217
          __cil_tmp32 = (unsigned char *)__cil_tmp31;
#line 217
          __cil_tmp33 = __cil_tmp32 + 528;
#line 217
          __cil_tmp34 = (long *)__cil_tmp33;
#line 217
          __cil_tmp35 = *__cil_tmp30;
#line 217
          __cil_tmp36 = *__cil_tmp34;
#line 217
          __cil_tmp37 = *__cil_ap_operational_cost;
#line 217
          __cil_tmp38 = __cil_tmp35 - __cil_tmp36;
#line 217
          *__cil_ap_operational_cost = __cil_tmp37 + __cil_tmp38;
#line 218
          __cil_tmp39 = *__cil_ap_fleet;
#line 218
          *__cil_ap_fleet = __cil_tmp39 + 1L;
        } else {
#line 221
          __cil_tmp40 = (unsigned char *)arc + 56;
#line 221
          __cil_tmp41 = (cost_t *)__cil_tmp40;
#line 221
          __cil_tmp42 = *__cil_ap_operational_cost;
#line 221
          __cil_tmp43 = *__cil_tmp41;
#line 221
          *__cil_ap_operational_cost = __cil_tmp42 + __cil_tmp43;
        }
      } else {
#line 223
        __cil_tmp44 = (unsigned char *)arc + 16;
#line 223
        __cil_tmp45 = (node_p *)__cil_tmp44;
#line 223
        __cil_tmp46 = *__cil_tmp45;
#line 223
        __cil_tmp47 = (unsigned char *)__cil_tmp46;
#line 223
        __cil_tmp48 = __cil_tmp47 + 96;
#line 223
        __cil_tmp49 = (int *)__cil_tmp48;
#line 223
        __cil_tmp50 = *__cil_tmp49;
#line 223
        __cil_tmp11 = __cil_tmp50 <= 0;
#line 223
        if (__cil_tmp11 != 0) {
#line 224
          __cil_tmp51 = (unsigned char *)arc + 8;
#line 224
          __cil_tmp52 = (node_p *)__cil_tmp51;
#line 224
          __cil_tmp53 = *__cil_tmp52;
#line 224
          __cil_tmp54 = (unsigned char *)__cil_tmp53;
#line 224
          __cil_tmp55 = __cil_tmp54 + 96;
#line 224
          __cil_tmp56 = (int *)__cil_tmp55;
#line 224
          __cil_tmp57 = *__cil_tmp56;
#line 224
          __cil_tmp12 = ! __cil_tmp57;
#line 224
          if (__cil_tmp12 != 0) {
#line 226
            __cil_tmp58 = (unsigned char *)arc + 56;
#line 226
            __cil_tmp59 = (cost_t *)__cil_tmp58;
#line 226
            __cil_tmp60 = *__cil_ap_net;
#line 226
            __cil_tmp61 = (unsigned char *)__cil_tmp60;
#line 226
            __cil_tmp62 = __cil_tmp61 + 528;
#line 226
            __cil_tmp63 = (long *)__cil_tmp62;
#line 226
            __cil_tmp64 = *__cil_tmp59;
#line 226
            __cil_tmp65 = *__cil_tmp63;
#line 226
            __cil_tmp66 = *__cil_ap_operational_cost;
#line 226
            __cil_tmp67 = __cil_tmp64 - __cil_tmp65;
#line 226
            *__cil_ap_operational_cost = __cil_tmp66 + __cil_tmp67;
#line 227
            __cil_tmp68 = *__cil_ap_fleet;
#line 227
            *__cil_ap_fleet = __cil_tmp68 + 1L;
          } else {
#line 230
            __cil_tmp69 = (unsigned char *)arc + 56;
#line 230
            __cil_tmp70 = (cost_t *)__cil_tmp69;
#line 230
            __cil_tmp71 = *__cil_ap_operational_cost;
#line 230
            __cil_tmp72 = *__cil_tmp70;
#line 230
            *__cil_ap_operational_cost = __cil_tmp71 + __cil_tmp72;
          }
        } else {

        }
      }
    } else {

    }
#line 209
    arc_ssa_1 = arc + 1;
#line 212
    flow_org_cost_cil_lr_3(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                           arc_ssa_1, stop);
#line 215
    return;
  } else {
#line 217
    return;
  }
#line 209
  arc_ssa_1 = arc + 1;
#line 212
  flow_org_cost_cil_lr_3(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost,
                         arc_ssa_1, stop);
#line 215
  return;
}
}
#line 218 "mcfutil.c"
void flow_cost_cil_lr_1(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                        arc_t *arc , void *stop ) 
{ 
  arc_t *arc_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  int *__cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  flow_t *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  flow_t *__cil_tmp15 ;

  {
#line 137
  __cil_tmp7 = (unsigned long )arc != (unsigned long )((arc_t *)stop);
#line 137
  if (__cil_tmp7 != 0) {
#line 139
    __cil_tmp9 = (unsigned char *)arc + 24;
#line 139
    __cil_tmp10 = (int *)__cil_tmp9;
#line 139
    __cil_tmp11 = *__cil_tmp10;
#line 139
    __cil_tmp8 = __cil_tmp11 == 2;
#line 139
    if (__cil_tmp8 != 0) {
#line 140
      __cil_tmp12 = (unsigned char *)arc + 48;
#line 140
      __cil_tmp13 = (flow_t *)__cil_tmp12;
#line 140
      *__cil_tmp13 = (flow_t )1;
    } else {
#line 142
      __cil_tmp14 = (unsigned char *)arc + 48;
#line 142
      __cil_tmp15 = (flow_t *)__cil_tmp14;
#line 142
      *__cil_tmp15 = (flow_t )0;
    }
#line 137
    arc_ssa_1 = arc + 1;
#line 140
    flow_cost_cil_lr_1(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost, arc_ssa_1,
                       stop);
#line 143
    return;
  } else {
#line 145
    return;
  }
}
}
#line 150 "mcfutil.c"
void flow_cost_cil_lr_2(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                        node_t *node , void *stop ) 
{ 
  node_t *node_ssa_1 ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  flow_t *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  arc_p *__cil_tmp11 ;
  arc_p __cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  flow_t *__cil_tmp15 ;

  {
#line 146
  __cil_tmp7 = (unsigned long )node != (unsigned long )((node_t *)stop);
#line 146
  if (__cil_tmp7 != 0) {
#line 147
    __cil_tmp8 = (unsigned char *)node + 80;
#line 147
    __cil_tmp9 = (flow_t *)__cil_tmp8;
#line 147
    __cil_tmp10 = (unsigned char *)node + 48;
#line 147
    __cil_tmp11 = (arc_p *)__cil_tmp10;
#line 147
    __cil_tmp12 = *__cil_tmp11;
#line 147
    __cil_tmp13 = (unsigned char *)__cil_tmp12;
#line 147
    __cil_tmp14 = __cil_tmp13 + 48;
#line 147
    __cil_tmp15 = (flow_t *)__cil_tmp14;
#line 147
    *__cil_tmp15 = *__cil_tmp9;
#line 146
    node_ssa_1 = node + 1;
#line 149
    flow_cost_cil_lr_2(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost, node_ssa_1,
                       stop);
#line 152
    return;
  } else {
#line 154
    return;
  }
}
}
#line 159 "mcfutil.c"
void flow_cost_cil_lr_3(network_t **__cil_ap_net , long *__cil_ap_fleet , cost_t *__cil_ap_operational_cost ,
                        arc_t *arc , void *stop ) 
{ 
  int tmp_ssa_1 ;
  int cond_ssa_1 ;
  arc_t *arc_ssa_1 ;
  int __cil_tmp11 ;
  flow_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  flow_t *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  node_p *__cil_tmp19 ;
  node_p __cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  int *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  node_p *__cil_tmp26 ;
  node_p __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  int *__cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  node_p *__cil_tmp33 ;
  node_p __cil_tmp34 ;
  unsigned char *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int __cil_tmp38 ;
  network_t *__cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  unsigned char *__cil_tmp41 ;
  long *__cil_tmp42 ;
  cost_t __cil_tmp43 ;
  long __cil_tmp44 ;
  cost_t __cil_tmp45 ;
  cost_t __cil_tmp46 ;
  long __cil_tmp47 ;
  cost_t __cil_tmp48 ;
  cost_t __cil_tmp49 ;
  cost_t *mem_48 ;
  cost_t *mem_49 ;

  {
#line 150
  __cil_tmp11 = (unsigned long )arc != (unsigned long )((arc_t *)stop);
#line 150
  if (__cil_tmp11 != 0) {
#line 152
    __cil_tmp16 = (unsigned char *)arc + 48;
#line 152
    __cil_tmp17 = (flow_t *)__cil_tmp16;
#line 152
    __cil_tmp12 = *__cil_tmp17;
#line 152
    if (__cil_tmp12 != 0) {
#line 154
      __cil_tmp18 = (unsigned char *)arc + 8;
#line 154
      __cil_tmp19 = (node_p *)__cil_tmp18;
#line 154
      __cil_tmp20 = *__cil_tmp19;
#line 154
      __cil_tmp21 = (unsigned char *)__cil_tmp20;
#line 154
      __cil_tmp22 = __cil_tmp21 + 96;
#line 154
      __cil_tmp23 = (int *)__cil_tmp22;
#line 154
      __cil_tmp24 = *__cil_tmp23;
#line 154
      __cil_tmp13 = __cil_tmp24 < 0;
#line 154
      if (__cil_tmp13 != 0) {
#line 154
        __cil_tmp25 = (unsigned char *)arc + 16;
#line 154
        __cil_tmp26 = (node_p *)__cil_tmp25;
#line 154
        __cil_tmp27 = *__cil_tmp26;
#line 154
        __cil_tmp28 = (unsigned char *)__cil_tmp27;
#line 154
        __cil_tmp29 = __cil_tmp28 + 96;
#line 154
        __cil_tmp30 = (int *)__cil_tmp29;
#line 154
        __cil_tmp31 = *__cil_tmp30;
#line 154
        __cil_tmp14 = __cil_tmp31 > 0;
#line 154
        if (__cil_tmp14 != 0) {
#line 154
          tmp_ssa_1 = 0;
        } else {
#line 154
          tmp_ssa_1 = 1;
        }
      } else {
#line 154
        tmp_ssa_1 = 1;
      }
#line 154
      cond_ssa_1 = tmp_ssa_1;
#line 156
      if (cond_ssa_1 != 0) {
#line 158
        __cil_tmp32 = (unsigned char *)arc + 8;
#line 158
        __cil_tmp33 = (node_p *)__cil_tmp32;
#line 158
        __cil_tmp34 = *__cil_tmp33;
#line 158
        __cil_tmp35 = (unsigned char *)__cil_tmp34;
#line 158
        __cil_tmp36 = __cil_tmp35 + 96;
#line 158
        __cil_tmp37 = (int *)__cil_tmp36;
#line 158
        __cil_tmp38 = *__cil_tmp37;
#line 158
        __cil_tmp15 = ! __cil_tmp38;
#line 158
        if (__cil_tmp15 != 0) {
#line 160
          __cil_tmp39 = *__cil_ap_net;
#line 160
          __cil_tmp40 = (unsigned char *)__cil_tmp39;
#line 160
          __cil_tmp41 = __cil_tmp40 + 528;
#line 160
          __cil_tmp42 = (long *)__cil_tmp41;
#line 160
          mem_48 = (cost_t *)arc;
#line 160
          __cil_tmp43 = *mem_48;
#line 160
          __cil_tmp44 = *__cil_tmp42;
#line 160
          __cil_tmp45 = *__cil_ap_operational_cost;
#line 160
          __cil_tmp46 = __cil_tmp43 - __cil_tmp44;
#line 160
          *__cil_ap_operational_cost = __cil_tmp45 + __cil_tmp46;
#line 161
          __cil_tmp47 = *__cil_ap_fleet;
#line 161
          *__cil_ap_fleet = __cil_tmp47 + 1L;
        } else {
#line 164
          __cil_tmp48 = *__cil_ap_operational_cost;
#line 164
          mem_49 = (cost_t *)arc;
#line 164
          __cil_tmp49 = *mem_49;
#line 164
          *__cil_ap_operational_cost = __cil_tmp48 + __cil_tmp49;
        }
      } else {

      }
    } else {

    }
#line 150
    arc_ssa_1 = arc + 1;
#line 153
    flow_cost_cil_lr_3(__cil_ap_net, __cil_ap_fleet, __cil_ap_operational_cost, arc_ssa_1,
                       stop);
#line 156
    return;
  } else {
#line 158
    return;
  }
}
}
#line 163 "mcfutil.c"
void refresh_potential_cil_lr_1(long *__cil_ap_checksum , node_t *node , node_t *tmp ,
                                node_t *root ) 
{ 
  node_t **__cil_pp_tmp ;
  node_t **__cil_pp_root ;
  node_t **__cil_pp_node ;
  node_t **__cil_fp_tmp ;
  node_t **__cil_fp_root ;
  node_t **__cil_fp_node ;
  node_t *tmp_ssa_1 ;
  node_t *root_ssa_1 ;
  node_t *node_ssa_1 ;
  node_t *node_ssa_2 ;
  node_t *tmp_ssa_2 ;
  node_t *root_ssa_2 ;
  int __cil_tmp17 ;

  {
#line 166
  __cil_fp_node = & node;
#line 166
  __cil_fp_root = & root;
#line 166
  __cil_fp_tmp = & tmp;
#line 166
  __cil_pp_node = & node;
#line 166
  __cil_pp_root = & root;
#line 166
  __cil_pp_tmp = & tmp;
#line 166
  return babel_wrapper_refresh_potential_cil_lr_1(__cil_pp_tmp, __cil_pp_root, __cil_pp_node,
                                                  __cil_fp_tmp, __cil_fp_root, __cil_fp_node,
                                                  __cil_ap_checksum, node, tmp, root);
#line 166
  __cil_pp_tmp = & tmp;
#line 167
  __cil_pp_root = & root;
#line 168
  __cil_pp_node = & node;
#line 169
  __cil_fp_tmp = & tmp;
#line 170
  __cil_fp_root = & root;
#line 171
  __cil_fp_node = & node;
#line 81
  __cil_tmp17 = (unsigned long )node != (unsigned long )root;
#line 81
  if (__cil_tmp17 != 0) {
#line 83
    *__cil_fp_tmp = tmp;
#line 84
    *__cil_fp_root = root;
#line 83
    refresh_potential_cil_lr_1_cil_lr_1(__cil_pp_tmp, __cil_pp_root, __cil_ap_checksum,
                                        node);
#line 85
    tmp_ssa_1 = *__cil_fp_tmp;
#line 86
    root_ssa_1 = *__cil_fp_root;
#line 97
    node_ssa_1 = tmp_ssa_1;
#line 100
    *__cil_fp_node = node_ssa_1;
#line 101
    *__cil_fp_tmp = tmp_ssa_1;
#line 102
    *__cil_fp_root = root_ssa_1;
#line 99
    refresh_potential_cil_lr_1_cil_lr_2(__cil_pp_node, __cil_pp_tmp, __cil_pp_root);
#line 100
    node_ssa_2 = *__cil_fp_node;
#line 101
    tmp_ssa_2 = *__cil_fp_tmp;
#line 102
    root_ssa_2 = *__cil_fp_root;
#line 105
    refresh_potential_cil_lr_1(__cil_ap_checksum, node_ssa_2, tmp_ssa_2, root_ssa_2);
#line 107
    return;
  } else {
#line 109
    return;
  }
}
}
#line 114 "mcfutil.c"
void refresh_neighbour_lists_cil_lr_1(network_t **__cil_ap_net , node_t *node , void *stop ) 
{ 
  node_t *node_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  arc_p *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  arc_p *__cil_tmp9 ;

  {

#line 40
  return babel_wrapper_refresh_neighbour_lists_cil_lr_1(__cil_ap_net, node, stop);
#line 40
  __cil_tmp5 = (unsigned long )node < (unsigned long )((node_t *)stop);
#line 40
  if (__cil_tmp5 != 0) {
#line 42
    __cil_tmp6 = (unsigned char *)node + 64;
#line 42
    __cil_tmp7 = (arc_p *)__cil_tmp6;
#line 42
    *__cil_tmp7 = (arc_t *)0;
#line 43
    __cil_tmp8 = (unsigned char *)node + 56;
#line 43
    __cil_tmp9 = (arc_p *)__cil_tmp8;
#line 43
    *__cil_tmp9 = (arc_t *)0;
#line 40
    node_ssa_1 = node + 1;
#line 43
    refresh_neighbour_lists_cil_lr_1(__cil_ap_net, node_ssa_1, stop);
#line 45
    return;
  } else {
#line 47
    return;
  }
}
}
#line 52 "mcfutil.c"
void refresh_neighbour_lists_cil_lr_2(arc_t *arc , void *stop ) 
{ 
  arc_t *arc_ssa_1 ;
  int __cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  node_p *__cil_tmp6 ;
  node_p __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  arc_p *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  arc_p *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  node_p *__cil_tmp14 ;
  node_p __cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  arc_p *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  node_p *__cil_tmp20 ;
  node_p __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  arc_p *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  arc_p *__cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  node_p *__cil_tmp28 ;
  node_p __cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  arc_p *__cil_tmp32 ;

  {

#line 47
  return babel_wrapper_refresh_neighbour_lists_cil_lr_2(arc, stop);
#line 47
  __cil_tmp4 = (unsigned long )arc < (unsigned long )((arc_t *)stop);
#line 47
  if (__cil_tmp4 != 0) {
#line 49
    __cil_tmp5 = (unsigned char *)arc + 8;
#line 49
    __cil_tmp6 = (node_p *)__cil_tmp5;
#line 49
    __cil_tmp7 = *__cil_tmp6;
#line 49
    __cil_tmp8 = (unsigned char *)__cil_tmp7;
#line 49
    __cil_tmp9 = __cil_tmp8 + 56;
#line 49
    __cil_tmp10 = (arc_p *)__cil_tmp9;
#line 49
    __cil_tmp11 = (unsigned char *)arc + 32;
#line 49
    __cil_tmp12 = (arc_p *)__cil_tmp11;
#line 49
    *__cil_tmp12 = *__cil_tmp10;
#line 50
    __cil_tmp13 = (unsigned char *)arc + 8;
#line 50
    __cil_tmp14 = (node_p *)__cil_tmp13;
#line 50
    __cil_tmp15 = *__cil_tmp14;
#line 50
    __cil_tmp16 = (unsigned char *)__cil_tmp15;
#line 50
    __cil_tmp17 = __cil_tmp16 + 56;
#line 50
    __cil_tmp18 = (arc_p *)__cil_tmp17;
#line 50
    *__cil_tmp18 = arc;
#line 51
    __cil_tmp19 = (unsigned char *)arc + 16;
#line 51
    __cil_tmp20 = (node_p *)__cil_tmp19;
#line 51
    __cil_tmp21 = *__cil_tmp20;
#line 51
    __cil_tmp22 = (unsigned char *)__cil_tmp21;
#line 51
    __cil_tmp23 = __cil_tmp22 + 64;
#line 51
    __cil_tmp24 = (arc_p *)__cil_tmp23;
#line 51
    __cil_tmp25 = (unsigned char *)arc + 40;
#line 51
    __cil_tmp26 = (arc_p *)__cil_tmp25;
#line 51
    *__cil_tmp26 = *__cil_tmp24;
#line 52
    __cil_tmp27 = (unsigned char *)arc + 16;
#line 52
    __cil_tmp28 = (node_p *)__cil_tmp27;
#line 52
    __cil_tmp29 = *__cil_tmp28;
#line 52
    __cil_tmp30 = (unsigned char *)__cil_tmp29;
#line 52
    __cil_tmp31 = __cil_tmp30 + 64;
#line 52
    __cil_tmp32 = (arc_p *)__cil_tmp31;
#line 52
    *__cil_tmp32 = arc;
#line 47
    arc_ssa_1 = arc + 1;
#line 50
    refresh_neighbour_lists_cil_lr_2(arc_ssa_1, stop);
#line 52
    return;
  } else {
#line 54
    return;
  }
}
}
#include <gprolog.h>

PlBool babel_ptrR(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

		return PL_TRUE;
}

PlBool babel_ptrR_byte(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

	return PL_TRUE;
}

PlBool babel_ptrE(PlLong* p,  PlLong e, PlLong len)
{
	if (p == 0)
	    return PL_FALSE;

	switch(len)
		{
		    case 1:
		    	*(unsigned char*)p = (unsigned char)e;
		    	break;
		    case 2:
		    	*(short*) p = (short)e;
		    	break;
		    case 4:
		    	*(int*)p = (int)e;
		    	break;
		    case 8:
		    	*(long long*)p = (long long)e;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrL\n");
		}

        return PL_TRUE;
}

PlBool babel_ptrFR(double* fp, PlLong ptr, PlLong len)
{
  if(len == 2)
  *(double *)fp = *(double *)ptr;
   else if (len == 1)
  *(float *)fp = *(float *)ptr;
  else
  return PL_FALSE;

  return PL_TRUE;
}

PlBool babel_ptrFW(PlLong ptr, double f, PlLong len)
{
  if (len == 2)
  *(double *)ptr = f;
   else if (len == 1)
  *(float *)ptr = f;
  else
  return PL_FALSE;
  
  return PL_TRUE;
}

PlBool babel__implicit_refresh_neighbour_listsc_0(network_t ** arg_0, node_t * arg_1, void * arg_2) 
{
refresh_neighbour_lists_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_refresh_neighbour_listsc_1(arc_t * arg_0, void * arg_1) 
{
refresh_neighbour_lists_cil_lr_2(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_refresh_potentialc_2(long * arg_0, node_t * arg_1, node_t * arg_2, node_t * arg_3) 
{
refresh_potential_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_flow_org_costc_3(network_t ** arg_0, long * arg_1, cost_t * arg_2, arc_t * arg_3, void * arg_4) 
{
flow_org_cost_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_flow_org_costc_4(network_t ** arg_0, long * arg_1, cost_t * arg_2, node_t * arg_3, void * arg_4) 
{
flow_org_cost_cil_lr_2(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_flow_org_costc_5(network_t ** arg_0, long * arg_1, cost_t * arg_2, arc_t * arg_3, void * arg_4) 
{
flow_org_cost_cil_lr_3(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_primal_feasiblec_6(network_t ** arg_0, long * arg_1, void * arg_2, node_t * arg_3, arc_t * arg_4, arc_t * arg_5, PlLong * babel_ret) 
{
*babel_ret = primal_feasible_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
return PL_TRUE;
}
PlBool babel__implicit_dual_feasiblec_7(struct _IO_FILE ** arg_0, int * arg_1, network_t * arg_2, arc_t * arg_3, arc_t * arg_4) 
{
dual_feasible_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_dual_feasiblec_8(FILE * __restrict   arg_0, char const   * __restrict   arg_1) 
{
fprintf(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_dual_feasiblec_9(FILE * __restrict   arg_0, char const   * __restrict   arg_1) 
{
fprintf(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_getfreec_10(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_getfreec_11(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_getfreec_12(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_refresh_potential_cil_lr_1c_20(node_t ** arg_0, node_t ** arg_1, long * arg_2, node_t * arg_3) 
{
refresh_potential_cil_lr_1_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_refresh_potential_cil_lr_1c_21(node_t ** arg_0, node_t ** arg_1, node_t ** arg_2) 
{
refresh_potential_cil_lr_1_cil_lr_2(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_refresh_potential_cil_lr_1c_22(long * arg_0, node_t * arg_1, node_t * arg_2, node_t * arg_3) 
{
refresh_potential_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
