/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 15 "web_server.c"
typedef unsigned long __dev_t;
#line 16 "web_server.c"
typedef unsigned int __uid_t;
#line 17 "web_server.c"
typedef unsigned int __gid_t;
#line 18 "web_server.c"
typedef unsigned long __ino_t;
#line 20 "web_server.c"
typedef unsigned int __mode_t;
#line 21 "web_server.c"
typedef unsigned long __nlink_t;
#line 22 "web_server.c"
typedef long __off_t;
#line 23 "web_server.c"
typedef long __off64_t;
#line 24 "web_server.c"
typedef int __pid_t;
#line 30 "web_server.c"
typedef long __time_t;
#line 37 "web_server.c"
typedef long __blksize_t;
#line 38 "web_server.c"
typedef long __blkcnt_t;
#line 46 "web_server.c"
typedef long __syscall_slong_t;
#line 47 "web_server.c"
typedef unsigned long __syscall_ulong_t;
#line 53 "web_server.c"
typedef __time_t time_t;
#line 63 "web_server.c"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   __syscall_ulong_t st_atimensec ;
   __time_t st_mtime ;
   __syscall_ulong_t st_mtimensec ;
   __time_t st_ctime ;
   __syscall_ulong_t st_ctimensec ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 113 "web_server.c"
typedef unsigned long size_t;
#line 114
struct _IO_FILE;
#line 114
struct _IO_FILE;
#line 115 "web_server.c"
typedef struct _IO_FILE FILE;
#line 136 "web_server.c"
typedef __builtin_va_list __gnuc_va_list;
#line 137
struct _IO_FILE;
#line 138 "web_server.c"
typedef void _IO_lock_t;
#line 139 "web_server.c"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 151 "web_server.c"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 212 "web_server.c"
typedef __gnuc_va_list va_list;
#line 730 "web_server.c"
typedef void (*__sighandler_t)(int  );
#line 1111 "web_server.c"
struct mg_header {
   char const   *name ;
   char const   *value ;
};
#line 1111 "web_server.c"
struct mg_connection {
   char const   *request_method ;
   char const   *uri ;
   char const   *http_version ;
   char const   *query_string ;
   char remote_ip[48] ;
   char local_ip[48] ;
   unsigned short remote_port ;
   unsigned short local_port ;
   int num_headers ;
   struct mg_header http_headers[30] ;
   char *content ;
   size_t content_len ;
   int is_websocket ;
   int status_code ;
   int wsbits ;
   void *server_param ;
   void *connection_param ;
   void *callback_param ;
};
#line 1134
struct mg_server;
#line 1134
struct mg_server;
#line 1136
enum mg_event {
    MG_POLL = 100,
    MG_CONNECT = 101,
    MG_AUTH = 102,
    MG_REQUEST = 103,
    MG_REPLY = 104,
    MG_RECV = 105,
    MG_CLOSE = 106,
    MG_WS_HANDSHAKE = 107,
    MG_WS_CONNECT = 108,
    MG_HTTP_ERROR = 109
} ;
#line 1204 "web_server.c"
typedef struct stat file_stat_t;
#line 84
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 215
extern struct _IO_FILE *stdout ;
#line 216
extern struct _IO_FILE *stderr ;
#line 217
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 223
extern int fclose(FILE *__stream ) ;
#line 224
extern int fflush(FILE *__stream ) ;
#line 225
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 234
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 236
extern int printf(char const   * __restrict  __format  , ...) ;
#line 239
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 244
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 253
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 280
extern int fputc(int __c , FILE *__stream ) ;
#line 285
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 502
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 507
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 512
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 522
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 733
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
#line 947
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 951
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 958
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 960
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 973
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 992
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 994
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 998
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 1015
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 1157
extern struct mg_server *mg_create_server(void *server_param , int (*handler)(struct mg_connection * ,
                                                                              enum mg_event  ) ) ;
#line 1158
extern void mg_destroy_server(struct mg_server ** ) ;
#line 1159
extern char const   *mg_set_option(struct mg_server * , char const   *opt , char const   *val ) ;
#line 1160
extern time_t mg_poll_server(struct mg_server * , int milliseconds ) ;
#line 1161
extern char const   **mg_get_valid_option_names(void) ;
#line 1162
extern char const   *mg_get_option(struct mg_server  const  *server , char const   *name ) ;
#line 1190
extern char *mg_md5(char *buf  , ...) ;
#line 1206
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 1235
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 1237
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 1631 "web_server.c"
static int exit_flag  ;
#line 1632 "web_server.c"
static char server_name[50]  ;
#line 1633 "web_server.c"
static char s_config_file[4096]  ;
#line 1634 "web_server.c"
static struct mg_server *server  ;
#line 1635 "web_server.c"
static char const   *s_default_document_root  =    ".";
#line 1636 "web_server.c"
static char const   *s_default_listening_port  =    "8080";
#line 1637 "web_server.c"
static char **s_argv  =    (char **)((void *)0);
#line 1638
static void set_options(char **argv ) ;
void set_options_cil_lr_1(struct mg_server **__cil_ap_server , char *options[100] ,
                          int i ) ;
void serving_thread_func_cil_lr_1(struct mg_server *srv ) ;
int get_option_cil_lr_1(char **__cil_ap___cil_ret5 , char **options , char const   *option_name ,
                        int i ) ;
void set_option_cil_lr_1(int *__cil_ap_i , char **options , char const   *name , char const   *value ) ;
void show_usage_and_exit_cil_lr_1(char const   **names , int i ) ;
void signal_handler_cil_lr_1(int sig_num ) ;
#line 1639 "web_server.c"
void signal_handler(int sig_num ) 
{ 
  void (*__cil_pp_signal_handler)(int sig_num )  = & signal_handler;
  int *__cil_gp_exit_flag  = & exit_flag;
  int __cil_tmp5 ;

  {
  {
#line 1640
  signal(sig_num, __cil_pp_signal_handler);
  }
  {
#line 1641
  __cil_tmp5 = sig_num == 17;
#line 1641
  if (__cil_tmp5) {
    {
#line 1642
    signal_handler_cil_lr_1(sig_num);
    }
  } else {
    {
#line 1644
    *__cil_gp_exit_flag = sig_num;
    }
  }
  }
#line 1645
  return;
}
}
#line 1646 "web_server.c"
void vnotify(char const   *fmt , va_list ap , int must_exit ) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  struct _IO_FILE *__cil_tmp5 ;
  struct _IO_FILE *__cil_tmp6 ;

  {
  {
#line 1647
  __cil_tmp5 = *__cil_gp_stderr;
#line 1647
  vfprintf((FILE */* __restrict  */)__cil_tmp5, (char const   */* __restrict  */)fmt,
           ap);
#line 1648
  __cil_tmp6 = *__cil_gp_stderr;
#line 1648
  fputc('\n', __cil_tmp6);
  }
#line 1649
  if (must_exit) {
    {
#line 1650
    exit(1);
    }
  } else {

  }
#line 1652
  return;
}
}
#line 1653 "web_server.c"
void notify(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 1655
  __builtin_va_start(ap, fmt);
#line 1656
  vnotify(fmt, ap, 0);
#line 1657
  __builtin_va_end(ap);
#line 1658
  return;
}
}
#line 1659 "web_server.c"
void die(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 1661
  __builtin_va_start(ap, fmt);
#line 1662
  vnotify(fmt, ap, 1);
#line 1663
  __builtin_va_end(ap);
#line 1664
  return;
}
}
#line 1665 "web_server.c"
void show_usage_and_exit(void) 
{ 
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  char const   **names_ssa_1 ;
  int i_ssa_1 ;
  struct _IO_FILE *__cil_tmp7 ;
  struct _IO_FILE *__cil_tmp8 ;
  struct _IO_FILE *__cil_tmp9 ;
  struct _IO_FILE *__cil_tmp10 ;
  struct _IO_FILE *__cil_tmp11 ;
  struct _IO_FILE *__cil_tmp12 ;

  {
  {
#line 1668
  __cil_tmp7 = *__cil_gp_stderr;
#line 1668
  fprintf((FILE */* __restrict  */)__cil_tmp7, (char const   */* __restrict  */)"Mongoose version %s (c) Sergey Lyubka, built on %s\n",
          "5.6", "Nov 19 2015");
#line 1670
  __cil_tmp8 = *__cil_gp_stderr;
#line 1670
  fprintf((FILE */* __restrict  */)__cil_tmp8, (char const   */* __restrict  */)"Usage:\n");
#line 1671
  __cil_tmp9 = *__cil_gp_stderr;
#line 1671
  fprintf((FILE */* __restrict  */)__cil_tmp9, (char const   */* __restrict  */)"  mongoose -A <htpasswd_file> <realm> <user> <passwd>\n");
#line 1672
  __cil_tmp10 = *__cil_gp_stderr;
#line 1672
  fprintf((FILE */* __restrict  */)__cil_tmp10, (char const   */* __restrict  */)"  mongoose [config_file]\n");
#line 1673
  __cil_tmp11 = *__cil_gp_stderr;
#line 1673
  fprintf((FILE */* __restrict  */)__cil_tmp11, (char const   */* __restrict  */)"  mongoose [-option value ...]\n");
#line 1674
  __cil_tmp12 = *__cil_gp_stderr;
#line 1674
  fprintf((FILE */* __restrict  */)__cil_tmp12, (char const   */* __restrict  */)"\nOPTIONS:\n");
#line 1675
  names_ssa_1 = mg_get_valid_option_names();
#line 1676
  i_ssa_1 = 0;
  }
  {
#line 1676
  show_usage_and_exit_cil_lr_1(names_ssa_1, i_ssa_1);
  }
  {
#line 1680
  exit(1);
  }
}
}
#line 1682 "web_server.c"
char *sdup(char const   *str ) 
{ 
  size_t tmp_ssa_1 ;
  void *tmp___0_ssa_1 ;
  char *p_ssa_1 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
  {
#line 1684
  tmp_ssa_1 = strlen(str);
#line 1684
  __cil_tmp9 = tmp_ssa_1 + 1UL;
#line 1684
  tmp___0_ssa_1 = malloc(__cil_tmp9);
#line 1684
  p_ssa_1 = (char *)tmp___0_ssa_1;
  }
  {
#line 1684
  __cil_tmp8 = (unsigned long )p_ssa_1 != (unsigned long )((void *)0);
#line 1684
  if (__cil_tmp8) {
    {
#line 1685
    strcpy((char */* __restrict  */)p_ssa_1, (char const   */* __restrict  */)str);
    }
  } else {

  }
  }
#line 1687
  return (p_ssa_1);
}
}
#line 1689 "web_server.c"
void set_option(char **options , char const   *name , char const   *value ) 
{ 
  int i ;
  int *__cil_pp_i  = & i;
  int *__cil_fp_i  = & i;
  int i_ssa_1 ;
  int i_ssa_2 ;
  int __cil_tmp10 ;

  {
  {
#line 1691
  i_ssa_1 = 0;
  }
  {
  *__cil_fp_i = i_ssa_1;
#line 1691
  set_option_cil_lr_1(__cil_pp_i, options, name, value);
  i_ssa_2 = *__cil_fp_i;
  }
  {
#line 1703
  __cil_tmp10 = i_ssa_2 == 97;
#line 1703
  if (__cil_tmp10) {
    {
#line 1704
    die("%s", "Too many options specified");
    }
  } else {

  }
  }
#line 1706
  return;
}
}
#line 1707 "web_server.c"
void process_command_line_arguments(char **argv , char **options ) 
{ 
  char line[8192] ;
  char opt[sizeof(line)] ;
  char val[sizeof(line)] ;
  char *p ;
  char cpath[4096] ;
  FILE *fp ;
  size_t i ;
  size_t cmd_line_opts_start ;
  size_t line_no ;
  int *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1711
  cmd_line_opts_start = (size_t )1;
#line 1711
  line_no = (size_t )0;
#line 1712
  if ((unsigned long )*(argv + 1) != (unsigned long )((void *)0)) {
#line 1712
    if ((int )*(*(argv + 1) + 0) != 45) {
#line 1713
      snprintf((char */* __restrict  */)(cpath), sizeof(cpath), (char const   */* __restrict  */)"%s",
               *(argv + 1));
#line 1714
      cmd_line_opts_start = (size_t )2;
    } else {
#line 1712
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1715
    p = strrchr((char const   *)*(argv + 0), '/');
#line 1715
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1716
      snprintf((char */* __restrict  */)(cpath), sizeof(cpath), (char const   */* __restrict  */)"%s",
               "mongoose.conf");
    } else {
#line 1718
      snprintf((char */* __restrict  */)(cpath), sizeof(cpath), (char const   */* __restrict  */)"%.*s%c%s",
               (int )(p - *(argv + 0)), *(argv + 0), '/', "mongoose.conf");
    }
  }
#line 1721
  realpath((char const   */* __restrict  */)(cpath), (char */* __restrict  */)(s_config_file));
#line 1722
  fp = fopen((char const   */* __restrict  */)(s_config_file), (char const   */* __restrict  */)"r");
#line 1723
  if (cmd_line_opts_start == 2UL) {
#line 1723
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1724
      tmp = __errno_location();
#line 1724
      tmp___0 = strerror(*tmp);
#line 1724
      die("Cannot open config file %s: %s", s_config_file, tmp___0);
    }
  }
#line 1726
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 1727
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading config file %s\n",
            s_config_file);
#line 1728
    while (1) {
#line 1728
      tmp___3 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
#line 1728
      if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 1728
        break;
      }
#line 1729
      line_no ++;
#line 1730
      i = (size_t )0;
#line 1730
      while (1) {
#line 1730
        tmp___1 = __ctype_b_loc();
#line 1730
        if (! ((int const   )*(*tmp___1 + (int )*((unsigned char *)(& line[i]))) & 8192)) {
#line 1730
          break;
        }
#line 1730
        i ++;
      }
#line 1731
      if ((int )line[i] == 35) {
#line 1732
        continue;
      } else
#line 1731
      if ((int )line[i] == 0) {
#line 1732
        continue;
      }
#line 1734
      tmp___2 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%s %[^\r\n#]",
                       opt, val);
#line 1734
      if (tmp___2 != 2) {
#line 1735
        printf((char const   */* __restrict  */)"%s: line %d is invalid, ignoring it:\n %s",
               s_config_file, (int )line_no, line);
      } else {
#line 1738
        set_option(options, (char const   *)(opt), (char const   *)(val));
      }
    }
#line 1741
    fclose(fp);
  }
#line 1743
  if ((unsigned long )*(argv + 1) == (unsigned long )((void *)0)) {
#line 1743
    goto _L___0;
  } else {
#line 1743
    tmp___4 = memcmp((void const   *)*(argv + 1), (void const   *)"-psn_", (size_t )5);
#line 1743
    if (tmp___4 != 0) {
      _L___0: /* CIL Label */ 
#line 1744
      i = cmd_line_opts_start;
#line 1744
      while ((unsigned long )*(argv + i) != (unsigned long )((void *)0)) {
#line 1745
        if ((int )*(*(argv + i) + 0) != 45) {
#line 1746
          show_usage_and_exit();
        } else
#line 1745
        if ((unsigned long )*(argv + (i + 1UL)) == (unsigned long )((void *)0)) {
#line 1746
          show_usage_and_exit();
        }
#line 1748
        set_option(options, (char const   *)(*(argv + i) + 1), (char const   *)*(argv + (i + 1UL)));
#line 1744
        i += 2UL;
      }
    }
  }
#line 1751
  return;
}
}
#line 1752 "web_server.c"
void init_server_name(void) 
{ 
  char const   *descr_ssa_1 ;
  char *__cil_tmp3 ;

  {
  {
#line 1753
  descr_ssa_1 = "";
#line 1754
  __cil_tmp3 = server_name;
#line 1754
  snprintf((char */* __restrict  */)__cil_tmp3, sizeof(server_name), (char const   */* __restrict  */)"Mongoose web server v.%s%s",
           "5.6", descr_ssa_1);
  }
#line 1756
  return;
}
}
#line 1757 "web_server.c"
int is_path_absolute(char const   *path ) 
{ 
  int tmp_ssa_1 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  char __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 1758
  __cil_tmp4 = (unsigned long )path != (unsigned long )((void *)0);
#line 1758
  if (__cil_tmp4) {
    {
#line 1758
    __cil_tmp6 = path + 0;
#line 1758
    __cil_tmp7 = *__cil_tmp6;
#line 1758
    __cil_tmp8 = (int const   )__cil_tmp7;
#line 1758
    __cil_tmp5 = __cil_tmp8 == 47;
#line 1758
    if (__cil_tmp5) {
      {
#line 1758
      tmp_ssa_1 = 1;
      }
    } else {
      {
#line 1758
      tmp_ssa_1 = 0;
      }
    }
    }
  } else {
    {
#line 1758
    tmp_ssa_1 = 0;
    }
  }
  }
#line 1758
  return (tmp_ssa_1);
}
}
#line 1760 "web_server.c"
char *get_option(char **options , char const   *option_name ) 
{ 
  char *__cil_ret5 ;
  char **__cil_pp___cil_ret5  = & __cil_ret5;
  char **__cil_fp___cil_ret5  = & __cil_ret5;
  int i_ssa_1 ;
  int retflag6_ssa_1 ;
  char *__cil_ret5_ssa_1 ;

  {
  {
#line 1762
  i_ssa_1 = 0;
  }
  {
  {
  *__cil_fp___cil_ret5 = __cil_ret5;
#line 1762
  retflag6_ssa_1 = get_option_cil_lr_1(__cil_pp___cil_ret5, options, option_name,
                                       i_ssa_1);
  __cil_ret5_ssa_1 = *__cil_fp___cil_ret5;
  }
#line 1762
  if (retflag6_ssa_1) {
#line 1762
    return (__cil_ret5_ssa_1);
  } else {
#line 1765
    return ((char *)0);
  }
  }
}
}
#line 1767 "web_server.c"
void *serving_thread_func(void *param ) 
{ 
  struct mg_server *srv_ssa_1 ;

  {
  {
#line 1768
  srv_ssa_1 = (struct mg_server *)param;
  }
  {
#line 1769
  serving_thread_func_cil_lr_1(srv_ssa_1);
  }
#line 1772
  return ((void *)0);
}
}
#line 1774 "web_server.c"
int path_exists(char const   *path , int is_dir ) 
{ 
  file_stat_t st ;
  file_stat_t *__cil_pp_st  = & st;
  int tmp___1_ssa_1 ;
  int tmp_ssa_1 ;
  int tmp___0_ssa_1 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  __mode_t *__cil_tmp16 ;
  __mode_t __cil_tmp17 ;
  unsigned int __cil_tmp18 ;

  {
  {
#line 1776
  __cil_tmp11 = (unsigned long )path == (unsigned long )((void *)0);
#line 1776
  if (__cil_tmp11) {
    {
#line 1776
    tmp___1_ssa_1 = 1;
    }
  } else {
    {
#line 1776
    tmp_ssa_1 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)__cil_pp_st);
    }
    {
#line 1776
    __cil_tmp12 = tmp_ssa_1 == 0;
#line 1776
    if (__cil_tmp12) {
      {
#line 1776
      __cil_tmp15 = (unsigned char *)__cil_pp_st + 24;
#line 1776
      __cil_tmp16 = (__mode_t *)__cil_tmp15;
#line 1776
      __cil_tmp17 = *__cil_tmp16;
#line 1776
      __cil_tmp18 = __cil_tmp17 & 61440U;
#line 1776
      __cil_tmp13 = __cil_tmp18 == 16384U;
#line 1776
      if (__cil_tmp13) {
        {
#line 1776
        tmp___0_ssa_1 = 1;
        }
      } else {
        {
#line 1776
        tmp___0_ssa_1 = 0;
        }
      }
      }
      {
#line 1776
      __cil_tmp14 = tmp___0_ssa_1 == is_dir;
#line 1776
      if (__cil_tmp14) {
        {
#line 1776
        tmp___1_ssa_1 = 1;
        }
      } else {
        {
#line 1776
        tmp___1_ssa_1 = 0;
        }
      }
      }
    } else {
      {
#line 1776
      tmp___1_ssa_1 = 0;
      }
    }
    }
  }
  }
#line 1776
  return (tmp___1_ssa_1);
}
}
#line 1779 "web_server.c"
void verify_existence(char **options , char const   *name , int is_dir ) 
{ 
  char *tmp_ssa_1 ;
  char const   *path_ssa_1 ;
  int tmp___2_ssa_1 ;
  int *tmp___0_ssa_1 ;
  char *tmp___1_ssa_1 ;
  int __cil_tmp14 ;

  {
  {
#line 1780
  tmp_ssa_1 = get_option(options, name);
#line 1780
  path_ssa_1 = (char const   *)tmp_ssa_1;
#line 1781
  tmp___2_ssa_1 = path_exists(path_ssa_1, is_dir);
  }
#line 1781
  if (! tmp___2_ssa_1) {
    {
#line 1782
    tmp___0_ssa_1 = __errno_location();
#line 1782
    __cil_tmp14 = *tmp___0_ssa_1;
#line 1782
    tmp___1_ssa_1 = strerror(__cil_tmp14);
#line 1782
    notify("Invalid path for %s: [%s]: (%s). Make sure that path is either absolute, or it is relative to mongoose executable.",
           name, path_ssa_1, tmp___1_ssa_1);
    }
  }
#line 1786
  return;
}
}
#line 1787 "web_server.c"
void set_absolute_path(char **options , char const   *option_name ) 
{ 
  char path[4096] ;
  char abs___0[4096] ;
  char *option_value_ssa_1 ;
  int tmp___0_ssa_1 ;
  char *tmp_ssa_1 ;
  char const   *p_ssa_1 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char const   *__cil_tmp19 ;
  long __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 1790
  option_value_ssa_1 = get_option(options, option_name);
  }
  {
#line 1791
  __cil_tmp13 = (unsigned long )option_value_ssa_1 != (unsigned long )((void *)0);
#line 1791
  if (__cil_tmp13) {
    {
#line 1791
    tmp___0_ssa_1 = is_path_absolute((char const   *)option_value_ssa_1);
    }
#line 1791
    if (! tmp___0_ssa_1) {
      {
#line 1792
      __cil_tmp15 = s_config_file;
#line 1792
      tmp_ssa_1 = strrchr((char const   *)__cil_tmp15, '/');
#line 1792
      p_ssa_1 = (char const   *)tmp_ssa_1;
      }
      {
#line 1792
      __cil_tmp14 = (unsigned long )p_ssa_1 == (unsigned long )((void *)0);
#line 1792
      if (__cil_tmp14) {
        {
#line 1793
        __cil_tmp16 = path;
#line 1793
        getcwd(__cil_tmp16, sizeof(path));
        }
      } else {
        {
#line 1795
        __cil_tmp17 = path;
#line 1795
        __cil_tmp18 = s_config_file;
#line 1795
        __cil_tmp19 = (char const   *)__cil_tmp18;
#line 1795
        __cil_tmp20 = p_ssa_1 - __cil_tmp19;
#line 1795
        __cil_tmp21 = s_config_file;
#line 1795
        snprintf((char */* __restrict  */)__cil_tmp17, sizeof(path), (char const   */* __restrict  */)"%.*s",
                 (int )__cil_tmp20, __cil_tmp21);
        }
      }
      }
      {
#line 1798
      __cil_tmp22 = path;
#line 1798
      __cil_tmp23 = sizeof(path) - 1UL;
#line 1798
      strncat((char */* __restrict  */)__cil_tmp22, (char const   */* __restrict  */)"/",
              __cil_tmp23);
#line 1799
      __cil_tmp24 = path;
#line 1799
      __cil_tmp25 = sizeof(path) - 1UL;
#line 1799
      strncat((char */* __restrict  */)__cil_tmp24, (char const   */* __restrict  */)option_value_ssa_1,
              __cil_tmp25);
#line 1800
      __cil_tmp26 = path;
#line 1800
      __cil_tmp27 = abs___0;
#line 1800
      realpath((char const   */* __restrict  */)__cil_tmp26, (char */* __restrict  */)__cil_tmp27);
#line 1801
      __cil_tmp28 = abs___0;
#line 1801
      set_option(options, option_name, (char const   *)__cil_tmp28);
      }
    }
  } else {

  }
  }
#line 1803
  return;
}
}
#line 1804 "web_server.c"
int modify_passwords_file(char const   *fname , char const   *domain , char const   *user ,
                          char const   *pass ) 
{ 
  int found ;
  char line[512] ;
  char u[512] ;
  char d[512] ;
  char ha1[33] ;
  char tmp[4096] ;
  FILE *fp ;
  FILE *fp2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 1809
  found = 0;
#line 1810
  fp2 = (FILE *)((void *)0);
#line 1811
  if ((unsigned long )pass != (unsigned long )((void *)0)) {
#line 1811
    if ((int const   )*(pass + 0) == 0) {
#line 1812
      pass = (char const   *)((void *)0);
    }
  }
#line 1814
  snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%s.tmp",
           fname);
#line 1815
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"a+");
#line 1815
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 1816
    fclose(fp);
  }
#line 1818
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
#line 1818
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1819
    return (0);
  } else {
#line 1820
    fp2 = fopen((char const   */* __restrict  */)(tmp), (char const   */* __restrict  */)"w+");
#line 1820
    if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
#line 1821
      fclose(fp);
#line 1822
      return (0);
    }
  }
#line 1824
  while (1) {
#line 1824
    tmp___3 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
#line 1824
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 1824
      break;
    }
#line 1825
    tmp___0 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%[^:]:%[^:]:%*s",
                     u, d);
#line 1825
    if (tmp___0 != 2) {
#line 1826
      continue;
    }
#line 1828
    tmp___1 = strcmp((char const   *)(u), user);
#line 1828
    if (tmp___1) {
#line 1835
      fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s",
              line);
    } else {
#line 1828
      tmp___2 = strcmp((char const   *)(d), domain);
#line 1828
      if (tmp___2) {
#line 1835
        fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s",
                line);
      } else {
#line 1829
        found ++;
#line 1830
        if ((unsigned long )pass != (unsigned long )((void *)0)) {
#line 1831
          mg_md5((char *)(ha1), user, ":", domain, ":", pass, (void *)0);
#line 1832
          fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s:%s:%s\n",
                  user, domain, ha1);
        }
      }
    }
  }
#line 1838
  if (! found) {
#line 1838
    if ((unsigned long )pass != (unsigned long )((void *)0)) {
#line 1839
      mg_md5((char *)(ha1), user, ":", domain, ":", pass, (void *)0);
#line 1840
      fprintf((FILE */* __restrict  */)fp2, (char const   */* __restrict  */)"%s:%s:%s\n",
              user, domain, ha1);
    }
  }
#line 1842
  fclose(fp);
#line 1843
  fclose(fp2);
#line 1844
  remove(fname);
#line 1845
  rename((char const   *)(tmp), fname);
#line 1846
  return (1);
}
}
#line 1848 "web_server.c"
void start_mongoose(int argc , char **argv ) 
{ 
  char ***__cil_gp_s_argv  = & s_argv;
  struct mg_server **__cil_gp_server  = & server;
  int tmp___2_ssa_1 ;
  int tmp___1_ssa_1 ;
  int tmp___0_ssa_1 ;
  int tmp___3_ssa_1 ;
  int tmp___4_ssa_1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  struct mg_server *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  char **__cil_tmp22 ;
  char *__cil_tmp23 ;
  char **__cil_tmp24 ;
  char *__cil_tmp25 ;
  char **__cil_tmp26 ;
  char *__cil_tmp27 ;
  char **__cil_tmp28 ;
  char *__cil_tmp29 ;
  char **__cil_tmp30 ;
  char *__cil_tmp31 ;
  char **__cil_tmp32 ;
  char *__cil_tmp33 ;
  char **__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 1849
  *__cil_gp_s_argv = argv;
#line 1850
  *__cil_gp_server = mg_create_server((void *)0, (int (*)(struct mg_connection * ,
                                                          enum mg_event  ))0);
  }
  {
#line 1850
  __cil_tmp20 = *__cil_gp_server;
#line 1850
  __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 1850
  __cil_tmp16 = __cil_tmp21 == (unsigned long )((void *)0);
#line 1850
  if (__cil_tmp16) {
    {
#line 1851
    die("%s", "Failed to start Mongoose.");
    }
  } else {

  }
  }
  {
#line 1853
  __cil_tmp17 = argc > 1;
#line 1853
  if (__cil_tmp17) {
    {
#line 1853
    __cil_tmp22 = argv + 1;
#line 1853
    __cil_tmp23 = *__cil_tmp22;
#line 1853
    tmp___2_ssa_1 = strcmp((char const   *)__cil_tmp23, "-A");
    }
#line 1853
    if (! tmp___2_ssa_1) {
      {
#line 1854
      __cil_tmp18 = argc != 6;
#line 1854
      if (__cil_tmp18) {
        {
#line 1855
        show_usage_and_exit();
        }
      } else {

      }
      }
      {
#line 1857
      __cil_tmp24 = argv + 2;
#line 1857
      __cil_tmp25 = *__cil_tmp24;
#line 1857
      __cil_tmp26 = argv + 3;
#line 1857
      __cil_tmp27 = *__cil_tmp26;
#line 1857
      __cil_tmp28 = argv + 4;
#line 1857
      __cil_tmp29 = *__cil_tmp28;
#line 1857
      __cil_tmp30 = argv + 5;
#line 1857
      __cil_tmp31 = *__cil_tmp30;
#line 1857
      tmp___1_ssa_1 = modify_passwords_file((char const   *)__cil_tmp25, (char const   *)__cil_tmp27,
                                            (char const   *)__cil_tmp29, (char const   *)__cil_tmp31);
      }
#line 1857
      if (tmp___1_ssa_1) {
        {
#line 1857
        tmp___0_ssa_1 = 0;
        }
      } else {
        {
#line 1857
        tmp___0_ssa_1 = 1;
        }
      }
      {
#line 1857
      exit(tmp___0_ssa_1);
      }
    }
  } else {

  }
  }
  {
#line 1860
  __cil_tmp19 = argc == 2;
#line 1860
  if (__cil_tmp19) {
    {
#line 1860
    __cil_tmp32 = argv + 1;
#line 1860
    __cil_tmp33 = *__cil_tmp32;
#line 1860
    tmp___3_ssa_1 = strcmp((char const   *)__cil_tmp33, "-h");
    }
#line 1860
    if (tmp___3_ssa_1) {
      {
#line 1860
      __cil_tmp34 = argv + 1;
#line 1860
      __cil_tmp35 = *__cil_tmp34;
#line 1860
      tmp___4_ssa_1 = strcmp((char const   *)__cil_tmp35, "--help");
      }
#line 1860
      if (! tmp___4_ssa_1) {
        {
#line 1861
        show_usage_and_exit();
        }
      }
    } else {
      {
#line 1861
      show_usage_and_exit();
      }
    }
  } else {

  }
  }
  {
#line 1863
  set_options(argv);
  }
#line 1864
  return;
}
}
#line 1865 "web_server.c"
static void set_options(char **argv ) 
{ 
  char *options[100] ;
  struct mg_server **__cil_pp_server  = & server;
  void (*__cil_pp_signal_handler)(int sig_num )  = & signal_handler;
  char const   **__cil_gp_s_default_document_root  = & s_default_document_root;
  char const   **__cil_gp_s_default_listening_port  = & s_default_listening_port;
  struct mg_server **__cil_gp_server  = & server;
  char *tmp___0_ssa_1 ;
  int tmp___1_ssa_1 ;
  char const   *tmp_ssa_1 ;
  int i_ssa_1 ;
  char const   *tmp___4_ssa_1 ;
  char **__cil_tmp21 ;
  char const   *__cil_tmp22 ;
  char **__cil_tmp23 ;
  char const   *__cil_tmp24 ;
  char **__cil_tmp25 ;
  char **__cil_tmp26 ;
  char **__cil_tmp27 ;
  char **__cil_tmp28 ;
  char **__cil_tmp29 ;
  char **__cil_tmp30 ;
  char **__cil_tmp31 ;
  char **__cil_tmp32 ;
  char **__cil_tmp33 ;
  char const   *__cil_tmp34 ;
  char **__cil_tmp35 ;
  struct mg_server *__cil_tmp36 ;
  char **__cil_tmp37 ;
  char **__cil_tmp38 ;
  char **__cil_tmp39 ;
  struct mg_server *__cil_tmp40 ;

  {
  {
#line 1868
  *((char **)options) = (char *)0;
#line 1869
  __cil_tmp21 = options;
#line 1869
  __cil_tmp22 = *__cil_gp_s_default_document_root;
#line 1869
  set_option(__cil_tmp21, "document_root", __cil_tmp22);
#line 1870
  __cil_tmp23 = options;
#line 1870
  __cil_tmp24 = *__cil_gp_s_default_listening_port;
#line 1870
  set_option(__cil_tmp23, "listening_port", __cil_tmp24);
#line 1871
  __cil_tmp25 = options;
#line 1871
  process_command_line_arguments(argv, __cil_tmp25);
#line 1872
  __cil_tmp26 = options;
#line 1872
  set_absolute_path(__cil_tmp26, "document_root");
#line 1873
  __cil_tmp27 = options;
#line 1873
  set_absolute_path(__cil_tmp27, "dav_auth_file");
#line 1874
  __cil_tmp28 = options;
#line 1874
  set_absolute_path(__cil_tmp28, "cgi_interpreter");
#line 1875
  __cil_tmp29 = options;
#line 1875
  set_absolute_path(__cil_tmp29, "access_log_file");
#line 1876
  __cil_tmp30 = options;
#line 1876
  set_absolute_path(__cil_tmp30, "global_auth_file");
#line 1877
  __cil_tmp31 = options;
#line 1877
  set_absolute_path(__cil_tmp31, "ssl_certificate");
#line 1878
  __cil_tmp32 = options;
#line 1878
  tmp___0_ssa_1 = get_option(__cil_tmp32, "document_root");
#line 1878
  tmp___1_ssa_1 = path_exists((char const   *)tmp___0_ssa_1, 1);
  }
#line 1878
  if (! tmp___1_ssa_1) {
    {
#line 1879
    __cil_tmp33 = options;
#line 1879
    __cil_tmp34 = *__cil_gp_s_default_document_root;
#line 1879
    set_option(__cil_tmp33, "document_root", __cil_tmp34);
#line 1880
    __cil_tmp35 = options;
#line 1880
    set_absolute_path(__cil_tmp35, "document_root");
#line 1881
    __cil_tmp36 = *__cil_gp_server;
#line 1881
    tmp_ssa_1 = mg_get_option((struct mg_server  const  *)__cil_tmp36, "document_root");
#line 1881
    notify("Setting document_root to [%s]", tmp_ssa_1);
    }
  }
  {
#line 1884
  __cil_tmp37 = options;
#line 1884
  verify_existence(__cil_tmp37, "document_root", 1);
#line 1885
  __cil_tmp38 = options;
#line 1885
  verify_existence(__cil_tmp38, "cgi_interpreter", 0);
#line 1886
  __cil_tmp39 = options;
#line 1886
  verify_existence(__cil_tmp39, "ssl_certificate", 0);
#line 1887
  i_ssa_1 = 0;
  }
  {
#line 1887
  set_options_cil_lr_1(__cil_pp_server, options, i_ssa_1);
  }
  {
#line 1900
  __cil_tmp40 = *__cil_gp_server;
#line 1900
  tmp___4_ssa_1 = mg_get_option((struct mg_server  const  *)__cil_tmp40, "document_root");
#line 1900
  chdir(tmp___4_ssa_1);
#line 1901
  signal(15, __cil_pp_signal_handler);
#line 1902
  signal(2, __cil_pp_signal_handler);
#line 1903
  signal(17, __cil_pp_signal_handler);
  }
#line 1904
  return;
}
}
#line 1905 "web_server.c"
int main(int argc , char **argv ) 
{ 
    Pl_Start_Prolog(argc, argv);

  struct mg_server **__cil_pp_server  = & server;
  struct mg_server **__cil_gp_server  = & server;
  struct _IO_FILE **__cil_gp_stdout  = & stdout;
  int *__cil_gp_exit_flag  = & exit_flag;
  char const   *tmp_ssa_1 ;
  char const   *tmp___0_ssa_1 ;
  struct mg_server *__cil_tmp11 ;
  struct mg_server *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct _IO_FILE *__cil_tmp14 ;
  struct mg_server *__cil_tmp15 ;
  int __cil_tmp16 ;
  struct _IO_FILE *__cil_tmp17 ;

  {
  {
#line 1906
  init_server_name();
#line 1907
  start_mongoose(argc, argv);
#line 1908
  __cil_tmp11 = *__cil_gp_server;
#line 1908
  tmp_ssa_1 = mg_get_option((struct mg_server  const  *)__cil_tmp11, "listening_port");
#line 1908
  __cil_tmp12 = *__cil_gp_server;
#line 1908
  tmp___0_ssa_1 = mg_get_option((struct mg_server  const  *)__cil_tmp12, "document_root");
#line 1908
  __cil_tmp13 = server_name;
#line 1908
  printf((char const   */* __restrict  */)"%s serving [%s] on port %s\n", __cil_tmp13,
         tmp___0_ssa_1, tmp_ssa_1);
#line 1911
  __cil_tmp14 = *__cil_gp_stdout;
#line 1911
  fflush(__cil_tmp14);
#line 1912
  __cil_tmp15 = *__cil_gp_server;
#line 1912
  serving_thread_func((void *)__cil_tmp15);
#line 1913
  __cil_tmp16 = *__cil_gp_exit_flag;
#line 1913
  printf((char const   */* __restrict  */)"Exiting on signal %d ...", __cil_tmp16);
#line 1914
  __cil_tmp17 = *__cil_gp_stdout;
#line 1914
  fflush(__cil_tmp17);
#line 1915
  mg_destroy_server(__cil_pp_server);
#line 1916
  printf((char const   */* __restrict  */)"%s\n", " done.");
  }
#line 1917
   Pl_Stop_Prolog();

  return (0);
}
}
void set_options_cil_lr_1(struct mg_server **__cil_ap_server , char *options[100] ,
                          int i ) 
{ 
  struct mg_server **__cil_gp_server  = & server;
  char const   **__cil_gp_s_default_listening_port  = & s_default_listening_port;
  char const   *tmp___2_ssa_1 ;
  char const   *msg_ssa_1 ;
  int tmp___3_ssa_1 ;
  int i_ssa_1 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char **__cil_tmp15 ;
  char *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  char **__cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char **__cil_tmp21 ;
  char *__cil_tmp22 ;
  struct mg_server *__cil_tmp23 ;
  char **__cil_tmp24 ;
  int __cil_tmp25 ;
  char **__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char **__cil_tmp29 ;
  char *__cil_tmp30 ;
  struct mg_server *__cil_tmp31 ;
  char const   *__cil_tmp32 ;
  char **__cil_tmp33 ;
  char *__cil_tmp34 ;
  char const   *__cil_tmp35 ;
  char **__cil_tmp36 ;
  char *__cil_tmp37 ;
  int __cil_tmp38 ;
  char **__cil_tmp39 ;
  char *__cil_tmp40 ;
  char **__cil_tmp41 ;
  char *__cil_tmp42 ;
  int __cil_tmp43 ;
  char **__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
  {
#line 1887
  __cil_tmp15 = options + i;
#line 1887
  __cil_tmp16 = *__cil_tmp15;
#line 1887
  __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 1887
  __cil_tmp13 = __cil_tmp17 != (unsigned long )((void *)0);
#line 1887
  if (__cil_tmp13) {
    {
#line 1888
    __cil_tmp18 = options + i;
#line 1888
    __cil_tmp19 = *__cil_tmp18;
#line 1888
    __cil_tmp20 = i + 1;
#line 1888
    __cil_tmp21 = options + __cil_tmp20;
#line 1888
    __cil_tmp22 = *__cil_tmp21;
#line 1888
    __cil_tmp23 = *__cil_gp_server;
#line 1888
    tmp___2_ssa_1 = mg_set_option(__cil_tmp23, (char const   *)__cil_tmp19, (char const   *)__cil_tmp22);
#line 1888
    msg_ssa_1 = tmp___2_ssa_1;
    }
    {
#line 1889
    __cil_tmp14 = (unsigned long )msg_ssa_1 != (unsigned long )((void *)0);
#line 1889
    if (__cil_tmp14) {
      {
#line 1890
      __cil_tmp24 = options + i;
#line 1890
      __cil_tmp25 = i + 1;
#line 1890
      __cil_tmp26 = options + __cil_tmp25;
#line 1890
      __cil_tmp27 = *__cil_tmp24;
#line 1890
      __cil_tmp28 = *__cil_tmp26;
#line 1890
      notify("Failed to set option [%s] to [%s]: %s", __cil_tmp27, __cil_tmp28, msg_ssa_1);
#line 1892
      __cil_tmp29 = options + i;
#line 1892
      __cil_tmp30 = *__cil_tmp29;
#line 1892
      tmp___3_ssa_1 = strcmp((char const   *)__cil_tmp30, "listening_port");
      }
#line 1892
      if (! tmp___3_ssa_1) {
        {
#line 1893
        __cil_tmp31 = *__cil_gp_server;
#line 1893
        __cil_tmp32 = *__cil_gp_s_default_listening_port;
#line 1893
        mg_set_option(__cil_tmp31, "listening_port", __cil_tmp32);
#line 1894
        __cil_tmp33 = options + i;
#line 1894
        __cil_tmp34 = *__cil_tmp33;
#line 1894
        __cil_tmp35 = *__cil_gp_s_default_listening_port;
#line 1894
        notify("Setting %s to [%s]", __cil_tmp34, __cil_tmp35);
        }
      }
    } else {

    }
    }
    {
#line 1897
    __cil_tmp36 = options + i;
#line 1897
    __cil_tmp37 = *__cil_tmp36;
#line 1897
    free((void *)__cil_tmp37);
#line 1898
    __cil_tmp38 = i + 1;
#line 1898
    __cil_tmp39 = options + __cil_tmp38;
#line 1898
    __cil_tmp40 = *__cil_tmp39;
#line 1898
    free((void *)__cil_tmp40);
#line 1887
    i_ssa_1 = i + 2;
    }
    {
    set_options_cil_lr_1(__cil_ap_server, options, i_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
  {
#line 1897
  __cil_tmp41 = options + i;
#line 1897
  __cil_tmp42 = *__cil_tmp41;
#line 1897
  free((void *)__cil_tmp42);
#line 1898
  __cil_tmp43 = i + 1;
#line 1898
  __cil_tmp44 = options + __cil_tmp43;
#line 1898
  __cil_tmp45 = *__cil_tmp44;
#line 1898
  free((void *)__cil_tmp45);
#line 1887
  i_ssa_1 = i + 2;
  }
  {
  set_options_cil_lr_1(__cil_ap_server, options, i_ssa_1);
  }
  return;
}
}
void serving_thread_func_cil_lr_1(struct mg_server *srv ) 
{ 
  int *__cil_gp_exit_flag  = & exit_flag;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 1769
  __cil_tmp4 = *__cil_gp_exit_flag;
#line 1769
  __cil_tmp3 = __cil_tmp4 == 0;
#line 1769
  if (__cil_tmp3) {
    {
#line 1770
    mg_poll_server(srv, 1000);
    }
    {
    serving_thread_func_cil_lr_1(srv);
    }
    return;
  } else {
    return;
  }
  }
}
}
int get_option_cil_lr_1(char **__cil_ap___cil_ret5 , char **options , char const   *option_name ,
                        int i ) 
{ 
  int tmp_ssa_1 ;
  int i_ssa_1 ;
  int retflag6_ssa_1 ;
  int __cil_tmp10 ;
  char **__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  char **__cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp16 ;
  char **__cil_tmp17 ;

  {
  {
#line 1762
  __cil_tmp11 = options + i;
#line 1762
  __cil_tmp12 = *__cil_tmp11;
#line 1762
  __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 1762
  __cil_tmp10 = __cil_tmp13 != (unsigned long )((void *)0);
#line 1762
  if (__cil_tmp10) {
    {
#line 1763
    __cil_tmp14 = options + i;
#line 1763
    __cil_tmp15 = *__cil_tmp14;
#line 1763
    tmp_ssa_1 = strcmp((char const   *)__cil_tmp15, option_name);
    }
#line 1763
    if (tmp_ssa_1) {
      {
#line 1762
      i_ssa_1 = i + 1;
      }
      {
      retflag6_ssa_1 = get_option_cil_lr_1(__cil_ap___cil_ret5, options, option_name,
                                           i_ssa_1);
      }
      return (retflag6_ssa_1);
    } else {
      {
      {
#line 1764
      __cil_tmp16 = i + 1;
#line 1764
      __cil_tmp17 = options + __cil_tmp16;
#line 1764
      *__cil_ap___cil_ret5 = *__cil_tmp17;
      }
      return (1);
      }
    }
  } else {
    return (0);
  }
  }
}
}
void set_option_cil_lr_1(int *__cil_ap_i , char **options , char const   *name , char const   *value ) 
{ 
  int tmp_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char **__cil_tmp11 ;
  char *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  char **__cil_tmp16 ;
  int __cil_tmp17 ;
  char **__cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  char **__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 1691
  __cil_tmp9 = *__cil_ap_i;
#line 1691
  __cil_tmp7 = __cil_tmp9 < 97;
#line 1691
  if (__cil_tmp7) {
    {
#line 1692
    __cil_tmp10 = *__cil_ap_i;
#line 1692
    __cil_tmp11 = options + __cil_tmp10;
#line 1692
    __cil_tmp12 = *__cil_tmp11;
#line 1692
    __cil_tmp13 = (unsigned long )__cil_tmp12;
#line 1692
    __cil_tmp8 = __cil_tmp13 == (unsigned long )((void *)0);
#line 1692
    if (__cil_tmp8) {
      {
#line 1693
      *(options + *__cil_ap_i) = sdup(name);
#line 1694
      *(options + (*__cil_ap_i + 1)) = sdup(value);
#line 1695
      __cil_tmp14 = *__cil_ap_i;
#line 1695
      __cil_tmp15 = __cil_tmp14 + 2;
#line 1695
      __cil_tmp16 = options + __cil_tmp15;
#line 1695
      *__cil_tmp16 = (char *)0;
      }
      return;
    } else {
      {
#line 1697
      __cil_tmp17 = *__cil_ap_i;
#line 1697
      __cil_tmp18 = options + __cil_tmp17;
#line 1697
      __cil_tmp19 = *__cil_tmp18;
#line 1697
      tmp_ssa_1 = strcmp((char const   *)__cil_tmp19, name);
      }
#line 1697
      if (tmp_ssa_1) {
        {
#line 1691
        __cil_tmp20 = *__cil_ap_i;
#line 1691
        *__cil_ap_i = __cil_tmp20 + 1;
        }
        {
        set_option_cil_lr_1(__cil_ap_i, options, name, value);
        }
        return;
      } else {
        {
#line 1698
        __cil_tmp21 = *__cil_ap_i;
#line 1698
        __cil_tmp22 = __cil_tmp21 + 1;
#line 1698
        __cil_tmp23 = options + __cil_tmp22;
#line 1698
        __cil_tmp24 = *__cil_tmp23;
#line 1698
        free((void *)__cil_tmp24);
#line 1699
        *(options + (*__cil_ap_i + 1)) = sdup(value);
        }
        return;
      }
    }
    }
  } else {
    return;
  }
  }
}
}
void show_usage_and_exit_cil_lr_1(char const   **names , int i ) 
{ 
  char const   *tmp ;
  struct _IO_FILE **__cil_gp_stderr  = & stderr;
  char const   *tmp_ssa_1 ;
  int i_ssa_1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  char const   **__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  char const   **__cil_tmp13 ;
  char const   *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  char const   **__cil_tmp17 ;
  struct _IO_FILE *__cil_tmp18 ;
  char const   **__cil_tmp19 ;
  char const   *__cil_tmp20 ;
  struct _IO_FILE *__cil_tmp21 ;
  char const   **__cil_tmp22 ;
  char const   *__cil_tmp23 ;

  {
  {
#line 1676
  __cil_tmp9 = names + i;
#line 1676
  __cil_tmp10 = *__cil_tmp9;
#line 1676
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 1676
  __cil_tmp7 = __cil_tmp11 != (unsigned long )((void *)0);
#line 1676
  if (__cil_tmp7) {
    {
#line 1677
    __cil_tmp12 = i + 1;
#line 1677
    __cil_tmp13 = names + __cil_tmp12;
#line 1677
    __cil_tmp14 = *__cil_tmp13;
#line 1677
    __cil_tmp15 = (unsigned long )__cil_tmp14;
#line 1677
    __cil_tmp8 = __cil_tmp15 == (unsigned long )((void *)0);
#line 1677
    if (__cil_tmp8) {
      {
#line 1677
      tmp_ssa_1 = "<empty>";
      }
    } else {
      {
#line 1677
      __cil_tmp16 = i + 1;
#line 1677
      __cil_tmp17 = names + __cil_tmp16;
#line 1677
      tmp_ssa_1 = *__cil_tmp17;
      }
    }
    }
    {
#line 1677
    __cil_tmp18 = *__cil_gp_stderr;
#line 1677
    __cil_tmp19 = names + i;
#line 1677
    __cil_tmp20 = *__cil_tmp19;
#line 1677
    fprintf((FILE */* __restrict  */)__cil_tmp18, (char const   */* __restrict  */)"  -%s %s\n",
            __cil_tmp20, tmp_ssa_1);
#line 1676
    i_ssa_1 = i + 2;
    }
    {
    show_usage_and_exit_cil_lr_1(names, i_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
  {
#line 1677
  __cil_tmp21 = *__cil_gp_stderr;
#line 1677
  __cil_tmp22 = names + i;
#line 1677
  __cil_tmp23 = *__cil_tmp22;
#line 1677
  fprintf((FILE */* __restrict  */)__cil_tmp21, (char const   */* __restrict  */)"  -%s %s\n",
          __cil_tmp23, tmp);
#line 1676
  i_ssa_1 = i + 2;
  }
  {
  show_usage_and_exit_cil_lr_1(names, i_ssa_1);
  }
  return;
}
}
void signal_handler_cil_lr_1(int sig_num ) 
{ 
  int *__cil_pp_sig_num  = & sig_num;
  int *__cil_fp_sig_num  = & sig_num;
  __pid_t tmp_ssa_1 ;
  int sig_num_ssa_1 ;
  int __cil_tmp7 ;

  {
  {
  *__cil_fp_sig_num = sig_num;
#line 1642
  tmp_ssa_1 = waitpid(-1, __cil_pp_sig_num, 1);
  sig_num_ssa_1 = *__cil_fp_sig_num;
  }
  {
#line 1642
  __cil_tmp7 = tmp_ssa_1 > 0;
#line 1642
  if (__cil_tmp7) {
    {
    signal_handler_cil_lr_1(sig_num_ssa_1);
    }
    return;
  } else {
    return;
  }
  }
}
}
