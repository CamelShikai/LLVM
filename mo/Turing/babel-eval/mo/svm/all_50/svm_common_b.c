#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 53 "svm_common.h"
struct word {
   long wnum ;
   float weight ;
};
#line 53 "svm_common.h"
typedef struct word WORD;
#line 58 "svm_common.h"
struct svector {
   WORD *words ;
   double twonorm_sq ;
   char *userdefined ;
   long kernel_id ;
   struct svector *next ;
   double factor ;
};
#line 58 "svm_common.h"
typedef struct svector SVECTOR;
#line 91 "svm_common.h"
struct doc {
   long docnum ;
   long queryid ;
   double costfactor ;
   long slackid ;
   SVECTOR *fvec ;
};
#line 91 "svm_common.h"
typedef struct doc DOC;
#line 184 "svm_common.h"
struct kernel_parm {
   long kernel_type ;
   long poly_degree ;
   double rbf_gamma ;
   double coef_lin ;
   double coef_const ;
   char custom[50] ;
};
#line 184 "svm_common.h"
typedef struct kernel_parm KERNEL_PARM;
#line 193 "svm_common.h"
struct model {
   long sv_num ;
   long at_upper_bound ;
   double b ;
   DOC **supvec ;
   double *alpha ;
   long *index ;
   long totwords ;
   long totdoc ;
   KERNEL_PARM kernel_parm ;
   double loo_error ;
   double loo_recall ;
   double loo_precision ;
   double xa_error ;
   double xa_recall ;
   double xa_precision ;
   double *lin_weights ;
   double maxdiff ;
};
#line 193 "svm_common.h"
typedef struct model MODEL;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 76 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tanh)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 259 "svm_common.h"
double classify_example(MODEL *model , DOC *ex ) ;
#line 260
double classify_example_linear(MODEL *model , DOC *ex ) ;
#line 261
double kernel(KERNEL_PARM *kernel_parm , DOC *a , DOC *b ) ;
#line 262
double single_kernel(KERNEL_PARM *kernel_parm , SVECTOR *a , SVECTOR *b ) ;
#line 263
double custom_kernel(KERNEL_PARM *kernel_parm , SVECTOR *a , SVECTOR *b ) ;
#line 264
SVECTOR *create_svector(WORD *words , char *userdefined , double factor ) ;
#line 265
SVECTOR *copy_svector(SVECTOR *vec ) ;
#line 266
void free_svector(SVECTOR *vec ) ;
#line 267
double sprod_ss(SVECTOR *a , SVECTOR *b ) ;
#line 268
SVECTOR *sub_ss(SVECTOR *a , SVECTOR *b ) ;
#line 269
SVECTOR *add_ss(SVECTOR *a , SVECTOR *b ) ;
#line 270
SVECTOR *add_list_ss(SVECTOR *a ) ;
#line 271
void append_svector_list(SVECTOR *a , SVECTOR *b ) ;
#line 272
SVECTOR *smult_s(SVECTOR *a , double factor ) ;
#line 273
int featvec_eq(SVECTOR *a , SVECTOR *b ) ;
#line 274
double model_length_s(MODEL *model , KERNEL_PARM *kernel_parm ) ;
#line 275
void clear_vector_n(double *vec , long n ) ;
#line 276
void add_vector_ns(double *vec_n , SVECTOR *vec_s , double faktor ) ;
#line 277
double sprod_ns(double *vec_n , SVECTOR *vec_s ) ;
#line 278
void add_weight_vector_to_linear_model(MODEL *model ) ;
#line 279
DOC *create_example(long docnum , long queryid , long slackid , double costfactor ,
                    SVECTOR *fvec ) ;
#line 280
void free_example(DOC *example , long deep ) ;
#line 281
MODEL *read_model(char *modelfile ) ;
#line 282
MODEL *copy_model(MODEL *model ) ;
#line 283
void free_model(MODEL *model , int deep ) ;
#line 284
void read_documents(char *docfile , DOC ***docs , double **label , long *totwords ,
                    long *totdoc ) ;
#line 285
int parse_document(char *line , WORD *words , double *label , long *queryid , long *slackid ,
                   double *costfactor , long *numwords , long max_words_doc , char **comment ) ;
#line 286
double *read_alphas(char *alphafile , long totdoc ) ;
#line 287
void nol_ll(char *file , long *nol , long *wol , long *ll ) ;
#line 288
long minl(long a , long b ) ;
#line 289
long maxl(long a , long b ) ;
#line 290
long get_runtime(void) ;
#line 291
int space_or_null(int c ) ;
#line 292
void *my_malloc(size_t size ) ;
#line 293
void copyright_notice(void) ;
#line 298 "svm_common.h"
long verbosity  ;
#line 299 "svm_common.h"
long kernel_cache_statistic  ;
#line 300
void write_model_cil_lr_2_cil_lr_1_cil_lr_1(SVECTOR **__cil_ap_v , FILE **__cil_ap_modelfl ,
                                            long j ) ;
#line 302
void parse_document_cil_lr_5_cil_lr_1(char **__cil_ap_line , long **__cil_ap_queryid ,
                                      long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                                      long *__cil_ap_max_words_doc , long *__cil_ap_pos ,
                                      long *__cil_ap_wnum , double *__cil_ap_weight ) ;
#line 306
void parse_document_cil_lr_5_cil_lr_2(char **__cil_ap_line , long **__cil_ap_queryid ,
                                      long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                                      long *__cil_ap_max_words_doc , long *__cil_ap_pos ,
                                      long *__cil_ap_wnum , double *__cil_ap_weight ) ;
#line 310
void write_model_cil_lr_2_cil_lr_1(MODEL **__cil_ap_model , long *__cil_ap_i , FILE **__cil_ap_modelfl ,
                                   SVECTOR *v ) ;
#line 312
void write_model_cil_lr_1_cil_lr_1(long *__cil_ap_i , long *__cil_ap_sv_num , SVECTOR *v ) ;
#line 313
void add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1(MODEL **__cil_ap_model ,
                                                         long *__cil_ap_i , SVECTOR *f ) ;
#line 315
void model_length_s_cil_lr_1_cil_lr_1(MODEL **__cil_ap_model , KERNEL_PARM **__cil_ap_kernel_parm ,
                                      long *__cil_ap_i , double *__cil_ap_sum , double alphai ,
                                      DOC *supveci , long j ) ;
#line 318
void kernel_cil_lr_1_cil_lr_1(KERNEL_PARM **__cil_ap_kernel_parm , DOC **__cil_ap_b ,
                              SVECTOR **__cil_ap_fa , double *__cil_ap_sum , SVECTOR *fb ) ;
#line 320
void nol_ll_cil_lr_1(FILE **__cil_ap_fl , long *nol , long *wol , long *ll , long current_length ,
                     long current_wol ) ;
#line 322
void read_alphas_cil_lr_1(struct _IO_FILE **__cil_ap_stdout , long *__cil_ap_verbosity ,
                          long *__cil_ap_totdoc , FILE **__cil_ap_fl , double **__cil_ap_alpha ,
                          long *__cil_ap_dnum ) ;
#line 325
void parse_document_cil_lr_1(char **__cil_ap_line , WORD **__cil_ap_words , double **__cil_ap_label ,
                             long **__cil_ap_queryid , long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             char ***__cil_ap_comment , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight ) ;
#line 330
void parse_document_cil_lr_2(char **__cil_ap_line , WORD **__cil_ap_words , double **__cil_ap_label ,
                             long **__cil_ap_queryid , long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             long *__cil_ap_wpos , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight , char *featurepair ) ;
#line 335
void parse_document_cil_lr_3(char **__cil_ap_line , WORD **__cil_ap_words , long **__cil_ap_queryid ,
                             long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             long *__cil_ap_wpos , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight ) ;
#line 340
void parse_document_cil_lr_4(char **__cil_ap_line , WORD **__cil_ap_words , long **__cil_ap_queryid ,
                             long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             long *__cil_ap_wpos , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight ) ;
#line 345
void parse_document_cil_lr_5(WORD **__cil_ap_words , long **__cil_ap_numwords , long *__cil_ap_wpos ,
                             char *line , long *queryid , long *slackid , double *costfactor ,
                             long max_words_doc , long pos , long wnum , double weight ,
                             char *featurepair , char *junk ) ;
#line 349
void free_model_cil_lr_1(MODEL **__cil_ap_model , long i ) ;
#line 350
void copy_model_cil_lr_1(MODEL **__cil_ap_model , MODEL **__cil_ap_newmodel , long i ) ;
#line 351
void copy_model_cil_lr_2(MODEL **__cil_ap_newmodel , MODEL *model , long i ) ;
#line 352
void read_model_cil_lr_1(struct _IO_FILE **__cil_ap_stdout , long *__cil_ap_verbosity ,
                         FILE **__cil_ap_modelfl , char **__cil_ap_line , WORD **__cil_ap_words ,
                         MODEL **__cil_ap_model , long i , long queryid , long slackid ,
                         double costfactor , long max_words , long ll , long wpos ,
                         char *comment ) ;
#line 357
void write_model_cil_lr_1(long *__cil_ap_verbosity , MODEL **__cil_ap_model , FILE **__cil_ap_modelfl ,
                          long *__cil_ap_sv_num , long i ) ;
#line 359
void write_model_cil_lr_2(long *__cil_ap_verbosity , FILE **__cil_ap_modelfl , MODEL *model ,
                          long i ) ;
#line 361
void add_weight_vector_to_linear_model_cil_lr_1(MODEL *model , long i ) ;
#line 362
void sprod_ns_cil_lr_1(double *__cil_ap_sum , double *vec_n , WORD *ai ) ;
#line 363
void add_vector_ns_cil_lr_1(double *vec_n , double faktor , WORD *ai ) ;
#line 364
void clear_vector_n_cil_lr_1(double *vec , long n , long i ) ;
#line 365
void model_length_s_cil_lr_1(double *__cil_ap_sum , MODEL *model , KERNEL_PARM *kernel_parm ,
                             long i ) ;
#line 367
int featvec_eq_cil_lr_1(int *__cil_ap___cil_ret5 , WORD *ai , WORD *bj ) ;
#line 368
void smult_s_cil_lr_1(SVECTOR **__cil_ap_a , double *__cil_ap_factor , long *__cil_ap_veclength ,
                      WORD *ai ) ;
#line 370
void smult_s_cil_lr_2(SVECTOR **__cil_ap_a , WORD **__cil_ap_sum , WORD **__cil_ap_sumi ,
                      double factor , WORD *ai ) ;
#line 372
void append_svector_list_cil_lr_1(SVECTOR **__cil_ap_b , SVECTOR **__cil_ap_f ) ;
#line 373
void add_list_ss_cil_lr_1(SVECTOR **__cil_ap_sum , SVECTOR *f ) ;
#line 374
void add_ss_cil_lr_1(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj , long *__cil_ap_veclength ) ;
#line 376
void add_ss_cil_lr_2(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     long *__cil_ap_veclength , WORD *bj ) ;
#line 378
void add_ss_cil_lr_3(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , long *__cil_ap_veclength ,
                     WORD *ai ) ;
#line 380
void add_ss_cil_lr_4(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj ) ;
#line 382
void add_ss_cil_lr_5(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD *bj ) ;
#line 384
void add_ss_cil_lr_6(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD *ai ) ;
#line 385
void sub_ss_cil_lr_1(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj , long *__cil_ap_veclength ) ;
#line 387
void sub_ss_cil_lr_2(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     long *__cil_ap_veclength , WORD *bj ) ;
#line 389
void sub_ss_cil_lr_3(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , long *__cil_ap_veclength ,
                     WORD *ai ) ;
#line 391
void sub_ss_cil_lr_4(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj ) ;
#line 393
void sub_ss_cil_lr_5(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD *bj ) ;
#line 395
void sub_ss_cil_lr_6(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD *ai ) ;
#line 396
void sprod_ss_cil_lr_1(double *__cil_ap_sum , WORD *ai , WORD *bj ) ;
#line 397
void create_svector_cil_lr_1(WORD **__cil_ap_words , char **__cil_ap_userdefined ,
                             double *__cil_ap_factor , long *__cil_ap_fnum ) ;
#line 399
void create_svector_cil_lr_2(char **__cil_ap_userdefined , double *__cil_ap_factor ,
                             SVECTOR **__cil_ap_vec , WORD *words , long fnum , long i ) ;
#line 401
void create_svector_cil_lr_3(char **__cil_ap_userdefined , double *__cil_ap_factor ,
                             SVECTOR **__cil_ap_vec , long *__cil_ap_fnum ) ;
#line 403
void create_svector_cil_lr_4(double *__cil_ap_factor , SVECTOR **__cil_ap_vec , char *userdefined ,
                             long fnum , long i ) ;
#line 405
void kernel_cil_lr_1(double *__cil_ap_sum , KERNEL_PARM *kernel_parm , DOC *b , SVECTOR *fa ) ;
#line 406
void classify_example_linear_cil_lr_1(MODEL **__cil_ap_model , double *__cil_ap_sum ,
                                      SVECTOR *f ) ;
#line 408
void classify_example_cil_lr_1(MODEL **__cil_ap_model , double *__cil_ap_dist , DOC *ex ,
                               long i ) ;

   int babel_wrapper_clear_vector_n(double * vec, long  n)                           // function name insert
      {
        // wrapper for function clear_vector_n        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("clear_vector_n"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(vec);
arg[1] = Pl_Mk_Integer(n);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_vector_ns(double * vec_n, SVECTOR * vec_s, double  faktor)                           // function name insert
      {
        // wrapper for function add_vector_ns        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_vector_ns"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(vec_n);
arg[1] = Pl_Mk_Integer(vec_s);
arg[2] = Pl_Mk_Float(faktor);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_clear_vector_n_cil_lr_1(double * vec, long  n, long  i)                           // function name insert
      {
        // wrapper for function clear_vector_n_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("clear_vector_n_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(vec);
arg[1] = Pl_Mk_Integer(n);
arg[2] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }













   double  babel_wrapper_classify_example(MODEL ** __cil_pp_model, double * __cil_pp_dist, MODEL ** __cil_fp_model, double * __cil_fp_dist, MODEL * model, DOC * ex)                           // function name insert
      {
        // wrapper for function classify_example        // function name insert
         double  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("classify_example"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_model);
arg[1] = Pl_Mk_Integer(__cil_pp_dist);
arg[2] = Pl_Mk_Integer(__cil_fp_model);
arg[3] = Pl_Mk_Integer(__cil_fp_dist);
arg[4] = Pl_Mk_Integer(model);
arg[5] = Pl_Mk_Integer(ex);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Float(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   double  babel_wrapper_classify_example_linear(MODEL ** __cil_pp_model, double * __cil_pp_sum, MODEL ** __cil_fp_model, double * __cil_fp_sum, MODEL * model, DOC * ex)                           // function name insert
      {
        // wrapper for function classify_example_linear        // function name insert
         double  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("classify_example_linear"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_model);
arg[1] = Pl_Mk_Integer(__cil_pp_sum);
arg[2] = Pl_Mk_Integer(__cil_fp_model);
arg[3] = Pl_Mk_Integer(__cil_fp_sum);
arg[4] = Pl_Mk_Integer(model);
arg[5] = Pl_Mk_Integer(ex);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Float(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_free_svector(SVECTOR * vec)                           // function name insert
      {
        // wrapper for function free_svector        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("free_svector"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(vec);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   SVECTOR * babel_wrapper_sub_ss(SVECTOR ** __cil_pp_a, SVECTOR ** __cil_pp_b, WORD ** __cil_pp_ai, WORD ** __cil_pp_bj, long * __cil_pp_veclength, WORD ** __cil_pp_sum, WORD ** __cil_pp_sumi, SVECTOR ** __cil_fp_a, SVECTOR ** __cil_fp_b, WORD ** __cil_fp_ai, WORD ** __cil_fp_bj, long * __cil_fp_veclength, WORD ** __cil_fp_sum, WORD ** __cil_fp_sumi, SVECTOR * a, SVECTOR * b)                           // function name insert
      {
        // wrapper for function sub_ss        // function name insert
         SVECTOR * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[17];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sub_ss"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_a);
arg[1] = Pl_Mk_Integer(__cil_pp_b);
arg[2] = Pl_Mk_Integer(__cil_pp_ai);
arg[3] = Pl_Mk_Integer(__cil_pp_bj);
arg[4] = Pl_Mk_Integer(__cil_pp_veclength);
arg[5] = Pl_Mk_Integer(__cil_pp_sum);
arg[6] = Pl_Mk_Integer(__cil_pp_sumi);
arg[7] = Pl_Mk_Integer(__cil_fp_a);
arg[8] = Pl_Mk_Integer(__cil_fp_b);
arg[9] = Pl_Mk_Integer(__cil_fp_ai);
arg[10] = Pl_Mk_Integer(__cil_fp_bj);
arg[11] = Pl_Mk_Integer(__cil_fp_veclength);
arg[12] = Pl_Mk_Integer(__cil_fp_sum);
arg[13] = Pl_Mk_Integer(__cil_fp_sumi);
arg[14] = Pl_Mk_Integer(a);
arg[15] = Pl_Mk_Integer(b);

      //routine code, reserve a place for return value
      arg[16] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 17, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[16]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   SVECTOR * babel_wrapper_add_ss(SVECTOR ** __cil_pp_a, SVECTOR ** __cil_pp_b, WORD ** __cil_pp_ai, WORD ** __cil_pp_bj, long * __cil_pp_veclength, WORD ** __cil_pp_sum, WORD ** __cil_pp_sumi, SVECTOR ** __cil_fp_a, SVECTOR ** __cil_fp_b, WORD ** __cil_fp_ai, WORD ** __cil_fp_bj, long * __cil_fp_veclength, WORD ** __cil_fp_sum, WORD ** __cil_fp_sumi, SVECTOR * a, SVECTOR * b)                           // function name insert
      {
        // wrapper for function add_ss        // function name insert
         SVECTOR * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[17];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_ss"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_a);
arg[1] = Pl_Mk_Integer(__cil_pp_b);
arg[2] = Pl_Mk_Integer(__cil_pp_ai);
arg[3] = Pl_Mk_Integer(__cil_pp_bj);
arg[4] = Pl_Mk_Integer(__cil_pp_veclength);
arg[5] = Pl_Mk_Integer(__cil_pp_sum);
arg[6] = Pl_Mk_Integer(__cil_pp_sumi);
arg[7] = Pl_Mk_Integer(__cil_fp_a);
arg[8] = Pl_Mk_Integer(__cil_fp_b);
arg[9] = Pl_Mk_Integer(__cil_fp_ai);
arg[10] = Pl_Mk_Integer(__cil_fp_bj);
arg[11] = Pl_Mk_Integer(__cil_fp_veclength);
arg[12] = Pl_Mk_Integer(__cil_fp_sum);
arg[13] = Pl_Mk_Integer(__cil_fp_sumi);
arg[14] = Pl_Mk_Integer(a);
arg[15] = Pl_Mk_Integer(b);

      //routine code, reserve a place for return value
      arg[16] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 17, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[16]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_append_svector_list(SVECTOR ** __cil_pp_b, SVECTOR ** __cil_pp_f, SVECTOR ** __cil_fp_b, SVECTOR ** __cil_fp_f, SVECTOR * a, SVECTOR * b)                           // function name insert
      {
        // wrapper for function append_svector_list        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("append_svector_list"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_b);
arg[1] = Pl_Mk_Integer(__cil_pp_f);
arg[2] = Pl_Mk_Integer(__cil_fp_b);
arg[3] = Pl_Mk_Integer(__cil_fp_f);
arg[4] = Pl_Mk_Integer(a);
arg[5] = Pl_Mk_Integer(b);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   SVECTOR * babel_wrapper_smult_s(SVECTOR ** __cil_pp_a, double * __cil_pp_factor, long * __cil_pp_veclength, WORD ** __cil_pp_sum, WORD ** __cil_pp_sumi, SVECTOR ** __cil_fp_a, double * __cil_fp_factor, long * __cil_fp_veclength, WORD ** __cil_fp_sum, WORD ** __cil_fp_sumi, SVECTOR * a, double  factor)                           // function name insert
      {
        // wrapper for function smult_s        // function name insert
         SVECTOR * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[13];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("smult_s"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_a);
arg[1] = Pl_Mk_Integer(__cil_pp_factor);
arg[2] = Pl_Mk_Integer(__cil_pp_veclength);
arg[3] = Pl_Mk_Integer(__cil_pp_sum);
arg[4] = Pl_Mk_Integer(__cil_pp_sumi);
arg[5] = Pl_Mk_Integer(__cil_fp_a);
arg[6] = Pl_Mk_Integer(__cil_fp_factor);
arg[7] = Pl_Mk_Integer(__cil_fp_veclength);
arg[8] = Pl_Mk_Integer(__cil_fp_sum);
arg[9] = Pl_Mk_Integer(__cil_fp_sumi);
arg[10] = Pl_Mk_Integer(a);
arg[11] = Pl_Mk_Float(factor);

      //routine code, reserve a place for return value
      arg[12] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 13, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[12]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   double  babel_wrapper_model_length_s(double * __cil_pp_sum, double * __cil_fp_sum, MODEL * model, KERNEL_PARM * kernel_parm)                           // function name insert
      {
        // wrapper for function model_length_s        // function name insert
         double  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("model_length_s"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_sum);
arg[1] = Pl_Mk_Integer(__cil_fp_sum);
arg[2] = Pl_Mk_Integer(model);
arg[3] = Pl_Mk_Integer(kernel_parm);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Float(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_add_weight_vector_to_linear_model(MODEL * model)                           // function name insert
      {
        // wrapper for function add_weight_vector_to_linear_model        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[2];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_weight_vector_to_linear_model"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(model);

      //routine code, reserve a place for return value
      arg[1] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[1]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   DOC * babel_wrapper_create_example(long  docnum, long  queryid, long  slackid, double  costfactor, SVECTOR * fvec)                           // function name insert
      {
        // wrapper for function create_example        // function name insert
         DOC * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("create_example"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(docnum);
arg[1] = Pl_Mk_Integer(queryid);
arg[2] = Pl_Mk_Integer(slackid);
arg[3] = Pl_Mk_Float(costfactor);
arg[4] = Pl_Mk_Integer(fvec);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_free_example(DOC * example, long  deep)                           // function name insert
      {
        // wrapper for function free_example        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("free_example"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(example);
arg[1] = Pl_Mk_Integer(deep);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_write_model(long * __cil_pp_verbosity, MODEL ** __cil_pp_model, FILE ** __cil_pp_modelfl, long * __cil_pp_sv_num, long * __cil_gp_verbosity, struct _IO_FILE ** __cil_gp_stdout, MODEL ** __cil_fp_model, FILE ** __cil_fp_modelfl, long * __cil_fp_sv_num, char * modelfile, MODEL * model)                           // function name insert
      {
        // wrapper for function write_model        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[12];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_model"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_verbosity);
arg[1] = Pl_Mk_Integer(__cil_pp_model);
arg[2] = Pl_Mk_Integer(__cil_pp_modelfl);
arg[3] = Pl_Mk_Integer(__cil_pp_sv_num);
arg[4] = Pl_Mk_Integer(__cil_gp_verbosity);
arg[5] = Pl_Mk_Integer(__cil_gp_stdout);
arg[6] = Pl_Mk_Integer(__cil_fp_model);
arg[7] = Pl_Mk_Integer(__cil_fp_modelfl);
arg[8] = Pl_Mk_Integer(__cil_fp_sv_num);
arg[9] = Pl_Mk_Integer(modelfile);
arg[10] = Pl_Mk_Integer(model);

      //routine code, reserve a place for return value
      arg[11] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 12, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[11]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   MODEL * babel_wrapper_copy_model(MODEL ** __cil_pp_model, MODEL ** __cil_pp_newmodel, MODEL ** __cil_fp_model, MODEL ** __cil_fp_newmodel, MODEL * model)                           // function name insert
      {
        // wrapper for function copy_model        // function name insert
         MODEL * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("copy_model"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_model);
arg[1] = Pl_Mk_Integer(__cil_pp_newmodel);
arg[2] = Pl_Mk_Integer(__cil_fp_model);
arg[3] = Pl_Mk_Integer(__cil_fp_newmodel);
arg[4] = Pl_Mk_Integer(model);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   long  babel_wrapper_minl(long  a, long  b)                           // function name insert
      {
        // wrapper for function minl        // function name insert
         long  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("minl"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(a);
arg[1] = Pl_Mk_Integer(b);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   long  babel_wrapper_maxl(long  a, long  b)                           // function name insert
      {
        // wrapper for function maxl        // function name insert
         long  return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("maxl"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(a);
arg[1] = Pl_Mk_Integer(b);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_write_model_cil_lr_2_cil_lr_1_cil_lr_1(SVECTOR ** __cil_ap_v, FILE ** __cil_ap_modelfl, long  j)                           // function name insert
      {
        // wrapper for function write_model_cil_lr_2_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_model_cil_lr_2_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_v);
arg[1] = Pl_Mk_Integer(__cil_ap_modelfl);
arg[2] = Pl_Mk_Integer(j);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_write_model_cil_lr_2_cil_lr_1(SVECTOR ** __cil_pp_v, SVECTOR ** __cil_fp_v, MODEL ** __cil_ap_model, long * __cil_ap_i, FILE ** __cil_ap_modelfl, SVECTOR * v)                           // function name insert
      {
        // wrapper for function write_model_cil_lr_2_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_model_cil_lr_2_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_v);
arg[1] = Pl_Mk_Integer(__cil_fp_v);
arg[2] = Pl_Mk_Integer(__cil_ap_model);
arg[3] = Pl_Mk_Integer(__cil_ap_i);
arg[4] = Pl_Mk_Integer(__cil_ap_modelfl);
arg[5] = Pl_Mk_Integer(v);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_write_model_cil_lr_1_cil_lr_1(long * __cil_ap_i, long * __cil_ap_sv_num, SVECTOR * v)                           // function name insert
      {
        // wrapper for function write_model_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_model_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_i);
arg[1] = Pl_Mk_Integer(__cil_ap_sv_num);
arg[2] = Pl_Mk_Integer(v);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1(MODEL ** __cil_ap_model, long * __cil_ap_i, SVECTOR * f)                           // function name insert
      {
        // wrapper for function add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_model);
arg[1] = Pl_Mk_Integer(__cil_ap_i);
arg[2] = Pl_Mk_Integer(f);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_model_length_s_cil_lr_1_cil_lr_1(MODEL ** __cil_ap_model, KERNEL_PARM ** __cil_ap_kernel_parm, long * __cil_ap_i, double * __cil_ap_sum, double  alphai, DOC * supveci, long  j)                           // function name insert
      {
        // wrapper for function model_length_s_cil_lr_1_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("model_length_s_cil_lr_1_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_model);
arg[1] = Pl_Mk_Integer(__cil_ap_kernel_parm);
arg[2] = Pl_Mk_Integer(__cil_ap_i);
arg[3] = Pl_Mk_Integer(__cil_ap_sum);
arg[4] = Pl_Mk_Float(alphai);
arg[5] = Pl_Mk_Integer(supveci);
arg[6] = Pl_Mk_Integer(j);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_copy_model_cil_lr_2(MODEL ** __cil_ap_newmodel, MODEL * model, long  i)                           // function name insert
      {
        // wrapper for function copy_model_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("copy_model_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_newmodel);
arg[1] = Pl_Mk_Integer(model);
arg[2] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_write_model_cil_lr_1(long * __cil_pp_i, long * __cil_fp_i, long * __cil_ap_verbosity, MODEL ** __cil_ap_model, FILE ** __cil_ap_modelfl, long * __cil_ap_sv_num, long  i)                           // function name insert
      {
        // wrapper for function write_model_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[8];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_model_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_i);
arg[1] = Pl_Mk_Integer(__cil_fp_i);
arg[2] = Pl_Mk_Integer(__cil_ap_verbosity);
arg[3] = Pl_Mk_Integer(__cil_ap_model);
arg[4] = Pl_Mk_Integer(__cil_ap_modelfl);
arg[5] = Pl_Mk_Integer(__cil_ap_sv_num);
arg[6] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[7] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 8, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[7]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_write_model_cil_lr_2(MODEL ** __cil_pp_model, long * __cil_pp_i, MODEL ** __cil_fp_model, long * __cil_fp_i, long * __cil_ap_verbosity, FILE ** __cil_ap_modelfl, MODEL * model, long  i)                           // function name insert
      {
        // wrapper for function write_model_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[9];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("write_model_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_model);
arg[1] = Pl_Mk_Integer(__cil_pp_i);
arg[2] = Pl_Mk_Integer(__cil_fp_model);
arg[3] = Pl_Mk_Integer(__cil_fp_i);
arg[4] = Pl_Mk_Integer(__cil_ap_verbosity);
arg[5] = Pl_Mk_Integer(__cil_ap_modelfl);
arg[6] = Pl_Mk_Integer(model);
arg[7] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[8] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 9, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[8]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_weight_vector_to_linear_model_cil_lr_1(MODEL ** __cil_pp_model, long * __cil_pp_i, MODEL ** __cil_fp_model, long * __cil_fp_i, MODEL * model, long  i)                           // function name insert
      {
        // wrapper for function add_weight_vector_to_linear_model_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[7];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_weight_vector_to_linear_model_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_model);
arg[1] = Pl_Mk_Integer(__cil_pp_i);
arg[2] = Pl_Mk_Integer(__cil_fp_model);
arg[3] = Pl_Mk_Integer(__cil_fp_i);
arg[4] = Pl_Mk_Integer(model);
arg[5] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[6] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 7, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[6]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_model_length_s_cil_lr_1(MODEL ** __cil_pp_model, KERNEL_PARM ** __cil_pp_kernel_parm, long * __cil_pp_i, MODEL ** __cil_fp_model, KERNEL_PARM ** __cil_fp_kernel_parm, long * __cil_fp_i, double * __cil_ap_sum, MODEL * model, KERNEL_PARM * kernel_parm, long  i)                           // function name insert
      {
        // wrapper for function model_length_s_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[11];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("model_length_s_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_pp_model);
arg[1] = Pl_Mk_Integer(__cil_pp_kernel_parm);
arg[2] = Pl_Mk_Integer(__cil_pp_i);
arg[3] = Pl_Mk_Integer(__cil_fp_model);
arg[4] = Pl_Mk_Integer(__cil_fp_kernel_parm);
arg[5] = Pl_Mk_Integer(__cil_fp_i);
arg[6] = Pl_Mk_Integer(__cil_ap_sum);
arg[7] = Pl_Mk_Integer(model);
arg[8] = Pl_Mk_Integer(kernel_parm);
arg[9] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[10] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 11, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[10]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_smult_s_cil_lr_1(SVECTOR ** __cil_ap_a, double * __cil_ap_factor, long * __cil_ap_veclength, WORD * ai)                           // function name insert
      {
        // wrapper for function smult_s_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("smult_s_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_factor);
arg[2] = Pl_Mk_Integer(__cil_ap_veclength);
arg[3] = Pl_Mk_Integer(ai);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_smult_s_cil_lr_2(SVECTOR ** __cil_ap_a, WORD ** __cil_ap_sum, WORD ** __cil_ap_sumi, double  factor, WORD * ai)                           // function name insert
      {
        // wrapper for function smult_s_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("smult_s_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_sum);
arg[2] = Pl_Mk_Integer(__cil_ap_sumi);
arg[3] = Pl_Mk_Float(factor);
arg[4] = Pl_Mk_Integer(ai);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_append_svector_list_cil_lr_1(SVECTOR ** __cil_ap_b, SVECTOR ** __cil_ap_f)                           // function name insert
      {
        // wrapper for function append_svector_list_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("append_svector_list_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_b);
arg[1] = Pl_Mk_Integer(__cil_ap_f);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_ss_cil_lr_1(SVECTOR ** __cil_ap_a, SVECTOR ** __cil_ap_b, WORD ** __cil_ap_ai, WORD ** __cil_ap_bj, long * __cil_ap_veclength)                           // function name insert
      {
        // wrapper for function add_ss_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_ss_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_b);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(__cil_ap_bj);
arg[4] = Pl_Mk_Integer(__cil_ap_veclength);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_ss_cil_lr_2(SVECTOR ** __cil_ap_a, SVECTOR ** __cil_ap_b, WORD ** __cil_ap_ai, long * __cil_ap_veclength, WORD * bj)                           // function name insert
      {
        // wrapper for function add_ss_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_ss_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_b);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(__cil_ap_veclength);
arg[4] = Pl_Mk_Integer(bj);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_ss_cil_lr_3(SVECTOR ** __cil_ap_a, SVECTOR ** __cil_ap_b, long * __cil_ap_veclength, WORD * ai)                           // function name insert
      {
        // wrapper for function add_ss_cil_lr_3        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_ss_cil_lr_3"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_b);
arg[2] = Pl_Mk_Integer(__cil_ap_veclength);
arg[3] = Pl_Mk_Integer(ai);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_ss_cil_lr_4(WORD ** __cil_ap_sum, WORD ** __cil_ap_sumi, WORD ** __cil_ap_ai, WORD ** __cil_ap_bj)                           // function name insert
      {
        // wrapper for function add_ss_cil_lr_4        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_ss_cil_lr_4"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_sum);
arg[1] = Pl_Mk_Integer(__cil_ap_sumi);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(__cil_ap_bj);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_ss_cil_lr_5(WORD ** __cil_ap_sum, WORD ** __cil_ap_sumi, WORD ** __cil_ap_ai, WORD * bj)                           // function name insert
      {
        // wrapper for function add_ss_cil_lr_5        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_ss_cil_lr_5"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_sum);
arg[1] = Pl_Mk_Integer(__cil_ap_sumi);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(bj);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_add_ss_cil_lr_6(WORD ** __cil_ap_sum, WORD ** __cil_ap_sumi, WORD * ai)                           // function name insert
      {
        // wrapper for function add_ss_cil_lr_6        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("add_ss_cil_lr_6"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_sum);
arg[1] = Pl_Mk_Integer(__cil_ap_sumi);
arg[2] = Pl_Mk_Integer(ai);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sub_ss_cil_lr_1(SVECTOR ** __cil_ap_a, SVECTOR ** __cil_ap_b, WORD ** __cil_ap_ai, WORD ** __cil_ap_bj, long * __cil_ap_veclength)                           // function name insert
      {
        // wrapper for function sub_ss_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sub_ss_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_b);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(__cil_ap_bj);
arg[4] = Pl_Mk_Integer(__cil_ap_veclength);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sub_ss_cil_lr_2(SVECTOR ** __cil_ap_a, SVECTOR ** __cil_ap_b, WORD ** __cil_ap_ai, long * __cil_ap_veclength, WORD * bj)                           // function name insert
      {
        // wrapper for function sub_ss_cil_lr_2        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[6];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sub_ss_cil_lr_2"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_b);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(__cil_ap_veclength);
arg[4] = Pl_Mk_Integer(bj);

      //routine code, reserve a place for return value
      arg[5] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 6, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[5]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sub_ss_cil_lr_3(SVECTOR ** __cil_ap_a, SVECTOR ** __cil_ap_b, long * __cil_ap_veclength, WORD * ai)                           // function name insert
      {
        // wrapper for function sub_ss_cil_lr_3        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sub_ss_cil_lr_3"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_a);
arg[1] = Pl_Mk_Integer(__cil_ap_b);
arg[2] = Pl_Mk_Integer(__cil_ap_veclength);
arg[3] = Pl_Mk_Integer(ai);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sub_ss_cil_lr_4(WORD ** __cil_ap_sum, WORD ** __cil_ap_sumi, WORD ** __cil_ap_ai, WORD ** __cil_ap_bj)                           // function name insert
      {
        // wrapper for function sub_ss_cil_lr_4        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sub_ss_cil_lr_4"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_sum);
arg[1] = Pl_Mk_Integer(__cil_ap_sumi);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(__cil_ap_bj);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sub_ss_cil_lr_5(WORD ** __cil_ap_sum, WORD ** __cil_ap_sumi, WORD ** __cil_ap_ai, WORD * bj)                           // function name insert
      {
        // wrapper for function sub_ss_cil_lr_5        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sub_ss_cil_lr_5"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_sum);
arg[1] = Pl_Mk_Integer(__cil_ap_sumi);
arg[2] = Pl_Mk_Integer(__cil_ap_ai);
arg[3] = Pl_Mk_Integer(bj);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_sub_ss_cil_lr_6(WORD ** __cil_ap_sum, WORD ** __cil_ap_sumi, WORD * ai)                           // function name insert
      {
        // wrapper for function sub_ss_cil_lr_6        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("sub_ss_cil_lr_6"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_sum);
arg[1] = Pl_Mk_Integer(__cil_ap_sumi);
arg[2] = Pl_Mk_Integer(ai);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_classify_example_linear_cil_lr_1(MODEL ** __cil_ap_model, double * __cil_ap_sum, SVECTOR * f)                           // function name insert
      {
        // wrapper for function classify_example_linear_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[4];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("classify_example_linear_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_model);
arg[1] = Pl_Mk_Integer(__cil_ap_sum);
arg[2] = Pl_Mk_Integer(f);

      //routine code, reserve a place for return value
      arg[3] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[3]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
   int babel_wrapper_classify_example_cil_lr_1(MODEL ** __cil_ap_model, double * __cil_ap_dist, DOC * ex, long  i)                           // function name insert
      {
        // wrapper for function classify_example_cil_lr_1        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[5];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("classify_example_cil_lr_1"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      arg[0] = Pl_Mk_Integer(__cil_ap_model);
arg[1] = Pl_Mk_Integer(__cil_ap_dist);
arg[2] = Pl_Mk_Integer(ex);
arg[3] = Pl_Mk_Integer(i);

      //routine code, reserve a place for return value
      arg[4] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[4]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
#line 36 "kernel.h"
double custom_kernel(KERNEL_PARM *kernel_parm , SVECTOR *a , SVECTOR *b ) 
{ 


  {
#line 39
  return (1.0);
}
}
#line 26 "svm_common.c"
double classify_example(MODEL *model , DOC *ex ) 
{ 
  double dist ;
  MODEL **__cil_pp_model ;
  double *__cil_pp_dist ;
  MODEL **__cil_fp_model ;
  double *__cil_fp_dist ;
  double tmp_ssa_1 ;
  double dist_ssa_1 ;
  long i_ssa_1 ;
  MODEL *model_ssa_1 ;
  double dist_ssa_2 ;
  int __cil_tmp16 ;
  double *__cil_tmp17 ;
  double __cil_tmp18 ;
  double __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  long *__cil_tmp21 ;
  long __cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  double **__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  double *__cil_tmp26 ;
  double __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  double *__cil_tmp29 ;
  double __cil_tmp30 ;

  {
#line 29
  __cil_fp_dist = & dist;
#line 29
  __cil_fp_model = & model;
#line 29
  __cil_pp_dist = & dist;
#line 29
  __cil_pp_model = & model;
#line 29
  return babel_wrapper_classify_example(__cil_pp_model, __cil_pp_dist, __cil_fp_model,
                                        __cil_fp_dist, model, ex);
#line 29
  __cil_pp_model = & model;
#line 30
  __cil_pp_dist = & dist;
#line 31
  __cil_fp_model = & model;
#line 32
  __cil_fp_dist = & dist;
#line 32
  __cil_tmp20 = (unsigned char *)model + 64;
#line 32
  __cil_tmp21 = (long *)__cil_tmp20;
#line 32
  __cil_tmp22 = *__cil_tmp21;
#line 32
  __cil_tmp16 = __cil_tmp22 == 0L;
#line 32
  if (__cil_tmp16 != 0) {
#line 32
    __cil_tmp23 = (unsigned char *)model + 208;
#line 32
    __cil_tmp24 = (double **)__cil_tmp23;
#line 32
    __cil_tmp17 = *__cil_tmp24;
#line 32
    if (__cil_tmp17 != 0) {
#line 33
      tmp_ssa_1 = classify_example_linear(model, ex);
#line 33
      return (tmp_ssa_1);
    } else {
#line 35
      dist_ssa_1 = (double )0;
#line 36
      i_ssa_1 = 1L;
#line 39
      *__cil_fp_model = model;
#line 40
      *__cil_fp_dist = dist_ssa_1;
#line 36
      classify_example_cil_lr_1(__cil_pp_model, __cil_pp_dist, ex, i_ssa_1);
#line 37
      model_ssa_1 = *__cil_fp_model;
#line 38
      dist_ssa_2 = *__cil_fp_dist;
#line 39
      __cil_tmp25 = (unsigned char *)model_ssa_1 + 16;
#line 39
      __cil_tmp26 = (double *)__cil_tmp25;
#line 39
      __cil_tmp27 = *__cil_tmp26;
#line 39
      __cil_tmp18 = dist_ssa_2 - __cil_tmp27;
#line 39
      return (__cil_tmp18);
    }
  } else {
#line 35
    dist_ssa_1 = (double )0;
#line 36
    i_ssa_1 = 1L;
#line 39
    *__cil_fp_model = model;
#line 40
    *__cil_fp_dist = dist_ssa_1;
#line 36
    classify_example_cil_lr_1(__cil_pp_model, __cil_pp_dist, ex, i_ssa_1);
#line 37
    model_ssa_1 = *__cil_fp_model;
#line 38
    dist_ssa_2 = *__cil_fp_dist;
#line 39
    __cil_tmp28 = (unsigned char *)model_ssa_1 + 16;
#line 39
    __cil_tmp29 = (double *)__cil_tmp28;
#line 39
    __cil_tmp30 = *__cil_tmp29;
#line 39
    __cil_tmp19 = dist_ssa_2 - __cil_tmp30;
#line 39
    return (__cil_tmp19);
  }
}
}
#line 42 "svm_common.c"
double classify_example_linear(MODEL *model , DOC *ex ) 
{ 
  double sum ;
  MODEL **__cil_pp_model ;
  double *__cil_pp_sum ;
  MODEL **__cil_fp_model ;
  double *__cil_fp_sum ;
  double sum_ssa_1 ;
  SVECTOR *f_ssa_1 ;
  MODEL *model_ssa_1 ;
  double sum_ssa_2 ;
  double __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  SVECTOR **__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  double *__cil_tmp18 ;
  double __cil_tmp19 ;

  {
#line 45
  __cil_fp_sum = & sum;
#line 45
  __cil_fp_model = & model;
#line 45
  __cil_pp_sum = & sum;
#line 45
  __cil_pp_model = & model;
#line 45
  return babel_wrapper_classify_example_linear(__cil_pp_model, __cil_pp_sum, __cil_fp_model,
                                               __cil_fp_sum, model, ex);
#line 45
  __cil_pp_model = & model;
#line 46
  __cil_pp_sum = & sum;
#line 47
  __cil_fp_model = & model;
#line 48
  __cil_fp_sum = & sum;
#line 52
  sum_ssa_1 = (double )0;
#line 55
  __cil_tmp15 = (unsigned char *)ex + 32;
#line 55
  __cil_tmp16 = (SVECTOR **)__cil_tmp15;
#line 55
  f_ssa_1 = *__cil_tmp16;
#line 58
  *__cil_fp_model = model;
#line 59
  *__cil_fp_sum = sum_ssa_1;
#line 55
  classify_example_linear_cil_lr_1(__cil_pp_model, __cil_pp_sum, f_ssa_1);
#line 56
  model_ssa_1 = *__cil_fp_model;
#line 57
  sum_ssa_2 = *__cil_fp_sum;
#line 57
  __cil_tmp17 = (unsigned char *)model_ssa_1 + 16;
#line 57
  __cil_tmp18 = (double *)__cil_tmp17;
#line 57
  __cil_tmp19 = *__cil_tmp18;
#line 57
  __cil_tmp14 = sum_ssa_2 - __cil_tmp19;
#line 57
  return (__cil_tmp14);
}
}
#line 61 "svm_common.c"
double kernel(KERNEL_PARM *kernel_parm , DOC *a , DOC *b ) 
{ 
  double sum ;
  double *__cil_pp_sum ;
  double *__cil_fp_sum ;
  double sum_ssa_1 ;
  SVECTOR *fa_ssa_1 ;
  double sum_ssa_2 ;
  unsigned char *__cil_tmp13 ;
  SVECTOR **__cil_tmp14 ;

  {
#line 64
  __cil_pp_sum = & sum;
#line 65
  __cil_fp_sum = & sum;
#line 64
  sum_ssa_1 = (double )0;
#line 70
  __cil_tmp13 = (unsigned char *)a + 32;
#line 70
  __cil_tmp14 = (SVECTOR **)__cil_tmp13;
#line 70
  fa_ssa_1 = *__cil_tmp14;
#line 73
  *__cil_fp_sum = sum_ssa_1;
#line 70
  kernel_cil_lr_1(__cil_pp_sum, kernel_parm, b, fa_ssa_1);
#line 71
  sum_ssa_2 = *__cil_fp_sum;
#line 76
  return (sum_ssa_2);
}
}
#line 79 "svm_common.c"
double single_kernel(KERNEL_PARM *kernel_parm , SVECTOR *a , SVECTOR *b ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 82
  kernel_cache_statistic ++;
  {
#line 84
  if (kernel_parm->kernel_type == 0L) {
#line 84
    goto case_0;
  } else {

  }
#line 86
  if (kernel_parm->kernel_type == 1L) {
#line 86
    goto case_1;
  } else {

  }
#line 88
  if (kernel_parm->kernel_type == 2L) {
#line 88
    goto case_2;
  } else {

  }
#line 90
  if (kernel_parm->kernel_type == 3L) {
#line 90
    goto case_3;
  } else {

  }
#line 92
  if (kernel_parm->kernel_type == 4L) {
#line 92
    goto case_4;
  } else {

  }
#line 94
  goto switch_default;
  case_0: /* CIL Label */ 
#line 85
  tmp = sprod_ss(a, b);
#line 85
  return (tmp);
  case_1: /* CIL Label */ 
#line 87
  tmp___0 = sprod_ss(a, b);
#line 87
  tmp___1 = pow(kernel_parm->coef_lin * tmp___0 + kernel_parm->coef_const, (double )kernel_parm->poly_degree);
#line 87
  return (tmp___1);
  case_2: /* CIL Label */ 
#line 89
  tmp___2 = sprod_ss(a, b);
#line 89
  tmp___3 = exp(- kernel_parm->rbf_gamma * ((a->twonorm_sq - (double )2 * tmp___2) + b->twonorm_sq));
#line 89
  return (tmp___3);
  case_3: /* CIL Label */ 
#line 91
  tmp___4 = sprod_ss(a, b);
#line 91
  tmp___5 = tanh(kernel_parm->coef_lin * tmp___4 + kernel_parm->coef_const);
#line 91
  return (tmp___5);
  case_4: /* CIL Label */ 
#line 93
  tmp___6 = custom_kernel(kernel_parm, a, b);
#line 93
  return (tmp___6);
  switch_default: /* CIL Label */ 
#line 94
  printf((char const   * __restrict  )"Error: Unknown kernel function\n");
#line 94
  exit(1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 99 "svm_common.c"
SVECTOR *create_svector(WORD *words , char *userdefined , double factor ) 
{ 
  SVECTOR *vec ;
  long fnum ;
  WORD **__cil_pp_words ;
  char **__cil_pp_userdefined ;
  double *__cil_pp_factor ;
  long *__cil_pp_fnum ;
  SVECTOR **__cil_pp_vec ;
  WORD **__cil_fp_words ;
  char **__cil_fp_userdefined ;
  double *__cil_fp_factor ;
  long *__cil_fp_fnum ;
  SVECTOR **__cil_fp_vec ;
  long fnum_ssa_1 ;
  WORD *words_ssa_1 ;
  char *userdefined_ssa_1 ;
  double factor_ssa_1 ;
  long fnum_ssa_2 ;
  long fnum_ssa_3 ;
  void *tmp_ssa_1 ;
  SVECTOR *vec_ssa_1 ;
  void *tmp___0_ssa_1 ;
  long i_ssa_1 ;
  char *userdefined_ssa_2 ;
  double factor_ssa_2 ;
  SVECTOR *vec_ssa_2 ;
  long fnum_ssa_4 ;
  char *userdefined_ssa_3 ;
  double factor_ssa_3 ;
  SVECTOR *vec_ssa_3 ;
  long fnum_ssa_5 ;
  long fnum_ssa_6 ;
  void *tmp___1_ssa_1 ;
  long i_ssa_2 ;
  double factor_ssa_4 ;
  SVECTOR *vec_ssa_4 ;
  unsigned long __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  char **__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  long *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  struct svector **__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  double *__cil_tmp52 ;
  WORD **mem_49 ;
  double *mem_50 ;

  {
#line 103
  __cil_pp_words = & words;
#line 104
  __cil_pp_userdefined = & userdefined;
#line 105
  __cil_pp_factor = & factor;
#line 106
  __cil_pp_fnum = & fnum;
#line 107
  __cil_pp_vec = & vec;
#line 108
  __cil_fp_words = & words;
#line 109
  __cil_fp_userdefined = & userdefined;
#line 110
  __cil_fp_factor = & factor;
#line 111
  __cil_fp_fnum = & fnum;
#line 112
  __cil_fp_vec = & vec;
#line 104
  fnum_ssa_1 = 0L;
#line 107
  *__cil_fp_words = words;
#line 108
  *__cil_fp_userdefined = userdefined;
#line 109
  *__cil_fp_factor = factor;
#line 110
  *__cil_fp_fnum = fnum_ssa_1;
#line 105
  create_svector_cil_lr_1(__cil_pp_words, __cil_pp_userdefined, __cil_pp_factor, __cil_pp_fnum);
#line 106
  words_ssa_1 = *__cil_fp_words;
#line 107
  userdefined_ssa_1 = *__cil_fp_userdefined;
#line 108
  factor_ssa_1 = *__cil_fp_factor;
#line 109
  fnum_ssa_2 = *__cil_fp_fnum;
#line 108
  fnum_ssa_3 = fnum_ssa_2 + 1L;
#line 109
  tmp_ssa_1 = my_malloc(sizeof(SVECTOR ));
#line 109
  vec_ssa_1 = (SVECTOR *)tmp_ssa_1;
#line 110
  __cil_tmp43 = sizeof(WORD ) * (unsigned long )fnum_ssa_3;
#line 110
  tmp___0_ssa_1 = my_malloc(__cil_tmp43);
#line 110
  mem_49 = (WORD **)vec_ssa_1;
#line 110
  *mem_49 = (WORD *)tmp___0_ssa_1;
#line 111
  i_ssa_1 = 0L;
#line 114
  *__cil_fp_userdefined = userdefined_ssa_1;
#line 115
  *__cil_fp_factor = factor_ssa_1;
#line 116
  *__cil_fp_vec = vec_ssa_1;
#line 111
  create_svector_cil_lr_2(__cil_pp_userdefined, __cil_pp_factor, __cil_pp_vec, words_ssa_1,
                          fnum_ssa_3, i_ssa_1);
#line 113
  userdefined_ssa_2 = *__cil_fp_userdefined;
#line 114
  factor_ssa_2 = *__cil_fp_factor;
#line 115
  vec_ssa_2 = *__cil_fp_vec;
#line 114
  mem_50 = (double *)((unsigned char *)vec_ssa_2 + 8);
#line 114
  *mem_50 = sprod_ss(vec_ssa_2, vec_ssa_2);
#line 116
  fnum_ssa_4 = 0L;
#line 119
  *__cil_fp_userdefined = userdefined_ssa_2;
#line 120
  *__cil_fp_factor = factor_ssa_2;
#line 121
  *__cil_fp_vec = vec_ssa_2;
#line 122
  *__cil_fp_fnum = fnum_ssa_4;
#line 117
  create_svector_cil_lr_3(__cil_pp_userdefined, __cil_pp_factor, __cil_pp_vec, __cil_pp_fnum);
#line 118
  userdefined_ssa_3 = *__cil_fp_userdefined;
#line 119
  factor_ssa_3 = *__cil_fp_factor;
#line 120
  vec_ssa_3 = *__cil_fp_vec;
#line 121
  fnum_ssa_5 = *__cil_fp_fnum;
#line 120
  fnum_ssa_6 = fnum_ssa_5 + 1L;
#line 121
  __cil_tmp44 = sizeof(char ) * (unsigned long )fnum_ssa_6;
#line 121
  tmp___1_ssa_1 = my_malloc(__cil_tmp44);
#line 121
  __cil_tmp45 = (unsigned char *)vec_ssa_3 + 16;
#line 121
  __cil_tmp46 = (char **)__cil_tmp45;
#line 121
  *__cil_tmp46 = (char *)tmp___1_ssa_1;
#line 122
  i_ssa_2 = 0L;
#line 125
  *__cil_fp_factor = factor_ssa_3;
#line 126
  *__cil_fp_vec = vec_ssa_3;
#line 122
  create_svector_cil_lr_4(__cil_pp_factor, __cil_pp_vec, userdefined_ssa_3, fnum_ssa_6,
                          i_ssa_2);
#line 124
  factor_ssa_4 = *__cil_fp_factor;
#line 125
  vec_ssa_4 = *__cil_fp_vec;
#line 125
  __cil_tmp47 = (unsigned char *)vec_ssa_4 + 24;
#line 125
  __cil_tmp48 = (long *)__cil_tmp47;
#line 125
  *__cil_tmp48 = 0L;
#line 126
  __cil_tmp49 = (unsigned char *)vec_ssa_4 + 32;
#line 126
  __cil_tmp50 = (struct svector **)__cil_tmp49;
#line 126
  *__cil_tmp50 = (struct svector *)0;
#line 127
  __cil_tmp51 = (unsigned char *)vec_ssa_4 + 40;
#line 127
  __cil_tmp52 = (double *)__cil_tmp51;
#line 127
  *__cil_tmp52 = factor_ssa_4;
#line 128
  return (vec_ssa_4);
}
}
#line 131 "svm_common.c"
SVECTOR *copy_svector(SVECTOR *vec ) 
{ 
  SVECTOR *newvec_ssa_1 ;
  SVECTOR *newvec_ssa_2 ;
  unsigned char *__cil_tmp5 ;
  char **__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  double *__cil_tmp8 ;
  WORD *__cil_tmp9 ;
  char *__cil_tmp10 ;
  double __cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  struct svector **__cil_tmp13 ;
  struct svector *__cil_tmp14 ;
  WORD **mem_14 ;
  struct svector **mem_15 ;

  {
#line 133
  newvec_ssa_1 = (SVECTOR *)0;
#line 134
  if (vec != 0) {
#line 135
    __cil_tmp5 = (unsigned char *)vec + 16;
#line 135
    __cil_tmp6 = (char **)__cil_tmp5;
#line 135
    __cil_tmp7 = (unsigned char *)vec + 40;
#line 135
    __cil_tmp8 = (double *)__cil_tmp7;
#line 135
    mem_14 = (WORD **)vec;
#line 135
    __cil_tmp9 = *mem_14;
#line 135
    __cil_tmp10 = *__cil_tmp6;
#line 135
    __cil_tmp11 = *__cil_tmp8;
#line 135
    newvec_ssa_2 = create_svector(__cil_tmp9, __cil_tmp10, __cil_tmp11);
#line 136
    __cil_tmp12 = (unsigned char *)vec + 32;
#line 136
    __cil_tmp13 = (struct svector **)__cil_tmp12;
#line 136
    __cil_tmp14 = *__cil_tmp13;
#line 136
    mem_15 = (struct svector **)((unsigned char *)newvec_ssa_2 + 32);
#line 136
    *mem_15 = copy_svector(__cil_tmp14);
  } else {
#line 139
    newvec_ssa_2 = newvec_ssa_1;
  }
#line 138
  return (newvec_ssa_2);
}
}
#line 141 "svm_common.c"
void free_svector(SVECTOR *vec ) 
{ 
  char *__cil_tmp2 ;
  WORD *__cil_tmp3 ;
  unsigned char *__cil_tmp4 ;
  char **__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  char **__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  struct svector **__cil_tmp10 ;
  struct svector *__cil_tmp11 ;
  WORD **mem_12 ;

  {

#line 143
  return babel_wrapper_free_svector(vec);
#line 143
  if (vec != 0) {
#line 144
    mem_12 = (WORD **)vec;
#line 144
    __cil_tmp3 = *mem_12;
#line 144
    free((void *)__cil_tmp3);
#line 145
    __cil_tmp4 = (unsigned char *)vec + 16;
#line 145
    __cil_tmp5 = (char **)__cil_tmp4;
#line 145
    __cil_tmp2 = *__cil_tmp5;
#line 145
    if (__cil_tmp2 != 0) {
#line 146
      __cil_tmp6 = (unsigned char *)vec + 16;
#line 146
      __cil_tmp7 = (char **)__cil_tmp6;
#line 146
      __cil_tmp8 = *__cil_tmp7;
#line 146
      free((void *)__cil_tmp8);
    } else {

    }
#line 147
    __cil_tmp9 = (unsigned char *)vec + 32;
#line 147
    __cil_tmp10 = (struct svector **)__cil_tmp9;
#line 147
    __cil_tmp11 = *__cil_tmp10;
#line 147
    free_svector(__cil_tmp11);
#line 148
    free((void *)vec);
  } else {

  }
#line 150
  return;
}
}
#line 152 "svm_common.c"
double sprod_ss(SVECTOR *a , SVECTOR *b ) 
{ 
  double sum ;
  double *__cil_pp_sum ;
  double *__cil_fp_sum ;
  double sum_ssa_1 ;
  WORD *ai_ssa_1 ;
  WORD *bj_ssa_1 ;
  double sum_ssa_2 ;
  WORD **mem_10 ;
  WORD **mem_11 ;

  {
#line 155
  __cil_pp_sum = & sum;
#line 156
  __cil_fp_sum = & sum;
#line 155
  sum_ssa_1 = (double )0;
#line 157
  mem_10 = (WORD **)a;
#line 157
  ai_ssa_1 = *mem_10;
#line 158
  mem_11 = (WORD **)b;
#line 158
  bj_ssa_1 = *mem_11;
#line 161
  *__cil_fp_sum = sum_ssa_1;
#line 159
  sprod_ss_cil_lr_1(__cil_pp_sum, ai_ssa_1, bj_ssa_1);
#line 160
  sum_ssa_2 = *__cil_fp_sum;
#line 172
  return (sum_ssa_2);
}
}
#line 175 "svm_common.c"
SVECTOR *sub_ss(SVECTOR *a , SVECTOR *b ) 
{ 
  WORD *sum ;
  WORD *sumi ;
  WORD *ai ;
  WORD *bj ;
  long veclength ;
  SVECTOR **__cil_pp_a ;
  SVECTOR **__cil_pp_b ;
  WORD **__cil_pp_ai ;
  WORD **__cil_pp_bj ;
  long *__cil_pp_veclength ;
  WORD **__cil_pp_sum ;
  WORD **__cil_pp_sumi ;
  SVECTOR **__cil_fp_a ;
  SVECTOR **__cil_fp_b ;
  WORD **__cil_fp_ai ;
  WORD **__cil_fp_bj ;
  long *__cil_fp_veclength ;
  WORD **__cil_fp_sum ;
  WORD **__cil_fp_sumi ;
  WORD *ai_ssa_1 ;
  WORD *bj_ssa_1 ;
  long veclength_ssa_1 ;
  SVECTOR *a_ssa_1 ;
  SVECTOR *b_ssa_1 ;
  WORD *ai_ssa_2 ;
  WORD *bj_ssa_2 ;
  long veclength_ssa_2 ;
  SVECTOR *a_ssa_2 ;
  SVECTOR *b_ssa_2 ;
  WORD *ai_ssa_3 ;
  long veclength_ssa_3 ;
  SVECTOR *a_ssa_3 ;
  SVECTOR *b_ssa_3 ;
  long veclength_ssa_4 ;
  long veclength_ssa_5 ;
  void *tmp_ssa_1 ;
  WORD *sum_ssa_1 ;
  WORD *sumi_ssa_1 ;
  WORD *ai_ssa_4 ;
  WORD *bj_ssa_3 ;
  WORD *sum_ssa_2 ;
  WORD *sumi_ssa_2 ;
  WORD *ai_ssa_5 ;
  WORD *bj_ssa_4 ;
  WORD *sum_ssa_3 ;
  WORD *sumi_ssa_3 ;
  WORD *ai_ssa_6 ;
  WORD *sum_ssa_4 ;
  WORD *sumi_ssa_4 ;
  SVECTOR *vec_ssa_1 ;
  unsigned long __cil_tmp55 ;
  WORD **mem_54 ;
  WORD **mem_55 ;
  WORD **mem_56 ;
  WORD **mem_57 ;
  long *mem_58 ;

  {
#line 182
  __cil_fp_sumi = & sumi;
#line 182
  __cil_fp_sum = & sum;
#line 182
  __cil_fp_veclength = & veclength;
#line 182
  __cil_fp_bj = & bj;
#line 182
  __cil_fp_ai = & ai;
#line 182
  __cil_fp_b = & b;
#line 182
  __cil_fp_a = & a;
#line 182
  __cil_pp_sumi = & sumi;
#line 182
  __cil_pp_sum = & sum;
#line 182
  __cil_pp_veclength = & veclength;
#line 182
  __cil_pp_bj = & bj;
#line 182
  __cil_pp_ai = & ai;
#line 182
  __cil_pp_b = & b;
#line 182
  __cil_pp_a = & a;
#line 182
  return babel_wrapper_sub_ss(__cil_pp_a, __cil_pp_b, __cil_pp_ai, __cil_pp_bj, __cil_pp_veclength,
                              __cil_pp_sum, __cil_pp_sumi, __cil_fp_a, __cil_fp_b,
                              __cil_fp_ai, __cil_fp_bj, __cil_fp_veclength, __cil_fp_sum,
                              __cil_fp_sumi, a, b);
#line 182
  __cil_pp_a = & a;
#line 183
  __cil_pp_b = & b;
#line 184
  __cil_pp_ai = & ai;
#line 185
  __cil_pp_bj = & bj;
#line 186
  __cil_pp_veclength = & veclength;
#line 187
  __cil_pp_sum = & sum;
#line 188
  __cil_pp_sumi = & sumi;
#line 189
  __cil_fp_a = & a;
#line 190
  __cil_fp_b = & b;
#line 191
  __cil_fp_ai = & ai;
#line 192
  __cil_fp_bj = & bj;
#line 193
  __cil_fp_veclength = & veclength;
#line 194
  __cil_fp_sum = & sum;
#line 195
  __cil_fp_sumi = & sumi;
#line 185
  mem_54 = (WORD **)a;
#line 185
  ai_ssa_1 = *mem_54;
#line 186
  mem_55 = (WORD **)b;
#line 186
  bj_ssa_1 = *mem_55;
#line 187
  veclength_ssa_1 = 0L;
#line 190
  *__cil_fp_a = a;
#line 191
  *__cil_fp_b = b;
#line 192
  *__cil_fp_ai = ai_ssa_1;
#line 193
  *__cil_fp_bj = bj_ssa_1;
#line 194
  *__cil_fp_veclength = veclength_ssa_1;
#line 188
  sub_ss_cil_lr_1(__cil_pp_a, __cil_pp_b, __cil_pp_ai, __cil_pp_bj, __cil_pp_veclength);
#line 189
  a_ssa_1 = *__cil_fp_a;
#line 190
  b_ssa_1 = *__cil_fp_b;
#line 191
  ai_ssa_2 = *__cil_fp_ai;
#line 192
  bj_ssa_2 = *__cil_fp_bj;
#line 193
  veclength_ssa_2 = *__cil_fp_veclength;
#line 196
  *__cil_fp_a = a_ssa_1;
#line 197
  *__cil_fp_b = b_ssa_1;
#line 198
  *__cil_fp_ai = ai_ssa_2;
#line 199
  *__cil_fp_veclength = veclength_ssa_2;
#line 203
  sub_ss_cil_lr_2(__cil_pp_a, __cil_pp_b, __cil_pp_ai, __cil_pp_veclength, bj_ssa_2);
#line 204
  a_ssa_2 = *__cil_fp_a;
#line 205
  b_ssa_2 = *__cil_fp_b;
#line 206
  ai_ssa_3 = *__cil_fp_ai;
#line 207
  veclength_ssa_3 = *__cil_fp_veclength;
#line 210
  *__cil_fp_a = a_ssa_2;
#line 211
  *__cil_fp_b = b_ssa_2;
#line 212
  *__cil_fp_veclength = veclength_ssa_3;
#line 207
  sub_ss_cil_lr_3(__cil_pp_a, __cil_pp_b, __cil_pp_veclength, ai_ssa_3);
#line 208
  a_ssa_3 = *__cil_fp_a;
#line 209
  b_ssa_3 = *__cil_fp_b;
#line 210
  veclength_ssa_4 = *__cil_fp_veclength;
#line 211
  veclength_ssa_5 = veclength_ssa_4 + 1L;
#line 213
  __cil_tmp55 = sizeof(WORD ) * (unsigned long )veclength_ssa_5;
#line 213
  tmp_ssa_1 = my_malloc(__cil_tmp55);
#line 213
  sum_ssa_1 = (WORD *)tmp_ssa_1;
#line 214
  sumi_ssa_1 = sum_ssa_1;
#line 215
  mem_56 = (WORD **)a_ssa_3;
#line 215
  ai_ssa_4 = *mem_56;
#line 216
  mem_57 = (WORD **)b_ssa_3;
#line 216
  bj_ssa_3 = *mem_57;
#line 219
  *__cil_fp_sum = sum_ssa_1;
#line 220
  *__cil_fp_sumi = sumi_ssa_1;
#line 221
  *__cil_fp_ai = ai_ssa_4;
#line 222
  *__cil_fp_bj = bj_ssa_3;
#line 217
  sub_ss_cil_lr_4(__cil_pp_sum, __cil_pp_sumi, __cil_pp_ai, __cil_pp_bj);
#line 218
  sum_ssa_2 = *__cil_fp_sum;
#line 219
  sumi_ssa_2 = *__cil_fp_sumi;
#line 220
  ai_ssa_5 = *__cil_fp_ai;
#line 221
  bj_ssa_4 = *__cil_fp_bj;
#line 224
  *__cil_fp_sum = sum_ssa_2;
#line 225
  *__cil_fp_sumi = sumi_ssa_2;
#line 226
  *__cil_fp_ai = ai_ssa_5;
#line 238
  sub_ss_cil_lr_5(__cil_pp_sum, __cil_pp_sumi, __cil_pp_ai, bj_ssa_4);
#line 239
  sum_ssa_3 = *__cil_fp_sum;
#line 240
  sumi_ssa_3 = *__cil_fp_sumi;
#line 241
  ai_ssa_6 = *__cil_fp_ai;
#line 244
  *__cil_fp_sum = sum_ssa_3;
#line 245
  *__cil_fp_sumi = sumi_ssa_3;
#line 244
  sub_ss_cil_lr_6(__cil_pp_sum, __cil_pp_sumi, ai_ssa_6);
#line 245
  sum_ssa_4 = *__cil_fp_sum;
#line 246
  sumi_ssa_4 = *__cil_fp_sumi;
#line 249
  mem_58 = (long *)sumi_ssa_4;
#line 249
  *mem_58 = 0L;
#line 251
  vec_ssa_1 = create_svector(sum_ssa_4, (char *)"", 1.0);
#line 252
  free((void *)sum_ssa_4);
#line 254
  return (vec_ssa_1);
}
}
#line 257 "svm_common.c"
SVECTOR *add_ss(SVECTOR *a , SVECTOR *b ) 
{ 
  WORD *sum ;
  WORD *sumi ;
  WORD *ai ;
  WORD *bj ;
  long veclength ;
  SVECTOR **__cil_pp_a ;
  SVECTOR **__cil_pp_b ;
  WORD **__cil_pp_ai ;
  WORD **__cil_pp_bj ;
  long *__cil_pp_veclength ;
  WORD **__cil_pp_sum ;
  WORD **__cil_pp_sumi ;
  SVECTOR **__cil_fp_a ;
  SVECTOR **__cil_fp_b ;
  WORD **__cil_fp_ai ;
  WORD **__cil_fp_bj ;
  long *__cil_fp_veclength ;
  WORD **__cil_fp_sum ;
  WORD **__cil_fp_sumi ;
  WORD *ai_ssa_1 ;
  WORD *bj_ssa_1 ;
  long veclength_ssa_1 ;
  SVECTOR *a_ssa_1 ;
  SVECTOR *b_ssa_1 ;
  WORD *ai_ssa_2 ;
  WORD *bj_ssa_2 ;
  long veclength_ssa_2 ;
  SVECTOR *a_ssa_2 ;
  SVECTOR *b_ssa_2 ;
  WORD *ai_ssa_3 ;
  long veclength_ssa_3 ;
  SVECTOR *a_ssa_3 ;
  SVECTOR *b_ssa_3 ;
  long veclength_ssa_4 ;
  long veclength_ssa_5 ;
  void *tmp_ssa_1 ;
  WORD *sum_ssa_1 ;
  WORD *sumi_ssa_1 ;
  WORD *ai_ssa_4 ;
  WORD *bj_ssa_3 ;
  WORD *sum_ssa_2 ;
  WORD *sumi_ssa_2 ;
  WORD *ai_ssa_5 ;
  WORD *bj_ssa_4 ;
  WORD *sum_ssa_3 ;
  WORD *sumi_ssa_3 ;
  WORD *ai_ssa_6 ;
  WORD *sum_ssa_4 ;
  WORD *sumi_ssa_4 ;
  SVECTOR *vec_ssa_1 ;
  unsigned long __cil_tmp55 ;
  WORD **mem_54 ;
  WORD **mem_55 ;
  WORD **mem_56 ;
  WORD **mem_57 ;
  long *mem_58 ;

  {
#line 264
  __cil_fp_sumi = & sumi;
#line 264
  __cil_fp_sum = & sum;
#line 264
  __cil_fp_veclength = & veclength;
#line 264
  __cil_fp_bj = & bj;
#line 264
  __cil_fp_ai = & ai;
#line 264
  __cil_fp_b = & b;
#line 264
  __cil_fp_a = & a;
#line 264
  __cil_pp_sumi = & sumi;
#line 264
  __cil_pp_sum = & sum;
#line 264
  __cil_pp_veclength = & veclength;
#line 264
  __cil_pp_bj = & bj;
#line 264
  __cil_pp_ai = & ai;
#line 264
  __cil_pp_b = & b;
#line 264
  __cil_pp_a = & a;
#line 264
  return babel_wrapper_add_ss(__cil_pp_a, __cil_pp_b, __cil_pp_ai, __cil_pp_bj, __cil_pp_veclength,
                              __cil_pp_sum, __cil_pp_sumi, __cil_fp_a, __cil_fp_b,
                              __cil_fp_ai, __cil_fp_bj, __cil_fp_veclength, __cil_fp_sum,
                              __cil_fp_sumi, a, b);
#line 264
  __cil_pp_a = & a;
#line 265
  __cil_pp_b = & b;
#line 266
  __cil_pp_ai = & ai;
#line 267
  __cil_pp_bj = & bj;
#line 268
  __cil_pp_veclength = & veclength;
#line 269
  __cil_pp_sum = & sum;
#line 270
  __cil_pp_sumi = & sumi;
#line 271
  __cil_fp_a = & a;
#line 272
  __cil_fp_b = & b;
#line 273
  __cil_fp_ai = & ai;
#line 274
  __cil_fp_bj = & bj;
#line 275
  __cil_fp_veclength = & veclength;
#line 276
  __cil_fp_sum = & sum;
#line 277
  __cil_fp_sumi = & sumi;
#line 267
  mem_54 = (WORD **)a;
#line 267
  ai_ssa_1 = *mem_54;
#line 268
  mem_55 = (WORD **)b;
#line 268
  bj_ssa_1 = *mem_55;
#line 269
  veclength_ssa_1 = 0L;
#line 272
  *__cil_fp_a = a;
#line 273
  *__cil_fp_b = b;
#line 274
  *__cil_fp_ai = ai_ssa_1;
#line 275
  *__cil_fp_bj = bj_ssa_1;
#line 276
  *__cil_fp_veclength = veclength_ssa_1;
#line 270
  add_ss_cil_lr_1(__cil_pp_a, __cil_pp_b, __cil_pp_ai, __cil_pp_bj, __cil_pp_veclength);
#line 271
  a_ssa_1 = *__cil_fp_a;
#line 272
  b_ssa_1 = *__cil_fp_b;
#line 273
  ai_ssa_2 = *__cil_fp_ai;
#line 274
  bj_ssa_2 = *__cil_fp_bj;
#line 275
  veclength_ssa_2 = *__cil_fp_veclength;
#line 278
  *__cil_fp_a = a_ssa_1;
#line 279
  *__cil_fp_b = b_ssa_1;
#line 280
  *__cil_fp_ai = ai_ssa_2;
#line 281
  *__cil_fp_veclength = veclength_ssa_2;
#line 285
  add_ss_cil_lr_2(__cil_pp_a, __cil_pp_b, __cil_pp_ai, __cil_pp_veclength, bj_ssa_2);
#line 286
  a_ssa_2 = *__cil_fp_a;
#line 287
  b_ssa_2 = *__cil_fp_b;
#line 288
  ai_ssa_3 = *__cil_fp_ai;
#line 289
  veclength_ssa_3 = *__cil_fp_veclength;
#line 292
  *__cil_fp_a = a_ssa_2;
#line 293
  *__cil_fp_b = b_ssa_2;
#line 294
  *__cil_fp_veclength = veclength_ssa_3;
#line 289
  add_ss_cil_lr_3(__cil_pp_a, __cil_pp_b, __cil_pp_veclength, ai_ssa_3);
#line 290
  a_ssa_3 = *__cil_fp_a;
#line 291
  b_ssa_3 = *__cil_fp_b;
#line 292
  veclength_ssa_4 = *__cil_fp_veclength;
#line 293
  veclength_ssa_5 = veclength_ssa_4 + 1L;
#line 297
  __cil_tmp55 = sizeof(WORD ) * (unsigned long )veclength_ssa_5;
#line 297
  tmp_ssa_1 = my_malloc(__cil_tmp55);
#line 297
  sum_ssa_1 = (WORD *)tmp_ssa_1;
#line 298
  sumi_ssa_1 = sum_ssa_1;
#line 299
  mem_56 = (WORD **)a_ssa_3;
#line 299
  ai_ssa_4 = *mem_56;
#line 300
  mem_57 = (WORD **)b_ssa_3;
#line 300
  bj_ssa_3 = *mem_57;
#line 303
  *__cil_fp_sum = sum_ssa_1;
#line 304
  *__cil_fp_sumi = sumi_ssa_1;
#line 305
  *__cil_fp_ai = ai_ssa_4;
#line 306
  *__cil_fp_bj = bj_ssa_3;
#line 301
  add_ss_cil_lr_4(__cil_pp_sum, __cil_pp_sumi, __cil_pp_ai, __cil_pp_bj);
#line 302
  sum_ssa_2 = *__cil_fp_sum;
#line 303
  sumi_ssa_2 = *__cil_fp_sumi;
#line 304
  ai_ssa_5 = *__cil_fp_ai;
#line 305
  bj_ssa_4 = *__cil_fp_bj;
#line 308
  *__cil_fp_sum = sum_ssa_2;
#line 309
  *__cil_fp_sumi = sumi_ssa_2;
#line 310
  *__cil_fp_ai = ai_ssa_5;
#line 321
  add_ss_cil_lr_5(__cil_pp_sum, __cil_pp_sumi, __cil_pp_ai, bj_ssa_4);
#line 322
  sum_ssa_3 = *__cil_fp_sum;
#line 323
  sumi_ssa_3 = *__cil_fp_sumi;
#line 324
  ai_ssa_6 = *__cil_fp_ai;
#line 327
  *__cil_fp_sum = sum_ssa_3;
#line 328
  *__cil_fp_sumi = sumi_ssa_3;
#line 326
  add_ss_cil_lr_6(__cil_pp_sum, __cil_pp_sumi, ai_ssa_6);
#line 327
  sum_ssa_4 = *__cil_fp_sum;
#line 328
  sumi_ssa_4 = *__cil_fp_sumi;
#line 331
  mem_58 = (long *)sumi_ssa_4;
#line 331
  *mem_58 = 0L;
#line 333
  vec_ssa_1 = create_svector(sum_ssa_4, (char *)"", 1.0);
#line 334
  free((void *)sum_ssa_4);
#line 336
  return (vec_ssa_1);
}
}
#line 339 "svm_common.c"
SVECTOR *add_list_ss(SVECTOR *a ) 
{ 
  SVECTOR *sum ;
  WORD empty[2] ;
  SVECTOR **__cil_pp_sum ;
  SVECTOR **__cil_fp_sum ;
  SVECTOR *sum_ssa_1 ;
  SVECTOR *f_ssa_1 ;
  SVECTOR *sum_ssa_2 ;
  unsigned char *__cil_tmp12 ;
  double *__cil_tmp13 ;
  double __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  struct svector **__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  double *__cil_tmp18 ;
  WORD *__cil_tmp19 ;
  long *mem_17 ;

  {
#line 343
  __cil_pp_sum = & sum;
#line 344
  __cil_fp_sum = & sum;
#line 346
  if (a != 0) {
#line 347
    __cil_tmp12 = (unsigned char *)a + 40;
#line 347
    __cil_tmp13 = (double *)__cil_tmp12;
#line 347
    __cil_tmp14 = *__cil_tmp13;
#line 347
    sum_ssa_1 = smult_s(a, __cil_tmp14);
#line 348
    __cil_tmp15 = (unsigned char *)a + 32;
#line 348
    __cil_tmp16 = (struct svector **)__cil_tmp15;
#line 348
    f_ssa_1 = *__cil_tmp16;
#line 351
    *__cil_fp_sum = sum_ssa_1;
#line 348
    add_list_ss_cil_lr_1(__cil_pp_sum, f_ssa_1);
#line 349
    sum_ssa_2 = *__cil_fp_sum;
#line 355
    __cil_tmp17 = (unsigned char *)sum_ssa_2 + 40;
#line 355
    __cil_tmp18 = (double *)__cil_tmp17;
#line 355
    *__cil_tmp18 = 1.0;
  } else {
#line 358
    mem_17 = (long *)(empty);
#line 358
    *mem_17 = 0L;
#line 359
    __cil_tmp19 = empty;
#line 359
    sum_ssa_1 = create_svector(__cil_tmp19, (char *)"", 1.0);
#line 360
    sum_ssa_2 = sum_ssa_1;
  }
#line 361
  return (sum_ssa_2);
}
}
#line 364 "svm_common.c"
void append_svector_list(SVECTOR *a , SVECTOR *b ) 
{ 
  SVECTOR *f ;
  SVECTOR **__cil_pp_b ;
  SVECTOR **__cil_pp_f ;
  SVECTOR **__cil_fp_b ;
  SVECTOR **__cil_fp_f ;
  SVECTOR *f_ssa_1 ;
  SVECTOR *b_ssa_1 ;
  SVECTOR *f_ssa_2 ;
  unsigned char *__cil_tmp11 ;
  struct svector **__cil_tmp12 ;

  {
#line 367
  __cil_fp_f = & f;
#line 367
  __cil_fp_b = & b;
#line 367
  __cil_pp_f = & f;
#line 367
  __cil_pp_b = & b;
#line 367
  return babel_wrapper_append_svector_list(__cil_pp_b, __cil_pp_f, __cil_fp_b, __cil_fp_f,
                                           a, b);
#line 367
  __cil_pp_b = & b;
#line 368
  __cil_pp_f = & f;
#line 369
  __cil_fp_b = & b;
#line 370
  __cil_fp_f = & f;
#line 369
  f_ssa_1 = a;
#line 372
  *__cil_fp_b = b;
#line 373
  *__cil_fp_f = f_ssa_1;
#line 369
  append_svector_list_cil_lr_1(__cil_pp_b, __cil_pp_f);
#line 370
  b_ssa_1 = *__cil_fp_b;
#line 371
  f_ssa_2 = *__cil_fp_f;
#line 370
  __cil_tmp11 = (unsigned char *)f_ssa_2 + 32;
#line 370
  __cil_tmp12 = (struct svector **)__cil_tmp11;
#line 370
  *__cil_tmp12 = b_ssa_1;
#line 371
  return;
}
}
#line 373 "svm_common.c"
SVECTOR *smult_s(SVECTOR *a , double factor ) 
{ 
  WORD *sum ;
  WORD *sumi ;
  long veclength ;
  SVECTOR **__cil_pp_a ;
  double *__cil_pp_factor ;
  long *__cil_pp_veclength ;
  WORD **__cil_pp_sum ;
  WORD **__cil_pp_sumi ;
  SVECTOR **__cil_fp_a ;
  double *__cil_fp_factor ;
  long *__cil_fp_veclength ;
  WORD **__cil_fp_sum ;
  WORD **__cil_fp_sumi ;
  WORD *ai_ssa_1 ;
  long veclength_ssa_1 ;
  SVECTOR *a_ssa_1 ;
  double factor_ssa_1 ;
  long veclength_ssa_2 ;
  long veclength_ssa_3 ;
  void *tmp_ssa_1 ;
  WORD *sum_ssa_1 ;
  WORD *sumi_ssa_1 ;
  WORD *ai_ssa_2 ;
  SVECTOR *a_ssa_2 ;
  WORD *sum_ssa_2 ;
  WORD *sumi_ssa_2 ;
  SVECTOR *vec_ssa_1 ;
  unsigned long __cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  char **__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  double *__cil_tmp37 ;
  char *__cil_tmp38 ;
  double __cil_tmp39 ;
  WORD **mem_37 ;
  WORD **mem_38 ;
  long *mem_39 ;

  {
#line 378
  __cil_fp_sumi = & sumi;
#line 378
  __cil_fp_sum = & sum;
#line 378
  __cil_fp_veclength = & veclength;
#line 378
  __cil_fp_factor = & factor;
#line 378
  __cil_fp_a = & a;
#line 378
  __cil_pp_sumi = & sumi;
#line 378
  __cil_pp_sum = & sum;
#line 378
  __cil_pp_veclength = & veclength;
#line 378
  __cil_pp_factor = & factor;
#line 378
  __cil_pp_a = & a;
#line 378
  return babel_wrapper_smult_s(__cil_pp_a, __cil_pp_factor, __cil_pp_veclength, __cil_pp_sum,
                               __cil_pp_sumi, __cil_fp_a, __cil_fp_factor, __cil_fp_veclength,
                               __cil_fp_sum, __cil_fp_sumi, a, factor);
#line 378
  __cil_pp_a = & a;
#line 379
  __cil_pp_factor = & factor;
#line 380
  __cil_pp_veclength = & veclength;
#line 381
  __cil_pp_sum = & sum;
#line 382
  __cil_pp_sumi = & sumi;
#line 383
  __cil_fp_a = & a;
#line 384
  __cil_fp_factor = & factor;
#line 385
  __cil_fp_veclength = & veclength;
#line 386
  __cil_fp_sum = & sum;
#line 387
  __cil_fp_sumi = & sumi;
#line 381
  mem_37 = (WORD **)a;
#line 381
  ai_ssa_1 = *mem_37;
#line 382
  veclength_ssa_1 = 0L;
#line 385
  *__cil_fp_a = a;
#line 386
  *__cil_fp_factor = factor;
#line 387
  *__cil_fp_veclength = veclength_ssa_1;
#line 383
  smult_s_cil_lr_1(__cil_pp_a, __cil_pp_factor, __cil_pp_veclength, ai_ssa_1);
#line 384
  a_ssa_1 = *__cil_fp_a;
#line 385
  factor_ssa_1 = *__cil_fp_factor;
#line 386
  veclength_ssa_2 = *__cil_fp_veclength;
#line 387
  veclength_ssa_3 = veclength_ssa_2 + 1L;
#line 389
  __cil_tmp33 = sizeof(WORD ) * (unsigned long )veclength_ssa_3;
#line 389
  tmp_ssa_1 = my_malloc(__cil_tmp33);
#line 389
  sum_ssa_1 = (WORD *)tmp_ssa_1;
#line 390
  sumi_ssa_1 = sum_ssa_1;
#line 391
  mem_38 = (WORD **)a_ssa_1;
#line 391
  ai_ssa_2 = *mem_38;
#line 394
  *__cil_fp_a = a_ssa_1;
#line 395
  *__cil_fp_sum = sum_ssa_1;
#line 396
  *__cil_fp_sumi = sumi_ssa_1;
#line 392
  smult_s_cil_lr_2(__cil_pp_a, __cil_pp_sum, __cil_pp_sumi, factor_ssa_1, ai_ssa_2);
#line 393
  a_ssa_2 = *__cil_fp_a;
#line 394
  sum_ssa_2 = *__cil_fp_sum;
#line 395
  sumi_ssa_2 = *__cil_fp_sumi;
#line 399
  mem_39 = (long *)sumi_ssa_2;
#line 399
  *mem_39 = 0L;
#line 401
  __cil_tmp34 = (unsigned char *)a_ssa_2 + 16;
#line 401
  __cil_tmp35 = (char **)__cil_tmp34;
#line 401
  __cil_tmp36 = (unsigned char *)a_ssa_2 + 40;
#line 401
  __cil_tmp37 = (double *)__cil_tmp36;
#line 401
  __cil_tmp38 = *__cil_tmp35;
#line 401
  __cil_tmp39 = *__cil_tmp37;
#line 401
  vec_ssa_1 = create_svector(sum_ssa_2, __cil_tmp38, __cil_tmp39);
#line 402
  free((void *)sum_ssa_2);
#line 404
  return (vec_ssa_1);
}
}
#line 407 "svm_common.c"
int featvec_eq(SVECTOR *a , SVECTOR *b ) 
{ 
  int __cil_ret5 ;
  int *__cil_pp___cil_ret5 ;
  int *__cil_fp___cil_ret5 ;
  WORD *ai_ssa_1 ;
  WORD *bj_ssa_1 ;
  int retflag6_ssa_1 ;
  int __cil_ret5_ssa_1 ;
  WORD **mem_10 ;
  WORD **mem_11 ;

  {
#line 410
  __cil_pp___cil_ret5 = & __cil_ret5;
#line 411
  __cil_fp___cil_ret5 = & __cil_ret5;
#line 411
  mem_10 = (WORD **)a;
#line 411
  ai_ssa_1 = *mem_10;
#line 412
  mem_11 = (WORD **)b;
#line 412
  bj_ssa_1 = *mem_11;
#line 416
  *__cil_fp___cil_ret5 = __cil_ret5;
#line 413
  retflag6_ssa_1 = featvec_eq_cil_lr_1(__cil_pp___cil_ret5, ai_ssa_1, bj_ssa_1);
#line 414
  __cil_ret5_ssa_1 = *__cil_fp___cil_ret5;
#line 413
  if (retflag6_ssa_1 != 0) {
#line 413
    return (__cil_ret5_ssa_1);
  } else {
#line 431
    return (1);
  }
}
}
#line 434 "svm_common.c"
double model_length_s(MODEL *model , KERNEL_PARM *kernel_parm ) 
{ 
  double sum ;
  double *__cil_pp_sum ;
  double *__cil_fp_sum ;
  double sum_ssa_1 ;
  long i_ssa_1 ;
  double sum_ssa_2 ;
  double tmp___0_ssa_1 ;

  {
#line 437
  __cil_fp_sum = & sum;
#line 437
  __cil_pp_sum = & sum;
#line 437
  return babel_wrapper_model_length_s(__cil_pp_sum, __cil_fp_sum, model, kernel_parm);
#line 437
  __cil_pp_sum = & sum;
#line 438
  __cil_fp_sum = & sum;
#line 438
  sum_ssa_1 = (double )0;
#line 441
  i_ssa_1 = 1L;
#line 444
  *__cil_fp_sum = sum_ssa_1;
#line 441
  model_length_s_cil_lr_1(__cil_pp_sum, model, kernel_parm, i_ssa_1);
#line 442
  sum_ssa_2 = *__cil_fp_sum;
#line 449
  tmp___0_ssa_1 = sqrt(sum_ssa_2);
#line 449
  return (tmp___0_ssa_1);
}
}
#line 452 "svm_common.c"
void clear_vector_n(double *vec , long n ) 
{ 
  long i_ssa_1 ;

  {
  return babel_wrapper_clear_vector_n(vec, n);
#line 455
  i_ssa_1 = 0L;
#line 455
  clear_vector_n_cil_lr_1(vec, n, i_ssa_1);
#line 456
  return;
}
}
#line 458 "svm_common.c"
void add_vector_ns(double *vec_n , SVECTOR *vec_s , double faktor ) 
{ 
  WORD *ai_ssa_1 ;
  WORD **mem_5 ;

  {
  return babel_wrapper_add_vector_ns(vec_n, vec_s, faktor);
#line 461
  mem_5 = (WORD **)vec_s;
#line 461
  ai_ssa_1 = *mem_5;
#line 462
  add_vector_ns_cil_lr_1(vec_n, faktor, ai_ssa_1);
#line 466
  return;
}
}
#line 468 "svm_common.c"
double sprod_ns(double *vec_n , SVECTOR *vec_s ) 
{ 
  double sum ;
  double *__cil_pp_sum ;
  double *__cil_fp_sum ;
  double sum_ssa_1 ;
  WORD *ai_ssa_1 ;
  double sum_ssa_2 ;
  WORD **mem_9 ;

  {
#line 471
  __cil_pp_sum = & sum;
#line 472
  __cil_fp_sum = & sum;
#line 470
  sum_ssa_1 = (double )0;
#line 472
  mem_9 = (WORD **)vec_s;
#line 472
  ai_ssa_1 = *mem_9;
#line 475
  *__cil_fp_sum = sum_ssa_1;
#line 473
  sprod_ns_cil_lr_1(__cil_pp_sum, vec_n, ai_ssa_1);
#line 474
  sum_ssa_2 = *__cil_fp_sum;
#line 477
  return (sum_ssa_2);
}
}
#line 480 "svm_common.c"
void add_weight_vector_to_linear_model(MODEL *model ) 
{ 
  void *tmp_ssa_1 ;
  long i_ssa_1 ;
  unsigned char *__cil_tmp7 ;
  long *__cil_tmp8 ;
  long __cil_tmp9 ;
  long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  double **__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  double **__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  long *__cil_tmp18 ;
  double *__cil_tmp19 ;
  long __cil_tmp20 ;

  {

#line 486
  return babel_wrapper_add_weight_vector_to_linear_model(model);
#line 486
  __cil_tmp7 = (unsigned char *)model + 48;
#line 486
  __cil_tmp8 = (long *)__cil_tmp7;
#line 486
  __cil_tmp9 = *__cil_tmp8;
#line 486
  __cil_tmp10 = __cil_tmp9 + 1L;
#line 486
  __cil_tmp11 = (unsigned long )__cil_tmp10;
#line 486
  __cil_tmp12 = sizeof(double ) * __cil_tmp11;
#line 486
  tmp_ssa_1 = my_malloc(__cil_tmp12);
#line 486
  __cil_tmp13 = (unsigned char *)model + 208;
#line 486
  __cil_tmp14 = (double **)__cil_tmp13;
#line 486
  *__cil_tmp14 = (double *)tmp_ssa_1;
#line 487
  __cil_tmp15 = (unsigned char *)model + 208;
#line 487
  __cil_tmp16 = (double **)__cil_tmp15;
#line 487
  __cil_tmp17 = (unsigned char *)model + 48;
#line 487
  __cil_tmp18 = (long *)__cil_tmp17;
#line 487
  __cil_tmp19 = *__cil_tmp16;
#line 487
  __cil_tmp20 = *__cil_tmp18;
#line 487
  clear_vector_n(__cil_tmp19, __cil_tmp20);
#line 488
  i_ssa_1 = 1L;
#line 488
  add_weight_vector_to_linear_model_cil_lr_1(model, i_ssa_1);
#line 492
  return;
}
}
#line 495 "svm_common.c"
DOC *create_example(long docnum , long queryid , long slackid , double costfactor ,
                    SVECTOR *fvec ) 
{ 
  void *tmp_ssa_1 ;
  DOC *example_ssa_1 ;
  unsigned char *__cil_tmp10 ;
  long *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  long *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  double *__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  SVECTOR **__cil_tmp17 ;
  long *mem_16 ;

  {

#line 499
  return babel_wrapper_create_example(docnum, queryid, slackid, costfactor, fvec);
#line 499
  tmp_ssa_1 = my_malloc(sizeof(DOC ));
#line 499
  example_ssa_1 = (DOC *)tmp_ssa_1;
#line 500
  mem_16 = (long *)example_ssa_1;
#line 500
  *mem_16 = docnum;
#line 501
  __cil_tmp10 = (unsigned char *)example_ssa_1 + 8;
#line 501
  __cil_tmp11 = (long *)__cil_tmp10;
#line 501
  *__cil_tmp11 = queryid;
#line 502
  __cil_tmp12 = (unsigned char *)example_ssa_1 + 24;
#line 502
  __cil_tmp13 = (long *)__cil_tmp12;
#line 502
  *__cil_tmp13 = slackid;
#line 503
  __cil_tmp14 = (unsigned char *)example_ssa_1 + 16;
#line 503
  __cil_tmp15 = (double *)__cil_tmp14;
#line 503
  *__cil_tmp15 = costfactor;
#line 504
  __cil_tmp16 = (unsigned char *)example_ssa_1 + 32;
#line 504
  __cil_tmp17 = (SVECTOR **)__cil_tmp16;
#line 504
  *__cil_tmp17 = fvec;
#line 505
  return (example_ssa_1);
}
}
#line 508 "svm_common.c"
void free_example(DOC *example , long deep ) 
{ 
  SVECTOR *__cil_tmp3 ;
  unsigned char *__cil_tmp4 ;
  SVECTOR **__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  SVECTOR **__cil_tmp7 ;
  SVECTOR *__cil_tmp8 ;

  {

#line 510
  return babel_wrapper_free_example(example, deep);
#line 510
  if (example != 0) {
#line 511
    if (deep != 0) {
#line 512
      __cil_tmp4 = (unsigned char *)example + 32;
#line 512
      __cil_tmp5 = (SVECTOR **)__cil_tmp4;
#line 512
      __cil_tmp3 = *__cil_tmp5;
#line 512
      if (__cil_tmp3 != 0) {
#line 513
        __cil_tmp6 = (unsigned char *)example + 32;
#line 513
        __cil_tmp7 = (SVECTOR **)__cil_tmp6;
#line 513
        __cil_tmp8 = *__cil_tmp7;
#line 513
        free_svector(__cil_tmp8);
      } else {

      }
    } else {

    }
#line 515
    free((void *)example);
  } else {

  }
#line 517
  return;
}
}
#line 519 "svm_common.c"
void write_model(char *modelfile , MODEL *model ) 
{ 
  FILE *modelfl ;
  long sv_num ;
  long *__cil_pp_verbosity ;
  MODEL **__cil_pp_model ;
  FILE **__cil_pp_modelfl ;
  long *__cil_pp_sv_num ;
  long *__cil_gp_verbosity ;
  struct _IO_FILE **__cil_gp_stdout ;
  MODEL **__cil_fp_model ;
  FILE **__cil_fp_modelfl ;
  long *__cil_fp_sv_num ;
  FILE *modelfl_ssa_1 ;
  long sv_num_ssa_1 ;
  long i_ssa_1 ;
  MODEL *model_ssa_1 ;
  FILE *modelfl_ssa_2 ;
  long sv_num_ssa_2 ;
  long i_ssa_2 ;
  FILE *modelfl_ssa_3 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  long __cil_tmp28 ;
  struct _IO_FILE *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  long *__cil_tmp31 ;
  long __cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  long *__cil_tmp34 ;
  long __cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  double *__cil_tmp37 ;
  double __cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  double *__cil_tmp40 ;
  double __cil_tmp41 ;
  unsigned char *__cil_tmp42 ;
  double *__cil_tmp43 ;
  double __cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  char (*__cil_tmp46)[50] ;
  char *__cil_tmp47 ;
  unsigned char *__cil_tmp48 ;
  long *__cil_tmp49 ;
  long __cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  long *__cil_tmp52 ;
  long __cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  double *__cil_tmp55 ;
  double __cil_tmp56 ;
  long __cil_tmp57 ;

  {
#line 523
  __cil_fp_sv_num = & sv_num;
#line 523
  __cil_fp_modelfl = & modelfl;
#line 523
  __cil_fp_model = & model;
#line 523
  __cil_gp_stdout = & stdout;
#line 523
  __cil_gp_verbosity = & verbosity;
#line 523
  __cil_pp_sv_num = & sv_num;
#line 523
  __cil_pp_modelfl = & modelfl;
#line 523
  __cil_pp_model = & model;
#line 523
  __cil_pp_verbosity = & verbosity;
#line 523
  return babel_wrapper_write_model(__cil_pp_verbosity, __cil_pp_model, __cil_pp_modelfl,
                                   __cil_pp_sv_num, __cil_gp_verbosity, __cil_gp_stdout,
                                   __cil_fp_model, __cil_fp_modelfl, __cil_fp_sv_num,
                                   modelfile, model);
#line 523
  __cil_pp_verbosity = & verbosity;
#line 524
  __cil_pp_model = & model;
#line 525
  __cil_pp_modelfl = & modelfl;
#line 526
  __cil_pp_sv_num = & sv_num;
#line 527
  __cil_gp_verbosity = & verbosity;
#line 528
  __cil_gp_stdout = & stdout;
#line 529
  __cil_fp_model = & model;
#line 530
  __cil_fp_modelfl = & modelfl;
#line 531
  __cil_fp_sv_num = & sv_num;
#line 525
  __cil_tmp28 = *__cil_gp_verbosity;
#line 525
  __cil_tmp25 = __cil_tmp28 >= 1L;
#line 525
  if (__cil_tmp25 != 0) {
#line 526
    printf((char const   * __restrict  )"Writing model file...");
#line 526
    __cil_tmp29 = *__cil_gp_stdout;
#line 526
    fflush(__cil_tmp29);
  } else {

  }
#line 528
  modelfl_ssa_1 = fopen((char const   * __restrict  )((char const   *)modelfile),
                        (char const   * __restrict  )"w");
#line 528
  __cil_tmp26 = (unsigned long )modelfl_ssa_1 == (unsigned long )((void *)0);
#line 528
  if (__cil_tmp26 != 0) {
#line 529
    perror((char const   *)modelfile);
#line 529
    exit(1);
  } else {

  }
#line 530
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"SVM-light Version %s\n",
          "V6.02");
#line 531
  __cil_tmp30 = (unsigned char *)model + 64;
#line 531
  __cil_tmp31 = (long *)__cil_tmp30;
#line 531
  __cil_tmp32 = *__cil_tmp31;
#line 531
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld # kernel type\n",
          __cil_tmp32);
#line 533
  __cil_tmp33 = (unsigned char *)model + 72;
#line 533
  __cil_tmp34 = (long *)__cil_tmp33;
#line 533
  __cil_tmp35 = *__cil_tmp34;
#line 533
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld # kernel parameter -d \n",
          __cil_tmp35);
#line 535
  __cil_tmp36 = (unsigned char *)model + 80;
#line 535
  __cil_tmp37 = (double *)__cil_tmp36;
#line 535
  __cil_tmp38 = *__cil_tmp37;
#line 535
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%.8g # kernel parameter -g \n",
          __cil_tmp38);
#line 537
  __cil_tmp39 = (unsigned char *)model + 88;
#line 537
  __cil_tmp40 = (double *)__cil_tmp39;
#line 537
  __cil_tmp41 = *__cil_tmp40;
#line 537
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%.8g # kernel parameter -s \n",
          __cil_tmp41);
#line 539
  __cil_tmp42 = (unsigned char *)model + 96;
#line 539
  __cil_tmp43 = (double *)__cil_tmp42;
#line 539
  __cil_tmp44 = *__cil_tmp43;
#line 539
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%.8g # kernel parameter -r \n",
          __cil_tmp44);
#line 541
  __cil_tmp45 = (unsigned char *)model + 104;
#line 541
  __cil_tmp46 = (char (*)[50])__cil_tmp45;
#line 541
  __cil_tmp47 = *__cil_tmp46;
#line 541
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%s# kernel parameter -u \n",
          __cil_tmp47);
#line 542
  __cil_tmp48 = (unsigned char *)model + 48;
#line 542
  __cil_tmp49 = (long *)__cil_tmp48;
#line 542
  __cil_tmp50 = *__cil_tmp49;
#line 542
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld # highest feature index \n",
          __cil_tmp50);
#line 543
  __cil_tmp51 = (unsigned char *)model + 56;
#line 543
  __cil_tmp52 = (long *)__cil_tmp51;
#line 543
  __cil_tmp53 = *__cil_tmp52;
#line 543
  fprintf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld # number of training documents \n",
          __cil_tmp53);
#line 545
  sv_num_ssa_1 = 1L;
#line 546
  i_ssa_1 = 1L;
#line 549
  *__cil_fp_model = model;
#line 550
  *__cil_fp_modelfl = modelfl_ssa_1;
#line 551
  *__cil_fp_sv_num = sv_num_ssa_1;
#line 546
  write_model_cil_lr_1(__cil_pp_verbosity, __cil_pp_model, __cil_pp_modelfl, __cil_pp_sv_num,
                       i_ssa_1);
#line 548
  model_ssa_1 = *__cil_fp_model;
#line 549
  modelfl_ssa_2 = *__cil_fp_modelfl;
#line 550
  sv_num_ssa_2 = *__cil_fp_sv_num;
#line 550
  fprintf((FILE * __restrict  )modelfl_ssa_2, (char const   * __restrict  )"%ld # number of support vectors plus 1 \n",
          sv_num_ssa_2);
#line 551
  __cil_tmp54 = (unsigned char *)model_ssa_1 + 16;
#line 551
  __cil_tmp55 = (double *)__cil_tmp54;
#line 551
  __cil_tmp56 = *__cil_tmp55;
#line 551
  fprintf((FILE * __restrict  )modelfl_ssa_2, (char const   * __restrict  )"%.8g # threshold b, each following line is a SV (starting with alpha*y)\n",
          __cil_tmp56);
#line 553
  i_ssa_2 = 1L;
#line 556
  *__cil_fp_modelfl = modelfl_ssa_2;
#line 553
  write_model_cil_lr_2(__cil_pp_verbosity, __cil_pp_modelfl, model_ssa_1, i_ssa_2);
#line 554
  modelfl_ssa_3 = *__cil_fp_modelfl;
#line 567
  fclose(modelfl_ssa_3);
#line 568
  __cil_tmp57 = *__cil_gp_verbosity;
#line 568
  __cil_tmp27 = __cil_tmp57 >= 1L;
#line 568
  if (__cil_tmp27 != 0) {
#line 569
    printf((char const   * __restrict  )"done\n");
  } else {

  }
#line 571
  return;
}
}
#line 574 "svm_common.c"
MODEL *read_model(char *modelfile ) 
{ 
  FILE *modelfl ;
  long queryid ;
  long slackid ;
  double costfactor ;
  long max_sv ;
  long max_words ;
  long ll ;
  long wpos ;
  char *line ;
  char *comment ;
  WORD *words ;
  char version_buffer[100] ;
  MODEL *model ;
  long *__cil_pp_max_sv ;
  long *__cil_pp_max_words ;
  long *__cil_pp_ll ;
  struct _IO_FILE **__cil_pp_stdout ;
  long *__cil_pp_verbosity ;
  FILE **__cil_pp_modelfl ;
  char **__cil_pp_line ;
  WORD **__cil_pp_words ;
  MODEL **__cil_pp_model ;
  long *__cil_gp_verbosity ;
  struct _IO_FILE **__cil_gp_stdout ;
  long *__cil_fp_max_sv ;
  long *__cil_fp_max_words ;
  long *__cil_fp_ll ;
  FILE **__cil_fp_modelfl ;
  char **__cil_fp_line ;
  WORD **__cil_fp_words ;
  MODEL **__cil_fp_model ;
  long max_words_ssa_1 ;
  long ll_ssa_1 ;
  long max_words_ssa_2 ;
  long ll_ssa_2 ;
  void *tmp_ssa_1 ;
  WORD *words_ssa_1 ;
  void *tmp___0_ssa_1 ;
  char *line_ssa_1 ;
  void *tmp___1_ssa_1 ;
  MODEL *model_ssa_1 ;
  FILE *modelfl_ssa_1 ;
  int tmp___2_ssa_1 ;
  void *tmp___3_ssa_1 ;
  void *tmp___4_ssa_1 ;
  long i_ssa_1 ;
  FILE *modelfl_ssa_2 ;
  char *line_ssa_2 ;
  WORD *words_ssa_2 ;
  MODEL *model_ssa_2 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  long __cil_tmp64 ;
  struct _IO_FILE *__cil_tmp65 ;
  long __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  unsigned char *__cil_tmp72 ;
  unsigned char *__cil_tmp73 ;
  unsigned char *__cil_tmp74 ;
  unsigned char *__cil_tmp75 ;
  unsigned char *__cil_tmp76 ;
  unsigned char *__cil_tmp77 ;
  char (*__cil_tmp78)[50] ;
  char *__cil_tmp79 ;
  unsigned char *__cil_tmp80 ;
  unsigned char *__cil_tmp81 ;
  unsigned char *__cil_tmp82 ;
  long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  unsigned char *__cil_tmp86 ;
  DOC ***__cil_tmp87 ;
  long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  unsigned char *__cil_tmp91 ;
  double **__cil_tmp92 ;
  unsigned char *__cil_tmp93 ;
  long **__cil_tmp94 ;
  unsigned char *__cil_tmp95 ;
  double **__cil_tmp96 ;
  long __cil_tmp97 ;
  struct _IO_FILE *__cil_tmp98 ;
  long __cil_tmp99 ;
  long __cil_tmp100 ;
  long *mem_92 ;
  long *mem_93 ;
  long *mem_94 ;

  {
#line 589
  __cil_pp_max_sv = & max_sv;
#line 590
  __cil_pp_max_words = & max_words;
#line 591
  __cil_pp_ll = & ll;
#line 592
  __cil_pp_stdout = & stdout;
#line 593
  __cil_pp_verbosity = & verbosity;
#line 594
  __cil_pp_modelfl = & modelfl;
#line 595
  __cil_pp_line = & line;
#line 596
  __cil_pp_words = & words;
#line 597
  __cil_pp_model = & model;
#line 598
  __cil_gp_verbosity = & verbosity;
#line 599
  __cil_gp_stdout = & stdout;
#line 600
  __cil_fp_max_sv = & max_sv;
#line 601
  __cil_fp_max_words = & max_words;
#line 602
  __cil_fp_ll = & ll;
#line 603
  __cil_fp_modelfl = & modelfl;
#line 604
  __cil_fp_line = & line;
#line 605
  __cil_fp_words = & words;
#line 606
  __cil_fp_model = & model;
#line 585
  __cil_tmp64 = *__cil_gp_verbosity;
#line 585
  __cil_tmp61 = __cil_tmp64 >= 1L;
#line 585
  if (__cil_tmp61 != 0) {
#line 586
    printf((char const   * __restrict  )"Reading model...");
#line 586
    __cil_tmp65 = *__cil_gp_stdout;
#line 586
    fflush(__cil_tmp65);
  } else {

  }
#line 593
  *__cil_fp_max_sv = max_sv;
#line 594
  *__cil_fp_max_words = max_words;
#line 595
  *__cil_fp_ll = ll;
#line 589
  nol_ll(modelfile, __cil_pp_max_sv, __cil_pp_max_words, __cil_pp_ll);
#line 590
  max_words_ssa_1 = *__cil_fp_max_words;
#line 591
  ll_ssa_1 = *__cil_fp_ll;
#line 590
  max_words_ssa_2 = max_words_ssa_1 + 2L;
#line 591
  ll_ssa_2 = ll_ssa_1 + 2L;
#line 593
  __cil_tmp66 = max_words_ssa_2 + 10L;
#line 593
  __cil_tmp67 = (unsigned long )__cil_tmp66;
#line 593
  __cil_tmp68 = sizeof(WORD ) * __cil_tmp67;
#line 593
  tmp_ssa_1 = my_malloc(__cil_tmp68);
#line 593
  words_ssa_1 = (WORD *)tmp_ssa_1;
#line 594
  __cil_tmp69 = sizeof(char ) * (unsigned long )ll_ssa_2;
#line 594
  tmp___0_ssa_1 = my_malloc(__cil_tmp69);
#line 594
  line_ssa_1 = (char *)tmp___0_ssa_1;
#line 595
  tmp___1_ssa_1 = my_malloc(sizeof(MODEL ));
#line 595
  model_ssa_1 = (MODEL *)tmp___1_ssa_1;
#line 597
  modelfl_ssa_1 = fopen((char const   * __restrict  )((char const   *)modelfile),
                        (char const   * __restrict  )"r");
#line 597
  __cil_tmp62 = (unsigned long )modelfl_ssa_1 == (unsigned long )((void *)0);
#line 597
  if (__cil_tmp62 != 0) {
#line 598
    perror((char const   *)modelfile);
#line 598
    exit(1);
  } else {

  }
#line 600
  __cil_tmp70 = version_buffer;
#line 600
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"SVM-light Version %s\n",
         __cil_tmp70);
#line 601
  __cil_tmp71 = version_buffer;
#line 601
  tmp___2_ssa_1 = strcmp((char const   *)__cil_tmp71, "V6.02");
#line 601
  if (tmp___2_ssa_1 != 0) {
#line 602
    perror("Version of model-file does not match version of svm_classify!");
#line 603
    exit(1);
  } else {

  }
#line 605
  __cil_tmp72 = (unsigned char *)model_ssa_1 + 64;
#line 605
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld%*[^\n]\n",
         (long *)__cil_tmp72);
#line 606
  __cil_tmp73 = (unsigned char *)model_ssa_1 + 72;
#line 606
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld%*[^\n]\n",
         (long *)__cil_tmp73);
#line 607
  __cil_tmp74 = (unsigned char *)model_ssa_1 + 80;
#line 607
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%lf%*[^\n]\n",
         (double *)__cil_tmp74);
#line 608
  __cil_tmp75 = (unsigned char *)model_ssa_1 + 88;
#line 608
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%lf%*[^\n]\n",
         (double *)__cil_tmp75);
#line 609
  __cil_tmp76 = (unsigned char *)model_ssa_1 + 96;
#line 609
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%lf%*[^\n]\n",
         (double *)__cil_tmp76);
#line 610
  __cil_tmp77 = (unsigned char *)model_ssa_1 + 104;
#line 610
  __cil_tmp78 = (char (*)[50])__cil_tmp77;
#line 610
  __cil_tmp79 = *__cil_tmp78;
#line 610
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%[^#]%*[^\n]\n",
         __cil_tmp79);
#line 612
  __cil_tmp80 = (unsigned char *)model_ssa_1 + 48;
#line 612
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld%*[^\n]\n",
         (long *)__cil_tmp80);
#line 613
  __cil_tmp81 = (unsigned char *)model_ssa_1 + 56;
#line 613
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld%*[^\n]\n",
         (long *)__cil_tmp81);
#line 614
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%ld%*[^\n]\n",
         (long *)model_ssa_1);
#line 615
  __cil_tmp82 = (unsigned char *)model_ssa_1 + 16;
#line 615
  fscanf((FILE * __restrict  )modelfl_ssa_1, (char const   * __restrict  )"%lf%*[^\n]\n",
         (double *)__cil_tmp82);
#line 617
  mem_92 = (long *)model_ssa_1;
#line 617
  __cil_tmp83 = *mem_92;
#line 617
  __cil_tmp84 = (unsigned long )__cil_tmp83;
#line 617
  __cil_tmp85 = sizeof(DOC *) * __cil_tmp84;
#line 617
  tmp___3_ssa_1 = my_malloc(__cil_tmp85);
#line 617
  __cil_tmp86 = (unsigned char *)model_ssa_1 + 24;
#line 617
  __cil_tmp87 = (DOC ***)__cil_tmp86;
#line 617
  *__cil_tmp87 = (DOC **)tmp___3_ssa_1;
#line 618
  mem_93 = (long *)model_ssa_1;
#line 618
  __cil_tmp88 = *mem_93;
#line 618
  __cil_tmp89 = (unsigned long )__cil_tmp88;
#line 618
  __cil_tmp90 = sizeof(double ) * __cil_tmp89;
#line 618
  tmp___4_ssa_1 = my_malloc(__cil_tmp90);
#line 618
  __cil_tmp91 = (unsigned char *)model_ssa_1 + 32;
#line 618
  __cil_tmp92 = (double **)__cil_tmp91;
#line 618
  *__cil_tmp92 = (double *)tmp___4_ssa_1;
#line 619
  __cil_tmp93 = (unsigned char *)model_ssa_1 + 40;
#line 619
  __cil_tmp94 = (long **)__cil_tmp93;
#line 619
  *__cil_tmp94 = (long *)0;
#line 620
  __cil_tmp95 = (unsigned char *)model_ssa_1 + 208;
#line 620
  __cil_tmp96 = (double **)__cil_tmp95;
#line 620
  *__cil_tmp96 = (double *)0;
#line 622
  i_ssa_1 = 1L;
#line 625
  *__cil_fp_modelfl = modelfl_ssa_1;
#line 626
  *__cil_fp_line = line_ssa_1;
#line 627
  *__cil_fp_words = words_ssa_1;
#line 628
  *__cil_fp_model = model_ssa_1;
#line 622
  read_model_cil_lr_1(__cil_pp_stdout, __cil_pp_verbosity, __cil_pp_modelfl, __cil_pp_line,
                      __cil_pp_words, __cil_pp_model, i_ssa_1, queryid, slackid, costfactor,
                      max_words_ssa_2, ll_ssa_2, wpos, comment);
#line 625
  modelfl_ssa_2 = *__cil_fp_modelfl;
#line 626
  line_ssa_2 = *__cil_fp_line;
#line 627
  words_ssa_2 = *__cil_fp_words;
#line 628
  model_ssa_2 = *__cil_fp_model;
#line 635
  fclose(modelfl_ssa_2);
#line 636
  free((void *)line_ssa_2);
#line 637
  free((void *)words_ssa_2);
#line 638
  __cil_tmp97 = *__cil_gp_verbosity;
#line 638
  __cil_tmp63 = __cil_tmp97 >= 1L;
#line 638
  if (__cil_tmp63 != 0) {
#line 639
    __cil_tmp98 = *__cil_gp_stdout;
#line 639
    mem_94 = (long *)model_ssa_2;
#line 639
    __cil_tmp99 = *mem_94;
#line 639
    __cil_tmp100 = __cil_tmp99 - 1L;
#line 639
    fprintf((FILE * __restrict  )__cil_tmp98, (char const   * __restrict  )"OK. (%d support vectors read)\n",
            (int )__cil_tmp100);
  } else {

  }
#line 641
  return (model_ssa_2);
}
}
#line 644 "svm_common.c"
MODEL *copy_model(MODEL *model ) 
{ 
  MODEL *newmodel ;
  MODEL **__cil_pp_model ;
  MODEL **__cil_pp_newmodel ;
  MODEL **__cil_fp_model ;
  MODEL **__cil_fp_newmodel ;
  void *tmp_ssa_1 ;
  MODEL *newmodel_ssa_1 ;
  void *tmp___0_ssa_1 ;
  void *tmp___1_ssa_1 ;
  long i_ssa_1 ;
  MODEL *model_ssa_1 ;
  MODEL *newmodel_ssa_2 ;
  void *tmp___3_ssa_1 ;
  long i_ssa_2 ;
  MODEL *newmodel_ssa_3 ;
  double *__cil_tmp23 ;
  long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  DOC ***__cil_tmp28 ;
  long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  double **__cil_tmp33 ;
  unsigned char *__cil_tmp34 ;
  long **__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  DOC ***__cil_tmp37 ;
  DOC **__cil_tmp38 ;
  DOC **__cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  double **__cil_tmp41 ;
  double *__cil_tmp42 ;
  double *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  double **__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  long *__cil_tmp47 ;
  long __cil_tmp48 ;
  long __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned char *__cil_tmp52 ;
  double **__cil_tmp53 ;
  long *mem_48 ;
  long *mem_49 ;

  {
#line 647
  __cil_fp_newmodel = & newmodel;
#line 647
  __cil_fp_model = & model;
#line 647
  __cil_pp_newmodel = & newmodel;
#line 647
  __cil_pp_model = & model;
#line 647
  return babel_wrapper_copy_model(__cil_pp_model, __cil_pp_newmodel, __cil_fp_model,
                                  __cil_fp_newmodel, model);
#line 647
  __cil_pp_model = & model;
#line 648
  __cil_pp_newmodel = & newmodel;
#line 649
  __cil_fp_model = & model;
#line 650
  __cil_fp_newmodel = & newmodel;
#line 649
  tmp_ssa_1 = my_malloc(sizeof(MODEL ));
#line 649
  newmodel_ssa_1 = (MODEL *)tmp_ssa_1;
#line 650
  *newmodel_ssa_1 = *model;
#line 651
  mem_48 = (long *)model;
#line 651
  __cil_tmp24 = *mem_48;
#line 651
  __cil_tmp25 = (unsigned long )__cil_tmp24;
#line 651
  __cil_tmp26 = sizeof(DOC *) * __cil_tmp25;
#line 651
  tmp___0_ssa_1 = my_malloc(__cil_tmp26);
#line 651
  __cil_tmp27 = (unsigned char *)newmodel_ssa_1 + 24;
#line 651
  __cil_tmp28 = (DOC ***)__cil_tmp27;
#line 651
  *__cil_tmp28 = (DOC **)tmp___0_ssa_1;
#line 652
  mem_49 = (long *)model;
#line 652
  __cil_tmp29 = *mem_49;
#line 652
  __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 652
  __cil_tmp31 = sizeof(double ) * __cil_tmp30;
#line 652
  tmp___1_ssa_1 = my_malloc(__cil_tmp31);
#line 652
  __cil_tmp32 = (unsigned char *)newmodel_ssa_1 + 32;
#line 652
  __cil_tmp33 = (double **)__cil_tmp32;
#line 652
  *__cil_tmp33 = (double *)tmp___1_ssa_1;
#line 653
  __cil_tmp34 = (unsigned char *)newmodel_ssa_1 + 40;
#line 653
  __cil_tmp35 = (long **)__cil_tmp34;
#line 653
  *__cil_tmp35 = (long *)0;
#line 654
  __cil_tmp36 = (unsigned char *)newmodel_ssa_1 + 24;
#line 654
  __cil_tmp37 = (DOC ***)__cil_tmp36;
#line 654
  __cil_tmp38 = *__cil_tmp37;
#line 654
  __cil_tmp39 = __cil_tmp38 + 0;
#line 654
  *__cil_tmp39 = (DOC *)0;
#line 655
  __cil_tmp40 = (unsigned char *)newmodel_ssa_1 + 32;
#line 655
  __cil_tmp41 = (double **)__cil_tmp40;
#line 655
  __cil_tmp42 = *__cil_tmp41;
#line 655
  __cil_tmp43 = __cil_tmp42 + 0;
#line 655
  *__cil_tmp43 = (double )0;
#line 656
  i_ssa_1 = 1L;
#line 659
  *__cil_fp_model = model;
#line 660
  *__cil_fp_newmodel = newmodel_ssa_1;
#line 656
  copy_model_cil_lr_1(__cil_pp_model, __cil_pp_newmodel, i_ssa_1);
#line 657
  model_ssa_1 = *__cil_fp_model;
#line 658
  newmodel_ssa_2 = *__cil_fp_newmodel;
#line 663
  __cil_tmp44 = (unsigned char *)model_ssa_1 + 208;
#line 663
  __cil_tmp45 = (double **)__cil_tmp44;
#line 663
  __cil_tmp23 = *__cil_tmp45;
#line 663
  if (__cil_tmp23 != 0) {
#line 664
    __cil_tmp46 = (unsigned char *)model_ssa_1 + 48;
#line 664
    __cil_tmp47 = (long *)__cil_tmp46;
#line 664
    __cil_tmp48 = *__cil_tmp47;
#line 664
    __cil_tmp49 = __cil_tmp48 + 1L;
#line 664
    __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 664
    __cil_tmp51 = sizeof(double ) * __cil_tmp50;
#line 664
    tmp___3_ssa_1 = my_malloc(__cil_tmp51);
#line 664
    __cil_tmp52 = (unsigned char *)newmodel_ssa_2 + 208;
#line 664
    __cil_tmp53 = (double **)__cil_tmp52;
#line 664
    *__cil_tmp53 = (double *)tmp___3_ssa_1;
#line 665
    i_ssa_2 = 0L;
#line 668
    *__cil_fp_newmodel = newmodel_ssa_2;
#line 665
    copy_model_cil_lr_2(__cil_pp_newmodel, model_ssa_1, i_ssa_2);
#line 666
    newmodel_ssa_3 = *__cil_fp_newmodel;
  } else {
#line 669
    newmodel_ssa_3 = newmodel_ssa_2;
  }
#line 668
  return (newmodel_ssa_3);
}
}
#line 671 "svm_common.c"
void free_model(MODEL *model , int deep ) 
{ 
  MODEL **__cil_pp_model ;
  MODEL **__cil_fp_model ;
  long i_ssa_1 ;
  MODEL *model_ssa_1 ;
  DOC **__cil_tmp8 ;
  double *__cil_tmp9 ;
  long *__cil_tmp10 ;
  double *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  DOC ***__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  DOC ***__cil_tmp15 ;
  DOC **__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  double **__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  double **__cil_tmp20 ;
  double *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  long **__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  long **__cil_tmp25 ;
  long *__cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  double **__cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  double **__cil_tmp30 ;
  double *__cil_tmp31 ;

  {
#line 673
  __cil_pp_model = & model;
#line 674
  __cil_fp_model = & model;
#line 675
  __cil_tmp12 = (unsigned char *)model + 24;
#line 675
  __cil_tmp13 = (DOC ***)__cil_tmp12;
#line 675
  __cil_tmp8 = *__cil_tmp13;
#line 675
  if (__cil_tmp8 != 0) {
#line 676
    if (deep != 0) {
#line 677
      i_ssa_1 = 1L;
#line 680
      *__cil_fp_model = model;
#line 677
      free_model_cil_lr_1(__cil_pp_model, i_ssa_1);
#line 678
      model_ssa_1 = *__cil_fp_model;
    } else {
#line 681
      model_ssa_1 = model;
    }
#line 681
    __cil_tmp14 = (unsigned char *)model_ssa_1 + 24;
#line 681
    __cil_tmp15 = (DOC ***)__cil_tmp14;
#line 681
    __cil_tmp16 = *__cil_tmp15;
#line 681
    free((void *)__cil_tmp16);
  } else {
#line 684
    model_ssa_1 = model;
  }
#line 683
  __cil_tmp17 = (unsigned char *)model_ssa_1 + 32;
#line 683
  __cil_tmp18 = (double **)__cil_tmp17;
#line 683
  __cil_tmp9 = *__cil_tmp18;
#line 683
  if (__cil_tmp9 != 0) {
#line 683
    __cil_tmp19 = (unsigned char *)model_ssa_1 + 32;
#line 683
    __cil_tmp20 = (double **)__cil_tmp19;
#line 683
    __cil_tmp21 = *__cil_tmp20;
#line 683
    free((void *)__cil_tmp21);
  } else {

  }
#line 684
  __cil_tmp22 = (unsigned char *)model_ssa_1 + 40;
#line 684
  __cil_tmp23 = (long **)__cil_tmp22;
#line 684
  __cil_tmp10 = *__cil_tmp23;
#line 684
  if (__cil_tmp10 != 0) {
#line 684
    __cil_tmp24 = (unsigned char *)model_ssa_1 + 40;
#line 684
    __cil_tmp25 = (long **)__cil_tmp24;
#line 684
    __cil_tmp26 = *__cil_tmp25;
#line 684
    free((void *)__cil_tmp26);
  } else {

  }
#line 685
  __cil_tmp27 = (unsigned char *)model_ssa_1 + 208;
#line 685
  __cil_tmp28 = (double **)__cil_tmp27;
#line 685
  __cil_tmp11 = *__cil_tmp28;
#line 685
  if (__cil_tmp11 != 0) {
#line 685
    __cil_tmp29 = (unsigned char *)model_ssa_1 + 208;
#line 685
    __cil_tmp30 = (double **)__cil_tmp29;
#line 685
    __cil_tmp31 = *__cil_tmp30;
#line 685
    free((void *)__cil_tmp31);
  } else {

  }
#line 686
  free((void *)model_ssa_1);
#line 687
  return;
}
}
#line 690 "svm_common.c"
void read_documents(char *docfile , DOC ***docs , double **label , long *totwords ,
                    long *totdoc ) 
{ 
  char *line ;
  char *comment ;
  WORD *words ;
  long dnum ;
  long wpos ;
  long dpos ;
  long dneg ;
  long dunlab ;
  long queryid ;
  long slackid ;
  long max_docs ;
  long max_words_doc ;
  long ll ;
  double doc_label ;
  double costfactor ;
  FILE *docfl ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  SVECTOR *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *mem_30 ;
  double *mem_31 ;
  WORD *mem_32 ;
  WORD *mem_33 ;
  DOC **mem_34 ;

  {
#line 695
  dpos = 0L;
#line 695
  dneg = 0L;
#line 695
  dunlab = 0L;
#line 700
  if (verbosity >= 1L) {
#line 701
    printf((char const   * __restrict  )"Scanning examples...");
#line 701
    fflush(stdout);
  } else {

  }
#line 703
  nol_ll(docfile, & max_docs, & max_words_doc, & ll);
#line 704
  max_words_doc += 2L;
#line 705
  ll += 2L;
#line 706
  max_docs += 2L;
#line 707
  if (verbosity >= 1L) {
#line 708
    printf((char const   * __restrict  )"done\n");
#line 708
    fflush(stdout);
  } else {

  }
#line 711
  tmp = my_malloc(sizeof(DOC *) * (unsigned long )max_docs);
#line 711
  *docs = (DOC **)tmp;
#line 712
  tmp___0 = my_malloc(sizeof(double ) * (unsigned long )max_docs);
#line 712
  *label = (double *)tmp___0;
#line 713
  tmp___1 = my_malloc(sizeof(char ) * (unsigned long )ll);
#line 713
  line = (char *)tmp___1;
#line 715
  docfl = fopen((char const   * __restrict  )((char const   *)docfile), (char const   * __restrict  )"r");
#line 715
  if ((unsigned long )docfl == (unsigned long )((void *)0)) {
#line 716
    perror((char const   *)docfile);
#line 716
    exit(1);
  } else {

  }
#line 718
  tmp___2 = my_malloc(sizeof(WORD ) * (unsigned long )(max_words_doc + 10L));
#line 718
  words = (WORD *)tmp___2;
#line 719
  if (verbosity >= 1L) {
#line 720
    printf((char const   * __restrict  )"Reading examples into memory...");
#line 720
    fflush(stdout);
  } else {

  }
#line 722
  dnum = 0L;
#line 723
  *totwords = 0L;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    tmp___5 = feof(docfl);
#line 724
    if (tmp___5 != 0) {
#line 724
      goto while_break;
    } else {
#line 724
      tmp___6 = fgets((char * __restrict  )line, (int )ll, (FILE * __restrict  )docfl);
#line 724
      if (tmp___6 == 0) {
#line 724
        goto while_break;
      } else {

      }
    }
    {
#line 725
    mem_30 = line + 0;
#line 725
    if ((int )*mem_30 == 35) {
#line 725
      goto while_continue;
    } else {

    }
    }
#line 726
    tmp___3 = parse_document(line, words, & doc_label, & queryid, & slackid, & costfactor,
                             & wpos, max_words_doc, & comment);
#line 726
    if (tmp___3 == 0) {
#line 728
      printf((char const   * __restrict  )"\nParsing error in line %ld!\n%s", dnum,
             line);
#line 729
      exit(1);
    } else {

    }
#line 731
    mem_31 = *label + dnum;
#line 731
    *mem_31 = doc_label;
#line 736
    if (wpos > 1L) {
      {
#line 736
      mem_32 = words + (wpos - 2L);
#line 736
      if (mem_32->wnum > *totwords) {
#line 737
        mem_33 = words + (wpos - 2L);
#line 737
        *totwords = mem_33->wnum;
      } else {

      }
      }
    } else {

    }
#line 738
    if (*totwords > 99999999L) {
#line 739
      printf((char const   * __restrict  )"\nMaximum feature number exceeds limit defined in MAXFEATNUM!\n");
#line 740
      printf((char const   * __restrict  )"LINE: %s\n", line);
#line 741
      exit(1);
    } else {

    }
#line 743
    tmp___4 = create_svector(words, comment, 1.0);
#line 743
    mem_34 = *docs + dnum;
#line 743
    *mem_34 = create_example(dnum, queryid, slackid, costfactor, tmp___4);
#line 746
    dnum ++;
#line 747
    if (verbosity >= 1L) {
#line 748
      if (dnum % 100L == 0L) {
#line 749
        printf((char const   * __restrict  )"%ld..", dnum);
#line 749
        fflush(stdout);
      } else {

      }
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  fclose(docfl);
#line 755
  free((void *)line);
#line 756
  free((void *)words);
#line 757
  if (verbosity >= 1L) {
#line 758
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"OK. (%ld examples read)\n",
            dnum);
  } else {

  }
#line 760
  *totdoc = dnum;
#line 761
  return;
}
}
#line 763 "svm_common.c"
int parse_document(char *line , WORD *words , double *label , long *queryid , long *slackid ,
                   double *costfactor , long *numwords , long max_words_doc , char **comment ) 
{ 
  long wpos ;
  long pos ;
  long wnum ;
  double weight ;
  char featurepair[1000] ;
  char junk[1000] ;
  char **__cil_pp_line ;
  WORD **__cil_pp_words ;
  double **__cil_pp_label ;
  long **__cil_pp_queryid ;
  long **__cil_pp_slackid ;
  double **__cil_pp_costfactor ;
  long **__cil_pp_numwords ;
  long *__cil_pp_max_words_doc ;
  char ***__cil_pp_comment ;
  long *__cil_pp_pos ;
  long *__cil_pp_wnum ;
  double *__cil_pp_weight ;
  long *__cil_pp_wpos ;
  char **__cil_fp_line ;
  WORD **__cil_fp_words ;
  double **__cil_fp_label ;
  long **__cil_fp_queryid ;
  long **__cil_fp_slackid ;
  double **__cil_fp_costfactor ;
  long **__cil_fp_numwords ;
  long *__cil_fp_max_words_doc ;
  char ***__cil_fp_comment ;
  long *__cil_fp_pos ;
  long *__cil_fp_wnum ;
  double *__cil_fp_weight ;
  long *__cil_fp_wpos ;
  long pos_ssa_1 ;
  char *line_ssa_1 ;
  WORD *words_ssa_1 ;
  double *label_ssa_1 ;
  long *queryid_ssa_1 ;
  long *slackid_ssa_1 ;
  double *costfactor_ssa_1 ;
  long *numwords_ssa_1 ;
  long max_words_doc_ssa_1 ;
  char **comment_ssa_1 ;
  long pos_ssa_2 ;
  long wnum_ssa_1 ;
  double weight_ssa_1 ;
  long wpos_ssa_1 ;
  int tmp_ssa_1 ;
  long pos_ssa_3 ;
  char *line_ssa_2 ;
  WORD *words_ssa_2 ;
  double *label_ssa_2 ;
  long *queryid_ssa_2 ;
  long *slackid_ssa_2 ;
  double *costfactor_ssa_2 ;
  long *numwords_ssa_2 ;
  long max_words_doc_ssa_2 ;
  long wpos_ssa_2 ;
  long pos_ssa_4 ;
  long wnum_ssa_2 ;
  double weight_ssa_2 ;
  int tmp___0_ssa_1 ;
  long pos_ssa_5 ;
  char *line_ssa_3 ;
  WORD *words_ssa_3 ;
  long *queryid_ssa_3 ;
  long *slackid_ssa_3 ;
  double *costfactor_ssa_3 ;
  long *numwords_ssa_3 ;
  long max_words_doc_ssa_3 ;
  long wpos_ssa_3 ;
  long pos_ssa_6 ;
  long wnum_ssa_3 ;
  double weight_ssa_3 ;
  char *line_ssa_4 ;
  WORD *words_ssa_4 ;
  long *queryid_ssa_4 ;
  long *slackid_ssa_4 ;
  double *costfactor_ssa_4 ;
  long *numwords_ssa_4 ;
  long max_words_doc_ssa_4 ;
  long wpos_ssa_4 ;
  long pos_ssa_7 ;
  long wnum_ssa_4 ;
  double weight_ssa_4 ;
  WORD *words_ssa_5 ;
  long *numwords_ssa_5 ;
  long wpos_ssa_5 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char __cil_tmp115 ;
  int __cil_tmp116 ;
  WORD *__cil_tmp117 ;
  long *__cil_tmp118 ;

  {
#line 772
  __cil_pp_line = & line;
#line 773
  __cil_pp_words = & words;
#line 774
  __cil_pp_label = & label;
#line 775
  __cil_pp_queryid = & queryid;
#line 776
  __cil_pp_slackid = & slackid;
#line 777
  __cil_pp_costfactor = & costfactor;
#line 778
  __cil_pp_numwords = & numwords;
#line 779
  __cil_pp_max_words_doc = & max_words_doc;
#line 780
  __cil_pp_comment = & comment;
#line 781
  __cil_pp_pos = & pos;
#line 782
  __cil_pp_wnum = & wnum;
#line 783
  __cil_pp_weight = & weight;
#line 784
  __cil_pp_wpos = & wpos;
#line 785
  __cil_fp_line = & line;
#line 786
  __cil_fp_words = & words;
#line 787
  __cil_fp_label = & label;
#line 788
  __cil_fp_queryid = & queryid;
#line 789
  __cil_fp_slackid = & slackid;
#line 790
  __cil_fp_costfactor = & costfactor;
#line 791
  __cil_fp_numwords = & numwords;
#line 792
  __cil_fp_max_words_doc = & max_words_doc;
#line 793
  __cil_fp_comment = & comment;
#line 794
  __cil_fp_pos = & pos;
#line 795
  __cil_fp_wnum = & wnum;
#line 796
  __cil_fp_weight = & weight;
#line 797
  __cil_fp_wpos = & wpos;
#line 774
  *queryid = 0L;
#line 775
  *slackid = 0L;
#line 776
  *costfactor = (double )1;
#line 778
  pos_ssa_1 = 0L;
#line 779
  *comment = (char *)0;
#line 782
  *__cil_fp_line = line;
#line 783
  *__cil_fp_words = words;
#line 784
  *__cil_fp_label = label;
#line 785
  *__cil_fp_queryid = queryid;
#line 786
  *__cil_fp_slackid = slackid;
#line 787
  *__cil_fp_costfactor = costfactor;
#line 788
  *__cil_fp_numwords = numwords;
#line 789
  *__cil_fp_max_words_doc = max_words_doc;
#line 790
  *__cil_fp_comment = comment;
#line 791
  *__cil_fp_pos = pos_ssa_1;
#line 792
  *__cil_fp_wnum = wnum;
#line 793
  *__cil_fp_weight = weight;
#line 780
  parse_document_cil_lr_1(__cil_pp_line, __cil_pp_words, __cil_pp_label, __cil_pp_queryid,
                          __cil_pp_slackid, __cil_pp_costfactor, __cil_pp_numwords,
                          __cil_pp_max_words_doc, __cil_pp_comment, __cil_pp_pos,
                          __cil_pp_wnum, __cil_pp_weight);
#line 784
  line_ssa_1 = *__cil_fp_line;
#line 785
  words_ssa_1 = *__cil_fp_words;
#line 786
  label_ssa_1 = *__cil_fp_label;
#line 787
  queryid_ssa_1 = *__cil_fp_queryid;
#line 788
  slackid_ssa_1 = *__cil_fp_slackid;
#line 789
  costfactor_ssa_1 = *__cil_fp_costfactor;
#line 790
  numwords_ssa_1 = *__cil_fp_numwords;
#line 791
  max_words_doc_ssa_1 = *__cil_fp_max_words_doc;
#line 792
  comment_ssa_1 = *__cil_fp_comment;
#line 793
  pos_ssa_2 = *__cil_fp_pos;
#line 794
  wnum_ssa_1 = *__cil_fp_wnum;
#line 795
  weight_ssa_1 = *__cil_fp_weight;
#line 790
  __cil_tmp112 = *comment_ssa_1;
#line 790
  __cil_tmp108 = ! __cil_tmp112;
#line 790
  if (__cil_tmp108 != 0) {
#line 790
    *comment_ssa_1 = line_ssa_1 + pos_ssa_2;
  } else {

  }
#line 793
  wpos_ssa_1 = 0L;
#line 796
  __cil_tmp113 = featurepair;
#line 796
  tmp_ssa_1 = sscanf((char const   * __restrict  )((char const   *)line_ssa_1), (char const   * __restrict  )"%s",
                     __cil_tmp113);
#line 796
  __cil_tmp109 = tmp_ssa_1 == -1;
#line 796
  if (__cil_tmp109 != 0) {
#line 796
    return (0);
  } else {
#line 797
    pos_ssa_3 = 0L;
#line 800
    *__cil_fp_line = line_ssa_1;
#line 801
    *__cil_fp_words = words_ssa_1;
#line 802
    *__cil_fp_label = label_ssa_1;
#line 803
    *__cil_fp_queryid = queryid_ssa_1;
#line 804
    *__cil_fp_slackid = slackid_ssa_1;
#line 805
    *__cil_fp_costfactor = costfactor_ssa_1;
#line 806
    *__cil_fp_numwords = numwords_ssa_1;
#line 807
    *__cil_fp_max_words_doc = max_words_doc_ssa_1;
#line 808
    *__cil_fp_wpos = wpos_ssa_1;
#line 809
    *__cil_fp_pos = pos_ssa_3;
#line 810
    *__cil_fp_wnum = wnum_ssa_1;
#line 811
    *__cil_fp_weight = weight_ssa_1;
#line 798
    parse_document_cil_lr_2(__cil_pp_line, __cil_pp_words, __cil_pp_label, __cil_pp_queryid,
                            __cil_pp_slackid, __cil_pp_costfactor, __cil_pp_numwords,
                            __cil_pp_max_words_doc, __cil_pp_wpos, __cil_pp_pos, __cil_pp_wnum,
                            __cil_pp_weight, (char *)(featurepair));
#line 802
    line_ssa_2 = *__cil_fp_line;
#line 803
    words_ssa_2 = *__cil_fp_words;
#line 804
    label_ssa_2 = *__cil_fp_label;
#line 805
    queryid_ssa_2 = *__cil_fp_queryid;
#line 806
    slackid_ssa_2 = *__cil_fp_slackid;
#line 807
    costfactor_ssa_2 = *__cil_fp_costfactor;
#line 808
    numwords_ssa_2 = *__cil_fp_numwords;
#line 809
    max_words_doc_ssa_2 = *__cil_fp_max_words_doc;
#line 810
    wpos_ssa_2 = *__cil_fp_wpos;
#line 811
    pos_ssa_4 = *__cil_fp_pos;
#line 812
    wnum_ssa_2 = *__cil_fp_wnum;
#line 813
    weight_ssa_2 = *__cil_fp_weight;
#line 799
    __cil_tmp114 = featurepair + pos_ssa_4;
#line 799
    __cil_tmp115 = *__cil_tmp114;
#line 799
    __cil_tmp116 = (int )__cil_tmp115;
#line 799
    __cil_tmp110 = __cil_tmp116 == 58;
#line 799
    if (__cil_tmp110 != 0) {
#line 800
      perror("Line must start with label or 0!!!\n");
#line 801
      printf((char const   * __restrict  )"LINE: %s\n", line_ssa_2);
#line 802
      exit(1);
    } else {

    }
#line 805
    tmp___0_ssa_1 = sscanf((char const   * __restrict  )((char const   *)line_ssa_2),
                           (char const   * __restrict  )"%lf", label_ssa_2);
#line 805
    __cil_tmp111 = tmp___0_ssa_1 == -1;
#line 805
    if (__cil_tmp111 != 0) {
#line 805
      return (0);
    } else {
#line 806
      pos_ssa_5 = 0L;
#line 809
      *__cil_fp_line = line_ssa_2;
#line 810
      *__cil_fp_words = words_ssa_2;
#line 811
      *__cil_fp_queryid = queryid_ssa_2;
#line 812
      *__cil_fp_slackid = slackid_ssa_2;
#line 813
      *__cil_fp_costfactor = costfactor_ssa_2;
#line 814
      *__cil_fp_numwords = numwords_ssa_2;
#line 815
      *__cil_fp_max_words_doc = max_words_doc_ssa_2;
#line 816
      *__cil_fp_wpos = wpos_ssa_2;
#line 817
      *__cil_fp_pos = pos_ssa_5;
#line 818
      *__cil_fp_wnum = wnum_ssa_2;
#line 819
      *__cil_fp_weight = weight_ssa_2;
#line 807
      parse_document_cil_lr_3(__cil_pp_line, __cil_pp_words, __cil_pp_queryid, __cil_pp_slackid,
                              __cil_pp_costfactor, __cil_pp_numwords, __cil_pp_max_words_doc,
                              __cil_pp_wpos, __cil_pp_pos, __cil_pp_wnum, __cil_pp_weight);
#line 810
      line_ssa_3 = *__cil_fp_line;
#line 811
      words_ssa_3 = *__cil_fp_words;
#line 812
      queryid_ssa_3 = *__cil_fp_queryid;
#line 813
      slackid_ssa_3 = *__cil_fp_slackid;
#line 814
      costfactor_ssa_3 = *__cil_fp_costfactor;
#line 815
      numwords_ssa_3 = *__cil_fp_numwords;
#line 816
      max_words_doc_ssa_3 = *__cil_fp_max_words_doc;
#line 817
      wpos_ssa_3 = *__cil_fp_wpos;
#line 818
      pos_ssa_6 = *__cil_fp_pos;
#line 819
      wnum_ssa_3 = *__cil_fp_wnum;
#line 820
      weight_ssa_3 = *__cil_fp_weight;
#line 823
      *__cil_fp_line = line_ssa_3;
#line 824
      *__cil_fp_words = words_ssa_3;
#line 825
      *__cil_fp_queryid = queryid_ssa_3;
#line 826
      *__cil_fp_slackid = slackid_ssa_3;
#line 827
      *__cil_fp_costfactor = costfactor_ssa_3;
#line 828
      *__cil_fp_numwords = numwords_ssa_3;
#line 829
      *__cil_fp_max_words_doc = max_words_doc_ssa_3;
#line 830
      *__cil_fp_wpos = wpos_ssa_3;
#line 831
      *__cil_fp_pos = pos_ssa_6;
#line 832
      *__cil_fp_wnum = wnum_ssa_3;
#line 833
      *__cil_fp_weight = weight_ssa_3;
#line 808
      parse_document_cil_lr_4(__cil_pp_line, __cil_pp_words, __cil_pp_queryid, __cil_pp_slackid,
                              __cil_pp_costfactor, __cil_pp_numwords, __cil_pp_max_words_doc,
                              __cil_pp_wpos, __cil_pp_pos, __cil_pp_wnum, __cil_pp_weight);
#line 811
      line_ssa_4 = *__cil_fp_line;
#line 812
      words_ssa_4 = *__cil_fp_words;
#line 813
      queryid_ssa_4 = *__cil_fp_queryid;
#line 814
      slackid_ssa_4 = *__cil_fp_slackid;
#line 815
      costfactor_ssa_4 = *__cil_fp_costfactor;
#line 816
      numwords_ssa_4 = *__cil_fp_numwords;
#line 817
      max_words_doc_ssa_4 = *__cil_fp_max_words_doc;
#line 818
      wpos_ssa_4 = *__cil_fp_wpos;
#line 819
      pos_ssa_7 = *__cil_fp_pos;
#line 820
      wnum_ssa_4 = *__cil_fp_wnum;
#line 821
      weight_ssa_4 = *__cil_fp_weight;
#line 824
      *__cil_fp_words = words_ssa_4;
#line 825
      *__cil_fp_numwords = numwords_ssa_4;
#line 826
      *__cil_fp_wpos = wpos_ssa_4;
#line 809
      parse_document_cil_lr_5(__cil_pp_words, __cil_pp_numwords, __cil_pp_wpos, line_ssa_4,
                              queryid_ssa_4, slackid_ssa_4, costfactor_ssa_4, max_words_doc_ssa_4,
                              pos_ssa_7, wnum_ssa_4, weight_ssa_4, (char *)(featurepair),
                              (char *)(junk));
#line 812
      words_ssa_5 = *__cil_fp_words;
#line 813
      numwords_ssa_5 = *__cil_fp_numwords;
#line 814
      wpos_ssa_5 = *__cil_fp_wpos;
#line 855
      __cil_tmp117 = words_ssa_5 + wpos_ssa_5;
#line 855
      __cil_tmp118 = (long *)__cil_tmp117;
#line 855
      *__cil_tmp118 = 0L;
#line 856
      *numwords_ssa_5 = wpos_ssa_5 + 1L;
#line 857
      return (1);
    }
  }
}
}
#line 860 "svm_common.c"
double *read_alphas(char *alphafile , long totdoc ) 
{ 
  FILE *fl ;
  double *alpha ;
  long dnum ;
  struct _IO_FILE **__cil_pp_stdout ;
  long *__cil_pp_verbosity ;
  long *__cil_pp_totdoc ;
  FILE **__cil_pp_fl ;
  double **__cil_pp_alpha ;
  long *__cil_pp_dnum ;
  long *__cil_gp_verbosity ;
  struct _IO_FILE **__cil_gp_stdout ;
  long *__cil_fp_totdoc ;
  FILE **__cil_fp_fl ;
  double **__cil_fp_alpha ;
  long *__cil_fp_dnum ;
  FILE *fl_ssa_1 ;
  void *tmp_ssa_1 ;
  double *alpha_ssa_1 ;
  long dnum_ssa_1 ;
  long totdoc_ssa_1 ;
  FILE *fl_ssa_2 ;
  double *alpha_ssa_2 ;
  long dnum_ssa_2 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  long __cil_tmp34 ;
  struct _IO_FILE *__cil_tmp35 ;
  long __cil_tmp36 ;
  struct _IO_FILE *__cil_tmp37 ;

  {
#line 865
  __cil_pp_stdout = & stdout;
#line 866
  __cil_pp_verbosity = & verbosity;
#line 867
  __cil_pp_totdoc = & totdoc;
#line 868
  __cil_pp_fl = & fl;
#line 869
  __cil_pp_alpha = & alpha;
#line 870
  __cil_pp_dnum = & dnum;
#line 871
  __cil_gp_verbosity = & verbosity;
#line 872
  __cil_gp_stdout = & stdout;
#line 873
  __cil_fp_totdoc = & totdoc;
#line 874
  __cil_fp_fl = & fl;
#line 875
  __cil_fp_alpha = & alpha;
#line 876
  __cil_fp_dnum = & dnum;
#line 868
  fl_ssa_1 = fopen((char const   * __restrict  )((char const   *)alphafile), (char const   * __restrict  )"r");
#line 868
  __cil_tmp29 = (unsigned long )fl_ssa_1 == (unsigned long )((void *)0);
#line 868
  if (__cil_tmp29 != 0) {
#line 869
    perror((char const   *)alphafile);
#line 869
    exit(1);
  } else {

  }
#line 871
  __cil_tmp33 = sizeof(double ) * (unsigned long )totdoc;
#line 871
  tmp_ssa_1 = my_malloc(__cil_tmp33);
#line 871
  alpha_ssa_1 = (double *)tmp_ssa_1;
#line 872
  __cil_tmp34 = *__cil_gp_verbosity;
#line 872
  __cil_tmp30 = __cil_tmp34 >= 1L;
#line 872
  if (__cil_tmp30 != 0) {
#line 873
    printf((char const   * __restrict  )"Reading alphas...");
#line 873
    __cil_tmp35 = *__cil_gp_stdout;
#line 873
    fflush(__cil_tmp35);
  } else {

  }
#line 875
  dnum_ssa_1 = 0L;
#line 878
  *__cil_fp_totdoc = totdoc;
#line 879
  *__cil_fp_fl = fl_ssa_1;
#line 880
  *__cil_fp_alpha = alpha_ssa_1;
#line 881
  *__cil_fp_dnum = dnum_ssa_1;
#line 876
  read_alphas_cil_lr_1(__cil_pp_stdout, __cil_pp_verbosity, __cil_pp_totdoc, __cil_pp_fl,
                       __cil_pp_alpha, __cil_pp_dnum);
#line 878
  totdoc_ssa_1 = *__cil_fp_totdoc;
#line 879
  fl_ssa_2 = *__cil_fp_fl;
#line 880
  alpha_ssa_2 = *__cil_fp_alpha;
#line 881
  dnum_ssa_2 = *__cil_fp_dnum;
#line 879
  __cil_tmp31 = dnum_ssa_2 != totdoc_ssa_1;
#line 879
  if (__cil_tmp31 != 0) {
#line 880
    perror("\nNot enough values in alpha file!");
#line 880
    exit(1);
  } else {

  }
#line 881
  fclose(fl_ssa_2);
#line 883
  __cil_tmp36 = *__cil_gp_verbosity;
#line 883
  __cil_tmp32 = __cil_tmp36 >= 1L;
#line 883
  if (__cil_tmp32 != 0) {
#line 884
    printf((char const   * __restrict  )"done\n");
#line 884
    __cil_tmp37 = *__cil_gp_stdout;
#line 884
    fflush(__cil_tmp37);
  } else {

  }
#line 887
  return (alpha_ssa_2);
}
}
#line 890 "svm_common.c"
void nol_ll(char *file , long *nol , long *wol , long *ll ) 
{ 
  FILE *fl ;
  FILE **__cil_pp_fl ;
  FILE **__cil_fp_fl ;
  FILE *fl_ssa_1 ;
  long current_length_ssa_1 ;
  long current_wol_ssa_1 ;
  FILE *fl_ssa_2 ;
  int __cil_tmp17 ;

  {
#line 893
  __cil_pp_fl = & fl;
#line 894
  __cil_fp_fl = & fl;
#line 899
  fl_ssa_1 = fopen((char const   * __restrict  )((char const   *)file), (char const   * __restrict  )"r");
#line 899
  __cil_tmp17 = (unsigned long )fl_ssa_1 == (unsigned long )((void *)0);
#line 899
  if (__cil_tmp17 != 0) {
#line 900
    perror((char const   *)file);
#line 900
    exit(1);
  } else {

  }
#line 901
  current_length_ssa_1 = 0L;
#line 902
  current_wol_ssa_1 = 0L;
#line 903
  *ll = 0L;
#line 904
  *nol = 1L;
#line 905
  *wol = 0L;
#line 908
  *__cil_fp_fl = fl_ssa_1;
#line 906
  nol_ll_cil_lr_1(__cil_pp_fl, nol, wol, ll, current_length_ssa_1, current_wol_ssa_1);
#line 907
  fl_ssa_2 = *__cil_fp_fl;
#line 924
  fclose(fl_ssa_2);
#line 925
  return;
}
}
#line 927 "svm_common.c"
long minl(long a , long b ) 
{ 
  int __cil_tmp3 ;

  {

#line 929
  return babel_wrapper_minl(a, b);
#line 929
  __cil_tmp3 = a < b;
#line 929
  if (__cil_tmp3 != 0) {
#line 930
    return (a);
  } else {
#line 932
    return (b);
  }
}
}
#line 935 "svm_common.c"
long maxl(long a , long b ) 
{ 
  int __cil_tmp3 ;

  {

#line 937
  return babel_wrapper_maxl(a, b);
#line 937
  __cil_tmp3 = a > b;
#line 937
  if (__cil_tmp3 != 0) {
#line 938
    return (a);
  } else {
#line 940
    return (b);
  }
}
}
#line 943 "svm_common.c"
long get_runtime(void) 
{ 
  clock_t start_ssa_1 ;
  long __cil_tmp3 ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;

  {
#line 946
  start_ssa_1 = clock();
#line 947
  __cil_tmp4 = (double )start_ssa_1 * 100.0;
#line 947
  __cil_tmp5 = __cil_tmp4 / (double )1000000L;
#line 947
  __cil_tmp3 = (long )__cil_tmp5;
#line 947
  return (__cil_tmp3);
}
}
#line 960 "svm_common.c"
int space_or_null(int c ) 
{ 
  unsigned short const   **tmp_ssa_1 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned short const   *__cil_tmp6 ;
  unsigned short const   *__cil_tmp7 ;
  unsigned short __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 961
  __cil_tmp4 = c == 0;
#line 961
  if (__cil_tmp4 != 0) {
#line 962
    return (1);
  } else {
#line 963
    tmp_ssa_1 = __ctype_b_loc();
#line 963
    __cil_tmp6 = *tmp_ssa_1;
#line 963
    __cil_tmp7 = __cil_tmp6 + (int )((unsigned char )c);
#line 963
    __cil_tmp8 = (unsigned short )*__cil_tmp7;
#line 963
    __cil_tmp9 = (int )((int const   )__cil_tmp8);
#line 963
    __cil_tmp10 = __cil_tmp9 & 8192;
#line 963
    __cil_tmp5 = __cil_tmp10;
#line 963
    return (__cil_tmp5);
  }
}
}
#line 966 "svm_common.c"
void *my_malloc(size_t size ) 
{ 
  size_t size_ssa_1 ;
  void *tmp_ssa_1 ;
  void *ptr_ssa_1 ;
  int __cil_tmp7 ;

  {
#line 969
  __cil_tmp7 = size <= 0UL;
#line 969
  if (__cil_tmp7 != 0) {
#line 969
    size_ssa_1 = (size_t )1;
  } else {
#line 972
    size_ssa_1 = size;
  }
#line 970
  tmp_ssa_1 = malloc(size_ssa_1);
#line 970
  ptr_ssa_1 = tmp_ssa_1;
#line 971
  if (ptr_ssa_1 == 0) {
#line 972
    perror("Out of memory!\n");
#line 973
    exit(1);
  } else {

  }
#line 975
  return (ptr_ssa_1);
}
}
#line 978 "svm_common.c"
void copyright_notice(void) 
{ 


  {
#line 980
  printf((char const   * __restrict  )"\nCopyright: Thorsten Joachims, thorsten@joachims.org\n\n");
#line 981
  printf((char const   * __restrict  )"This software is available for non-commercial use only. It must not\n");
#line 982
  printf((char const   * __restrict  )"be modified and distributed without prior permission of the author.\n");
#line 983
  printf((char const   * __restrict  )"The author is not responsible for implications from the use of this\n");
#line 984
  printf((char const   * __restrict  )"software.\n\n");
#line 985
  return;
}
}
#line 988 "svm_common.c"
void write_model_cil_lr_2_cil_lr_1_cil_lr_1(SVECTOR **__cil_ap_v , FILE **__cil_ap_modelfl ,
                                            long j ) 
{ 
  long j_ssa_1 ;
  long __cil_tmp5 ;
  SVECTOR *__cil_tmp6 ;
  WORD **__cil_tmp7 ;
  WORD *__cil_tmp8 ;
  WORD *__cil_tmp9 ;
  long *__cil_tmp10 ;
  FILE *__cil_tmp11 ;
  SVECTOR *__cil_tmp12 ;
  WORD **__cil_tmp13 ;
  WORD *__cil_tmp14 ;
  WORD *__cil_tmp15 ;
  long *__cil_tmp16 ;
  SVECTOR *__cil_tmp17 ;
  WORD **__cil_tmp18 ;
  WORD *__cil_tmp19 ;
  WORD *__cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  float *__cil_tmp23 ;
  float __cil_tmp24 ;
  long __cil_tmp25 ;

  {

#line 556
  return babel_wrapper_write_model_cil_lr_2_cil_lr_1_cil_lr_1(__cil_ap_v, __cil_ap_modelfl,
                                                              j);
#line 556
  __cil_tmp6 = *__cil_ap_v;
#line 556
  __cil_tmp7 = (WORD **)__cil_tmp6;
#line 556
  __cil_tmp8 = *__cil_tmp7;
#line 556
  __cil_tmp9 = __cil_tmp8 + j;
#line 556
  __cil_tmp10 = (long *)__cil_tmp9;
#line 556
  __cil_tmp5 = *__cil_tmp10;
#line 556
  if (__cil_tmp5 != 0) {
#line 557
    __cil_tmp11 = *__cil_ap_modelfl;
#line 557
    __cil_tmp12 = *__cil_ap_v;
#line 557
    __cil_tmp13 = (WORD **)__cil_tmp12;
#line 557
    __cil_tmp14 = *__cil_tmp13;
#line 557
    __cil_tmp15 = __cil_tmp14 + j;
#line 557
    __cil_tmp16 = (long *)__cil_tmp15;
#line 557
    __cil_tmp17 = *__cil_ap_v;
#line 557
    __cil_tmp18 = (WORD **)__cil_tmp17;
#line 557
    __cil_tmp19 = *__cil_tmp18;
#line 557
    __cil_tmp20 = __cil_tmp19 + j;
#line 557
    __cil_tmp21 = (unsigned char *)__cil_tmp20;
#line 557
    __cil_tmp22 = __cil_tmp21 + 8;
#line 557
    __cil_tmp23 = (float *)__cil_tmp22;
#line 557
    __cil_tmp24 = *__cil_tmp23;
#line 557
    __cil_tmp25 = *__cil_tmp16;
#line 557
    fprintf((FILE * __restrict  )__cil_tmp11, (char const   * __restrict  )"%ld:%.8g ",
            __cil_tmp25, (double )__cil_tmp24);
#line 556
    j_ssa_1 = j + 1L;
#line 559
    write_model_cil_lr_2_cil_lr_1_cil_lr_1(__cil_ap_v, __cil_ap_modelfl, j_ssa_1);
#line 561
    return;
  } else {
#line 563
    return;
  }
}
}
#line 568 "svm_common.c"
void parse_document_cil_lr_5_cil_lr_1(char **__cil_ap_line , long **__cil_ap_queryid ,
                                      long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                                      long *__cil_ap_max_words_doc , long *__cil_ap_pos ,
                                      long *__cil_ap_wnum , double *__cil_ap_weight ) 
{ 
  int tmp___3_ssa_1 ;
  char *__cil_tmp11 ;
  long __cil_tmp12 ;
  char *__cil_tmp13 ;
  char __cil_tmp14 ;
  long __cil_tmp15 ;

  {
#line 813
  __cil_tmp11 = *__cil_ap_line;
#line 813
  __cil_tmp12 = *__cil_ap_pos;
#line 813
  __cil_tmp13 = __cil_tmp11 + __cil_tmp12;
#line 813
  __cil_tmp14 = *__cil_tmp13;
#line 813
  tmp___3_ssa_1 = space_or_null((int )__cil_tmp14);
#line 813
  if (tmp___3_ssa_1 != 0) {
#line 813
    __cil_tmp15 = *__cil_ap_pos;
#line 813
    *__cil_ap_pos = __cil_tmp15 + 1L;
#line 816
    parse_document_cil_lr_5_cil_lr_1(__cil_ap_line, __cil_ap_queryid, __cil_ap_slackid,
                                     __cil_ap_costfactor, __cil_ap_max_words_doc,
                                     __cil_ap_pos, __cil_ap_wnum, __cil_ap_weight);
#line 820
    return;
  } else {
#line 822
    return;
  }
}
}
#line 826 "svm_common.c"
void parse_document_cil_lr_5_cil_lr_2(char **__cil_ap_line , long **__cil_ap_queryid ,
                                      long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                                      long *__cil_ap_max_words_doc , long *__cil_ap_pos ,
                                      long *__cil_ap_wnum , double *__cil_ap_weight ) 
{ 
  int tmp___4_ssa_1 ;
  char __cil_tmp11 ;
  char *__cil_tmp12 ;
  long __cil_tmp13 ;
  char *__cil_tmp14 ;
  char __cil_tmp15 ;
  char *__cil_tmp16 ;
  long __cil_tmp17 ;
  char *__cil_tmp18 ;
  long __cil_tmp19 ;

  {
#line 814
  __cil_tmp12 = *__cil_ap_line;
#line 814
  __cil_tmp13 = *__cil_ap_pos;
#line 814
  __cil_tmp14 = __cil_tmp12 + __cil_tmp13;
#line 814
  __cil_tmp15 = *__cil_tmp14;
#line 814
  tmp___4_ssa_1 = space_or_null((int )__cil_tmp15);
#line 814
  if (tmp___4_ssa_1 != 0) {
#line 815
    return;
  } else {
#line 814
    __cil_tmp16 = *__cil_ap_line;
#line 814
    __cil_tmp17 = *__cil_ap_pos;
#line 814
    __cil_tmp18 = __cil_tmp16 + __cil_tmp17;
#line 814
    __cil_tmp11 = *__cil_tmp18;
#line 814
    if (__cil_tmp11 != 0) {
#line 814
      __cil_tmp19 = *__cil_ap_pos;
#line 814
      *__cil_ap_pos = __cil_tmp19 + 1L;
#line 817
      parse_document_cil_lr_5_cil_lr_2(__cil_ap_line, __cil_ap_queryid, __cil_ap_slackid,
                                       __cil_ap_costfactor, __cil_ap_max_words_doc,
                                       __cil_ap_pos, __cil_ap_wnum, __cil_ap_weight);
#line 821
      return;
    } else {
#line 823
      return;
    }
  }
}
}
#line 829 "svm_common.c"
void write_model_cil_lr_2_cil_lr_1(MODEL **__cil_ap_model , long *__cil_ap_i , FILE **__cil_ap_modelfl ,
                                   SVECTOR *v ) 
{ 
  SVECTOR **__cil_pp_v ;
  SVECTOR **__cil_fp_v ;
  long j_ssa_1 ;
  SVECTOR *v_ssa_1 ;
  SVECTOR *v_ssa_2 ;
  FILE *__cil_tmp11 ;
  MODEL *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  double **__cil_tmp15 ;
  double *__cil_tmp16 ;
  long __cil_tmp17 ;
  double *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  double *__cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  double __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  char **__cil_tmp26 ;
  char *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  struct svector **__cil_tmp29 ;

  {
#line 832
  __cil_fp_v = & v;
#line 832
  __cil_pp_v = & v;
#line 832
  return babel_wrapper_write_model_cil_lr_2_cil_lr_1(__cil_pp_v, __cil_fp_v, __cil_ap_model,
                                                     __cil_ap_i, __cil_ap_modelfl,
                                                     v);
#line 832
  __cil_pp_v = & v;
#line 833
  __cil_fp_v = & v;
#line 554
  if (v != 0) {
#line 555
    __cil_tmp11 = *__cil_ap_modelfl;
#line 555
    __cil_tmp12 = *__cil_ap_model;
#line 555
    __cil_tmp13 = (unsigned char *)__cil_tmp12;
#line 555
    __cil_tmp14 = __cil_tmp13 + 32;
#line 555
    __cil_tmp15 = (double **)__cil_tmp14;
#line 555
    __cil_tmp16 = *__cil_tmp15;
#line 555
    __cil_tmp17 = *__cil_ap_i;
#line 555
    __cil_tmp18 = __cil_tmp16 + __cil_tmp17;
#line 555
    __cil_tmp19 = (unsigned char *)v + 40;
#line 555
    __cil_tmp20 = (double *)__cil_tmp19;
#line 555
    __cil_tmp21 = *__cil_tmp18;
#line 555
    __cil_tmp22 = *__cil_tmp20;
#line 555
    __cil_tmp23 = __cil_tmp21 * __cil_tmp22;
#line 555
    fprintf((FILE * __restrict  )__cil_tmp11, (char const   * __restrict  )"%.32g ",
            __cil_tmp23);
#line 556
    j_ssa_1 = 0L;
#line 559
    *__cil_fp_v = v;
#line 556
    write_model_cil_lr_2_cil_lr_1_cil_lr_1(__cil_pp_v, __cil_ap_modelfl, j_ssa_1);
#line 557
    v_ssa_1 = *__cil_fp_v;
#line 561
    __cil_tmp24 = *__cil_ap_modelfl;
#line 561
    __cil_tmp25 = (unsigned char *)v_ssa_1 + 16;
#line 561
    __cil_tmp26 = (char **)__cil_tmp25;
#line 561
    __cil_tmp27 = *__cil_tmp26;
#line 561
    fprintf((FILE * __restrict  )__cil_tmp24, (char const   * __restrict  )"#%s\n",
            __cil_tmp27);
#line 554
    __cil_tmp28 = (unsigned char *)v_ssa_1 + 32;
#line 554
    __cil_tmp29 = (struct svector **)__cil_tmp28;
#line 554
    v_ssa_2 = *__cil_tmp29;
#line 557
    write_model_cil_lr_2_cil_lr_1(__cil_ap_model, __cil_ap_i, __cil_ap_modelfl, v_ssa_2);
#line 559
    return;
  } else {
#line 561
    return;
  }
}
}
#line 565 "svm_common.c"
void write_model_cil_lr_1_cil_lr_1(long *__cil_ap_i , long *__cil_ap_sv_num , SVECTOR *v ) 
{ 
  SVECTOR *v_ssa_1 ;
  long __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  struct svector **__cil_tmp7 ;

  {

#line 547
  return babel_wrapper_write_model_cil_lr_1_cil_lr_1(__cil_ap_i, __cil_ap_sv_num,
                                                     v);
#line 547
  if (v != 0) {
#line 548
    __cil_tmp5 = *__cil_ap_sv_num;
#line 548
    *__cil_ap_sv_num = __cil_tmp5 + 1L;
#line 547
    __cil_tmp6 = (unsigned char *)v + 32;
#line 547
    __cil_tmp7 = (struct svector **)__cil_tmp6;
#line 547
    v_ssa_1 = *__cil_tmp7;
#line 550
    write_model_cil_lr_1_cil_lr_1(__cil_ap_i, __cil_ap_sv_num, v_ssa_1);
#line 552
    return;
  } else {
#line 554
    return;
  }
}
}
#line 558 "svm_common.c"
void add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1(MODEL **__cil_ap_model ,
                                                         long *__cil_ap_i , SVECTOR *f ) 
{ 
  SVECTOR *f_ssa_1 ;
  MODEL *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  unsigned char *__cil_tmp7 ;
  double **__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  double *__cil_tmp10 ;
  MODEL *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  double **__cil_tmp14 ;
  double *__cil_tmp15 ;
  long __cil_tmp16 ;
  double *__cil_tmp17 ;
  double __cil_tmp18 ;
  double __cil_tmp19 ;
  double *__cil_tmp20 ;
  double __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  struct svector **__cil_tmp23 ;

  {

#line 489
  return babel_wrapper_add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1(__cil_ap_model,
                                                                           __cil_ap_i,
                                                                           f);
#line 489
  if (f != 0) {
#line 490
    __cil_tmp5 = *__cil_ap_model;
#line 490
    __cil_tmp6 = (unsigned char *)__cil_tmp5;
#line 490
    __cil_tmp7 = __cil_tmp6 + 208;
#line 490
    __cil_tmp8 = (double **)__cil_tmp7;
#line 490
    __cil_tmp9 = (unsigned char *)f + 40;
#line 490
    __cil_tmp10 = (double *)__cil_tmp9;
#line 490
    __cil_tmp11 = *__cil_ap_model;
#line 490
    __cil_tmp12 = (unsigned char *)__cil_tmp11;
#line 490
    __cil_tmp13 = __cil_tmp12 + 32;
#line 490
    __cil_tmp14 = (double **)__cil_tmp13;
#line 490
    __cil_tmp15 = *__cil_tmp14;
#line 490
    __cil_tmp16 = *__cil_ap_i;
#line 490
    __cil_tmp17 = __cil_tmp15 + __cil_tmp16;
#line 490
    __cil_tmp18 = *__cil_tmp10;
#line 490
    __cil_tmp19 = *__cil_tmp17;
#line 490
    __cil_tmp20 = *__cil_tmp8;
#line 490
    __cil_tmp21 = __cil_tmp18 * __cil_tmp19;
#line 490
    add_vector_ns(__cil_tmp20, f, __cil_tmp21);
#line 489
    __cil_tmp22 = (unsigned char *)f + 32;
#line 489
    __cil_tmp23 = (struct svector **)__cil_tmp22;
#line 489
    f_ssa_1 = *__cil_tmp23;
#line 492
    add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1(__cil_ap_model, __cil_ap_i,
                                                        f_ssa_1);
#line 495
    return;
  } else {
#line 497
    return;
  }
}
}
#line 501 "svm_common.c"
void model_length_s_cil_lr_1_cil_lr_1(MODEL **__cil_ap_model , KERNEL_PARM **__cil_ap_kernel_parm ,
                                      long *__cil_ap_i , double *__cil_ap_sum , double alphai ,
                                      DOC *supveci , long j ) 
{ 
  double tmp_ssa_1 ;
  long j_ssa_1 ;
  int __cil_tmp11 ;
  MODEL *__cil_tmp12 ;
  long *__cil_tmp13 ;
  long __cil_tmp14 ;
  MODEL *__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  DOC ***__cil_tmp18 ;
  DOC **__cil_tmp19 ;
  DOC **__cil_tmp20 ;
  KERNEL_PARM *__cil_tmp21 ;
  DOC *__cil_tmp22 ;
  MODEL *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  double **__cil_tmp26 ;
  double *__cil_tmp27 ;
  double *__cil_tmp28 ;
  double __cil_tmp29 ;
  double __cil_tmp30 ;
  double __cil_tmp31 ;
  double __cil_tmp32 ;

  {

#line 444
  return babel_wrapper_model_length_s_cil_lr_1_cil_lr_1(__cil_ap_model, __cil_ap_kernel_parm,
                                                        __cil_ap_i, __cil_ap_sum,
                                                        alphai, supveci, j);
#line 444
  __cil_tmp12 = *__cil_ap_model;
#line 444
  __cil_tmp13 = (long *)__cil_tmp12;
#line 444
  __cil_tmp14 = *__cil_tmp13;
#line 444
  __cil_tmp11 = j < __cil_tmp14;
#line 444
  if (__cil_tmp11 != 0) {
#line 445
    __cil_tmp15 = *__cil_ap_model;
#line 445
    __cil_tmp16 = (unsigned char *)__cil_tmp15;
#line 445
    __cil_tmp17 = __cil_tmp16 + 24;
#line 445
    __cil_tmp18 = (DOC ***)__cil_tmp17;
#line 445
    __cil_tmp19 = *__cil_tmp18;
#line 445
    __cil_tmp20 = __cil_tmp19 + j;
#line 445
    __cil_tmp21 = *__cil_ap_kernel_parm;
#line 445
    __cil_tmp22 = *__cil_tmp20;
#line 445
    tmp_ssa_1 = kernel(__cil_tmp21, supveci, __cil_tmp22);
#line 445
    __cil_tmp23 = *__cil_ap_model;
#line 445
    __cil_tmp24 = (unsigned char *)__cil_tmp23;
#line 445
    __cil_tmp25 = __cil_tmp24 + 32;
#line 445
    __cil_tmp26 = (double **)__cil_tmp25;
#line 445
    __cil_tmp27 = *__cil_tmp26;
#line 445
    __cil_tmp28 = __cil_tmp27 + j;
#line 445
    __cil_tmp29 = *__cil_tmp28;
#line 445
    __cil_tmp30 = alphai * __cil_tmp29;
#line 445
    __cil_tmp31 = *__cil_ap_sum;
#line 445
    __cil_tmp32 = __cil_tmp30 * tmp_ssa_1;
#line 445
    *__cil_ap_sum = __cil_tmp31 + __cil_tmp32;
#line 444
    j_ssa_1 = j + 1L;
#line 447
    model_length_s_cil_lr_1_cil_lr_1(__cil_ap_model, __cil_ap_kernel_parm, __cil_ap_i,
                                     __cil_ap_sum, alphai, supveci, j_ssa_1);
#line 450
    return;
  } else {
#line 452
    return;
  }
}
}
#line 457 "svm_common.c"
void kernel_cil_lr_1_cil_lr_1(KERNEL_PARM **__cil_ap_kernel_parm , DOC **__cil_ap_b ,
                              SVECTOR **__cil_ap_fa , double *__cil_ap_sum , SVECTOR *fb ) 
{ 
  double tmp_ssa_1 ;
  SVECTOR *fb_ssa_1 ;
  int __cil_tmp9 ;
  SVECTOR *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  long *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  long *__cil_tmp15 ;
  long __cil_tmp16 ;
  long __cil_tmp17 ;
  KERNEL_PARM *__cil_tmp18 ;
  SVECTOR *__cil_tmp19 ;
  SVECTOR *__cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  double *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  double *__cil_tmp25 ;
  double __cil_tmp26 ;
  double __cil_tmp27 ;
  double __cil_tmp28 ;
  double __cil_tmp29 ;
  double __cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  struct svector **__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  struct svector **__cil_tmp34 ;

  {
#line 71
  if (fb != 0) {
#line 72
    __cil_tmp10 = *__cil_ap_fa;
#line 72
    __cil_tmp11 = (unsigned char *)__cil_tmp10;
#line 72
    __cil_tmp12 = __cil_tmp11 + 24;
#line 72
    __cil_tmp13 = (long *)__cil_tmp12;
#line 72
    __cil_tmp14 = (unsigned char *)fb + 24;
#line 72
    __cil_tmp15 = (long *)__cil_tmp14;
#line 72
    __cil_tmp16 = *__cil_tmp13;
#line 72
    __cil_tmp17 = *__cil_tmp15;
#line 72
    __cil_tmp9 = __cil_tmp16 == __cil_tmp17;
#line 72
    if (__cil_tmp9 != 0) {
#line 73
      __cil_tmp18 = *__cil_ap_kernel_parm;
#line 73
      __cil_tmp19 = *__cil_ap_fa;
#line 73
      tmp_ssa_1 = single_kernel(__cil_tmp18, __cil_tmp19, fb);
#line 73
      __cil_tmp20 = *__cil_ap_fa;
#line 73
      __cil_tmp21 = (unsigned char *)__cil_tmp20;
#line 73
      __cil_tmp22 = __cil_tmp21 + 40;
#line 73
      __cil_tmp23 = (double *)__cil_tmp22;
#line 73
      __cil_tmp24 = (unsigned char *)fb + 40;
#line 73
      __cil_tmp25 = (double *)__cil_tmp24;
#line 73
      __cil_tmp26 = *__cil_tmp23;
#line 73
      __cil_tmp27 = *__cil_tmp25;
#line 73
      __cil_tmp28 = __cil_tmp26 * __cil_tmp27;
#line 73
      __cil_tmp29 = *__cil_ap_sum;
#line 73
      __cil_tmp30 = __cil_tmp28 * tmp_ssa_1;
#line 73
      *__cil_ap_sum = __cil_tmp29 + __cil_tmp30;
    } else {

    }
#line 71
    __cil_tmp31 = (unsigned char *)fb + 32;
#line 71
    __cil_tmp32 = (struct svector **)__cil_tmp31;
#line 71
    fb_ssa_1 = *__cil_tmp32;
#line 74
    kernel_cil_lr_1_cil_lr_1(__cil_ap_kernel_parm, __cil_ap_b, __cil_ap_fa, __cil_ap_sum,
                             fb_ssa_1);
#line 77
    return;
  } else {
#line 79
    return;
  }
#line 71
  __cil_tmp33 = (unsigned char *)fb + 32;
#line 71
  __cil_tmp34 = (struct svector **)__cil_tmp33;
#line 71
  fb_ssa_1 = *__cil_tmp34;
#line 74
  kernel_cil_lr_1_cil_lr_1(__cil_ap_kernel_parm, __cil_ap_b, __cil_ap_fa, __cil_ap_sum,
                           fb_ssa_1);
#line 77
  return;
}
}
#line 80 "svm_common.c"
void nol_ll_cil_lr_1(FILE **__cil_ap_fl , long *nol , long *wol , long *ll , long current_length ,
                     long current_wol ) 
{ 
  char c ;
  int ic_ssa_1 ;
  char c_ssa_1 ;
  long current_length_ssa_1 ;
  int tmp_ssa_1 ;
  long current_wol_ssa_1 ;
  long current_length_ssa_2 ;
  long current_wol_ssa_2 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  long __cil_tmp25 ;
  long __cil_tmp26 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  long __cil_tmp29 ;
  long __cil_tmp30 ;

  {
#line 906
  __cil_tmp24 = *__cil_ap_fl;
#line 906
  ic_ssa_1 = _IO_getc(__cil_tmp24);
#line 906
  __cil_tmp17 = ic_ssa_1 != -1;
#line 906
  if (__cil_tmp17 != 0) {
#line 907
    c_ssa_1 = (char )ic_ssa_1;
#line 908
    current_length_ssa_1 = current_length + 1L;
#line 909
    tmp_ssa_1 = space_or_null((int )c_ssa_1);
#line 909
    if (tmp_ssa_1 != 0) {
#line 910
      current_wol_ssa_1 = current_wol + 1L;
    } else {
#line 913
      current_wol_ssa_1 = current_wol;
    }
#line 912
    __cil_tmp18 = (int )c_ssa_1 == 10;
#line 912
    if (__cil_tmp18 != 0) {
#line 913
      __cil_tmp25 = *nol;
#line 913
      *nol = __cil_tmp25 + 1L;
#line 914
      __cil_tmp26 = *ll;
#line 914
      __cil_tmp19 = current_length_ssa_1 > __cil_tmp26;
#line 914
      if (__cil_tmp19 != 0) {
#line 915
        *ll = current_length_ssa_1;
      } else {

      }
#line 917
      __cil_tmp27 = *wol;
#line 917
      __cil_tmp20 = current_wol_ssa_1 > __cil_tmp27;
#line 917
      if (__cil_tmp20 != 0) {
#line 918
        *wol = current_wol_ssa_1;
      } else {

      }
#line 920
      current_length_ssa_2 = 0L;
#line 921
      current_wol_ssa_2 = 0L;
    } else {
#line 924
      current_length_ssa_2 = current_length_ssa_1;
#line 925
      current_wol_ssa_2 = current_wol_ssa_1;
    }
#line 929
    nol_ll_cil_lr_1(__cil_ap_fl, nol, wol, ll, current_length_ssa_2, current_wol_ssa_2);
#line 931
    return;
  } else {
#line 933
    return;
  }
#line 912
  __cil_tmp21 = (int )c == 10;
#line 912
  if (__cil_tmp21 != 0) {
#line 913
    __cil_tmp28 = *nol;
#line 913
    *nol = __cil_tmp28 + 1L;
#line 914
    __cil_tmp29 = *ll;
#line 914
    __cil_tmp22 = current_length > __cil_tmp29;
#line 914
    if (__cil_tmp22 != 0) {
#line 915
      *ll = current_length;
    } else {

    }
#line 917
    __cil_tmp30 = *wol;
#line 917
    __cil_tmp23 = current_wol > __cil_tmp30;
#line 917
    if (__cil_tmp23 != 0) {
#line 918
      *wol = current_wol;
    } else {

    }
#line 920
    current_length_ssa_1 = 0L;
#line 921
    current_wol_ssa_1 = 0L;
  } else {
#line 924
    current_length_ssa_1 = current_length;
#line 925
    current_wol_ssa_1 = current_wol;
  }
#line 929
  nol_ll_cil_lr_1(__cil_ap_fl, nol, wol, ll, current_length_ssa_1, current_wol_ssa_1);
#line 931
  return;
}
}
#line 934 "svm_common.c"
void read_alphas_cil_lr_1(struct _IO_FILE **__cil_ap_stdout , long *__cil_ap_verbosity ,
                          long *__cil_ap_totdoc , FILE **__cil_ap_fl , double **__cil_ap_alpha ,
                          long *__cil_ap_dnum ) 
{ 
  int tmp___0_ssa_1 ;
  int tmp___1_ssa_1 ;
  int __cil_tmp11 ;
  FILE *__cil_tmp12 ;
  FILE *__cil_tmp13 ;
  double *__cil_tmp14 ;
  long __cil_tmp15 ;
  double *__cil_tmp16 ;
  long __cil_tmp17 ;
  long __cil_tmp18 ;
  long __cil_tmp19 ;

  {
#line 876
  __cil_tmp12 = *__cil_ap_fl;
#line 876
  tmp___0_ssa_1 = feof(__cil_tmp12);
#line 876
  if (tmp___0_ssa_1 != 0) {
#line 877
    return;
  } else {
#line 876
    __cil_tmp13 = *__cil_ap_fl;
#line 876
    __cil_tmp14 = *__cil_ap_alpha;
#line 876
    __cil_tmp15 = *__cil_ap_dnum;
#line 876
    __cil_tmp16 = __cil_tmp14 + __cil_tmp15;
#line 876
    tmp___1_ssa_1 = fscanf((FILE * __restrict  )__cil_tmp13, (char const   * __restrict  )"%lf\n",
                           __cil_tmp16);
#line 876
    if (tmp___1_ssa_1 != 0) {
#line 876
      __cil_tmp17 = *__cil_ap_dnum;
#line 876
      __cil_tmp18 = *__cil_ap_totdoc;
#line 876
      __cil_tmp11 = __cil_tmp17 < __cil_tmp18;
#line 876
      if (__cil_tmp11 != 0) {
#line 877
        __cil_tmp19 = *__cil_ap_dnum;
#line 877
        *__cil_ap_dnum = __cil_tmp19 + 1L;
#line 880
        read_alphas_cil_lr_1(__cil_ap_stdout, __cil_ap_verbosity, __cil_ap_totdoc,
                             __cil_ap_fl, __cil_ap_alpha, __cil_ap_dnum);
#line 883
        return;
      } else {
#line 885
        return;
      }
    } else {
#line 889
      return;
    }
  }
}
}
#line 894 "svm_common.c"
void parse_document_cil_lr_1(char **__cil_ap_line , WORD **__cil_ap_words , double **__cil_ap_label ,
                             long **__cil_ap_queryid , long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             char ***__cil_ap_comment , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight ) 
{ 
  char __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  long __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  long __cil_tmp22 ;
  char *__cil_tmp23 ;
  char __cil_tmp24 ;
  int __cil_tmp25 ;
  char **__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  long __cil_tmp29 ;
  char *__cil_tmp30 ;
  long __cil_tmp31 ;
  char *__cil_tmp32 ;
  long __cil_tmp33 ;
  char **__cil_tmp34 ;
  char *__cil_tmp35 ;
  long __cil_tmp36 ;
  char *__cil_tmp37 ;
  char __cil_tmp38 ;
  int __cil_tmp39 ;
  char *__cil_tmp40 ;
  long __cil_tmp41 ;
  char *__cil_tmp42 ;
  long __cil_tmp43 ;
  char *__cil_tmp44 ;
  long __cil_tmp45 ;
  char *__cil_tmp46 ;
  char __cil_tmp47 ;
  int __cil_tmp48 ;
  char *__cil_tmp49 ;
  long __cil_tmp50 ;
  char *__cil_tmp51 ;
  long __cil_tmp52 ;

  {
#line 780
  __cil_tmp18 = *__cil_ap_line;
#line 780
  __cil_tmp19 = *__cil_ap_pos;
#line 780
  __cil_tmp20 = __cil_tmp18 + __cil_tmp19;
#line 780
  __cil_tmp13 = *__cil_tmp20;
#line 780
  if (__cil_tmp13 != 0) {
#line 781
    __cil_tmp21 = *__cil_ap_line;
#line 781
    __cil_tmp22 = *__cil_ap_pos;
#line 781
    __cil_tmp23 = __cil_tmp21 + __cil_tmp22;
#line 781
    __cil_tmp24 = *__cil_tmp23;
#line 781
    __cil_tmp25 = (int )__cil_tmp24;
#line 781
    __cil_tmp14 = __cil_tmp25 == 35;
#line 781
    if (__cil_tmp14 != 0) {
#line 781
      __cil_tmp26 = *__cil_ap_comment;
#line 781
      __cil_tmp27 = *__cil_tmp26;
#line 781
      __cil_tmp15 = ! __cil_tmp27;
#line 781
      if (__cil_tmp15 != 0) {
#line 782
        __cil_tmp28 = *__cil_ap_line;
#line 782
        __cil_tmp29 = *__cil_ap_pos;
#line 782
        __cil_tmp30 = __cil_tmp28 + __cil_tmp29;
#line 782
        *__cil_tmp30 = (char)0;
#line 783
        __cil_tmp31 = *__cil_ap_pos;
#line 783
        __cil_tmp32 = *__cil_ap_line;
#line 783
        __cil_tmp33 = __cil_tmp31 + 1L;
#line 783
        __cil_tmp34 = *__cil_ap_comment;
#line 783
        *__cil_tmp34 = __cil_tmp32 + __cil_tmp33;
      } else {

      }
    } else {

    }
#line 785
    __cil_tmp35 = *__cil_ap_line;
#line 785
    __cil_tmp36 = *__cil_ap_pos;
#line 785
    __cil_tmp37 = __cil_tmp35 + __cil_tmp36;
#line 785
    __cil_tmp38 = *__cil_tmp37;
#line 785
    __cil_tmp39 = (int )__cil_tmp38;
#line 785
    __cil_tmp16 = __cil_tmp39 == 10;
#line 785
    if (__cil_tmp16 != 0) {
#line 786
      __cil_tmp40 = *__cil_ap_line;
#line 786
      __cil_tmp41 = *__cil_ap_pos;
#line 786
      __cil_tmp42 = __cil_tmp40 + __cil_tmp41;
#line 786
      *__cil_tmp42 = (char)0;
    } else {

    }
#line 788
    __cil_tmp43 = *__cil_ap_pos;
#line 788
    *__cil_ap_pos = __cil_tmp43 + 1L;
#line 791
    parse_document_cil_lr_1(__cil_ap_line, __cil_ap_words, __cil_ap_label, __cil_ap_queryid,
                            __cil_ap_slackid, __cil_ap_costfactor, __cil_ap_numwords,
                            __cil_ap_max_words_doc, __cil_ap_comment, __cil_ap_pos,
                            __cil_ap_wnum, __cil_ap_weight);
#line 796
    return;
  } else {
#line 798
    return;
  }
#line 785
  __cil_tmp44 = *__cil_ap_line;
#line 785
  __cil_tmp45 = *__cil_ap_pos;
#line 785
  __cil_tmp46 = __cil_tmp44 + __cil_tmp45;
#line 785
  __cil_tmp47 = *__cil_tmp46;
#line 785
  __cil_tmp48 = (int )__cil_tmp47;
#line 785
  __cil_tmp17 = __cil_tmp48 == 10;
#line 785
  if (__cil_tmp17 != 0) {
#line 786
    __cil_tmp49 = *__cil_ap_line;
#line 786
    __cil_tmp50 = *__cil_ap_pos;
#line 786
    __cil_tmp51 = __cil_tmp49 + __cil_tmp50;
#line 786
    *__cil_tmp51 = (char)0;
  } else {

  }
#line 788
  __cil_tmp52 = *__cil_ap_pos;
#line 788
  *__cil_ap_pos = __cil_tmp52 + 1L;
#line 791
  parse_document_cil_lr_1(__cil_ap_line, __cil_ap_words, __cil_ap_label, __cil_ap_queryid,
                          __cil_ap_slackid, __cil_ap_costfactor, __cil_ap_numwords,
                          __cil_ap_max_words_doc, __cil_ap_comment, __cil_ap_pos,
                          __cil_ap_wnum, __cil_ap_weight);
#line 796
  return;
}
}
#line 799 "svm_common.c"
void parse_document_cil_lr_2(char **__cil_ap_line , WORD **__cil_ap_words , double **__cil_ap_label ,
                             long **__cil_ap_queryid , long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             long *__cil_ap_wpos , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight , char *featurepair ) 
{ 
  int __cil_tmp14 ;
  char __cil_tmp15 ;
  long __cil_tmp16 ;
  char *__cil_tmp17 ;
  char __cil_tmp18 ;
  int __cil_tmp19 ;
  long __cil_tmp20 ;
  char *__cil_tmp21 ;
  long __cil_tmp22 ;

  {
#line 798
  __cil_tmp16 = *__cil_ap_pos;
#line 798
  __cil_tmp17 = (char *)(featurepair + __cil_tmp16);
#line 798
  __cil_tmp18 = *__cil_tmp17;
#line 798
  __cil_tmp19 = (int )__cil_tmp18;
#line 798
  __cil_tmp14 = __cil_tmp19 != 58;
#line 798
  if (__cil_tmp14 != 0) {
#line 798
    __cil_tmp20 = *__cil_ap_pos;
#line 798
    __cil_tmp21 = (char *)(featurepair + __cil_tmp20);
#line 798
    __cil_tmp15 = *__cil_tmp21;
#line 798
    if (__cil_tmp15 != 0) {
#line 798
      __cil_tmp22 = *__cil_ap_pos;
#line 798
      *__cil_ap_pos = __cil_tmp22 + 1L;
#line 801
      parse_document_cil_lr_2(__cil_ap_line, __cil_ap_words, __cil_ap_label, __cil_ap_queryid,
                              __cil_ap_slackid, __cil_ap_costfactor, __cil_ap_numwords,
                              __cil_ap_max_words_doc, __cil_ap_wpos, __cil_ap_pos,
                              __cil_ap_wnum, __cil_ap_weight, featurepair);
#line 806
      return;
    } else {
#line 808
      return;
    }
  } else {
#line 812
    return;
  }
}
}
#line 817 "svm_common.c"
void parse_document_cil_lr_3(char **__cil_ap_line , WORD **__cil_ap_words , long **__cil_ap_queryid ,
                             long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             long *__cil_ap_wpos , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight ) 
{ 
  int tmp___1_ssa_1 ;
  char *__cil_tmp14 ;
  long __cil_tmp15 ;
  char *__cil_tmp16 ;
  char __cil_tmp17 ;
  long __cil_tmp18 ;

  {
#line 807
  __cil_tmp14 = *__cil_ap_line;
#line 807
  __cil_tmp15 = *__cil_ap_pos;
#line 807
  __cil_tmp16 = __cil_tmp14 + __cil_tmp15;
#line 807
  __cil_tmp17 = *__cil_tmp16;
#line 807
  tmp___1_ssa_1 = space_or_null((int )__cil_tmp17);
#line 807
  if (tmp___1_ssa_1 != 0) {
#line 807
    __cil_tmp18 = *__cil_ap_pos;
#line 807
    *__cil_ap_pos = __cil_tmp18 + 1L;
#line 810
    parse_document_cil_lr_3(__cil_ap_line, __cil_ap_words, __cil_ap_queryid, __cil_ap_slackid,
                            __cil_ap_costfactor, __cil_ap_numwords, __cil_ap_max_words_doc,
                            __cil_ap_wpos, __cil_ap_pos, __cil_ap_wnum, __cil_ap_weight);
#line 814
    return;
  } else {
#line 816
    return;
  }
}
}
#line 820 "svm_common.c"
void parse_document_cil_lr_4(char **__cil_ap_line , WORD **__cil_ap_words , long **__cil_ap_queryid ,
                             long **__cil_ap_slackid , double **__cil_ap_costfactor ,
                             long **__cil_ap_numwords , long *__cil_ap_max_words_doc ,
                             long *__cil_ap_wpos , long *__cil_ap_pos , long *__cil_ap_wnum ,
                             double *__cil_ap_weight ) 
{ 
  int tmp___2_ssa_1 ;
  char __cil_tmp14 ;
  char *__cil_tmp15 ;
  long __cil_tmp16 ;
  char *__cil_tmp17 ;
  char __cil_tmp18 ;
  char *__cil_tmp19 ;
  long __cil_tmp20 ;
  char *__cil_tmp21 ;
  long __cil_tmp22 ;

  {
#line 808
  __cil_tmp15 = *__cil_ap_line;
#line 808
  __cil_tmp16 = *__cil_ap_pos;
#line 808
  __cil_tmp17 = __cil_tmp15 + __cil_tmp16;
#line 808
  __cil_tmp18 = *__cil_tmp17;
#line 808
  tmp___2_ssa_1 = space_or_null((int )__cil_tmp18);
#line 808
  if (tmp___2_ssa_1 != 0) {
#line 809
    return;
  } else {
#line 808
    __cil_tmp19 = *__cil_ap_line;
#line 808
    __cil_tmp20 = *__cil_ap_pos;
#line 808
    __cil_tmp21 = __cil_tmp19 + __cil_tmp20;
#line 808
    __cil_tmp14 = *__cil_tmp21;
#line 808
    if (__cil_tmp14 != 0) {
#line 808
      __cil_tmp22 = *__cil_ap_pos;
#line 808
      *__cil_ap_pos = __cil_tmp22 + 1L;
#line 811
      parse_document_cil_lr_4(__cil_ap_line, __cil_ap_words, __cil_ap_queryid, __cil_ap_slackid,
                              __cil_ap_costfactor, __cil_ap_numwords, __cil_ap_max_words_doc,
                              __cil_ap_wpos, __cil_ap_pos, __cil_ap_wnum, __cil_ap_weight);
#line 815
      return;
    } else {
#line 817
      return;
    }
  }
}
}
#line 823 "svm_common.c"
void parse_document_cil_lr_5(WORD **__cil_ap_words , long **__cil_ap_numwords , long *__cil_ap_wpos ,
                             char *line , long *queryid , long *slackid , double *costfactor ,
                             long max_words_doc , long pos , long wnum , double weight ,
                             char *featurepair , char *junk ) 
{ 
  char **__cil_pp_line ;
  long **__cil_pp_queryid ;
  long **__cil_pp_slackid ;
  double **__cil_pp_costfactor ;
  long *__cil_pp_max_words_doc ;
  long *__cil_pp_pos ;
  long *__cil_pp_wnum ;
  double *__cil_pp_weight ;
  char **__cil_fp_line ;
  long **__cil_fp_queryid ;
  long **__cil_fp_slackid ;
  double **__cil_fp_costfactor ;
  long *__cil_fp_max_words_doc ;
  long *__cil_fp_pos ;
  long *__cil_fp_wnum ;
  double *__cil_fp_weight ;
  int numread_ssa_1 ;
  char *line_ssa_1 ;
  long *queryid_ssa_1 ;
  long *slackid_ssa_1 ;
  double *costfactor_ssa_1 ;
  long max_words_doc_ssa_1 ;
  long pos_ssa_1 ;
  long wnum_ssa_1 ;
  double weight_ssa_1 ;
  char *line_ssa_2 ;
  long *queryid_ssa_2 ;
  long *slackid_ssa_2 ;
  double *costfactor_ssa_2 ;
  long max_words_doc_ssa_2 ;
  long pos_ssa_2 ;
  long wnum_ssa_2 ;
  double weight_ssa_2 ;
  int tmp___8_ssa_1 ;
  long wnum_ssa_3 ;
  int tmp___7_ssa_1 ;
  long wnum_ssa_4 ;
  int tmp___6_ssa_1 ;
  double weight_ssa_3 ;
  int tmp___5_ssa_1 ;
  long wnum_ssa_5 ;
  double weight_ssa_4 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  long __cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  long __cil_tmp85 ;
  long __cil_tmp86 ;
  WORD *__cil_tmp87 ;
  long __cil_tmp88 ;
  WORD *__cil_tmp89 ;
  long *__cil_tmp90 ;
  long __cil_tmp91 ;
  WORD *__cil_tmp92 ;
  long __cil_tmp93 ;
  WORD *__cil_tmp94 ;
  long *__cil_tmp95 ;
  WORD *__cil_tmp96 ;
  long __cil_tmp97 ;
  WORD *__cil_tmp98 ;
  unsigned char *__cil_tmp99 ;
  unsigned char *__cil_tmp100 ;
  float *__cil_tmp101 ;
  long __cil_tmp102 ;
  char *__cil_tmp103 ;

  {
#line 828
  __cil_pp_line = & line;
#line 829
  __cil_pp_queryid = & queryid;
#line 830
  __cil_pp_slackid = & slackid;
#line 831
  __cil_pp_costfactor = & costfactor;
#line 832
  __cil_pp_max_words_doc = & max_words_doc;
#line 833
  __cil_pp_pos = & pos;
#line 834
  __cil_pp_wnum = & wnum;
#line 835
  __cil_pp_weight = & weight;
#line 836
  __cil_fp_line = & line;
#line 837
  __cil_fp_queryid = & queryid;
#line 838
  __cil_fp_slackid = & slackid;
#line 839
  __cil_fp_costfactor = & costfactor;
#line 840
  __cil_fp_max_words_doc = & max_words_doc;
#line 841
  __cil_fp_pos = & pos;
#line 842
  __cil_fp_wnum = & wnum;
#line 843
  __cil_fp_weight = & weight;
#line 809
  __cil_tmp74 = line + pos;
#line 809
  __cil_tmp75 = (char *)featurepair;
#line 809
  numread_ssa_1 = sscanf((char const   * __restrict  )((char const   *)__cil_tmp74),
                         (char const   * __restrict  )"%s", __cil_tmp75);
#line 809
  __cil_tmp63 = numread_ssa_1 != -1;
#line 809
  if (__cil_tmp63 != 0) {
#line 809
    __cil_tmp64 = numread_ssa_1 > 0;
#line 809
    if (__cil_tmp64 != 0) {
#line 809
      __cil_tmp76 = *__cil_ap_wpos;
#line 809
      __cil_tmp65 = __cil_tmp76 < max_words_doc;
#line 809
      if (__cil_tmp65 != 0) {
#line 811
        *__cil_fp_line = line;
#line 812
        *__cil_fp_queryid = queryid;
#line 813
        *__cil_fp_slackid = slackid;
#line 814
        *__cil_fp_costfactor = costfactor;
#line 815
        *__cil_fp_max_words_doc = max_words_doc;
#line 816
        *__cil_fp_pos = pos;
#line 817
        *__cil_fp_wnum = wnum;
#line 818
        *__cil_fp_weight = weight;
#line 813
        parse_document_cil_lr_5_cil_lr_1(__cil_pp_line, __cil_pp_queryid, __cil_pp_slackid,
                                         __cil_pp_costfactor, __cil_pp_max_words_doc,
                                         __cil_pp_pos, __cil_pp_wnum, __cil_pp_weight);
#line 816
        line_ssa_1 = *__cil_fp_line;
#line 817
        queryid_ssa_1 = *__cil_fp_queryid;
#line 818
        slackid_ssa_1 = *__cil_fp_slackid;
#line 819
        costfactor_ssa_1 = *__cil_fp_costfactor;
#line 820
        max_words_doc_ssa_1 = *__cil_fp_max_words_doc;
#line 821
        pos_ssa_1 = *__cil_fp_pos;
#line 822
        wnum_ssa_1 = *__cil_fp_wnum;
#line 823
        weight_ssa_1 = *__cil_fp_weight;
#line 826
        *__cil_fp_line = line_ssa_1;
#line 827
        *__cil_fp_queryid = queryid_ssa_1;
#line 828
        *__cil_fp_slackid = slackid_ssa_1;
#line 829
        *__cil_fp_costfactor = costfactor_ssa_1;
#line 830
        *__cil_fp_max_words_doc = max_words_doc_ssa_1;
#line 831
        *__cil_fp_pos = pos_ssa_1;
#line 832
        *__cil_fp_wnum = wnum_ssa_1;
#line 833
        *__cil_fp_weight = weight_ssa_1;
#line 814
        parse_document_cil_lr_5_cil_lr_2(__cil_pp_line, __cil_pp_queryid, __cil_pp_slackid,
                                         __cil_pp_costfactor, __cil_pp_max_words_doc,
                                         __cil_pp_pos, __cil_pp_wnum, __cil_pp_weight);
#line 817
        line_ssa_2 = *__cil_fp_line;
#line 818
        queryid_ssa_2 = *__cil_fp_queryid;
#line 819
        slackid_ssa_2 = *__cil_fp_slackid;
#line 820
        costfactor_ssa_2 = *__cil_fp_costfactor;
#line 821
        max_words_doc_ssa_2 = *__cil_fp_max_words_doc;
#line 822
        pos_ssa_2 = *__cil_fp_pos;
#line 823
        wnum_ssa_2 = *__cil_fp_wnum;
#line 824
        weight_ssa_2 = *__cil_fp_weight;
#line 827
        *__cil_fp_wnum = wnum_ssa_2;
#line 815
        __cil_tmp77 = (char *)featurepair;
#line 815
        __cil_tmp78 = (char *)junk;
#line 815
        tmp___8_ssa_1 = sscanf((char const   * __restrict  )((char const   *)__cil_tmp77),
                               (char const   * __restrict  )"qid:%ld%s", __cil_pp_wnum,
                               __cil_tmp78);
#line 817
        wnum_ssa_3 = *__cil_fp_wnum;
#line 815
        __cil_tmp66 = tmp___8_ssa_1 == 1;
#line 815
        if (__cil_tmp66 != 0) {
#line 817
          *queryid_ssa_2 = wnum_ssa_3;
#line 818
          weight_ssa_4 = weight_ssa_2;
#line 819
          wnum_ssa_5 = wnum_ssa_3;
        } else {
#line 823
          *__cil_fp_wnum = wnum_ssa_3;
#line 819
          __cil_tmp79 = (char *)featurepair;
#line 819
          __cil_tmp80 = (char *)junk;
#line 819
          tmp___7_ssa_1 = sscanf((char const   * __restrict  )((char const   *)__cil_tmp79),
                                 (char const   * __restrict  )"sid:%ld%s", __cil_pp_wnum,
                                 __cil_tmp80);
#line 821
          wnum_ssa_4 = *__cil_fp_wnum;
#line 819
          __cil_tmp67 = tmp___7_ssa_1 == 1;
#line 819
          if (__cil_tmp67 != 0) {
#line 821
            __cil_tmp68 = wnum_ssa_4 > 0L;
#line 821
            if (__cil_tmp68 != 0) {
#line 822
              *slackid_ssa_2 = wnum_ssa_4;
#line 823
              weight_ssa_4 = weight_ssa_2;
#line 824
              wnum_ssa_5 = wnum_ssa_4;
            } else {
#line 824
              perror("Slack-id must be greater or equal to 1!!!\n");
#line 825
              printf((char const   * __restrict  )"LINE: %s\n", line_ssa_2);
#line 826
              exit(1);
            }
          } else {
#line 832
            *__cil_fp_weight = weight_ssa_2;
#line 829
            __cil_tmp81 = (char *)featurepair;
#line 829
            __cil_tmp82 = (char *)junk;
#line 829
            tmp___6_ssa_1 = sscanf((char const   * __restrict  )((char const   *)__cil_tmp81),
                                   (char const   * __restrict  )"cost:%lf%s", __cil_pp_weight,
                                   __cil_tmp82);
#line 831
            weight_ssa_3 = *__cil_fp_weight;
#line 829
            __cil_tmp69 = tmp___6_ssa_1 == 1;
#line 829
            if (__cil_tmp69 != 0) {
#line 831
              *costfactor_ssa_2 = weight_ssa_3;
#line 832
              weight_ssa_4 = weight_ssa_3;
#line 833
              wnum_ssa_5 = wnum_ssa_4;
            } else {
#line 837
              *__cil_fp_wnum = wnum_ssa_4;
#line 838
              *__cil_fp_weight = weight_ssa_3;
#line 833
              __cil_tmp83 = (char *)featurepair;
#line 833
              __cil_tmp84 = (char *)junk;
#line 833
              tmp___5_ssa_1 = sscanf((char const   * __restrict  )((char const   *)__cil_tmp83),
                                     (char const   * __restrict  )"%ld:%lf%s", __cil_pp_wnum,
                                     __cil_pp_weight, __cil_tmp84);
#line 836
              wnum_ssa_5 = *__cil_fp_wnum;
#line 837
              weight_ssa_4 = *__cil_fp_weight;
#line 833
              __cil_tmp70 = tmp___5_ssa_1 == 2;
#line 833
              if (__cil_tmp70 != 0) {
#line 835
                __cil_tmp71 = wnum_ssa_5 <= 0L;
#line 835
                if (__cil_tmp71 != 0) {
#line 836
                  perror("Feature numbers must be larger or equal to 1!!!\n");
#line 837
                  printf((char const   * __restrict  )"LINE: %s\n", line_ssa_2);
#line 838
                  exit(1);
                } else {

                }
#line 840
                __cil_tmp85 = *__cil_ap_wpos;
#line 840
                __cil_tmp72 = __cil_tmp85 > 0L;
#line 840
                if (__cil_tmp72 != 0) {
#line 840
                  __cil_tmp86 = *__cil_ap_wpos;
#line 840
                  __cil_tmp87 = *__cil_ap_words;
#line 840
                  __cil_tmp88 = __cil_tmp86 - 1L;
#line 840
                  __cil_tmp89 = __cil_tmp87 + __cil_tmp88;
#line 840
                  __cil_tmp90 = (long *)__cil_tmp89;
#line 840
                  __cil_tmp91 = *__cil_tmp90;
#line 840
                  __cil_tmp73 = __cil_tmp91 >= wnum_ssa_5;
#line 840
                  if (__cil_tmp73 != 0) {
#line 841
                    perror("Features must be in increasing order!!!\n");
#line 842
                    printf((char const   * __restrict  )"LINE: %s\n", line_ssa_2);
#line 843
                    exit(1);
                  } else {

                  }
                } else {

                }
#line 845
                __cil_tmp92 = *__cil_ap_words;
#line 845
                __cil_tmp93 = *__cil_ap_wpos;
#line 845
                __cil_tmp94 = __cil_tmp92 + __cil_tmp93;
#line 845
                __cil_tmp95 = (long *)__cil_tmp94;
#line 845
                *__cil_tmp95 = wnum_ssa_5;
#line 846
                __cil_tmp96 = *__cil_ap_words;
#line 846
                __cil_tmp97 = *__cil_ap_wpos;
#line 846
                __cil_tmp98 = __cil_tmp96 + __cil_tmp97;
#line 846
                __cil_tmp99 = (unsigned char *)__cil_tmp98;
#line 846
                __cil_tmp100 = __cil_tmp99 + 8;
#line 846
                __cil_tmp101 = (float *)__cil_tmp100;
#line 846
                *__cil_tmp101 = (float )weight_ssa_4;
#line 847
                __cil_tmp102 = *__cil_ap_wpos;
#line 847
                *__cil_ap_wpos = __cil_tmp102 + 1L;
              } else {
#line 850
                perror("Cannot parse feature/value pair!!!\n");
#line 851
                __cil_tmp103 = (char *)featurepair;
#line 851
                printf((char const   * __restrict  )"\'%s\' in LINE: %s\n", __cil_tmp103,
                       line_ssa_2);
#line 852
                exit(1);
              }
            }
          }
        }
#line 863
        parse_document_cil_lr_5(__cil_ap_words, __cil_ap_numwords, __cil_ap_wpos,
                                line_ssa_2, queryid_ssa_2, slackid_ssa_2, costfactor_ssa_2,
                                max_words_doc_ssa_2, pos_ssa_2, wnum_ssa_5, weight_ssa_4,
                                featurepair, junk);
#line 868
        return;
      } else {
#line 870
        return;
      }
    } else {
#line 874
      return;
    }
  } else {
#line 878
    return;
  }
#line 882
  parse_document_cil_lr_5(__cil_ap_words, __cil_ap_numwords, __cil_ap_wpos, line,
                          queryid, slackid, costfactor, max_words_doc, pos, wnum,
                          weight, featurepair, junk);
#line 886
  return;
}
}
#line 889 "svm_common.c"
void free_model_cil_lr_1(MODEL **__cil_ap_model , long i ) 
{ 
  long i_ssa_1 ;
  int __cil_tmp4 ;
  MODEL *__cil_tmp5 ;
  long *__cil_tmp6 ;
  long __cil_tmp7 ;
  MODEL *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  DOC ***__cil_tmp11 ;
  DOC **__cil_tmp12 ;
  DOC **__cil_tmp13 ;
  DOC *__cil_tmp14 ;

  {
#line 677
  __cil_tmp5 = *__cil_ap_model;
#line 677
  __cil_tmp6 = (long *)__cil_tmp5;
#line 677
  __cil_tmp7 = *__cil_tmp6;
#line 677
  __cil_tmp4 = i < __cil_tmp7;
#line 677
  if (__cil_tmp4 != 0) {
#line 678
    __cil_tmp8 = *__cil_ap_model;
#line 678
    __cil_tmp9 = (unsigned char *)__cil_tmp8;
#line 678
    __cil_tmp10 = __cil_tmp9 + 24;
#line 678
    __cil_tmp11 = (DOC ***)__cil_tmp10;
#line 678
    __cil_tmp12 = *__cil_tmp11;
#line 678
    __cil_tmp13 = __cil_tmp12 + i;
#line 678
    __cil_tmp14 = *__cil_tmp13;
#line 678
    free_example(__cil_tmp14, 1L);
#line 677
    i_ssa_1 = i + 1L;
#line 680
    free_model_cil_lr_1(__cil_ap_model, i_ssa_1);
#line 682
    return;
  } else {
#line 684
    return;
  }
}
}
#line 689 "svm_common.c"
void copy_model_cil_lr_1(MODEL **__cil_ap_model , MODEL **__cil_ap_newmodel , long i ) 
{ 
  SVECTOR *tmp___2_ssa_1 ;
  long i_ssa_1 ;
  int __cil_tmp7 ;
  MODEL *__cil_tmp8 ;
  long *__cil_tmp9 ;
  long __cil_tmp10 ;
  MODEL *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  double **__cil_tmp14 ;
  double *__cil_tmp15 ;
  double *__cil_tmp16 ;
  MODEL *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  double **__cil_tmp20 ;
  double *__cil_tmp21 ;
  double *__cil_tmp22 ;
  MODEL *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  DOC ***__cil_tmp26 ;
  DOC **__cil_tmp27 ;
  DOC **__cil_tmp28 ;
  DOC *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  SVECTOR **__cil_tmp32 ;
  SVECTOR *__cil_tmp33 ;
  MODEL *__cil_tmp34 ;
  unsigned char *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  DOC ***__cil_tmp37 ;
  DOC **__cil_tmp38 ;
  DOC **__cil_tmp39 ;
  DOC *__cil_tmp40 ;
  long *__cil_tmp41 ;
  MODEL *__cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  DOC ***__cil_tmp45 ;
  DOC **__cil_tmp46 ;
  DOC **__cil_tmp47 ;
  DOC *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  long *__cil_tmp51 ;
  MODEL *__cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  DOC ***__cil_tmp55 ;
  DOC **__cil_tmp56 ;
  DOC **__cil_tmp57 ;
  DOC *__cil_tmp58 ;
  unsigned char *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  double *__cil_tmp61 ;
  long __cil_tmp62 ;
  long __cil_tmp63 ;
  double __cil_tmp64 ;
  DOC ***mem_64 ;
  DOC **mem_65 ;

  {
#line 656
  __cil_tmp8 = *__cil_ap_model;
#line 656
  __cil_tmp9 = (long *)__cil_tmp8;
#line 656
  __cil_tmp10 = *__cil_tmp9;
#line 656
  __cil_tmp7 = i < __cil_tmp10;
#line 656
  if (__cil_tmp7 != 0) {
#line 657
    __cil_tmp11 = *__cil_ap_model;
#line 657
    __cil_tmp12 = (unsigned char *)__cil_tmp11;
#line 657
    __cil_tmp13 = __cil_tmp12 + 32;
#line 657
    __cil_tmp14 = (double **)__cil_tmp13;
#line 657
    __cil_tmp15 = *__cil_tmp14;
#line 657
    __cil_tmp16 = __cil_tmp15 + i;
#line 657
    __cil_tmp17 = *__cil_ap_newmodel;
#line 657
    __cil_tmp18 = (unsigned char *)__cil_tmp17;
#line 657
    __cil_tmp19 = __cil_tmp18 + 32;
#line 657
    __cil_tmp20 = (double **)__cil_tmp19;
#line 657
    __cil_tmp21 = *__cil_tmp20;
#line 657
    __cil_tmp22 = __cil_tmp21 + i;
#line 657
    *__cil_tmp22 = *__cil_tmp16;
#line 658
    __cil_tmp23 = *__cil_ap_model;
#line 658
    __cil_tmp24 = (unsigned char *)__cil_tmp23;
#line 658
    __cil_tmp25 = __cil_tmp24 + 24;
#line 658
    __cil_tmp26 = (DOC ***)__cil_tmp25;
#line 658
    __cil_tmp27 = *__cil_tmp26;
#line 658
    __cil_tmp28 = __cil_tmp27 + i;
#line 658
    __cil_tmp29 = *__cil_tmp28;
#line 658
    __cil_tmp30 = (unsigned char *)__cil_tmp29;
#line 658
    __cil_tmp31 = __cil_tmp30 + 32;
#line 658
    __cil_tmp32 = (SVECTOR **)__cil_tmp31;
#line 658
    __cil_tmp33 = *__cil_tmp32;
#line 658
    tmp___2_ssa_1 = copy_svector(__cil_tmp33);
#line 658
    __cil_tmp34 = *__cil_ap_model;
#line 658
    __cil_tmp35 = (unsigned char *)__cil_tmp34;
#line 658
    __cil_tmp36 = __cil_tmp35 + 24;
#line 658
    __cil_tmp37 = (DOC ***)__cil_tmp36;
#line 658
    __cil_tmp38 = *__cil_tmp37;
#line 658
    __cil_tmp39 = __cil_tmp38 + i;
#line 658
    __cil_tmp40 = *__cil_tmp39;
#line 658
    __cil_tmp41 = (long *)__cil_tmp40;
#line 658
    __cil_tmp42 = *__cil_ap_model;
#line 658
    __cil_tmp43 = (unsigned char *)__cil_tmp42;
#line 658
    __cil_tmp44 = __cil_tmp43 + 24;
#line 658
    __cil_tmp45 = (DOC ***)__cil_tmp44;
#line 658
    __cil_tmp46 = *__cil_tmp45;
#line 658
    __cil_tmp47 = __cil_tmp46 + i;
#line 658
    __cil_tmp48 = *__cil_tmp47;
#line 658
    __cil_tmp49 = (unsigned char *)__cil_tmp48;
#line 658
    __cil_tmp50 = __cil_tmp49 + 8;
#line 658
    __cil_tmp51 = (long *)__cil_tmp50;
#line 658
    __cil_tmp52 = *__cil_ap_model;
#line 658
    __cil_tmp53 = (unsigned char *)__cil_tmp52;
#line 658
    __cil_tmp54 = __cil_tmp53 + 24;
#line 658
    __cil_tmp55 = (DOC ***)__cil_tmp54;
#line 658
    __cil_tmp56 = *__cil_tmp55;
#line 658
    __cil_tmp57 = __cil_tmp56 + i;
#line 658
    __cil_tmp58 = *__cil_tmp57;
#line 658
    __cil_tmp59 = (unsigned char *)__cil_tmp58;
#line 658
    __cil_tmp60 = __cil_tmp59 + 16;
#line 658
    __cil_tmp61 = (double *)__cil_tmp60;
#line 658
    __cil_tmp62 = *__cil_tmp41;
#line 658
    __cil_tmp63 = *__cil_tmp51;
#line 658
    __cil_tmp64 = *__cil_tmp61;
#line 658
    mem_64 = (DOC ***)((unsigned char *)*__cil_ap_newmodel + 24);
#line 658
    mem_65 = *mem_64 + i;
#line 658
    *mem_65 = create_example(__cil_tmp62, __cil_tmp63, 0L, __cil_tmp64, tmp___2_ssa_1);
#line 656
    i_ssa_1 = i + 1L;
#line 659
    copy_model_cil_lr_1(__cil_ap_model, __cil_ap_newmodel, i_ssa_1);
#line 661
    return;
  } else {
#line 663
    return;
  }
}
}
#line 668 "svm_common.c"
void copy_model_cil_lr_2(MODEL **__cil_ap_newmodel , MODEL *model , long i ) 
{ 
  long i_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  long *__cil_tmp7 ;
  long __cil_tmp8 ;
  long __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  double **__cil_tmp11 ;
  double *__cil_tmp12 ;
  double *__cil_tmp13 ;
  MODEL *__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  double **__cil_tmp17 ;
  double *__cil_tmp18 ;
  double *__cil_tmp19 ;

  {

#line 665
  return babel_wrapper_copy_model_cil_lr_2(__cil_ap_newmodel, model, i);
#line 665
  __cil_tmp6 = (unsigned char *)model + 48;
#line 665
  __cil_tmp7 = (long *)__cil_tmp6;
#line 665
  __cil_tmp8 = *__cil_tmp7;
#line 665
  __cil_tmp9 = __cil_tmp8 + 1L;
#line 665
  __cil_tmp5 = i < __cil_tmp9;
#line 665
  if (__cil_tmp5 != 0) {
#line 666
    __cil_tmp10 = (unsigned char *)model + 208;
#line 666
    __cil_tmp11 = (double **)__cil_tmp10;
#line 666
    __cil_tmp12 = *__cil_tmp11;
#line 666
    __cil_tmp13 = __cil_tmp12 + i;
#line 666
    __cil_tmp14 = *__cil_ap_newmodel;
#line 666
    __cil_tmp15 = (unsigned char *)__cil_tmp14;
#line 666
    __cil_tmp16 = __cil_tmp15 + 208;
#line 666
    __cil_tmp17 = (double **)__cil_tmp16;
#line 666
    __cil_tmp18 = *__cil_tmp17;
#line 666
    __cil_tmp19 = __cil_tmp18 + i;
#line 666
    *__cil_tmp19 = *__cil_tmp13;
#line 665
    i_ssa_1 = i + 1L;
#line 668
    copy_model_cil_lr_2(__cil_ap_newmodel, model, i_ssa_1);
#line 670
    return;
  } else {
#line 672
    return;
  }
}
}
#line 677 "svm_common.c"
void read_model_cil_lr_1(struct _IO_FILE **__cil_ap_stdout , long *__cil_ap_verbosity ,
                         FILE **__cil_ap_modelfl , char **__cil_ap_line , WORD **__cil_ap_words ,
                         MODEL **__cil_ap_model , long i , long queryid , long slackid ,
                         double costfactor , long max_words , long ll , long wpos ,
                         char *comment ) 
{ 
  long *__cil_pp_queryid ;
  long *__cil_pp_slackid ;
  double *__cil_pp_costfactor ;
  long *__cil_pp_wpos ;
  char **__cil_pp_comment ;
  long *__cil_fp_queryid ;
  long *__cil_fp_slackid ;
  double *__cil_fp_costfactor ;
  long *__cil_fp_wpos ;
  char **__cil_fp_comment ;
  int tmp___5_ssa_1 ;
  long queryid_ssa_1 ;
  long slackid_ssa_1 ;
  double costfactor_ssa_1 ;
  long wpos_ssa_1 ;
  char *comment_ssa_1 ;
  SVECTOR *tmp___6_ssa_1 ;
  long i_ssa_1 ;
  int __cil_tmp35 ;
  MODEL *__cil_tmp36 ;
  long *__cil_tmp37 ;
  long __cil_tmp38 ;
  char *__cil_tmp39 ;
  FILE *__cil_tmp40 ;
  MODEL *__cil_tmp41 ;
  unsigned char *__cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  double **__cil_tmp44 ;
  double *__cil_tmp45 ;
  char *__cil_tmp46 ;
  WORD *__cil_tmp47 ;
  double *__cil_tmp48 ;
  char *__cil_tmp49 ;
  WORD *__cil_tmp50 ;
  DOC ***mem_49 ;
  DOC **mem_50 ;

  {
#line 683
  __cil_pp_queryid = & queryid;
#line 684
  __cil_pp_slackid = & slackid;
#line 685
  __cil_pp_costfactor = & costfactor;
#line 686
  __cil_pp_wpos = & wpos;
#line 687
  __cil_pp_comment = & comment;
#line 688
  __cil_fp_queryid = & queryid;
#line 689
  __cil_fp_slackid = & slackid;
#line 690
  __cil_fp_costfactor = & costfactor;
#line 691
  __cil_fp_wpos = & wpos;
#line 692
  __cil_fp_comment = & comment;
#line 622
  __cil_tmp36 = *__cil_ap_model;
#line 622
  __cil_tmp37 = (long *)__cil_tmp36;
#line 622
  __cil_tmp38 = *__cil_tmp37;
#line 622
  __cil_tmp35 = i < __cil_tmp38;
#line 622
  if (__cil_tmp35 != 0) {
#line 623
    __cil_tmp39 = *__cil_ap_line;
#line 623
    __cil_tmp40 = *__cil_ap_modelfl;
#line 623
    fgets((char * __restrict  )__cil_tmp39, (int )ll, (FILE * __restrict  )__cil_tmp40);
#line 624
    *__cil_fp_queryid = queryid;
#line 625
    *__cil_fp_slackid = slackid;
#line 626
    *__cil_fp_costfactor = costfactor;
#line 627
    *__cil_fp_wpos = wpos;
#line 628
    *__cil_fp_comment = comment;
#line 624
    __cil_tmp41 = *__cil_ap_model;
#line 624
    __cil_tmp42 = (unsigned char *)__cil_tmp41;
#line 624
    __cil_tmp43 = __cil_tmp42 + 32;
#line 624
    __cil_tmp44 = (double **)__cil_tmp43;
#line 624
    __cil_tmp45 = *__cil_tmp44;
#line 624
    __cil_tmp46 = *__cil_ap_line;
#line 624
    __cil_tmp47 = *__cil_ap_words;
#line 624
    __cil_tmp48 = __cil_tmp45 + i;
#line 624
    tmp___5_ssa_1 = parse_document(__cil_tmp46, __cil_tmp47, __cil_tmp48, __cil_pp_queryid,
                                   __cil_pp_slackid, __cil_pp_costfactor, __cil_pp_wpos,
                                   max_words, __cil_pp_comment);
#line 627
    queryid_ssa_1 = *__cil_fp_queryid;
#line 628
    slackid_ssa_1 = *__cil_fp_slackid;
#line 629
    costfactor_ssa_1 = *__cil_fp_costfactor;
#line 630
    wpos_ssa_1 = *__cil_fp_wpos;
#line 631
    comment_ssa_1 = *__cil_fp_comment;
#line 624
    if (tmp___5_ssa_1 == 0) {
#line 626
      __cil_tmp49 = *__cil_ap_line;
#line 626
      printf((char const   * __restrict  )"\nParsing error while reading model file in SV %ld!\n%s",
             i, __cil_tmp49);
#line 628
      exit(1);
    } else {

    }
#line 630
    __cil_tmp50 = *__cil_ap_words;
#line 630
    tmp___6_ssa_1 = create_svector(__cil_tmp50, comment_ssa_1, 1.0);
#line 630
    mem_49 = (DOC ***)((unsigned char *)*__cil_ap_model + 24);
#line 630
    mem_50 = *mem_49 + i;
#line 630
    *mem_50 = create_example(-1L, 0L, 0L, 0.0, tmp___6_ssa_1);
#line 622
    i_ssa_1 = i + 1L;
#line 625
    read_model_cil_lr_1(__cil_ap_stdout, __cil_ap_verbosity, __cil_ap_modelfl, __cil_ap_line,
                        __cil_ap_words, __cil_ap_model, i_ssa_1, queryid_ssa_1, slackid_ssa_1,
                        costfactor_ssa_1, max_words, ll, wpos_ssa_1, comment_ssa_1);
#line 629
    return;
  } else {
#line 631
    return;
  }
}
}
#line 636 "svm_common.c"
void write_model_cil_lr_1(long *__cil_ap_verbosity , MODEL **__cil_ap_model , FILE **__cil_ap_modelfl ,
                          long *__cil_ap_sv_num , long i ) 
{ 
  long *__cil_pp_i ;
  long *__cil_fp_i ;
  SVECTOR *v_ssa_1 ;
  long i_ssa_1 ;
  long i_ssa_2 ;
  int __cil_tmp12 ;
  MODEL *__cil_tmp13 ;
  long *__cil_tmp14 ;
  long __cil_tmp15 ;
  MODEL *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  DOC ***__cil_tmp19 ;
  DOC **__cil_tmp20 ;
  DOC **__cil_tmp21 ;
  DOC *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  SVECTOR **__cil_tmp25 ;

  {
#line 639
  __cil_fp_i = & i;
#line 639
  __cil_pp_i = & i;
#line 639
  return babel_wrapper_write_model_cil_lr_1(__cil_pp_i, __cil_fp_i, __cil_ap_verbosity,
                                            __cil_ap_model, __cil_ap_modelfl, __cil_ap_sv_num,
                                            i);
#line 639
  __cil_pp_i = & i;
#line 640
  __cil_fp_i = & i;
#line 546
  __cil_tmp13 = *__cil_ap_model;
#line 546
  __cil_tmp14 = (long *)__cil_tmp13;
#line 546
  __cil_tmp15 = *__cil_tmp14;
#line 546
  __cil_tmp12 = i < __cil_tmp15;
#line 546
  if (__cil_tmp12 != 0) {
#line 547
    __cil_tmp16 = *__cil_ap_model;
#line 547
    __cil_tmp17 = (unsigned char *)__cil_tmp16;
#line 547
    __cil_tmp18 = __cil_tmp17 + 24;
#line 547
    __cil_tmp19 = (DOC ***)__cil_tmp18;
#line 547
    __cil_tmp20 = *__cil_tmp19;
#line 547
    __cil_tmp21 = __cil_tmp20 + i;
#line 547
    __cil_tmp22 = *__cil_tmp21;
#line 547
    __cil_tmp23 = (unsigned char *)__cil_tmp22;
#line 547
    __cil_tmp24 = __cil_tmp23 + 32;
#line 547
    __cil_tmp25 = (SVECTOR **)__cil_tmp24;
#line 547
    v_ssa_1 = *__cil_tmp25;
#line 550
    *__cil_fp_i = i;
#line 547
    write_model_cil_lr_1_cil_lr_1(__cil_pp_i, __cil_ap_sv_num, v_ssa_1);
#line 548
    i_ssa_1 = *__cil_fp_i;
#line 546
    i_ssa_2 = i_ssa_1 + 1L;
#line 549
    write_model_cil_lr_1(__cil_ap_verbosity, __cil_ap_model, __cil_ap_modelfl, __cil_ap_sv_num,
                         i_ssa_2);
#line 552
    return;
  } else {
#line 554
    return;
  }
}
}
#line 559 "svm_common.c"
void write_model_cil_lr_2(long *__cil_ap_verbosity , FILE **__cil_ap_modelfl , MODEL *model ,
                          long i ) 
{ 
  MODEL **__cil_pp_model ;
  long *__cil_pp_i ;
  MODEL **__cil_fp_model ;
  long *__cil_fp_i ;
  SVECTOR *v_ssa_1 ;
  MODEL *model_ssa_1 ;
  long i_ssa_1 ;
  long i_ssa_2 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  DOC ***__cil_tmp18 ;
  DOC **__cil_tmp19 ;
  DOC **__cil_tmp20 ;
  DOC *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  SVECTOR **__cil_tmp24 ;
  long *mem_23 ;

  {
#line 562
  __cil_fp_i = & i;
#line 562
  __cil_fp_model = & model;
#line 562
  __cil_pp_i = & i;
#line 562
  __cil_pp_model = & model;
#line 562
  return babel_wrapper_write_model_cil_lr_2(__cil_pp_model, __cil_pp_i, __cil_fp_model,
                                            __cil_fp_i, __cil_ap_verbosity, __cil_ap_modelfl,
                                            model, i);
#line 562
  __cil_pp_model = & model;
#line 563
  __cil_pp_i = & i;
#line 564
  __cil_fp_model = & model;
#line 565
  __cil_fp_i = & i;
#line 553
  mem_23 = (long *)model;
#line 553
  __cil_tmp16 = *mem_23;
#line 553
  __cil_tmp15 = i < __cil_tmp16;
#line 553
  if (__cil_tmp15 != 0) {
#line 554
    __cil_tmp17 = (unsigned char *)model + 24;
#line 554
    __cil_tmp18 = (DOC ***)__cil_tmp17;
#line 554
    __cil_tmp19 = *__cil_tmp18;
#line 554
    __cil_tmp20 = __cil_tmp19 + i;
#line 554
    __cil_tmp21 = *__cil_tmp20;
#line 554
    __cil_tmp22 = (unsigned char *)__cil_tmp21;
#line 554
    __cil_tmp23 = __cil_tmp22 + 32;
#line 554
    __cil_tmp24 = (SVECTOR **)__cil_tmp23;
#line 554
    v_ssa_1 = *__cil_tmp24;
#line 557
    *__cil_fp_model = model;
#line 558
    *__cil_fp_i = i;
#line 554
    write_model_cil_lr_2_cil_lr_1(__cil_pp_model, __cil_pp_i, __cil_ap_modelfl, v_ssa_1);
#line 555
    model_ssa_1 = *__cil_fp_model;
#line 556
    i_ssa_1 = *__cil_fp_i;
#line 553
    i_ssa_2 = i_ssa_1 + 1L;
#line 556
    write_model_cil_lr_2(__cil_ap_verbosity, __cil_ap_modelfl, model_ssa_1, i_ssa_2);
#line 558
    return;
  } else {
#line 560
    return;
  }
}
}
#line 565 "svm_common.c"
void add_weight_vector_to_linear_model_cil_lr_1(MODEL *model , long i ) 
{ 
  MODEL **__cil_pp_model ;
  long *__cil_pp_i ;
  MODEL **__cil_fp_model ;
  long *__cil_fp_i ;
  SVECTOR *f_ssa_1 ;
  MODEL *model_ssa_1 ;
  long i_ssa_1 ;
  long i_ssa_2 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  DOC ***__cil_tmp15 ;
  DOC **__cil_tmp16 ;
  DOC **__cil_tmp17 ;
  DOC *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  SVECTOR **__cil_tmp21 ;
  long *mem_21 ;

  {
#line 567
  __cil_fp_i = & i;
#line 567
  __cil_fp_model = & model;
#line 567
  __cil_pp_i = & i;
#line 567
  __cil_pp_model = & model;
#line 567
  return babel_wrapper_add_weight_vector_to_linear_model_cil_lr_1(__cil_pp_model,
                                                                  __cil_pp_i, __cil_fp_model,
                                                                  __cil_fp_i, model,
                                                                  i);
#line 567
  __cil_pp_model = & model;
#line 568
  __cil_pp_i = & i;
#line 569
  __cil_fp_model = & model;
#line 570
  __cil_fp_i = & i;
#line 488
  mem_21 = (long *)model;
#line 488
  __cil_tmp13 = *mem_21;
#line 488
  __cil_tmp12 = i < __cil_tmp13;
#line 488
  if (__cil_tmp12 != 0) {
#line 489
    __cil_tmp14 = (unsigned char *)model + 24;
#line 489
    __cil_tmp15 = (DOC ***)__cil_tmp14;
#line 489
    __cil_tmp16 = *__cil_tmp15;
#line 489
    __cil_tmp17 = __cil_tmp16 + i;
#line 489
    __cil_tmp18 = *__cil_tmp17;
#line 489
    __cil_tmp19 = (unsigned char *)__cil_tmp18;
#line 489
    __cil_tmp20 = __cil_tmp19 + 32;
#line 489
    __cil_tmp21 = (SVECTOR **)__cil_tmp20;
#line 489
    f_ssa_1 = *__cil_tmp21;
#line 492
    *__cil_fp_model = model;
#line 493
    *__cil_fp_i = i;
#line 489
    add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1(__cil_pp_model, __cil_pp_i,
                                                        f_ssa_1);
#line 491
    model_ssa_1 = *__cil_fp_model;
#line 492
    i_ssa_1 = *__cil_fp_i;
#line 488
    i_ssa_2 = i_ssa_1 + 1L;
#line 491
    add_weight_vector_to_linear_model_cil_lr_1(model_ssa_1, i_ssa_2);
#line 493
    return;
  } else {
#line 495
    return;
  }
}
}
#line 500 "svm_common.c"
void sprod_ns_cil_lr_1(double *__cil_ap_sum , double *vec_n , WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  double *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  float *__cil_tmp9 ;
  float __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  long *mem_15 ;
  long *mem_16 ;

  {
#line 473
  mem_15 = (long *)ai;
#line 473
  __cil_tmp5 = *mem_15;
#line 473
  if (__cil_tmp5 != 0) {
#line 474
    mem_16 = (long *)ai;
#line 474
    __cil_tmp6 = *mem_16;
#line 474
    __cil_tmp7 = vec_n + __cil_tmp6;
#line 474
    __cil_tmp8 = (unsigned char *)ai + 8;
#line 474
    __cil_tmp9 = (float *)__cil_tmp8;
#line 474
    __cil_tmp10 = *__cil_tmp9;
#line 474
    __cil_tmp11 = *__cil_tmp7;
#line 474
    __cil_tmp12 = (double )__cil_tmp10;
#line 474
    __cil_tmp13 = *__cil_ap_sum;
#line 474
    __cil_tmp14 = __cil_tmp11 * __cil_tmp12;
#line 474
    *__cil_ap_sum = __cil_tmp13 + __cil_tmp14;
#line 475
    ai_ssa_1 = ai + 1;
#line 478
    sprod_ns_cil_lr_1(__cil_ap_sum, vec_n, ai_ssa_1);
#line 480
    return;
  } else {
#line 482
    return;
  }
}
}
#line 487 "svm_common.c"
void add_vector_ns_cil_lr_1(double *vec_n , double faktor , WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  double *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  float *__cil_tmp9 ;
  float __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  long __cil_tmp14 ;
  double *__cil_tmp15 ;
  long *mem_16 ;
  long *mem_17 ;
  long *mem_18 ;

  {
#line 462
  mem_16 = (long *)ai;
#line 462
  __cil_tmp5 = *mem_16;
#line 462
  if (__cil_tmp5 != 0) {
#line 463
    mem_17 = (long *)ai;
#line 463
    __cil_tmp6 = *mem_17;
#line 463
    __cil_tmp7 = vec_n + __cil_tmp6;
#line 463
    __cil_tmp8 = (unsigned char *)ai + 8;
#line 463
    __cil_tmp9 = (float *)__cil_tmp8;
#line 463
    __cil_tmp10 = *__cil_tmp9;
#line 463
    __cil_tmp11 = (double )__cil_tmp10;
#line 463
    __cil_tmp12 = *__cil_tmp7;
#line 463
    __cil_tmp13 = faktor * __cil_tmp11;
#line 463
    mem_18 = (long *)ai;
#line 463
    __cil_tmp14 = *mem_18;
#line 463
    __cil_tmp15 = vec_n + __cil_tmp14;
#line 463
    *__cil_tmp15 = __cil_tmp12 + __cil_tmp13;
#line 464
    ai_ssa_1 = ai + 1;
#line 467
    add_vector_ns_cil_lr_1(vec_n, faktor, ai_ssa_1);
#line 469
    return;
  } else {
#line 471
    return;
  }
}
}
#line 476 "svm_common.c"
void clear_vector_n_cil_lr_1(double *vec , long n , long i ) 
{ 
  long i_ssa_1 ;
  int __cil_tmp5 ;
  double *__cil_tmp6 ;

  {
  return babel_wrapper_clear_vector_n_cil_lr_1(vec, n, i);
#line 455
  __cil_tmp5 = i <= n;
#line 455
  if (__cil_tmp5 != 0) {
#line 455
    __cil_tmp6 = vec + i;
#line 455
    *__cil_tmp6 = (double )0;
#line 455
    i_ssa_1 = i + 1L;
#line 458
    clear_vector_n_cil_lr_1(vec, n, i_ssa_1);
#line 460
    return;
  } else {
#line 462
    return;
  }
}
}
#line 467 "svm_common.c"
void model_length_s_cil_lr_1(double *__cil_ap_sum , MODEL *model , KERNEL_PARM *kernel_parm ,
                             long i ) 
{ 
  MODEL **__cil_pp_model ;
  KERNEL_PARM **__cil_pp_kernel_parm ;
  long *__cil_pp_i ;
  MODEL **__cil_fp_model ;
  KERNEL_PARM **__cil_fp_kernel_parm ;
  long *__cil_fp_i ;
  double alphai_ssa_1 ;
  DOC *supveci_ssa_1 ;
  long j_ssa_1 ;
  MODEL *model_ssa_1 ;
  KERNEL_PARM *kernel_parm_ssa_1 ;
  long i_ssa_1 ;
  long i_ssa_2 ;
  int __cil_tmp22 ;
  long __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  double **__cil_tmp25 ;
  double *__cil_tmp26 ;
  double *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  DOC ***__cil_tmp29 ;
  DOC **__cil_tmp30 ;
  DOC **__cil_tmp31 ;
  long *mem_28 ;

  {
#line 470
  __cil_fp_i = & i;
#line 470
  __cil_fp_kernel_parm = & kernel_parm;
#line 470
  __cil_fp_model = & model;
#line 470
  __cil_pp_i = & i;
#line 470
  __cil_pp_kernel_parm = & kernel_parm;
#line 470
  __cil_pp_model = & model;
#line 470
  return babel_wrapper_model_length_s_cil_lr_1(__cil_pp_model, __cil_pp_kernel_parm,
                                               __cil_pp_i, __cil_fp_model, __cil_fp_kernel_parm,
                                               __cil_fp_i, __cil_ap_sum, model, kernel_parm,
                                               i);
#line 470
  __cil_pp_model = & model;
#line 471
  __cil_pp_kernel_parm = & kernel_parm;
#line 472
  __cil_pp_i = & i;
#line 473
  __cil_fp_model = & model;
#line 474
  __cil_fp_kernel_parm = & kernel_parm;
#line 475
  __cil_fp_i = & i;
#line 441
  mem_28 = (long *)model;
#line 441
  __cil_tmp23 = *mem_28;
#line 441
  __cil_tmp22 = i < __cil_tmp23;
#line 441
  if (__cil_tmp22 != 0) {
#line 442
    __cil_tmp24 = (unsigned char *)model + 32;
#line 442
    __cil_tmp25 = (double **)__cil_tmp24;
#line 442
    __cil_tmp26 = *__cil_tmp25;
#line 442
    __cil_tmp27 = __cil_tmp26 + i;
#line 442
    alphai_ssa_1 = *__cil_tmp27;
#line 443
    __cil_tmp28 = (unsigned char *)model + 24;
#line 443
    __cil_tmp29 = (DOC ***)__cil_tmp28;
#line 443
    __cil_tmp30 = *__cil_tmp29;
#line 443
    __cil_tmp31 = __cil_tmp30 + i;
#line 443
    supveci_ssa_1 = *__cil_tmp31;
#line 444
    j_ssa_1 = 1L;
#line 447
    *__cil_fp_model = model;
#line 448
    *__cil_fp_kernel_parm = kernel_parm;
#line 449
    *__cil_fp_i = i;
#line 444
    model_length_s_cil_lr_1_cil_lr_1(__cil_pp_model, __cil_pp_kernel_parm, __cil_pp_i,
                                     __cil_ap_sum, alphai_ssa_1, supveci_ssa_1, j_ssa_1);
#line 446
    model_ssa_1 = *__cil_fp_model;
#line 447
    kernel_parm_ssa_1 = *__cil_fp_kernel_parm;
#line 448
    i_ssa_1 = *__cil_fp_i;
#line 441
    i_ssa_2 = i_ssa_1 + 1L;
#line 444
    model_length_s_cil_lr_1(__cil_ap_sum, model_ssa_1, kernel_parm_ssa_1, i_ssa_2);
#line 446
    return;
  } else {
#line 448
    return;
  }
}
}
#line 453 "svm_common.c"
int featvec_eq_cil_lr_1(int *__cil_ap___cil_ret5 , WORD *ai , WORD *bj ) 
{ 
  WORD *bj_ssa_1 ;
  int retflag4_ssa_1 ;
  WORD *ai_ssa_1 ;
  long __cil_tmp8 ;
  long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  float *__cil_tmp18 ;
  float __cil_tmp19 ;
  long __cil_tmp20 ;
  long __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  float *__cil_tmp23 ;
  float __cil_tmp24 ;
  unsigned char *__cil_tmp25 ;
  float *__cil_tmp26 ;
  unsigned char *__cil_tmp27 ;
  float *__cil_tmp28 ;
  float __cil_tmp29 ;
  float __cil_tmp30 ;
  long *mem_30 ;
  long *mem_31 ;
  long *mem_32 ;
  long *mem_33 ;
  long *mem_34 ;
  long *mem_35 ;

  {
#line 413
  mem_30 = (long *)ai;
#line 413
  __cil_tmp8 = *mem_30;
#line 413
  if (__cil_tmp8 != 0) {
#line 413
    mem_31 = (long *)bj;
#line 413
    __cil_tmp9 = *mem_31;
#line 413
    if (__cil_tmp9 != 0) {
#line 414
      mem_32 = (long *)ai;
#line 414
      __cil_tmp15 = *mem_32;
#line 414
      mem_33 = (long *)bj;
#line 414
      __cil_tmp16 = *mem_33;
#line 414
      __cil_tmp10 = __cil_tmp15 > __cil_tmp16;
#line 414
      if (__cil_tmp10 != 0) {
#line 415
        __cil_tmp17 = (unsigned char *)bj + 8;
#line 415
        __cil_tmp18 = (float *)__cil_tmp17;
#line 415
        __cil_tmp19 = *__cil_tmp18;
#line 415
        __cil_tmp11 = __cil_tmp19 != (float )0;
#line 415
        if (__cil_tmp11 != 0) {
#line 416
          *__cil_ap___cil_ret5 = 0;
#line 418
          return (1);
        } else {
#line 417
          bj_ssa_1 = bj + 1;
#line 420
          retflag4_ssa_1 = featvec_eq_cil_lr_1(__cil_ap___cil_ret5, ai, bj_ssa_1);
#line 422
          return (retflag4_ssa_1);
        }
      } else {
#line 419
        mem_34 = (long *)ai;
#line 419
        __cil_tmp20 = *mem_34;
#line 419
        mem_35 = (long *)bj;
#line 419
        __cil_tmp21 = *mem_35;
#line 419
        __cil_tmp12 = __cil_tmp20 < __cil_tmp21;
#line 419
        if (__cil_tmp12 != 0) {
#line 420
          __cil_tmp22 = (unsigned char *)ai + 8;
#line 420
          __cil_tmp23 = (float *)__cil_tmp22;
#line 420
          __cil_tmp24 = *__cil_tmp23;
#line 420
          __cil_tmp13 = __cil_tmp24 != (float )0;
#line 420
          if (__cil_tmp13 != 0) {
#line 421
            *__cil_ap___cil_ret5 = 0;
#line 423
            return (1);
          } else {
#line 422
            ai_ssa_1 = ai + 1;
#line 425
            retflag4_ssa_1 = featvec_eq_cil_lr_1(__cil_ap___cil_ret5, ai_ssa_1, bj);
#line 427
            return (retflag4_ssa_1);
          }
        } else {
#line 425
          __cil_tmp25 = (unsigned char *)ai + 8;
#line 425
          __cil_tmp26 = (float *)__cil_tmp25;
#line 425
          __cil_tmp27 = (unsigned char *)bj + 8;
#line 425
          __cil_tmp28 = (float *)__cil_tmp27;
#line 425
          __cil_tmp29 = *__cil_tmp26;
#line 425
          __cil_tmp30 = *__cil_tmp28;
#line 425
          __cil_tmp14 = __cil_tmp29 != __cil_tmp30;
#line 425
          if (__cil_tmp14 != 0) {
#line 426
            *__cil_ap___cil_ret5 = 0;
#line 428
            return (1);
          } else {
#line 427
            ai_ssa_1 = ai + 1;
#line 428
            bj_ssa_1 = bj + 1;
#line 431
            retflag4_ssa_1 = featvec_eq_cil_lr_1(__cil_ap___cil_ret5, ai_ssa_1, bj_ssa_1);
#line 433
            return (retflag4_ssa_1);
          }
        }
      }
    } else {
#line 441
      return (0);
    }
  } else {
#line 445
    return (0);
  }
}
}
#line 450 "svm_common.c"
void smult_s_cil_lr_1(SVECTOR **__cil_ap_a , double *__cil_ap_factor , long *__cil_ap_veclength ,
                      WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  long *mem_8 ;

  {

#line 383
  return babel_wrapper_smult_s_cil_lr_1(__cil_ap_a, __cil_ap_factor, __cil_ap_veclength,
                                        ai);
#line 383
  mem_8 = (long *)ai;
#line 383
  __cil_tmp6 = *mem_8;
#line 383
  if (__cil_tmp6 != 0) {
#line 384
    __cil_tmp7 = *__cil_ap_veclength;
#line 384
    *__cil_ap_veclength = __cil_tmp7 + 1L;
#line 385
    ai_ssa_1 = ai + 1;
#line 388
    smult_s_cil_lr_1(__cil_ap_a, __cil_ap_factor, __cil_ap_veclength, ai_ssa_1);
#line 390
    return;
  } else {
#line 392
    return;
  }
}
}
#line 397 "svm_common.c"
void smult_s_cil_lr_2(SVECTOR **__cil_ap_a , WORD **__cil_ap_sum , WORD **__cil_ap_sumi ,
                      double factor , WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp7 ;
  int __cil_tmp8 ;
  WORD *__cil_tmp9 ;
  WORD *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  float *__cil_tmp13 ;
  float __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  WORD *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  float *__cil_tmp20 ;
  WORD *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  float *__cil_tmp24 ;
  float __cil_tmp25 ;
  WORD *__cil_tmp26 ;
  long *mem_27 ;

  {

#line 392
  return babel_wrapper_smult_s_cil_lr_2(__cil_ap_a, __cil_ap_sum, __cil_ap_sumi, factor,
                                        ai);
#line 392
  mem_27 = (long *)ai;
#line 392
  __cil_tmp7 = *mem_27;
#line 392
  if (__cil_tmp7 != 0) {
#line 393
    __cil_tmp9 = *__cil_ap_sumi;
#line 393
    *__cil_tmp9 = *ai;
#line 394
    __cil_tmp10 = *__cil_ap_sumi;
#line 394
    __cil_tmp11 = (unsigned char *)__cil_tmp10;
#line 394
    __cil_tmp12 = __cil_tmp11 + 8;
#line 394
    __cil_tmp13 = (float *)__cil_tmp12;
#line 394
    __cil_tmp14 = *__cil_tmp13;
#line 394
    __cil_tmp15 = (double )__cil_tmp14;
#line 394
    __cil_tmp16 = __cil_tmp15 * factor;
#line 394
    __cil_tmp17 = *__cil_ap_sumi;
#line 394
    __cil_tmp18 = (unsigned char *)__cil_tmp17;
#line 394
    __cil_tmp19 = __cil_tmp18 + 8;
#line 394
    __cil_tmp20 = (float *)__cil_tmp19;
#line 394
    *__cil_tmp20 = (float )__cil_tmp16;
#line 395
    __cil_tmp21 = *__cil_ap_sumi;
#line 395
    __cil_tmp22 = (unsigned char *)__cil_tmp21;
#line 395
    __cil_tmp23 = __cil_tmp22 + 8;
#line 395
    __cil_tmp24 = (float *)__cil_tmp23;
#line 395
    __cil_tmp25 = *__cil_tmp24;
#line 395
    __cil_tmp8 = __cil_tmp25 != (float )0;
#line 395
    if (__cil_tmp8 != 0) {
#line 396
      __cil_tmp26 = *__cil_ap_sumi;
#line 396
      *__cil_ap_sumi = __cil_tmp26 + 1;
    } else {

    }
#line 397
    ai_ssa_1 = ai + 1;
#line 400
    smult_s_cil_lr_2(__cil_ap_a, __cil_ap_sum, __cil_ap_sumi, factor, ai_ssa_1);
#line 402
    return;
  } else {
#line 404
    return;
  }
#line 397
  ai_ssa_1 = ai + 1;
#line 400
  smult_s_cil_lr_2(__cil_ap_a, __cil_ap_sum, __cil_ap_sumi, factor, ai_ssa_1);
#line 402
  return;
}
}
#line 405 "svm_common.c"
void append_svector_list_cil_lr_1(SVECTOR **__cil_ap_b , SVECTOR **__cil_ap_f ) 
{ 
  struct svector *__cil_tmp3 ;
  SVECTOR *__cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  struct svector **__cil_tmp7 ;
  SVECTOR *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  struct svector **__cil_tmp11 ;

  {

#line 369
  return babel_wrapper_append_svector_list_cil_lr_1(__cil_ap_b, __cil_ap_f);
#line 369
  __cil_tmp4 = *__cil_ap_f;
#line 369
  __cil_tmp5 = (unsigned char *)__cil_tmp4;
#line 369
  __cil_tmp6 = __cil_tmp5 + 32;
#line 369
  __cil_tmp7 = (struct svector **)__cil_tmp6;
#line 369
  __cil_tmp3 = *__cil_tmp7;
#line 369
  if (__cil_tmp3 != 0) {
#line 369
    __cil_tmp8 = *__cil_ap_f;
#line 369
    __cil_tmp9 = (unsigned char *)__cil_tmp8;
#line 369
    __cil_tmp10 = __cil_tmp9 + 32;
#line 369
    __cil_tmp11 = (struct svector **)__cil_tmp10;
#line 369
    *__cil_ap_f = *__cil_tmp11;
#line 372
    append_svector_list_cil_lr_1(__cil_ap_b, __cil_ap_f);
#line 374
    return;
  } else {
#line 376
    return;
  }
}
}
#line 381 "svm_common.c"
void add_list_ss_cil_lr_1(SVECTOR **__cil_ap_sum , SVECTOR *f ) 
{ 
  SVECTOR *scaled_ssa_1 ;
  SVECTOR *oldsum_ssa_1 ;
  SVECTOR *f_ssa_1 ;
  unsigned char *__cil_tmp8 ;
  double *__cil_tmp9 ;
  double __cil_tmp10 ;
  SVECTOR *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  struct svector **__cil_tmp13 ;

  {
#line 348
  if (f != 0) {
#line 349
    __cil_tmp8 = (unsigned char *)f + 40;
#line 349
    __cil_tmp9 = (double *)__cil_tmp8;
#line 349
    __cil_tmp10 = *__cil_tmp9;
#line 349
    scaled_ssa_1 = smult_s(f, __cil_tmp10);
#line 350
    oldsum_ssa_1 = *__cil_ap_sum;
#line 351
    __cil_tmp11 = *__cil_ap_sum;
#line 351
    *__cil_ap_sum = add_ss(__cil_tmp11, scaled_ssa_1);
#line 352
    free_svector(oldsum_ssa_1);
#line 353
    free_svector(scaled_ssa_1);
#line 348
    __cil_tmp12 = (unsigned char *)f + 32;
#line 348
    __cil_tmp13 = (struct svector **)__cil_tmp12;
#line 348
    f_ssa_1 = *__cil_tmp13;
#line 351
    add_list_ss_cil_lr_1(__cil_ap_sum, f_ssa_1);
#line 353
    return;
  } else {
#line 355
    return;
  }
}
}
#line 359 "svm_common.c"
void add_ss_cil_lr_1(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj , long *__cil_ap_veclength ) 
{ 
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  WORD *__cil_tmp10 ;
  long *__cil_tmp11 ;
  WORD *__cil_tmp12 ;
  long *__cil_tmp13 ;
  WORD *__cil_tmp14 ;
  long *__cil_tmp15 ;
  WORD *__cil_tmp16 ;
  long *__cil_tmp17 ;
  long __cil_tmp18 ;
  long __cil_tmp19 ;
  long __cil_tmp20 ;
  WORD *__cil_tmp21 ;
  WORD *__cil_tmp22 ;
  long *__cil_tmp23 ;
  WORD *__cil_tmp24 ;
  long *__cil_tmp25 ;
  long __cil_tmp26 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  WORD *__cil_tmp29 ;
  long __cil_tmp30 ;
  WORD *__cil_tmp31 ;
  WORD *__cil_tmp32 ;

  {

#line 270
  return babel_wrapper_add_ss_cil_lr_1(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_bj,
                                       __cil_ap_veclength);
#line 270
  __cil_tmp10 = *__cil_ap_ai;
#line 270
  __cil_tmp11 = (long *)__cil_tmp10;
#line 270
  __cil_tmp6 = *__cil_tmp11;
#line 270
  if (__cil_tmp6 != 0) {
#line 270
    __cil_tmp12 = *__cil_ap_bj;
#line 270
    __cil_tmp13 = (long *)__cil_tmp12;
#line 270
    __cil_tmp7 = *__cil_tmp13;
#line 270
    if (__cil_tmp7 != 0) {
#line 271
      __cil_tmp14 = *__cil_ap_ai;
#line 271
      __cil_tmp15 = (long *)__cil_tmp14;
#line 271
      __cil_tmp16 = *__cil_ap_bj;
#line 271
      __cil_tmp17 = (long *)__cil_tmp16;
#line 271
      __cil_tmp18 = *__cil_tmp15;
#line 271
      __cil_tmp19 = *__cil_tmp17;
#line 271
      __cil_tmp8 = __cil_tmp18 > __cil_tmp19;
#line 271
      if (__cil_tmp8 != 0) {
#line 272
        __cil_tmp20 = *__cil_ap_veclength;
#line 272
        *__cil_ap_veclength = __cil_tmp20 + 1L;
#line 273
        __cil_tmp21 = *__cil_ap_bj;
#line 273
        *__cil_ap_bj = __cil_tmp21 + 1;
      } else {
#line 275
        __cil_tmp22 = *__cil_ap_ai;
#line 275
        __cil_tmp23 = (long *)__cil_tmp22;
#line 275
        __cil_tmp24 = *__cil_ap_bj;
#line 275
        __cil_tmp25 = (long *)__cil_tmp24;
#line 275
        __cil_tmp26 = *__cil_tmp23;
#line 275
        __cil_tmp27 = *__cil_tmp25;
#line 275
        __cil_tmp9 = __cil_tmp26 < __cil_tmp27;
#line 275
        if (__cil_tmp9 != 0) {
#line 276
          __cil_tmp28 = *__cil_ap_veclength;
#line 276
          *__cil_ap_veclength = __cil_tmp28 + 1L;
#line 277
          __cil_tmp29 = *__cil_ap_ai;
#line 277
          *__cil_ap_ai = __cil_tmp29 + 1;
        } else {
#line 280
          __cil_tmp30 = *__cil_ap_veclength;
#line 280
          *__cil_ap_veclength = __cil_tmp30 + 1L;
#line 281
          __cil_tmp31 = *__cil_ap_ai;
#line 281
          *__cil_ap_ai = __cil_tmp31 + 1;
#line 282
          __cil_tmp32 = *__cil_ap_bj;
#line 282
          *__cil_ap_bj = __cil_tmp32 + 1;
        }
      }
#line 289
      add_ss_cil_lr_1(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_bj, __cil_ap_veclength);
#line 291
      return;
    } else {
#line 293
      return;
    }
  } else {
#line 297
    return;
  }
#line 301
  add_ss_cil_lr_1(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_bj, __cil_ap_veclength);
#line 303
  return;
}
}
#line 306 "svm_common.c"
void add_ss_cil_lr_2(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     long *__cil_ap_veclength , WORD *bj ) 
{ 
  WORD *bj_ssa_1 ;
  long __cil_tmp7 ;
  long __cil_tmp8 ;
  long *mem_9 ;

  {

#line 285
  return babel_wrapper_add_ss_cil_lr_2(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_veclength,
                                       bj);
#line 285
  mem_9 = (long *)bj;
#line 285
  __cil_tmp7 = *mem_9;
#line 285
  if (__cil_tmp7 != 0) {
#line 286
    __cil_tmp8 = *__cil_ap_veclength;
#line 286
    *__cil_ap_veclength = __cil_tmp8 + 1L;
#line 287
    bj_ssa_1 = bj + 1;
#line 290
    add_ss_cil_lr_2(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_veclength, bj_ssa_1);
#line 292
    return;
  } else {
#line 294
    return;
  }
}
}
#line 299 "svm_common.c"
void add_ss_cil_lr_3(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , long *__cil_ap_veclength ,
                     WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  long *mem_8 ;

  {

#line 289
  return babel_wrapper_add_ss_cil_lr_3(__cil_ap_a, __cil_ap_b, __cil_ap_veclength,
                                       ai);
#line 289
  mem_8 = (long *)ai;
#line 289
  __cil_tmp6 = *mem_8;
#line 289
  if (__cil_tmp6 != 0) {
#line 290
    __cil_tmp7 = *__cil_ap_veclength;
#line 290
    *__cil_ap_veclength = __cil_tmp7 + 1L;
#line 291
    ai_ssa_1 = ai + 1;
#line 294
    add_ss_cil_lr_3(__cil_ap_a, __cil_ap_b, __cil_ap_veclength, ai_ssa_1);
#line 296
    return;
  } else {
#line 298
    return;
  }
}
}
#line 303 "svm_common.c"
void add_ss_cil_lr_4(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj ) 
{ 
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  WORD *__cil_tmp10 ;
  long *__cil_tmp11 ;
  WORD *__cil_tmp12 ;
  long *__cil_tmp13 ;
  WORD *__cil_tmp14 ;
  long *__cil_tmp15 ;
  WORD *__cil_tmp16 ;
  long *__cil_tmp17 ;
  long __cil_tmp18 ;
  long __cil_tmp19 ;
  WORD *__cil_tmp20 ;
  WORD *__cil_tmp21 ;
  WORD *__cil_tmp22 ;
  WORD *__cil_tmp23 ;
  WORD *__cil_tmp24 ;
  long *__cil_tmp25 ;
  WORD *__cil_tmp26 ;
  long *__cil_tmp27 ;
  long __cil_tmp28 ;
  long __cil_tmp29 ;
  WORD *__cil_tmp30 ;
  WORD *__cil_tmp31 ;
  WORD *__cil_tmp32 ;
  WORD *__cil_tmp33 ;
  WORD *__cil_tmp34 ;
  WORD *__cil_tmp35 ;
  WORD *__cil_tmp36 ;
  unsigned char *__cil_tmp37 ;
  unsigned char *__cil_tmp38 ;
  float *__cil_tmp39 ;
  WORD *__cil_tmp40 ;
  unsigned char *__cil_tmp41 ;
  unsigned char *__cil_tmp42 ;
  float *__cil_tmp43 ;
  float __cil_tmp44 ;
  float __cil_tmp45 ;
  WORD *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  unsigned char *__cil_tmp48 ;
  float *__cil_tmp49 ;
  WORD *__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  unsigned char *__cil_tmp52 ;
  float *__cil_tmp53 ;
  float __cil_tmp54 ;
  WORD *__cil_tmp55 ;
  WORD *__cil_tmp56 ;
  WORD *__cil_tmp57 ;

  {

#line 301
  return babel_wrapper_add_ss_cil_lr_4(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, __cil_ap_bj);
#line 301
  __cil_tmp10 = *__cil_ap_ai;
#line 301
  __cil_tmp11 = (long *)__cil_tmp10;
#line 301
  __cil_tmp5 = *__cil_tmp11;
#line 301
  if (__cil_tmp5 != 0) {
#line 301
    __cil_tmp12 = *__cil_ap_bj;
#line 301
    __cil_tmp13 = (long *)__cil_tmp12;
#line 301
    __cil_tmp6 = *__cil_tmp13;
#line 301
    if (__cil_tmp6 != 0) {
#line 302
      __cil_tmp14 = *__cil_ap_ai;
#line 302
      __cil_tmp15 = (long *)__cil_tmp14;
#line 302
      __cil_tmp16 = *__cil_ap_bj;
#line 302
      __cil_tmp17 = (long *)__cil_tmp16;
#line 302
      __cil_tmp18 = *__cil_tmp15;
#line 302
      __cil_tmp19 = *__cil_tmp17;
#line 302
      __cil_tmp7 = __cil_tmp18 > __cil_tmp19;
#line 302
      if (__cil_tmp7 != 0) {
#line 303
        __cil_tmp20 = *__cil_ap_bj;
#line 303
        __cil_tmp21 = *__cil_ap_sumi;
#line 303
        *__cil_tmp21 = *__cil_tmp20;
#line 304
        __cil_tmp22 = *__cil_ap_sumi;
#line 304
        *__cil_ap_sumi = __cil_tmp22 + 1;
#line 305
        __cil_tmp23 = *__cil_ap_bj;
#line 305
        *__cil_ap_bj = __cil_tmp23 + 1;
      } else {
#line 307
        __cil_tmp24 = *__cil_ap_ai;
#line 307
        __cil_tmp25 = (long *)__cil_tmp24;
#line 307
        __cil_tmp26 = *__cil_ap_bj;
#line 307
        __cil_tmp27 = (long *)__cil_tmp26;
#line 307
        __cil_tmp28 = *__cil_tmp25;
#line 307
        __cil_tmp29 = *__cil_tmp27;
#line 307
        __cil_tmp8 = __cil_tmp28 < __cil_tmp29;
#line 307
        if (__cil_tmp8 != 0) {
#line 308
          __cil_tmp30 = *__cil_ap_ai;
#line 308
          __cil_tmp31 = *__cil_ap_sumi;
#line 308
          *__cil_tmp31 = *__cil_tmp30;
#line 309
          __cil_tmp32 = *__cil_ap_sumi;
#line 309
          *__cil_ap_sumi = __cil_tmp32 + 1;
#line 310
          __cil_tmp33 = *__cil_ap_ai;
#line 310
          *__cil_ap_ai = __cil_tmp33 + 1;
        } else {
#line 313
          __cil_tmp34 = *__cil_ap_ai;
#line 313
          __cil_tmp35 = *__cil_ap_sumi;
#line 313
          *__cil_tmp35 = *__cil_tmp34;
#line 314
          __cil_tmp36 = *__cil_ap_sumi;
#line 314
          __cil_tmp37 = (unsigned char *)__cil_tmp36;
#line 314
          __cil_tmp38 = __cil_tmp37 + 8;
#line 314
          __cil_tmp39 = (float *)__cil_tmp38;
#line 314
          __cil_tmp40 = *__cil_ap_bj;
#line 314
          __cil_tmp41 = (unsigned char *)__cil_tmp40;
#line 314
          __cil_tmp42 = __cil_tmp41 + 8;
#line 314
          __cil_tmp43 = (float *)__cil_tmp42;
#line 314
          __cil_tmp44 = *__cil_tmp39;
#line 314
          __cil_tmp45 = *__cil_tmp43;
#line 314
          __cil_tmp46 = *__cil_ap_sumi;
#line 314
          __cil_tmp47 = (unsigned char *)__cil_tmp46;
#line 314
          __cil_tmp48 = __cil_tmp47 + 8;
#line 314
          __cil_tmp49 = (float *)__cil_tmp48;
#line 314
          *__cil_tmp49 = __cil_tmp44 + __cil_tmp45;
#line 315
          __cil_tmp50 = *__cil_ap_sumi;
#line 315
          __cil_tmp51 = (unsigned char *)__cil_tmp50;
#line 315
          __cil_tmp52 = __cil_tmp51 + 8;
#line 315
          __cil_tmp53 = (float *)__cil_tmp52;
#line 315
          __cil_tmp54 = *__cil_tmp53;
#line 315
          __cil_tmp9 = __cil_tmp54 != (float )0;
#line 315
          if (__cil_tmp9 != 0) {
#line 316
            __cil_tmp55 = *__cil_ap_sumi;
#line 316
            *__cil_ap_sumi = __cil_tmp55 + 1;
          } else {

          }
#line 317
          __cil_tmp56 = *__cil_ap_ai;
#line 317
          *__cil_ap_ai = __cil_tmp56 + 1;
#line 318
          __cil_tmp57 = *__cil_ap_bj;
#line 318
          *__cil_ap_bj = __cil_tmp57 + 1;
        }
      }
#line 325
      add_ss_cil_lr_4(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, __cil_ap_bj);
#line 327
      return;
    } else {
#line 329
      return;
    }
  } else {
#line 333
    return;
  }
#line 337
  add_ss_cil_lr_4(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, __cil_ap_bj);
#line 339
  return;
}
}
#line 342 "svm_common.c"
void add_ss_cil_lr_5(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD *bj ) 
{ 
  WORD *bj_ssa_1 ;
  long __cil_tmp6 ;
  WORD *__cil_tmp7 ;
  WORD *__cil_tmp8 ;
  long *mem_9 ;

  {

#line 321
  return babel_wrapper_add_ss_cil_lr_5(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, bj);
#line 321
  mem_9 = (long *)bj;
#line 321
  __cil_tmp6 = *mem_9;
#line 321
  if (__cil_tmp6 != 0) {
#line 322
    __cil_tmp7 = *__cil_ap_sumi;
#line 322
    *__cil_tmp7 = *bj;
#line 323
    __cil_tmp8 = *__cil_ap_sumi;
#line 323
    *__cil_ap_sumi = __cil_tmp8 + 1;
#line 324
    bj_ssa_1 = bj + 1;
#line 327
    add_ss_cil_lr_5(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, bj_ssa_1);
#line 329
    return;
  } else {
#line 331
    return;
  }
}
}
#line 336 "svm_common.c"
void add_ss_cil_lr_6(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp5 ;
  WORD *__cil_tmp6 ;
  WORD *__cil_tmp7 ;
  long *mem_8 ;

  {

#line 326
  return babel_wrapper_add_ss_cil_lr_6(__cil_ap_sum, __cil_ap_sumi, ai);
#line 326
  mem_8 = (long *)ai;
#line 326
  __cil_tmp5 = *mem_8;
#line 326
  if (__cil_tmp5 != 0) {
#line 327
    __cil_tmp6 = *__cil_ap_sumi;
#line 327
    *__cil_tmp6 = *ai;
#line 328
    __cil_tmp7 = *__cil_ap_sumi;
#line 328
    *__cil_ap_sumi = __cil_tmp7 + 1;
#line 329
    ai_ssa_1 = ai + 1;
#line 332
    add_ss_cil_lr_6(__cil_ap_sum, __cil_ap_sumi, ai_ssa_1);
#line 334
    return;
  } else {
#line 336
    return;
  }
}
}
#line 341 "svm_common.c"
void sub_ss_cil_lr_1(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj , long *__cil_ap_veclength ) 
{ 
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  WORD *__cil_tmp10 ;
  long *__cil_tmp11 ;
  WORD *__cil_tmp12 ;
  long *__cil_tmp13 ;
  WORD *__cil_tmp14 ;
  long *__cil_tmp15 ;
  WORD *__cil_tmp16 ;
  long *__cil_tmp17 ;
  long __cil_tmp18 ;
  long __cil_tmp19 ;
  long __cil_tmp20 ;
  WORD *__cil_tmp21 ;
  WORD *__cil_tmp22 ;
  long *__cil_tmp23 ;
  WORD *__cil_tmp24 ;
  long *__cil_tmp25 ;
  long __cil_tmp26 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  WORD *__cil_tmp29 ;
  long __cil_tmp30 ;
  WORD *__cil_tmp31 ;
  WORD *__cil_tmp32 ;

  {

#line 188
  return babel_wrapper_sub_ss_cil_lr_1(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_bj,
                                       __cil_ap_veclength);
#line 188
  __cil_tmp10 = *__cil_ap_ai;
#line 188
  __cil_tmp11 = (long *)__cil_tmp10;
#line 188
  __cil_tmp6 = *__cil_tmp11;
#line 188
  if (__cil_tmp6 != 0) {
#line 188
    __cil_tmp12 = *__cil_ap_bj;
#line 188
    __cil_tmp13 = (long *)__cil_tmp12;
#line 188
    __cil_tmp7 = *__cil_tmp13;
#line 188
    if (__cil_tmp7 != 0) {
#line 189
      __cil_tmp14 = *__cil_ap_ai;
#line 189
      __cil_tmp15 = (long *)__cil_tmp14;
#line 189
      __cil_tmp16 = *__cil_ap_bj;
#line 189
      __cil_tmp17 = (long *)__cil_tmp16;
#line 189
      __cil_tmp18 = *__cil_tmp15;
#line 189
      __cil_tmp19 = *__cil_tmp17;
#line 189
      __cil_tmp8 = __cil_tmp18 > __cil_tmp19;
#line 189
      if (__cil_tmp8 != 0) {
#line 190
        __cil_tmp20 = *__cil_ap_veclength;
#line 190
        *__cil_ap_veclength = __cil_tmp20 + 1L;
#line 191
        __cil_tmp21 = *__cil_ap_bj;
#line 191
        *__cil_ap_bj = __cil_tmp21 + 1;
      } else {
#line 193
        __cil_tmp22 = *__cil_ap_ai;
#line 193
        __cil_tmp23 = (long *)__cil_tmp22;
#line 193
        __cil_tmp24 = *__cil_ap_bj;
#line 193
        __cil_tmp25 = (long *)__cil_tmp24;
#line 193
        __cil_tmp26 = *__cil_tmp23;
#line 193
        __cil_tmp27 = *__cil_tmp25;
#line 193
        __cil_tmp9 = __cil_tmp26 < __cil_tmp27;
#line 193
        if (__cil_tmp9 != 0) {
#line 194
          __cil_tmp28 = *__cil_ap_veclength;
#line 194
          *__cil_ap_veclength = __cil_tmp28 + 1L;
#line 195
          __cil_tmp29 = *__cil_ap_ai;
#line 195
          *__cil_ap_ai = __cil_tmp29 + 1;
        } else {
#line 198
          __cil_tmp30 = *__cil_ap_veclength;
#line 198
          *__cil_ap_veclength = __cil_tmp30 + 1L;
#line 199
          __cil_tmp31 = *__cil_ap_ai;
#line 199
          *__cil_ap_ai = __cil_tmp31 + 1;
#line 200
          __cil_tmp32 = *__cil_ap_bj;
#line 200
          *__cil_ap_bj = __cil_tmp32 + 1;
        }
      }
#line 207
      sub_ss_cil_lr_1(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_bj, __cil_ap_veclength);
#line 209
      return;
    } else {
#line 211
      return;
    }
  } else {
#line 215
    return;
  }
#line 219
  sub_ss_cil_lr_1(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_bj, __cil_ap_veclength);
#line 221
  return;
}
}
#line 224 "svm_common.c"
void sub_ss_cil_lr_2(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , WORD **__cil_ap_ai ,
                     long *__cil_ap_veclength , WORD *bj ) 
{ 
  WORD *bj_ssa_1 ;
  long __cil_tmp7 ;
  long __cil_tmp8 ;
  long *mem_9 ;

  {

#line 203
  return babel_wrapper_sub_ss_cil_lr_2(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_veclength,
                                       bj);
#line 203
  mem_9 = (long *)bj;
#line 203
  __cil_tmp7 = *mem_9;
#line 203
  if (__cil_tmp7 != 0) {
#line 204
    __cil_tmp8 = *__cil_ap_veclength;
#line 204
    *__cil_ap_veclength = __cil_tmp8 + 1L;
#line 205
    bj_ssa_1 = bj + 1;
#line 208
    sub_ss_cil_lr_2(__cil_ap_a, __cil_ap_b, __cil_ap_ai, __cil_ap_veclength, bj_ssa_1);
#line 210
    return;
  } else {
#line 212
    return;
  }
}
}
#line 217 "svm_common.c"
void sub_ss_cil_lr_3(SVECTOR **__cil_ap_a , SVECTOR **__cil_ap_b , long *__cil_ap_veclength ,
                     WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  long *mem_8 ;

  {

#line 207
  return babel_wrapper_sub_ss_cil_lr_3(__cil_ap_a, __cil_ap_b, __cil_ap_veclength,
                                       ai);
#line 207
  mem_8 = (long *)ai;
#line 207
  __cil_tmp6 = *mem_8;
#line 207
  if (__cil_tmp6 != 0) {
#line 208
    __cil_tmp7 = *__cil_ap_veclength;
#line 208
    *__cil_ap_veclength = __cil_tmp7 + 1L;
#line 209
    ai_ssa_1 = ai + 1;
#line 212
    sub_ss_cil_lr_3(__cil_ap_a, __cil_ap_b, __cil_ap_veclength, ai_ssa_1);
#line 214
    return;
  } else {
#line 216
    return;
  }
}
}
#line 221 "svm_common.c"
void sub_ss_cil_lr_4(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD **__cil_ap_bj ) 
{ 
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  WORD *__cil_tmp10 ;
  long *__cil_tmp11 ;
  WORD *__cil_tmp12 ;
  long *__cil_tmp13 ;
  WORD *__cil_tmp14 ;
  long *__cil_tmp15 ;
  WORD *__cil_tmp16 ;
  long *__cil_tmp17 ;
  long __cil_tmp18 ;
  long __cil_tmp19 ;
  WORD *__cil_tmp20 ;
  WORD *__cil_tmp21 ;
  WORD *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  float *__cil_tmp25 ;
  float __cil_tmp26 ;
  WORD *__cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  float *__cil_tmp30 ;
  WORD *__cil_tmp31 ;
  WORD *__cil_tmp32 ;
  WORD *__cil_tmp33 ;
  long *__cil_tmp34 ;
  WORD *__cil_tmp35 ;
  long *__cil_tmp36 ;
  long __cil_tmp37 ;
  long __cil_tmp38 ;
  WORD *__cil_tmp39 ;
  WORD *__cil_tmp40 ;
  WORD *__cil_tmp41 ;
  WORD *__cil_tmp42 ;
  WORD *__cil_tmp43 ;
  WORD *__cil_tmp44 ;
  WORD *__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  float *__cil_tmp48 ;
  WORD *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  float *__cil_tmp52 ;
  float __cil_tmp53 ;
  float __cil_tmp54 ;
  WORD *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  unsigned char *__cil_tmp57 ;
  float *__cil_tmp58 ;
  WORD *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  unsigned char *__cil_tmp61 ;
  float *__cil_tmp62 ;
  float __cil_tmp63 ;
  WORD *__cil_tmp64 ;
  WORD *__cil_tmp65 ;
  WORD *__cil_tmp66 ;

  {

#line 217
  return babel_wrapper_sub_ss_cil_lr_4(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, __cil_ap_bj);
#line 217
  __cil_tmp10 = *__cil_ap_ai;
#line 217
  __cil_tmp11 = (long *)__cil_tmp10;
#line 217
  __cil_tmp5 = *__cil_tmp11;
#line 217
  if (__cil_tmp5 != 0) {
#line 217
    __cil_tmp12 = *__cil_ap_bj;
#line 217
    __cil_tmp13 = (long *)__cil_tmp12;
#line 217
    __cil_tmp6 = *__cil_tmp13;
#line 217
    if (__cil_tmp6 != 0) {
#line 218
      __cil_tmp14 = *__cil_ap_ai;
#line 218
      __cil_tmp15 = (long *)__cil_tmp14;
#line 218
      __cil_tmp16 = *__cil_ap_bj;
#line 218
      __cil_tmp17 = (long *)__cil_tmp16;
#line 218
      __cil_tmp18 = *__cil_tmp15;
#line 218
      __cil_tmp19 = *__cil_tmp17;
#line 218
      __cil_tmp7 = __cil_tmp18 > __cil_tmp19;
#line 218
      if (__cil_tmp7 != 0) {
#line 219
        __cil_tmp20 = *__cil_ap_bj;
#line 219
        __cil_tmp21 = *__cil_ap_sumi;
#line 219
        *__cil_tmp21 = *__cil_tmp20;
#line 220
        __cil_tmp22 = *__cil_ap_sumi;
#line 220
        __cil_tmp23 = (unsigned char *)__cil_tmp22;
#line 220
        __cil_tmp24 = __cil_tmp23 + 8;
#line 220
        __cil_tmp25 = (float *)__cil_tmp24;
#line 220
        __cil_tmp26 = *__cil_tmp25;
#line 220
        __cil_tmp27 = *__cil_ap_sumi;
#line 220
        __cil_tmp28 = (unsigned char *)__cil_tmp27;
#line 220
        __cil_tmp29 = __cil_tmp28 + 8;
#line 220
        __cil_tmp30 = (float *)__cil_tmp29;
#line 220
        *__cil_tmp30 = __cil_tmp26 * (float )-1;
#line 221
        __cil_tmp31 = *__cil_ap_sumi;
#line 221
        *__cil_ap_sumi = __cil_tmp31 + 1;
#line 222
        __cil_tmp32 = *__cil_ap_bj;
#line 222
        *__cil_ap_bj = __cil_tmp32 + 1;
      } else {
#line 224
        __cil_tmp33 = *__cil_ap_ai;
#line 224
        __cil_tmp34 = (long *)__cil_tmp33;
#line 224
        __cil_tmp35 = *__cil_ap_bj;
#line 224
        __cil_tmp36 = (long *)__cil_tmp35;
#line 224
        __cil_tmp37 = *__cil_tmp34;
#line 224
        __cil_tmp38 = *__cil_tmp36;
#line 224
        __cil_tmp8 = __cil_tmp37 < __cil_tmp38;
#line 224
        if (__cil_tmp8 != 0) {
#line 225
          __cil_tmp39 = *__cil_ap_ai;
#line 225
          __cil_tmp40 = *__cil_ap_sumi;
#line 225
          *__cil_tmp40 = *__cil_tmp39;
#line 226
          __cil_tmp41 = *__cil_ap_sumi;
#line 226
          *__cil_ap_sumi = __cil_tmp41 + 1;
#line 227
          __cil_tmp42 = *__cil_ap_ai;
#line 227
          *__cil_ap_ai = __cil_tmp42 + 1;
        } else {
#line 230
          __cil_tmp43 = *__cil_ap_ai;
#line 230
          __cil_tmp44 = *__cil_ap_sumi;
#line 230
          *__cil_tmp44 = *__cil_tmp43;
#line 231
          __cil_tmp45 = *__cil_ap_sumi;
#line 231
          __cil_tmp46 = (unsigned char *)__cil_tmp45;
#line 231
          __cil_tmp47 = __cil_tmp46 + 8;
#line 231
          __cil_tmp48 = (float *)__cil_tmp47;
#line 231
          __cil_tmp49 = *__cil_ap_bj;
#line 231
          __cil_tmp50 = (unsigned char *)__cil_tmp49;
#line 231
          __cil_tmp51 = __cil_tmp50 + 8;
#line 231
          __cil_tmp52 = (float *)__cil_tmp51;
#line 231
          __cil_tmp53 = *__cil_tmp48;
#line 231
          __cil_tmp54 = *__cil_tmp52;
#line 231
          __cil_tmp55 = *__cil_ap_sumi;
#line 231
          __cil_tmp56 = (unsigned char *)__cil_tmp55;
#line 231
          __cil_tmp57 = __cil_tmp56 + 8;
#line 231
          __cil_tmp58 = (float *)__cil_tmp57;
#line 231
          *__cil_tmp58 = __cil_tmp53 - __cil_tmp54;
#line 232
          __cil_tmp59 = *__cil_ap_sumi;
#line 232
          __cil_tmp60 = (unsigned char *)__cil_tmp59;
#line 232
          __cil_tmp61 = __cil_tmp60 + 8;
#line 232
          __cil_tmp62 = (float *)__cil_tmp61;
#line 232
          __cil_tmp63 = *__cil_tmp62;
#line 232
          __cil_tmp9 = __cil_tmp63 != (float )0;
#line 232
          if (__cil_tmp9 != 0) {
#line 233
            __cil_tmp64 = *__cil_ap_sumi;
#line 233
            *__cil_ap_sumi = __cil_tmp64 + 1;
          } else {

          }
#line 234
          __cil_tmp65 = *__cil_ap_ai;
#line 234
          *__cil_ap_ai = __cil_tmp65 + 1;
#line 235
          __cil_tmp66 = *__cil_ap_bj;
#line 235
          *__cil_ap_bj = __cil_tmp66 + 1;
        }
      }
#line 242
      sub_ss_cil_lr_4(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, __cil_ap_bj);
#line 244
      return;
    } else {
#line 246
      return;
    }
  } else {
#line 250
    return;
  }
#line 254
  sub_ss_cil_lr_4(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, __cil_ap_bj);
#line 256
  return;
}
}
#line 259 "svm_common.c"
void sub_ss_cil_lr_5(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD **__cil_ap_ai ,
                     WORD *bj ) 
{ 
  WORD *bj_ssa_1 ;
  long __cil_tmp6 ;
  WORD *__cil_tmp7 ;
  WORD *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  float *__cil_tmp11 ;
  float __cil_tmp12 ;
  WORD *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  float *__cil_tmp16 ;
  WORD *__cil_tmp17 ;
  long *mem_18 ;

  {

#line 238
  return babel_wrapper_sub_ss_cil_lr_5(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, bj);
#line 238
  mem_18 = (long *)bj;
#line 238
  __cil_tmp6 = *mem_18;
#line 238
  if (__cil_tmp6 != 0) {
#line 239
    __cil_tmp7 = *__cil_ap_sumi;
#line 239
    *__cil_tmp7 = *bj;
#line 240
    __cil_tmp8 = *__cil_ap_sumi;
#line 240
    __cil_tmp9 = (unsigned char *)__cil_tmp8;
#line 240
    __cil_tmp10 = __cil_tmp9 + 8;
#line 240
    __cil_tmp11 = (float *)__cil_tmp10;
#line 240
    __cil_tmp12 = *__cil_tmp11;
#line 240
    __cil_tmp13 = *__cil_ap_sumi;
#line 240
    __cil_tmp14 = (unsigned char *)__cil_tmp13;
#line 240
    __cil_tmp15 = __cil_tmp14 + 8;
#line 240
    __cil_tmp16 = (float *)__cil_tmp15;
#line 240
    *__cil_tmp16 = __cil_tmp12 * (float )-1;
#line 241
    __cil_tmp17 = *__cil_ap_sumi;
#line 241
    *__cil_ap_sumi = __cil_tmp17 + 1;
#line 242
    bj_ssa_1 = bj + 1;
#line 245
    sub_ss_cil_lr_5(__cil_ap_sum, __cil_ap_sumi, __cil_ap_ai, bj_ssa_1);
#line 247
    return;
  } else {
#line 249
    return;
  }
}
}
#line 254 "svm_common.c"
void sub_ss_cil_lr_6(WORD **__cil_ap_sum , WORD **__cil_ap_sumi , WORD *ai ) 
{ 
  WORD *ai_ssa_1 ;
  long __cil_tmp5 ;
  WORD *__cil_tmp6 ;
  WORD *__cil_tmp7 ;
  long *mem_8 ;

  {

#line 244
  return babel_wrapper_sub_ss_cil_lr_6(__cil_ap_sum, __cil_ap_sumi, ai);
#line 244
  mem_8 = (long *)ai;
#line 244
  __cil_tmp5 = *mem_8;
#line 244
  if (__cil_tmp5 != 0) {
#line 245
    __cil_tmp6 = *__cil_ap_sumi;
#line 245
    *__cil_tmp6 = *ai;
#line 246
    __cil_tmp7 = *__cil_ap_sumi;
#line 246
    *__cil_ap_sumi = __cil_tmp7 + 1;
#line 247
    ai_ssa_1 = ai + 1;
#line 250
    sub_ss_cil_lr_6(__cil_ap_sum, __cil_ap_sumi, ai_ssa_1);
#line 252
    return;
  } else {
#line 254
    return;
  }
}
}
#line 259 "svm_common.c"
void sprod_ss_cil_lr_1(double *__cil_ap_sum , WORD *ai , WORD *bj ) 
{ 
  WORD *bj_ssa_1 ;
  WORD *ai_ssa_1 ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  long __cil_tmp10 ;
  long __cil_tmp11 ;
  long __cil_tmp12 ;
  long __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  float *__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  float *__cil_tmp17 ;
  float __cil_tmp18 ;
  float __cil_tmp19 ;
  float __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  long *mem_23 ;
  long *mem_24 ;
  long *mem_25 ;
  long *mem_26 ;
  long *mem_27 ;
  long *mem_28 ;

  {
#line 159
  mem_23 = (long *)ai;
#line 159
  __cil_tmp6 = *mem_23;
#line 159
  if (__cil_tmp6 != 0) {
#line 159
    mem_24 = (long *)bj;
#line 159
    __cil_tmp7 = *mem_24;
#line 159
    if (__cil_tmp7 != 0) {
#line 160
      mem_25 = (long *)ai;
#line 160
      __cil_tmp10 = *mem_25;
#line 160
      mem_26 = (long *)bj;
#line 160
      __cil_tmp11 = *mem_26;
#line 160
      __cil_tmp8 = __cil_tmp10 > __cil_tmp11;
#line 160
      if (__cil_tmp8 != 0) {
#line 161
        bj_ssa_1 = bj + 1;
#line 162
        ai_ssa_1 = ai;
      } else {
#line 163
        mem_27 = (long *)ai;
#line 163
        __cil_tmp12 = *mem_27;
#line 163
        mem_28 = (long *)bj;
#line 163
        __cil_tmp13 = *mem_28;
#line 163
        __cil_tmp9 = __cil_tmp12 < __cil_tmp13;
#line 163
        if (__cil_tmp9 != 0) {
#line 164
          ai_ssa_1 = ai + 1;
#line 165
          bj_ssa_1 = bj;
        } else {
#line 167
          __cil_tmp14 = (unsigned char *)ai + 8;
#line 167
          __cil_tmp15 = (float *)__cil_tmp14;
#line 167
          __cil_tmp16 = (unsigned char *)bj + 8;
#line 167
          __cil_tmp17 = (float *)__cil_tmp16;
#line 167
          __cil_tmp18 = *__cil_tmp15;
#line 167
          __cil_tmp19 = *__cil_tmp17;
#line 167
          __cil_tmp20 = __cil_tmp18 * __cil_tmp19;
#line 167
          __cil_tmp21 = *__cil_ap_sum;
#line 167
          __cil_tmp22 = (double )__cil_tmp20;
#line 167
          *__cil_ap_sum = __cil_tmp21 + __cil_tmp22;
#line 168
          ai_ssa_1 = ai + 1;
#line 169
          bj_ssa_1 = bj + 1;
        }
      }
#line 176
      sprod_ss_cil_lr_1(__cil_ap_sum, ai_ssa_1, bj_ssa_1);
#line 178
      return;
    } else {
#line 180
      return;
    }
  } else {
#line 184
    return;
  }
#line 188
  sprod_ss_cil_lr_1(__cil_ap_sum, ai, bj);
#line 190
  return;
}
}
#line 193 "svm_common.c"
void create_svector_cil_lr_1(WORD **__cil_ap_words , char **__cil_ap_userdefined ,
                             double *__cil_ap_factor , long *__cil_ap_fnum ) 
{ 
  long __cil_tmp5 ;
  WORD *__cil_tmp6 ;
  long __cil_tmp7 ;
  WORD *__cil_tmp8 ;
  long *__cil_tmp9 ;
  long __cil_tmp10 ;

  {
#line 105
  __cil_tmp6 = *__cil_ap_words;
#line 105
  __cil_tmp7 = *__cil_ap_fnum;
#line 105
  __cil_tmp8 = __cil_tmp6 + __cil_tmp7;
#line 105
  __cil_tmp9 = (long *)__cil_tmp8;
#line 105
  __cil_tmp5 = *__cil_tmp9;
#line 105
  if (__cil_tmp5 != 0) {
#line 106
    __cil_tmp10 = *__cil_ap_fnum;
#line 106
    *__cil_ap_fnum = __cil_tmp10 + 1L;
#line 109
    create_svector_cil_lr_1(__cil_ap_words, __cil_ap_userdefined, __cil_ap_factor,
                            __cil_ap_fnum);
#line 112
    return;
  } else {
#line 114
    return;
  }
}
}
#line 119 "svm_common.c"
void create_svector_cil_lr_2(char **__cil_ap_userdefined , double *__cil_ap_factor ,
                             SVECTOR **__cil_ap_vec , WORD *words , long fnum , long i ) 
{ 
  long i_ssa_1 ;
  int __cil_tmp8 ;
  WORD *__cil_tmp9 ;
  SVECTOR *__cil_tmp10 ;
  WORD **__cil_tmp11 ;
  WORD *__cil_tmp12 ;
  WORD *__cil_tmp13 ;

  {
#line 111
  __cil_tmp8 = i < fnum;
#line 111
  if (__cil_tmp8 != 0) {
#line 112
    __cil_tmp9 = words + i;
#line 112
    __cil_tmp10 = *__cil_ap_vec;
#line 112
    __cil_tmp11 = (WORD **)__cil_tmp10;
#line 112
    __cil_tmp12 = *__cil_tmp11;
#line 112
    __cil_tmp13 = __cil_tmp12 + i;
#line 112
    *__cil_tmp13 = *__cil_tmp9;
#line 111
    i_ssa_1 = i + 1L;
#line 114
    create_svector_cil_lr_2(__cil_ap_userdefined, __cil_ap_factor, __cil_ap_vec, words,
                            fnum, i_ssa_1);
#line 117
    return;
  } else {
#line 119
    return;
  }
}
}
#line 124 "svm_common.c"
void create_svector_cil_lr_3(char **__cil_ap_userdefined , double *__cil_ap_factor ,
                             SVECTOR **__cil_ap_vec , long *__cil_ap_fnum ) 
{ 
  char __cil_tmp5 ;
  char *__cil_tmp6 ;
  long __cil_tmp7 ;
  char *__cil_tmp8 ;
  long __cil_tmp9 ;

  {
#line 117
  __cil_tmp6 = *__cil_ap_userdefined;
#line 117
  __cil_tmp7 = *__cil_ap_fnum;
#line 117
  __cil_tmp8 = __cil_tmp6 + __cil_tmp7;
#line 117
  __cil_tmp5 = *__cil_tmp8;
#line 117
  if (__cil_tmp5 != 0) {
#line 118
    __cil_tmp9 = *__cil_ap_fnum;
#line 118
    *__cil_ap_fnum = __cil_tmp9 + 1L;
#line 121
    create_svector_cil_lr_3(__cil_ap_userdefined, __cil_ap_factor, __cil_ap_vec, __cil_ap_fnum);
#line 123
    return;
  } else {
#line 125
    return;
  }
}
}
#line 130 "svm_common.c"
void create_svector_cil_lr_4(double *__cil_ap_factor , SVECTOR **__cil_ap_vec , char *userdefined ,
                             long fnum , long i ) 
{ 
  long i_ssa_1 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  SVECTOR *__cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  char **__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 122
  __cil_tmp7 = i < fnum;
#line 122
  if (__cil_tmp7 != 0) {
#line 123
    __cil_tmp8 = userdefined + i;
#line 123
    __cil_tmp9 = *__cil_ap_vec;
#line 123
    __cil_tmp10 = (unsigned char *)__cil_tmp9;
#line 123
    __cil_tmp11 = __cil_tmp10 + 16;
#line 123
    __cil_tmp12 = (char **)__cil_tmp11;
#line 123
    __cil_tmp13 = *__cil_tmp12;
#line 123
    __cil_tmp14 = __cil_tmp13 + i;
#line 123
    *__cil_tmp14 = *__cil_tmp8;
#line 122
    i_ssa_1 = i + 1L;
#line 125
    create_svector_cil_lr_4(__cil_ap_factor, __cil_ap_vec, userdefined, fnum, i_ssa_1);
#line 127
    return;
  } else {
#line 129
    return;
  }
}
}
#line 134 "svm_common.c"
void kernel_cil_lr_1(double *__cil_ap_sum , KERNEL_PARM *kernel_parm , DOC *b , SVECTOR *fa ) 
{ 
  KERNEL_PARM **__cil_pp_kernel_parm ;
  DOC **__cil_pp_b ;
  SVECTOR **__cil_pp_fa ;
  KERNEL_PARM **__cil_fp_kernel_parm ;
  DOC **__cil_fp_b ;
  SVECTOR **__cil_fp_fa ;
  SVECTOR *fb_ssa_1 ;
  KERNEL_PARM *kernel_parm_ssa_1 ;
  DOC *b_ssa_1 ;
  SVECTOR *fa_ssa_1 ;
  SVECTOR *fa_ssa_2 ;
  unsigned char *__cil_tmp18 ;
  SVECTOR **__cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  struct svector **__cil_tmp21 ;

  {
#line 136
  __cil_pp_kernel_parm = & kernel_parm;
#line 137
  __cil_pp_b = & b;
#line 138
  __cil_pp_fa = & fa;
#line 139
  __cil_fp_kernel_parm = & kernel_parm;
#line 140
  __cil_fp_b = & b;
#line 141
  __cil_fp_fa = & fa;
#line 70
  if (fa != 0) {
#line 71
    __cil_tmp18 = (unsigned char *)b + 32;
#line 71
    __cil_tmp19 = (SVECTOR **)__cil_tmp18;
#line 71
    fb_ssa_1 = *__cil_tmp19;
#line 74
    *__cil_fp_kernel_parm = kernel_parm;
#line 75
    *__cil_fp_b = b;
#line 76
    *__cil_fp_fa = fa;
#line 71
    kernel_cil_lr_1_cil_lr_1(__cil_pp_kernel_parm, __cil_pp_b, __cil_pp_fa, __cil_ap_sum,
                             fb_ssa_1);
#line 73
    kernel_parm_ssa_1 = *__cil_fp_kernel_parm;
#line 74
    b_ssa_1 = *__cil_fp_b;
#line 75
    fa_ssa_1 = *__cil_fp_fa;
#line 70
    __cil_tmp20 = (unsigned char *)fa_ssa_1 + 32;
#line 70
    __cil_tmp21 = (struct svector **)__cil_tmp20;
#line 70
    fa_ssa_2 = *__cil_tmp21;
#line 73
    kernel_cil_lr_1(__cil_ap_sum, kernel_parm_ssa_1, b_ssa_1, fa_ssa_2);
#line 75
    return;
  } else {
#line 77
    return;
  }
}
}
#line 81 "svm_common.c"
void classify_example_linear_cil_lr_1(MODEL **__cil_ap_model , double *__cil_ap_sum ,
                                      SVECTOR *f ) 
{ 
  double tmp_ssa_1 ;
  SVECTOR *f_ssa_1 ;
  MODEL *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  double **__cil_tmp10 ;
  double *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  double *__cil_tmp13 ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  struct svector **__cil_tmp18 ;

  {

#line 55
  return babel_wrapper_classify_example_linear_cil_lr_1(__cil_ap_model, __cil_ap_sum,
                                                        f);
#line 55
  if (f != 0) {
#line 56
    __cil_tmp7 = *__cil_ap_model;
#line 56
    __cil_tmp8 = (unsigned char *)__cil_tmp7;
#line 56
    __cil_tmp9 = __cil_tmp8 + 208;
#line 56
    __cil_tmp10 = (double **)__cil_tmp9;
#line 56
    __cil_tmp11 = *__cil_tmp10;
#line 56
    tmp_ssa_1 = sprod_ns(__cil_tmp11, f);
#line 56
    __cil_tmp12 = (unsigned char *)f + 40;
#line 56
    __cil_tmp13 = (double *)__cil_tmp12;
#line 56
    __cil_tmp14 = *__cil_tmp13;
#line 56
    __cil_tmp15 = *__cil_ap_sum;
#line 56
    __cil_tmp16 = __cil_tmp14 * tmp_ssa_1;
#line 56
    *__cil_ap_sum = __cil_tmp15 + __cil_tmp16;
#line 55
    __cil_tmp17 = (unsigned char *)f + 32;
#line 55
    __cil_tmp18 = (struct svector **)__cil_tmp17;
#line 55
    f_ssa_1 = *__cil_tmp18;
#line 58
    classify_example_linear_cil_lr_1(__cil_ap_model, __cil_ap_sum, f_ssa_1);
#line 60
    return;
  } else {
#line 62
    return;
  }
}
}
#line 66 "svm_common.c"
void classify_example_cil_lr_1(MODEL **__cil_ap_model , double *__cil_ap_dist , DOC *ex ,
                               long i ) 
{ 
  double tmp___0_ssa_1 ;
  long i_ssa_1 ;
  int __cil_tmp8 ;
  MODEL *__cil_tmp9 ;
  long *__cil_tmp10 ;
  long __cil_tmp11 ;
  MODEL *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  MODEL *__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  DOC ***__cil_tmp18 ;
  DOC **__cil_tmp19 ;
  DOC **__cil_tmp20 ;
  DOC *__cil_tmp21 ;
  MODEL *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  double **__cil_tmp25 ;
  double *__cil_tmp26 ;
  double *__cil_tmp27 ;
  double __cil_tmp28 ;
  double __cil_tmp29 ;
  double __cil_tmp30 ;

  {

#line 36
  return babel_wrapper_classify_example_cil_lr_1(__cil_ap_model, __cil_ap_dist, ex,
                                                 i);
#line 36
  __cil_tmp9 = *__cil_ap_model;
#line 36
  __cil_tmp10 = (long *)__cil_tmp9;
#line 36
  __cil_tmp11 = *__cil_tmp10;
#line 36
  __cil_tmp8 = i < __cil_tmp11;
#line 36
  if (__cil_tmp8 != 0) {
#line 37
    __cil_tmp12 = *__cil_ap_model;
#line 37
    __cil_tmp13 = (unsigned char *)__cil_tmp12;
#line 37
    __cil_tmp14 = __cil_tmp13 + 64;
#line 37
    __cil_tmp15 = *__cil_ap_model;
#line 37
    __cil_tmp16 = (unsigned char *)__cil_tmp15;
#line 37
    __cil_tmp17 = __cil_tmp16 + 24;
#line 37
    __cil_tmp18 = (DOC ***)__cil_tmp17;
#line 37
    __cil_tmp19 = *__cil_tmp18;
#line 37
    __cil_tmp20 = __cil_tmp19 + i;
#line 37
    __cil_tmp21 = *__cil_tmp20;
#line 37
    tmp___0_ssa_1 = kernel((KERNEL_PARM *)__cil_tmp14, __cil_tmp21, ex);
#line 37
    __cil_tmp22 = *__cil_ap_model;
#line 37
    __cil_tmp23 = (unsigned char *)__cil_tmp22;
#line 37
    __cil_tmp24 = __cil_tmp23 + 32;
#line 37
    __cil_tmp25 = (double **)__cil_tmp24;
#line 37
    __cil_tmp26 = *__cil_tmp25;
#line 37
    __cil_tmp27 = __cil_tmp26 + i;
#line 37
    __cil_tmp28 = *__cil_tmp27;
#line 37
    __cil_tmp29 = *__cil_ap_dist;
#line 37
    __cil_tmp30 = tmp___0_ssa_1 * __cil_tmp28;
#line 37
    *__cil_ap_dist = __cil_tmp29 + __cil_tmp30;
#line 36
    i_ssa_1 = i + 1L;
#line 39
    classify_example_cil_lr_1(__cil_ap_model, __cil_ap_dist, ex, i_ssa_1);
#line 41
    return;
  } else {
#line 43
    return;
  }
}
}
//#include <gprolog.h>
//
//lBool babel_ptrR(PlLong* p,  PlLong* star_p, PlLong len)
//{
//
//	if (star_p == 0)
//	    return PL_FALSE;
//	else
//	{
//		switch(len)
//		{
//		    case 1:
//		    	*p = *(unsigned char*)star_p;
//		    	break;
//		    case 2:
//		    	*p = *(short*)star_p;
//		    	break;
//		    case 4:
//		    	*p = *(int*)star_p;
//		    	break;
//		    case 8:
//		    	*p = *(long long*)star_p;
//		    	break;
//		    default :
//		    	printf("undefined exp length in babel_ptrR\n");
//		}
//	}
//
//		return PL_TRUE;
//}
//
//PlBool babel_ptrR_byte(PlLong* p,  PlLong* star_p, PlLong len)
//{
//
//	if (star_p == 0)
//	    return PL_FALSE;
//	else
//	{
//		switch(len)
//		{
//		    case 1:
//		    	*p = *(unsigned char*)star_p;
//		    	break;
//		    case 2:
//		    	*p = *(short*)star_p;
//		    	break;
//		    case 4:
//		    	*p = *(int*)star_p;
//		    	break;
//		    case 8:
//		    	*p = *(long long*)star_p;
//		    	break;
//		    default :
//		    	printf("undefined exp length in babel_ptrR\n");
//		}
//	}
//
//	return PL_TRUE;
//}
//
//PlBool babel_ptrE(PlLong* p,  PlLong e, PlLong len)
//{
//	if (p == 0)
//	    return PL_FALSE;
//
//	switch(len)
//		{
//		    case 1:
//		    	*(unsigned char*)p = (unsigned char)e;
//		    	break;
//		    case 2:
//		    	*(short*) p = (short)e;
//		    	break;
//		    case 4:
//		    	*(int*)p = (int)e;
//		    	break;
//		    case 8:
//		    	*(long long*)p = (long long)e;
//		    	break;
//		    default :
//		    	printf("undefined exp length in babel_ptrL\n");
//		}
//
//        return PL_TRUE;
//}
//
//PlBool babel_ptrFR(double* fp, PlLong ptr, PlLong len)
//{
//  if(len == 2)
//  *(double *)fp = *(double *)ptr;
//   else if (len == 1)
//  *(float *)fp = *(float *)ptr;
//  else
//  return PL_FALSE;
//
//  return PL_TRUE;
//}
//
//PlBool babel_ptrFW(PlLong ptr, double f, PlLong len)
//{
//  if (len == 2)
//  *(double *)ptr = f;
//   else if (len == 1)
//  *(float *)ptr = f;
//  else
//  return PL_FALSE;
//  
//  return PL_TRUE;
//}

PlBool babel__implicit_classify_examplec_0(MODEL * arg_0, DOC * arg_1, double * babel_ret) 
{
*babel_ret = classify_example_linear(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_classify_examplec_1(MODEL ** arg_0, double * arg_1, DOC * arg_2, long  arg_3) 
{
classify_example_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_classify_examplec_2(MODEL ** arg_0, double * arg_1, DOC * arg_2, long  arg_3) 
{
classify_example_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_classify_example_linearc_3(MODEL ** arg_0, double * arg_1, SVECTOR * arg_2) 
{
classify_example_linear_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_free_svectorc_4(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_free_svectorc_5(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_free_svectorc_6(struct svector * arg_0) 
{
free_svector(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_free_svectorc_7(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_8(SVECTOR ** arg_0, SVECTOR ** arg_1, WORD ** arg_2, WORD ** arg_3, long * arg_4) 
{
sub_ss_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_9(SVECTOR ** arg_0, SVECTOR ** arg_1, WORD ** arg_2, long * arg_3, WORD * arg_4) 
{
sub_ss_cil_lr_2(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_10(SVECTOR ** arg_0, SVECTOR ** arg_1, long * arg_2, WORD * arg_3) 
{
sub_ss_cil_lr_3(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_11(unsigned long  arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_12(WORD ** arg_0, WORD ** arg_1, WORD ** arg_2, WORD ** arg_3) 
{
sub_ss_cil_lr_4(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_13(WORD ** arg_0, WORD ** arg_1, WORD ** arg_2, WORD * arg_3) 
{
sub_ss_cil_lr_5(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_14(WORD ** arg_0, WORD ** arg_1, WORD * arg_2) 
{
sub_ss_cil_lr_6(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_15(WORD * arg_0, char * arg_1, float arg_2, PlLong * babel_ret) 
{
*babel_ret = create_svector(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_sub_ssc_16(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_17(SVECTOR ** arg_0, SVECTOR ** arg_1, WORD ** arg_2, WORD ** arg_3, long * arg_4) 
{
add_ss_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_18(SVECTOR ** arg_0, SVECTOR ** arg_1, WORD ** arg_2, long * arg_3, WORD * arg_4) 
{
add_ss_cil_lr_2(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_19(SVECTOR ** arg_0, SVECTOR ** arg_1, long * arg_2, WORD * arg_3) 
{
add_ss_cil_lr_3(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_20(unsigned long  arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_21(WORD ** arg_0, WORD ** arg_1, WORD ** arg_2, WORD ** arg_3) 
{
add_ss_cil_lr_4(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_22(WORD ** arg_0, WORD ** arg_1, WORD ** arg_2, WORD * arg_3) 
{
add_ss_cil_lr_5(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_23(WORD ** arg_0, WORD ** arg_1, WORD * arg_2) 
{
add_ss_cil_lr_6(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_24(WORD * arg_0, char * arg_1, float arg_2, PlLong * babel_ret) 
{
*babel_ret = create_svector(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_add_ssc_25(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_append_svector_listc_26(SVECTOR ** arg_0, SVECTOR ** arg_1) 
{
append_svector_list_cil_lr_1(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_smult_sc_27(SVECTOR ** arg_0, double * arg_1, long * arg_2, WORD * arg_3) 
{
smult_s_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_smult_sc_28(unsigned long  arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_smult_sc_29(SVECTOR ** arg_0, WORD ** arg_1, WORD ** arg_2, double  arg_3, WORD * arg_4) 
{
smult_s_cil_lr_2(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_smult_sc_30(WORD * arg_0, char * arg_1, double  arg_2, PlLong * babel_ret) 
{
*babel_ret = create_svector(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_smult_sc_31(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_model_length_sc_32(double * arg_0, MODEL * arg_1, KERNEL_PARM * arg_2, long  arg_3) 
{
model_length_s_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_model_length_sc_33(double  arg_0, double * babel_ret) 
{
*babel_ret = sqrt(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_add_weight_vector_to_linear_modelc_34(unsigned long  arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_add_weight_vector_to_linear_modelc_35(double * arg_0, long  arg_1) 
{
clear_vector_n(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_add_weight_vector_to_linear_modelc_36(MODEL * arg_0, long  arg_1) 
{
add_weight_vector_to_linear_model_cil_lr_1(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_create_examplec_37(int arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_free_examplec_38(SVECTOR * arg_0) 
{
free_svector(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_free_examplec_39(void * arg_0) 
{
free(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_40(char const   * __restrict   arg_0) 
{
printf(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_41(struct _IO_FILE * arg_0) 
{
fflush(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_42(char const   * __restrict   arg_0, char const   * __restrict   arg_1, PlLong * babel_ret) 
{
*babel_ret = fopen(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_43(char const   * arg_0) 
{
perror(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_44(int arg_0) 
{
exit(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_45(FILE * __restrict   arg_0, char const   * __restrict   arg_1, char* arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_46(FILE * __restrict   arg_0, char const   * __restrict   arg_1, long  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_47(FILE * __restrict   arg_0, char const   * __restrict   arg_1, long  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_48(FILE * __restrict   arg_0, char const   * __restrict   arg_1, double  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_49(FILE * __restrict   arg_0, char const   * __restrict   arg_1, double  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_50(FILE * __restrict   arg_0, char const   * __restrict   arg_1, double  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_51(FILE * __restrict   arg_0, char const   * __restrict   arg_1, char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_52(FILE * __restrict   arg_0, char const   * __restrict   arg_1, long  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_53(FILE * __restrict   arg_0, char const   * __restrict   arg_1, long  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_54(long * arg_0, MODEL ** arg_1, FILE ** arg_2, long * arg_3, long  arg_4) 
{
write_model_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_55(FILE * __restrict   arg_0, char const   * __restrict   arg_1, long  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_56(FILE * __restrict   arg_0, char const   * __restrict   arg_1, double  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_57(long * arg_0, FILE ** arg_1, MODEL * arg_2, long  arg_3) 
{
write_model_cil_lr_2(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_58(FILE * arg_0) 
{
fclose(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_write_modelc_59(char const   * __restrict   arg_0) 
{
printf(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copy_modelc_60(int arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copy_modelc_61(unsigned long  arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copy_modelc_62(unsigned long  arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copy_modelc_63(MODEL ** arg_0, MODEL ** arg_1, long  arg_2) 
{
copy_model_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_copy_modelc_64(unsigned long  arg_0, PlLong * babel_ret) 
{
*babel_ret = my_malloc(arg_0);
return PL_TRUE;
}
PlBool babel__implicit_copy_modelc_65(MODEL ** arg_0, MODEL * arg_1, long  arg_2) 
{
copy_model_cil_lr_2(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_2_cil_lr_1_cil_lr_1c_66(FILE * __restrict   arg_0, char const   * __restrict   arg_1, long  arg_2, double  arg_3) 
{
fprintf(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_2_cil_lr_1c_68(FILE * __restrict   arg_0, char const   * __restrict   arg_1, double  arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_2_cil_lr_1c_69(SVECTOR ** arg_0, FILE ** arg_1, long  arg_2) 
{
write_model_cil_lr_2_cil_lr_1_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_2_cil_lr_1c_70(FILE * __restrict   arg_0, char const   * __restrict   arg_1, char * arg_2) 
{
fprintf(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_2_cil_lr_1c_71(MODEL ** arg_0, long * arg_1, FILE ** arg_2, SVECTOR * arg_3) 
{
write_model_cil_lr_2_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1c_73(double * arg_0, SVECTOR * arg_1, double  arg_2) 
{
add_vector_ns(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_model_length_s_cil_lr_1_cil_lr_1c_75(KERNEL_PARM * arg_0, DOC * arg_1, DOC * arg_2, double * babel_ret) 
{
*babel_ret = kernel(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_1c_78(long * arg_0, long * arg_1, SVECTOR * arg_2) 
{
write_model_cil_lr_1_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_1c_79(long * arg_0, MODEL ** arg_1, FILE ** arg_2, long * arg_3, long  arg_4) 
{
write_model_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_2c_80(MODEL ** arg_0, long * arg_1, FILE ** arg_2, SVECTOR * arg_3) 
{
write_model_cil_lr_2_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_write_model_cil_lr_2c_81(long * arg_0, FILE ** arg_1, MODEL * arg_2, long  arg_3) 
{
write_model_cil_lr_2(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_add_weight_vector_to_linear_model_cil_lr_1c_82(MODEL ** arg_0, long * arg_1, SVECTOR * arg_2) 
{
add_weight_vector_to_linear_model_cil_lr_1_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_add_weight_vector_to_linear_model_cil_lr_1c_83(MODEL * arg_0, long  arg_1) 
{
add_weight_vector_to_linear_model_cil_lr_1(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_model_length_s_cil_lr_1c_84(MODEL ** arg_0, KERNEL_PARM ** arg_1, long * arg_2, double * arg_3, double  arg_4, DOC * arg_5, long  arg_6) 
{
model_length_s_cil_lr_1_cil_lr_1(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6);
return PL_TRUE;
}
PlBool babel__implicit_model_length_s_cil_lr_1c_85(double * arg_0, MODEL * arg_1, KERNEL_PARM * arg_2, long  arg_3) 
{
model_length_s_cil_lr_1(arg_0, arg_1, arg_2, arg_3);
return PL_TRUE;
}
PlBool babel__implicit_classify_example_linear_cil_lr_1c_106(double * arg_0, SVECTOR * arg_1, double * babel_ret) 
{
*babel_ret = sprod_ns(arg_0, arg_1);
return PL_TRUE;
}
PlBool babel__implicit_classify_example_cil_lr_1c_108(KERNEL_PARM * arg_0, DOC * arg_1, DOC * arg_2, double * babel_ret) 
{
*babel_ret = kernel(arg_0, arg_1, arg_2);
return PL_TRUE;
}


PlBool babel__implicit_clear_vector_nc_0(double * arg_0, long  arg_1, long  arg_2) 
{
clear_vector_n_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
PlBool babel__implicit_add_vector_nsc_1(double * arg_0, double  arg_1, WORD * arg_2) 
{
add_vector_ns_cil_lr_1(arg_0, arg_1, arg_2);
return PL_TRUE;
}
