#include <stdbool.h>
 static int label = -1;/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h"
typedef unsigned long size_t;
#line 8 "regexp.h"
struct regexp {
   char *startp[10] ;
   char *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
#line 8 "regexp.h"
typedef struct regexp regexp;
#line 122 "regexp.c"
struct comp {
   char *regparse ;
   int regnpar ;
   char *regcode ;
   char regdummy[3] ;
   long regsize ;
};
#line 648 "regexp.c"
struct exec {
   char *reginput ;
   char *regbol ;
   char **regstartp ;
   char **regendp ;
};
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 49 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 146
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 235
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 284
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 288
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 18 "regexp.h"
regexp *regcomp(char const   *exp ) ;
#line 19
int regexec(regexp *prog , char const   *str ) ;
#line 21
extern void regerror(char *message ) ;
#line 134 "regexp.c"
static char *reg(struct comp *cp , int paren , int *flagp ) ;
#line 135
static char *regbranch(struct comp *cp , int *flagp ) ;
#line 136
static char *regpiece(struct comp *cp , int *flagp ) ;
#line 137
static char *regatom(struct comp *cp , int *flagp ) ;
#line 138
static char *regnode(struct comp *cp , char op ) ;
#line 139
static char *regnext(char *p ) ;
#line 140
static void regc(struct comp *cp , char b ) ;
#line 141
static void reginsert(struct comp *cp , char op , char *opnd ) ;
#line 142
static void regtail(struct comp *cp , char *p , char *val ) ;
#line 143
static void regoptail(struct comp *cp , char *p , char *val ) ;
#line 658
static int regtry(struct exec *ep , regexp *prog , char *string ) ;
#line 659
static int regmatch(struct exec *ep , char *prog ) ;
#line 660
static size_t regrepeat(struct exec *ep , char *node ) ;
#line 661

   char * babel_wrapper_regnode(struct comp * cp, char  op)                           // function name insert
      {
        // wrapper for function regnode        // function name insert
         char * return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("regnode"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      //  arg[0] = Pl_Mk_Integer(n);
      arg[0] = Pl_Mk_Integer(cp);
arg[1] = Pl_Mk_Integer(op);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return return_value;
        }
      
   int babel_wrapper_regc(struct comp * cp, char  b)                           // function name insert
      {
        // wrapper for function regc        // function name insert
         int return_value; //  return value type (how about array type)

        //rountine code
        int func;
        PlTerm arg[3];    //  function variable + return value insert
        PlBool res;

        func = Pl_Find_Atom("regc"); // function name insert

      //routine code
        Pl_Query_Begin(PL_FALSE);

      //prepare parameters
      //partial routine code, pass in parameter  // we need to init arguments and return value
      //  arg[0] = Pl_Mk_Integer(n);
      arg[0] = Pl_Mk_Integer(cp);
arg[1] = Pl_Mk_Integer(b);

      //routine code, reserve a place for return value
      arg[2] = Pl_Mk_Variable();

      //partial routine code, 2 is not routine. (number of arguments) + 1
        res = Pl_Query_Call(func, 3, arg);          // insert (variable+return value)

      //get return value, partial routine code, 1 is not routine
        return_value = Pl_Rd_Integer(arg[2]);        // insert ()

      //routine code
        Pl_Query_End(PL_KEEP_FOR_PROLOG);

      //routine code
        return 0;
        }
      
      
//   size_t  babel_wrapper_regrepeat(size_t * __cil_pp_count, size_t * __cil_fp_count, struct exec * ep, char * node)                           // function name insert
//      {
//        // wrapper for function regrepeat        // function name insert
//         size_t  return_value; //  return value type (how about array type)
//
//        //rountine code
//        int func;
//        PlTerm arg[5];    //  function variable + return value insert
//        PlBool res;
//
//        func = Pl_Find_Atom("regrepeat"); // function name insert
//
//      //routine code
//        Pl_Query_Begin(PL_FALSE);
//
//      //prepare parameters
//      //partial routine code, pass in parameter  // we need to init arguments and return value
//      //  arg[0] = Pl_Mk_Integer(n);
//      arg[0] = Pl_Mk_Integer(__cil_pp_count);
//arg[1] = Pl_Mk_Integer(__cil_fp_count);
//arg[2] = Pl_Mk_Integer(ep);
//arg[3] = Pl_Mk_Integer(node);
//
//      //routine code, reserve a place for return value
//      arg[4] = Pl_Mk_Variable();
//
//      //partial routine code, 2 is not routine. (number of arguments) + 1
//        res = Pl_Query_Call(func, 5, arg);          // insert (variable+return value)
//
//      //get return value, partial routine code, 1 is not routine
//        return_value = Pl_Rd_Integer(arg[4]);        // insert ()
//
//      //routine code
//        Pl_Query_End(PL_KEEP_FOR_PROLOG);
//
//      //routine code
//        return return_value;
//        }
//      
//   char * babel_wrapper_regnext(char * p)                           // function name insert
//      {
//        // wrapper for function regnext        // function name insert
//         char * return_value; //  return value type (how about array type)
//
//        //rountine code
//        int func;
//        PlTerm arg[2];    //  function variable + return value insert
//        PlBool res;
//
//        func = Pl_Find_Atom("regnext"); // function name insert
//
//      //routine code
//        Pl_Query_Begin(PL_FALSE);
//
//      //prepare parameters
//      //partial routine code, pass in parameter  // we need to init arguments and return value
//      //  arg[0] = Pl_Mk_Integer(n);
//      arg[0] = Pl_Mk_Integer(p);
//
//      //routine code, reserve a place for return value
//      arg[1] = Pl_Mk_Variable();
//
//      //partial routine code, 2 is not routine. (number of arguments) + 1
//        res = Pl_Query_Call(func, 2, arg);          // insert (variable+return value)
//
//      //get return value, partial routine code, 1 is not routine
//        return_value = Pl_Rd_Integer(arg[1]);        // insert ()
//
//      //routine code
//        Pl_Query_End(PL_KEEP_FOR_PROLOG);
//
//      //routine code
//        return return_value;
//        }
//      
//   int babel_wrapper_regrepeat_cil_lr_1(size_t * __cil_ap_count, char * scan, char  ch)                           // function name insert
//      {
//        // wrapper for function regrepeat_cil_lr_1        // function name insert
//         int return_value; //  return value type (how about array type)
//
//        //rountine code
//        int func;
//        PlTerm arg[4];    //  function variable + return value insert
//        PlBool res;
//
//        func = Pl_Find_Atom("regrepeat_cil_lr_1"); // function name insert
//
//      //routine code
//        Pl_Query_Begin(PL_FALSE);
//
//      //prepare parameters
//      //partial routine code, pass in parameter  // we need to init arguments and return value
//      //  arg[0] = Pl_Mk_Integer(n);
//      arg[0] = Pl_Mk_Integer(__cil_ap_count);
//arg[1] = Pl_Mk_Integer(scan);
//arg[2] = Pl_Mk_Integer(ch);
//
//      //routine code, reserve a place for return value
//      arg[3] = Pl_Mk_Variable();
//
//      //partial routine code, 2 is not routine. (number of arguments) + 1
//        res = Pl_Query_Call(func, 4, arg);          // insert (variable+return value)
//
//      //get return value, partial routine code, 1 is not routine
//        return_value = Pl_Rd_Integer(arg[3]);        // insert ()
//
//      //routine code
//        Pl_Query_End(PL_KEEP_FOR_PROLOG);
//
//      //routine code
//        return 0;
//        }
      
regexp *
regcomp(exp)
const char *exp;
{
 register regexp *r;
 register char *scan;
 int flags;
 struct comp co;
 if (exp == ((void *)0))
  { regerror("NULL argument to regcomp"); return(((void *)0)); };
 co.regparse = (char *)exp;
 co.regnpar = 1;
 co.regsize = 0L;
 co.regdummy[0] = 9;
 co.regdummy[1] = co.regdummy[2] = 0;
 co.regcode = co.regdummy;
 regc(&co, 0234);
 if (reg(&co, 0, &flags) == ((void *)0))
  return(((void *)0));
 if (co.regsize >= 0x7fffL)
  { regerror("regexp too big"); return(((void *)0)); };
 r = (regexp *)malloc(sizeof(regexp) + (size_t)co.regsize);
 if (r == ((void *)0))
  { regerror("out of space"); return(((void *)0)); };
 co.regparse = (char *)exp;
 co.regnpar = 1;
 co.regcode = r->program;
 regc(&co, 0234);
 if (reg(&co, 0, &flags) == ((void *)0))
  return(((void *)0));
 r->regstart = '\0';
 r->reganch = 0;
 r->regmust = ((void *)0);
 r->regmlen = 0;
 scan = r->program+1;
 if ((*(regnext(scan))) == 0) {
  scan = ((scan) + 3);
  if ((*(scan)) == 8)
   r->regstart = *((scan) + 3);
  else if ((*(scan)) == 1)
   r->reganch = 1;
  if (flags&04) {
   register char *longest = ((void *)0);
   register size_t len = 0;
   for (; scan != ((void *)0); scan = regnext(scan))
    if ((*(scan)) == 8 && strlen(((scan) + 3)) >= len) {
     longest = ((scan) + 3);
     len = strlen(((scan) + 3));
    }
   r->regmust = longest;
   r->regmlen = (int)len;
  }
 }
 return(r);
}

static char *
reg(cp, paren, flagp)
register struct comp *cp;
int paren;
int *flagp;
{
 register char *ret;
 register char *br;
 register char *ender;
 register int parno;
 int flags;
 *flagp = 01;
 if (paren) {
  if (cp->regnpar >= 10)
   { regerror("too many ()"); return(((void *)0)); };
  parno = cp->regnpar;
  cp->regnpar++;
  ret = regnode(cp, 20 +parno);
 }
 br = regbranch(cp, &flags);
 if (br == ((void *)0))
  return(((void *)0));
 if (paren)
  regtail(cp, ret, br);
 else
  ret = br;
 *flagp &= ~(~flags&01);
 *flagp |= flags&04;
 while (*cp->regparse == '|') {
  cp->regparse++;
  br = regbranch(cp, &flags);
  if (br == ((void *)0))
   return(((void *)0));
  regtail(cp, ret, br);
  *flagp &= ~(~flags&01);
  *flagp |= flags&04;
 }
 ender = regnode(cp, (paren) ? 30 +parno : 0);
 regtail(cp, ret, ender);
 for (br = ret; br != ((void *)0); br = regnext(br))
  regoptail(cp, br, ender);
 if (paren && *cp->regparse++ != ')') {
  { regerror("unterminated ()"); return(((void *)0)); };
 } else if (!paren && *cp->regparse != '\0') {
  if (*cp->regparse == ')') {
   { regerror("unmatched ()"); return(((void *)0)); };
  } else
   { regerror("internal error: junk on end"); return(((void *)0)); };
 }
 return(ret);
}

#line 360 "regexp.c"
static char *regpiece(struct comp *cp , int *flagp ) 
{ 
  char *ret ;
  char op ;
  char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *mem_14 ;
  char *mem_15 ;
  char *mem_16 ;
  char *mem_17 ;

  {
#line 370
  ret = regatom(cp, & flags);
#line 371
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 372
    return ((char *)((void *)0));
  } else {

  }
#line 374
  mem_14 = cp->regparse;
#line 374
  op = *mem_14;
#line 375
  if ((int )op != 42) {
#line 375
    if ((int )op != 43) {
#line 375
      if ((int )op != 63) {
#line 376
        *flagp = flags;
#line 377
        return (ret);
      } else {

      }
    } else {

    }
  } else {

  }
#line 380
  if ((flags & 1) == 0) {
#line 380
    if ((int )op != 63) {
#line 381
      regerror((char *)"*+ operand could be empty");
#line 381
      return ((char *)((void *)0));
    } else {

    }
  } else {

  }
  {
#line 383
  if ((int )op == 42) {
#line 383
    goto case_42;
  } else {

  }
#line 384
  if ((int )op == 43) {
#line 384
    goto case_43;
  } else {

  }
#line 385
  if ((int )op == 63) {
#line 385
    goto case_63;
  } else {

  }
#line 382
  goto switch_break;
  case_42: /* CIL Label */ 
#line 383
  *flagp = 4;
#line 383
  goto switch_break;
  case_43: /* CIL Label */ 
#line 384
  *flagp = 5;
#line 384
  goto switch_break;
  case_63: /* CIL Label */ 
#line 385
  *flagp = 0;
#line 385
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 388
  if ((int )op == 42) {
#line 388
    if ((flags & 2) != 0) {
#line 389
      reginsert(cp, (char)10, ret);
    } else {
#line 388
      goto _L___0;
    }
  } else
  _L___0: 
#line 390
  if ((int )op == 42) {
#line 392
    reginsert(cp, (char)6, ret);
#line 393
    tmp = regnode(cp, (char)7);
#line 393
    regoptail(cp, ret, tmp);
#line 394
    regoptail(cp, ret, ret);
#line 395
    tmp___0 = regnode(cp, (char)6);
#line 395
    regtail(cp, ret, tmp___0);
#line 396
    tmp___1 = regnode(cp, (char)9);
#line 396
    regtail(cp, ret, tmp___1);
  } else
#line 397
  if ((int )op == 43) {
#line 397
    if ((flags & 2) != 0) {
#line 398
      reginsert(cp, (char)11, ret);
    } else {
#line 397
      goto _L;
    }
  } else
  _L: 
#line 399
  if ((int )op == 43) {
#line 401
    next = regnode(cp, (char)6);
#line 402
    regtail(cp, ret, next);
#line 403
    tmp___2 = regnode(cp, (char)7);
#line 403
    regtail(cp, tmp___2, ret);
#line 404
    tmp___3 = regnode(cp, (char)6);
#line 404
    regtail(cp, next, tmp___3);
#line 405
    tmp___4 = regnode(cp, (char)9);
#line 405
    regtail(cp, ret, tmp___4);
  } else
#line 406
  if ((int )op == 63) {
#line 408
    reginsert(cp, (char)6, ret);
#line 409
    tmp___5 = regnode(cp, (char)6);
#line 409
    regtail(cp, ret, tmp___5);
#line 410
    next = regnode(cp, (char)9);
#line 411
    regtail(cp, ret, next);
#line 412
    regoptail(cp, ret, next);
  } else {

  }
#line 414
  (cp->regparse) ++;
  {
#line 415
  mem_15 = cp->regparse;
#line 415
  if ((int )*mem_15 == 42) {
#line 416
    regerror((char *)"nested *?+");
#line 416
    return ((char *)((void *)0));
  } else {
    {
#line 415
    mem_16 = cp->regparse;
#line 415
    if ((int )*mem_16 == 43) {
#line 416
      regerror((char *)"nested *?+");
#line 416
      return ((char *)((void *)0));
    } else {
      {
#line 415
      mem_17 = cp->regparse;
#line 415
      if ((int )*mem_17 == 63) {
#line 416
        regerror((char *)"nested *?+");
#line 416
        return ((char *)((void *)0));
      } else {

      }
      }
    }
    }
  }
  }
#line 418
  return (ret);
}
}
#line 429 "regexp.c"
static char *regatom(struct comp *cp , int *flagp ) 
{ 
  char *ret ;
  int flags ;
  char *tmp ;
  int range ;
  int rangeend ;
  int c ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t len ;
  char ender ;
  char *tmp___2 ;
  char *mem_14 ;
  char *mem_15 ;
  char *mem_16 ;
  char *mem_17 ;
  char *mem_18 ;
  char *mem_19 ;

  {
#line 437
  *flagp = 0;
#line 439
  tmp = cp->regparse;
#line 439
  (cp->regparse) ++;
  {
#line 440
  if ((int )*tmp == 94) {
#line 440
    goto case_94;
  } else {

  }
#line 443
  if ((int )*tmp == 36) {
#line 443
    goto case_36;
  } else {

  }
#line 446
  if ((int )*tmp == 46) {
#line 446
    goto case_46;
  } else {

  }
#line 450
  if ((int )*tmp == 91) {
#line 450
    goto case_91;
  } else {

  }
#line 484
  if ((int )*tmp == 40) {
#line 484
    goto case_40;
  } else {

  }
#line 493
  if ((int )*tmp == 0) {
#line 493
    goto case_0;
  } else {

  }
#line 492
  if ((int )*tmp == 124) {
#line 492
    goto case_0;
  } else {

  }
#line 491
  if ((int )*tmp == 41) {
#line 491
    goto case_0;
  } else {

  }
#line 499
  if ((int )*tmp == 63) {
#line 499
    goto case_63;
  } else {

  }
#line 498
  if ((int )*tmp == 43) {
#line 498
    goto case_63;
  } else {

  }
#line 497
  if ((int )*tmp == 42) {
#line 497
    goto case_63;
  } else {

  }
#line 502
  if ((int )*tmp == 92) {
#line 502
    goto case_92;
  } else {

  }
#line 510
  goto switch_default;
  case_94: /* CIL Label */ 
#line 441
  ret = regnode(cp, (char)1);
#line 442
  goto switch_break;
  case_36: /* CIL Label */ 
#line 444
  ret = regnode(cp, (char)2);
#line 445
  goto switch_break;
  case_46: /* CIL Label */ 
#line 447
  ret = regnode(cp, (char)3);
#line 448
  *flagp |= 3;
#line 449
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 455
  mem_14 = cp->regparse;
#line 455
  if ((int )*mem_14 == 94) {
#line 456
    ret = regnode(cp, (char)5);
#line 457
    (cp->regparse) ++;
  } else {
#line 459
    ret = regnode(cp, (char)4);
  }
  }
#line 460
  mem_15 = cp->regparse;
#line 460
  c = (int )*mem_15;
#line 460
  if (c == 93) {
#line 461
    regc(cp, (char )c);
#line 462
    (cp->regparse) ++;
  } else
#line 460
  if (c == 45) {
#line 461
    regc(cp, (char )c);
#line 462
    (cp->regparse) ++;
  } else {

  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    tmp___0 = cp->regparse;
#line 464
    (cp->regparse) ++;
#line 464
    c = (int )*tmp___0;
#line 464
    if (c != 0) {
#line 464
      if (c == 93) {
#line 464
        goto while_break;
      } else {

      }
    } else {
#line 464
      goto while_break;
    }
#line 465
    if (c != 45) {
#line 466
      regc(cp, (char )c);
    } else {
#line 467
      mem_16 = cp->regparse;
#line 467
      c = (int )*mem_16;
#line 467
      if (c == 93) {
#line 468
        regc(cp, (char )'-');
      } else
#line 467
      if (c == 0) {
#line 468
        regc(cp, (char )'-');
      } else {
#line 470
        mem_17 = cp->regparse - 2;
#line 470
        range = (int )((unsigned char )*mem_17);
#line 471
        rangeend = (int )((unsigned char )c);
#line 472
        if (range > rangeend) {
#line 473
          regerror((char *)"invalid [] range");
#line 473
          return ((char *)((void *)0));
        } else {

        }
#line 474
        range ++;
        {
#line 474
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 474
          if (range <= rangeend) {

          } else {
#line 474
            goto while_break___0;
          }
#line 475
          regc(cp, (char )range);
#line 474
          range ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 476
        (cp->regparse) ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  regc(cp, (char )'\000');
#line 480
  if (c != 93) {
#line 481
    regerror((char *)"unmatched []");
#line 481
    return ((char *)((void *)0));
  } else {

  }
#line 482
  *flagp |= 3;
#line 483
  goto switch_break;
  case_40: /* CIL Label */ 
#line 486
  ret = reg(cp, 1, & flags);
#line 487
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 488
    return ((char *)((void *)0));
  } else {

  }
#line 489
  *flagp |= flags & 5;
#line 490
  goto switch_break;
  case_0: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_41: /* CIL Label */ 
#line 495
  regerror((char *)"internal error: \\0|) unexpected");
#line 495
  return ((char *)((void *)0));
#line 496
  goto switch_break;
  case_63: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
#line 500
  regerror((char *)"?+* follows nothing");
#line 500
  return ((char *)((void *)0));
#line 501
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 503
  mem_18 = cp->regparse;
#line 503
  if ((int )*mem_18 == 0) {
#line 504
    regerror((char *)"trailing \\");
#line 504
    return ((char *)((void *)0));
  } else {

  }
  }
#line 505
  ret = regnode(cp, (char)8);
#line 506
  tmp___1 = cp->regparse;
#line 506
  (cp->regparse) ++;
#line 506
  regc(cp, (char )((int )*tmp___1));
#line 507
  regc(cp, (char )'\000');
#line 508
  *flagp |= 3;
#line 509
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 514
  (cp->regparse) --;
#line 515
  len = strcspn((char const   *)cp->regparse, "^$.[()|?+*\\");
#line 516
  if (len == 0UL) {
#line 517
    regerror((char *)"internal error: strcspn 0");
#line 517
    return ((char *)((void *)0));
  } else {

  }
#line 518
  mem_19 = cp->regparse + len;
#line 518
  ender = *mem_19;
#line 519
  if (len > 1UL) {
#line 519
    if ((int )ender == 42) {
#line 520
      len --;
    } else
#line 519
    if ((int )ender == 43) {
#line 520
      len --;
    } else
#line 519
    if ((int )ender == 63) {
#line 520
      len --;
    } else {

    }
  } else {

  }
#line 521
  *flagp |= 1;
#line 522
  if (len == 1UL) {
#line 523
    *flagp |= 2;
  } else {

  }
#line 524
  ret = regnode(cp, (char)8);
  {
#line 525
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 525
    if (len > 0UL) {

    } else {
#line 525
      goto while_break___1;
    }
#line 526
    tmp___2 = cp->regparse;
#line 526
    (cp->regparse) ++;
#line 526
    regc(cp, (char )((int )*tmp___2));
#line 525
    len --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 527
  regc(cp, (char )'\000');
#line 528
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 532
  return (ret);
}
}
#line 538 "regexp.c"
static char *regnode(struct comp *cp , char op ) 
{ 
  char *ret_ssa_1 ;
  char *ptr_ssa_1 ;
  char *tmp_ssa_1 ;
  char *ptr_ssa_2 ;
  char *tmp___0_ssa_1 ;
  char *ptr_ssa_3 ;
  char *tmp___1_ssa_1 ;
  char *ptr_ssa_4 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  char **__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  char **__cil_tmp20 ;
  char *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  char (*__cil_tmp23)[3] ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  long *__cil_tmp29 ;
  long __cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  long *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  char **__cil_tmp34 ;

  {

#line 543
  return babel_wrapper_regnode(cp, op);
#line 543
  __cil_tmp17 = (unsigned char *)cp + 16;
#line 543
  __cil_tmp18 = (char **)__cil_tmp17;
#line 543
  ret_ssa_1 = *__cil_tmp18;
#line 546
  __cil_tmp19 = (unsigned char *)cp + 16;
#line 546
  __cil_tmp20 = (char **)__cil_tmp19;
#line 546
  __cil_tmp21 = *__cil_tmp20;
#line 546
  __cil_tmp22 = (unsigned char *)cp + 24;
#line 546
  __cil_tmp23 = (char (*)[3])__cil_tmp22;
#line 546
  __cil_tmp24 = *__cil_tmp23;
#line 546
  __cil_tmp25 = (unsigned long )__cil_tmp21;
#line 546
  __cil_tmp26 = (unsigned long )__cil_tmp24;
#line 546
  __cil_tmp27 = __cil_tmp25 != __cil_tmp26;
#line 546
  __cil_tmp16 = ! __cil_tmp27;
#line 546
  if (__cil_tmp16 != 0) {
#line 547
    __cil_tmp28 = (unsigned char *)cp + 32;
#line 547
    __cil_tmp29 = (long *)__cil_tmp28;
#line 547
    __cil_tmp30 = *__cil_tmp29;
#line 547
    __cil_tmp31 = (unsigned char *)cp + 32;
#line 547
    __cil_tmp32 = (long *)__cil_tmp31;
#line 547
    *__cil_tmp32 = __cil_tmp30 + 3L;
#line 548
    return (ret_ssa_1);
  } else {
#line 551
    ptr_ssa_1 = ret_ssa_1;
#line 552
    tmp_ssa_1 = ptr_ssa_1;
#line 552
    ptr_ssa_2 = ptr_ssa_1 + 1;
#line 552
    *tmp_ssa_1 = op;
#line 553
    tmp___0_ssa_1 = ptr_ssa_2;
#line 553
    ptr_ssa_3 = ptr_ssa_2 + 1;
#line 553
    *tmp___0_ssa_1 = (char )'\000';
#line 554
    tmp___1_ssa_1 = ptr_ssa_3;
#line 554
    ptr_ssa_4 = ptr_ssa_3 + 1;
#line 554
    *tmp___1_ssa_1 = (char )'\000';
#line 555
    __cil_tmp33 = (unsigned char *)cp + 16;
#line 555
    __cil_tmp34 = (char **)__cil_tmp33;
#line 555
    *__cil_tmp34 = ptr_ssa_4;
#line 557
    return (ret_ssa_1);
  }
}
}
#line 563 "regexp.c"
static void regc(struct comp *cp , char b ) 
{ 
  char *tmp_ssa_1 ;
  int __cil_tmp5 ;
  unsigned char *__cil_tmp6 ;
  char **__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned char *__cil_tmp9 ;
  char (*__cil_tmp10)[3] ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  char **__cil_tmp15 ;
  unsigned char *__cil_tmp16 ;
  char **__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  char **__cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  long *__cil_tmp22 ;
  long __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  long *__cil_tmp25 ;

  {

#line 568
  return babel_wrapper_regc(cp, b);
#line 568
  __cil_tmp6 = (unsigned char *)cp + 16;
#line 568
  __cil_tmp7 = (char **)__cil_tmp6;
#line 568
  __cil_tmp8 = *__cil_tmp7;
#line 568
  __cil_tmp9 = (unsigned char *)cp + 24;
#line 568
  __cil_tmp10 = (char (*)[3])__cil_tmp9;
#line 568
  __cil_tmp11 = *__cil_tmp10;
#line 568
  __cil_tmp12 = (unsigned long )__cil_tmp8;
#line 568
  __cil_tmp13 = (unsigned long )__cil_tmp11;
#line 568
  __cil_tmp5 = __cil_tmp12 != __cil_tmp13;
#line 568
  if (__cil_tmp5 != 0) {
#line 569
    __cil_tmp14 = (unsigned char *)cp + 16;
#line 569
    __cil_tmp15 = (char **)__cil_tmp14;
#line 569
    tmp_ssa_1 = *__cil_tmp15;
#line 569
    __cil_tmp16 = (unsigned char *)cp + 16;
#line 569
    __cil_tmp17 = (char **)__cil_tmp16;
#line 569
    __cil_tmp18 = *__cil_tmp17;
#line 569
    __cil_tmp19 = (unsigned char *)cp + 16;
#line 569
    __cil_tmp20 = (char **)__cil_tmp19;
#line 569
    *__cil_tmp20 = __cil_tmp18 + 1;
#line 569
    *tmp_ssa_1 = b;
  } else {
#line 571
    __cil_tmp21 = (unsigned char *)cp + 32;
#line 571
    __cil_tmp22 = (long *)__cil_tmp21;
#line 571
    __cil_tmp23 = *__cil_tmp22;
#line 571
    __cil_tmp24 = (unsigned char *)cp + 32;
#line 571
    __cil_tmp25 = (long *)__cil_tmp24;
#line 571
    *__cil_tmp25 = __cil_tmp23 + 1L;
  }
#line 572
  return;
}
}
#line 579 "regexp.c"
static void
reginsert(cp, op, opnd)
register struct comp *cp;
char op;
char *opnd;
{
 register char *place;
 if (!((cp)->regcode != (cp)->regdummy)) {
  cp->regsize += 3;
  return;
 }
 (void) memmove(opnd+3, opnd, (size_t)(cp->regcode - opnd));
 cp->regcode += 3;
 place = opnd;
 *place++ = op;
 *place++ = '\0';
 *place++ = '\0';
}
static void
regtail(cp, p, val)
register struct comp *cp;
char *p;
char *val;
{
 register char *scan;
 register char *temp;
 register int offset;
 if (!((cp)->regcode != (cp)->regdummy))
  return;
 for (scan = p; (temp = regnext(scan)) != ((void *)0); scan = temp)
  continue;
 offset = ((*(scan)) == 7) ? scan - val : val - scan;
 *(scan+1) = (offset>>8)&0177;
 *(scan+2) = offset&0377;
}

#line 637 "regexp.c"
static void
regoptail(cp, p, val)
register struct comp *cp;
char *p;
char *val;
{
 if (!((cp)->regcode != (cp)->regdummy) || (*(p)) != 6)
  return;
 regtail(cp, ((p) + 3), val);
}


static int
regtry(ep, prog, string)
register struct exec *ep;
regexp *prog;
char *string;
{
 register int i;
 register char **stp;
 register char **enp;
 ep->reginput = string;
 stp = prog->startp;
 enp = prog->endp;
 for (i = 10; i > 0; i--) {
  *stp++ = ((void *)0);
  *enp++ = ((void *)0);
 }
 if (regmatch(ep, prog->program + 1)) {
  prog->startp[0] = string;
  prog->endp[0] = ep->reginput;
  return(1);
 } else
  return(0);
}

#line 761 "regexp.c"
static int regmatch(struct exec *ep , char *prog ) 
{ 
  char *scan ;
  char *next ;
  size_t len ;
  char *opnd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int no ;
  char *input ;
  int tmp___2 ;
  int no___0 ;
  char *input___0 ;
  int tmp___3 ;
  char *save ;
  int tmp___4 ;
  char nextch ;
  int tmp___5 ;
  size_t no___1 ;
  char *save___0 ;
  size_t min ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *mem_26 ;
  char *mem_27 ;
  char *mem_28 ;
  char *mem_29 ;
  char *mem_30 ;
  char *mem_31 ;
  char *mem_32 ;
  char **mem_33 ;
  char **mem_34 ;
  char **mem_35 ;
  char **mem_36 ;
  char *mem_37 ;
  char *mem_38 ;

  {
#line 773
  scan = prog;
  {
#line 773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 773
    if ((unsigned long )scan != (unsigned long )((void *)0)) {

    } else {
#line 773
      goto while_break;
    }
#line 778
    next = regnext(scan);
    {
#line 781
    if ((int )*scan == 1) {
#line 781
      goto case_1;
    } else {

    }
#line 785
    if ((int )*scan == 2) {
#line 785
      goto case_2;
    } else {

    }
#line 789
    if ((int )*scan == 3) {
#line 789
      goto case_3;
    } else {

    }
#line 794
    if ((int )*scan == 8) {
#line 794
      goto case_8;
    } else {

    }
#line 806
    if ((int )*scan == 4) {
#line 806
      goto case_4;
    } else {

    }
#line 813
    if ((int )*scan == 5) {
#line 813
      goto case_5;
    } else {

    }
#line 819
    if ((int )*scan == 9) {
#line 819
      goto case_9;
    } else {

    }
#line 821
    if ((int )*scan == 7) {
#line 821
      goto case_7;
    } else {

    }
#line 831
    if ((int )*scan == 21) {
#line 831
      goto case_21;
    } else {

    }
#line 830
    if ((int )*scan == 22) {
#line 830
      goto case_21;
    } else {

    }
#line 829
    if ((int )*scan == 23) {
#line 829
      goto case_21;
    } else {

    }
#line 828
    if ((int )*scan == 24) {
#line 828
      goto case_21;
    } else {

    }
#line 827
    if ((int )*scan == 25) {
#line 827
      goto case_21;
    } else {

    }
#line 826
    if ((int )*scan == 26) {
#line 826
      goto case_21;
    } else {

    }
#line 825
    if ((int )*scan == 27) {
#line 825
      goto case_21;
    } else {

    }
#line 824
    if ((int )*scan == 28) {
#line 824
      goto case_21;
    } else {

    }
#line 823
    if ((int )*scan == 29) {
#line 823
      goto case_21;
    } else {

    }
#line 849
    if ((int )*scan == 31) {
#line 849
      goto case_31;
    } else {

    }
#line 848
    if ((int )*scan == 32) {
#line 848
      goto case_31;
    } else {

    }
#line 847
    if ((int )*scan == 33) {
#line 847
      goto case_31;
    } else {

    }
#line 846
    if ((int )*scan == 34) {
#line 846
      goto case_31;
    } else {

    }
#line 845
    if ((int )*scan == 35) {
#line 845
      goto case_31;
    } else {

    }
#line 844
    if ((int )*scan == 36) {
#line 844
      goto case_31;
    } else {

    }
#line 843
    if ((int )*scan == 37) {
#line 843
      goto case_31;
    } else {

    }
#line 842
    if ((int )*scan == 38) {
#line 842
      goto case_31;
    } else {

    }
#line 841
    if ((int )*scan == 39) {
#line 841
      goto case_31;
    } else {

    }
#line 860
    if ((int )*scan == 6) {
#line 860
      goto case_6;
    } else {

    }
#line 878
    if ((int )*scan == 10) {
#line 878
      goto case_10;
    } else {

    }
#line 877
    if ((int )*scan == 11) {
#line 877
      goto case_10;
    } else {

    }
#line 894
    if ((int )*scan == 0) {
#line 894
      goto case_0;
    } else {

    }
#line 898
    goto switch_default;
    case_1: /* CIL Label */ 
#line 782
    if ((unsigned long )ep->reginput != (unsigned long )ep->regbol) {
#line 783
      return (0);
    } else {

    }
#line 784
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 786
    mem_26 = ep->reginput;
#line 786
    if ((int )*mem_26 != 0) {
#line 787
      return (0);
    } else {

    }
    }
#line 788
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 790
    mem_27 = ep->reginput;
#line 790
    if ((int )*mem_27 == 0) {
#line 791
      return (0);
    } else {

    }
    }
#line 792
    (ep->reginput) ++;
#line 793
    goto switch_break;
    case_8: /* CIL Label */ 
#line 796
    opnd = scan + 3;
    {
#line 799
    mem_28 = ep->reginput;
#line 799
    if ((int )*opnd != (int )*mem_28) {
#line 800
      return (0);
    } else {

    }
    }
#line 801
    len = strlen((char const   *)opnd);
#line 802
    if (len > 1UL) {
#line 802
      tmp = strncmp((char const   *)opnd, (char const   *)ep->reginput, len);
#line 802
      if (tmp != 0) {
#line 803
        return (0);
      } else {

      }
    } else {

    }
#line 804
    ep->reginput += len;
#line 805
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 808
    mem_29 = ep->reginput;
#line 808
    if ((int )*mem_29 == 0) {
#line 810
      return (0);
    } else {
#line 808
      mem_30 = ep->reginput;
#line 808
      tmp___0 = strchr((char const   *)(scan + 3), (int )*mem_30);
#line 808
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 810
        return (0);
      } else {

      }
    }
    }
#line 811
    (ep->reginput) ++;
#line 812
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 814
    mem_31 = ep->reginput;
#line 814
    if ((int )*mem_31 == 0) {
#line 816
      return (0);
    } else {
#line 814
      mem_32 = ep->reginput;
#line 814
      tmp___1 = strchr((char const   *)(scan + 3), (int )*mem_32);
#line 814
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 816
        return (0);
      } else {

      }
    }
    }
#line 817
    (ep->reginput) ++;
#line 818
    goto switch_break;
    case_9: /* CIL Label */ 
#line 820
    goto switch_break;
    case_7: /* CIL Label */ 
#line 822
    goto switch_break;
    case_21: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 826
    no = (int )*scan - 20;
#line 827
    input = ep->reginput;
#line 829
    tmp___2 = regmatch(ep, next);
#line 829
    if (tmp___2 != 0) {
      {
#line 835
      mem_33 = ep->regstartp + no;
#line 835
      if ((unsigned long )*mem_33 == (unsigned long )((void *)0)) {
#line 836
        mem_34 = ep->regstartp + no;
#line 836
        *mem_34 = input;
      } else {

      }
      }
#line 837
      return (1);
    } else {
#line 839
      return (0);
    }
#line 840
    goto switch_break;
    case_31: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 845
    no___0 = (int )*scan - 30;
#line 846
    input___0 = ep->reginput;
#line 848
    tmp___3 = regmatch(ep, next);
#line 848
    if (tmp___3 != 0) {
      {
#line 854
      mem_35 = ep->regendp + no___0;
#line 854
      if ((unsigned long )*mem_35 == (unsigned long )((void *)0)) {
#line 855
        mem_36 = ep->regendp + no___0;
#line 855
        *mem_36 = input___0;
      } else {

      }
      }
#line 856
      return (1);
    } else {
#line 858
      return (0);
    }
#line 859
    goto switch_break;
    case_6: /* CIL Label */ 
#line 862
    save = ep->reginput;
#line 864
    if ((int )*next != 6) {
#line 865
      next = scan + 3;
    } else {
      {
#line 867
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 867
        if ((int )*scan == 6) {

        } else {
#line 867
          goto while_break___0;
        }
#line 868
        tmp___4 = regmatch(ep, scan + 3);
#line 868
        if (tmp___4 != 0) {
#line 869
          return (1);
        } else {

        }
#line 870
        ep->reginput = save;
#line 871
        scan = regnext(scan);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 873
      return (0);
    }
#line 876
    goto switch_break;
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 879
    if ((int )*next == 8) {
#line 879
      mem_37 = next + 3;
#line 879
      tmp___5 = (int )*mem_37;
    } else {
#line 879
      tmp___5 = '\000';
    }
#line 879
    nextch = (char )tmp___5;
#line 882
    save___0 = ep->reginput;
#line 883
    if ((int )*scan == 10) {
#line 883
      tmp___6 = 0;
    } else {
#line 883
      tmp___6 = 1;
    }
#line 883
    min = (size_t )tmp___6;
#line 885
    tmp___7 = regrepeat(ep, scan + 3);
#line 885
    no___1 = tmp___7 + 1UL;
    {
#line 885
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 885
      if (no___1 > min) {

      } else {
#line 885
        goto while_break___1;
      }
#line 886
      ep->reginput = (save___0 + no___1) - 1;
#line 888
      if ((int )nextch == 0) {
#line 888
        goto _L;
      } else {
        {
#line 888
        mem_38 = ep->reginput;
#line 888
        if ((int )*mem_38 == (int )nextch) {
          _L: 
#line 889
          tmp___8 = regmatch(ep, next);
#line 889
          if (tmp___8 != 0) {
#line 890
            return (1);
          } else {

          }
        } else {

        }
        }
      }
#line 885
      no___1 --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 892
    return (0);
#line 893
    goto switch_break;
    case_0: /* CIL Label */ 
#line 896
    return (1);
#line 897
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 899
    regerror((char *)"regexp corruption");
#line 900
    return (0);
#line 901
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 773
    scan = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  regerror((char *)"corrupted pointers");
#line 910
  return (0);
}
}
#line 916 "regexp.c"

#line 950 "regexp.c"
static char *regnext(char *p ) 
{ 
  char *tmp ;
  int offset_ssa_1 ;
  char *tmp_ssa_1 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char __cil_tmp17 ;
  int __cil_tmp18 ;

  {

#line 954
  //return babel_wrapper_regnext(p);
#line 954
  __cil_tmp8 = p + 1;
#line 954
  __cil_tmp9 = *__cil_tmp8;
#line 954
  __cil_tmp10 = (int )__cil_tmp9;
#line 954
  __cil_tmp11 = __cil_tmp10 & 127;
#line 954
  __cil_tmp12 = p + 2;
#line 954
  __cil_tmp13 = *__cil_tmp12;
#line 954
  __cil_tmp14 = (int )__cil_tmp13;
#line 954
  __cil_tmp15 = __cil_tmp11 << 8;
#line 954
  __cil_tmp16 = __cil_tmp14 & 255;
#line 954
  offset_ssa_1 = __cil_tmp15 + __cil_tmp16;
#line 956
  __cil_tmp6 = offset_ssa_1 == 0;
#line 956
  if (__cil_tmp6 != 0) {
#line 957
    return ((char *)0);
  } else {
#line 959
    __cil_tmp17 = *p;
#line 959
    __cil_tmp18 = (int )__cil_tmp17;
#line 959
    __cil_tmp7 = __cil_tmp18 == 7;
#line 959
    if (__cil_tmp7 != 0) {
#line 959
      tmp_ssa_1 = p - offset_ssa_1;
    } else {
#line 959
      tmp_ssa_1 = p + offset_ssa_1;
    }
#line 959
    return (tmp_ssa_1);
  }
#line 959
  return (tmp);
}
}
static size_t regrepeat(ep, node)
register struct exec *ep;
char *node;
{
 register size_t count;
 register char *scan;
 register char ch;
 switch ((*(node))) {
 case 3:
  return(strlen(ep->reginput));
  break;
 case 8:
  ch = *((node) + 3);
  count = 0;
  for (scan = ep->reginput; *scan == ch; scan++)
   count++;
  return(count);
  break;
 case 4:
  return(strspn(ep->reginput, ((node) + 3)));
  break;
 case 5:
  return(strcspn(ep->reginput, ((node) + 3)));
  break;
 default:
  regerror("internal error: bad call of regrepeat");
  return(0);
  break;
 }
}
int
regexec(prog, str)
register regexp *prog;
const char *str;
{
 register char *string = (char *)str;
 register char *s;
 struct exec ex;
 if (prog == ((void *)0) || string == ((void *)0)) {
  regerror("NULL argument to regexec");
  return(0);
 }
 if ((unsigned char)*prog->program != 0234) {
  regerror("corrupted regexp");
  return(0);
 }
 if (prog->regmust != ((void *)0) && strstr(string, prog->regmust) == ((void *)0))
  return(0);
 ex.regbol = string;
 ex.regstartp = prog->startp;
 ex.regendp = prog->endp;
 if (prog->reganch)
  return(regtry(&ex, prog, string));
 if (prog->regstart != '\0') {
  for (s = string; s != ((void *)0); s = strchr(s+1, prog->regstart))
   if (regtry(&ex, prog, s))
    return(1);
  return(0);
 } else {
  for (s = string; !regtry(&ex, prog, s); s++)
   if (*s == '\0')
    return(0);
  return(1);
 }
}


static char *
regbranch(cp, flagp)
register struct comp *cp;
int *flagp;
{
 register char *ret;
 register char *chain;
 register char *latest;
 int flags;
 register int c;
 *flagp = 0;
 ret = regnode(cp, 6);
 chain = ((void *)0);
 while ((c = *cp->regparse) != '\0' && c != '|' && c != ')') {
  latest = regpiece(cp, &flags);
  if (latest == ((void *)0))
   return(((void *)0));
  *flagp |= flags&01;
  if (chain == ((void *)0))
   *flagp |= flags&04;
  else
   regtail(cp, chain, latest);
  chain = latest;
 }
 if (chain == ((void *)0))
  (void) regnode(cp, 9);
 return(ret);
}

#include <gprolog.h>

PlBool babel_ptrR(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

		return PL_TRUE;
}

PlBool babel_ptrR_byte(PlLong* p,  PlLong* star_p, PlLong len)
{

	if (star_p == 0)
	    return PL_FALSE;
	else
	{
		switch(len)
		{
		    case 1:
		    	*p = *(unsigned char*)star_p;
		    	break;
		    case 2:
		    	*p = *(short*)star_p;
		    	break;
		    case 4:
		    	*p = *(int*)star_p;
		    	break;
		    case 8:
		    	*p = *(long long*)star_p;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrR\n");
		}
	}

	return PL_TRUE;
}

PlBool babel_ptrE(PlLong* p,  PlLong e, PlLong len)
{
	if (p == 0)
	    return PL_FALSE;

	switch(len)
		{
		    case 1:
		    	*(unsigned char*)p = (unsigned char)e;
		    	break;
		    case 2:
		    	*(short*) p = (short)e;
		    	break;
		    case 4:
		    	*(int*)p = (int)e;
		    	break;
		    case 8:
		    	*(long long*)p = (long long)e;
		    	break;
		    default :
		    	printf("undefined exp length in babel_ptrL\n");
		}

        return PL_TRUE;
}







